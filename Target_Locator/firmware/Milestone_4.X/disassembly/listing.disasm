Disassembly Listing for Milestone_4
Generated From:
C:/Users/Daniel/Documents/VT 2016-2017/Embedded/Milestone_4/firmware/Milestone_4.X/dist/default/debug/Milestone_4.X.debug.elf
Nov 9, 2016 10:54:13 PM

---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/uart_tx.c  ----------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       uart_tx.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "uart_tx.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  UART_TX_DATA uart_txData;
80:                  QueueHandle_t UART_TX_Byte_Q;
81:                  static DRV_HANDLE UART_TX_Comms;
82:                  
83:                  // *****************************************************************************
84:                  // *****************************************************************************
85:                  // Section: Application Callback Functions
86:                  // *****************************************************************************
87:                  // *****************************************************************************
88:                  
89:                  /* TODO:  Add any necessary callback functions.
90:                  */
91:                  
92:                  // *****************************************************************************
93:                  // *****************************************************************************
94:                  // Section: Application Local Functions
95:                  // *****************************************************************************
96:                  // *****************************************************************************
97:                  
98:                  
99:                  /* TODO:  Add any necessary local functions.
100:                 */
101:                 int UARTSendByteToTXQ(uint8_t byte)
102:                 {
9D00D5D4  27BDFFE8   ADDIU SP, SP, -24
9D00D5D8  AFBF0014   SW RA, 20(SP)
9D00D5DC  A3A40018   SB A0, 24(SP)
103:                     if (xQueueSend(UART_TX_Byte_Q, &byte, portMAX_DELAY) == pdTRUE)
9D00D5E0  8F8480AC   LW A0, -32596(GP)
9D00D5E4  27A50018   ADDIU A1, SP, 24
9D00D5E8  2406FFFF   ADDIU A2, ZERO, -1
9D00D5EC  0F40199A   JAL xQueueGenericSend
9D00D5F0  00003821   ADDU A3, ZERO, ZERO
9D00D5F4  38420001   XORI V0, V0, 1
104:                         return 1;
105:                     return 0;
106:                 }
9D00D5F8  2C420001   SLTIU V0, V0, 1
9D00D5FC  8FBF0014   LW RA, 20(SP)
9D00D600  03E00008   JR RA
9D00D604  27BD0018   ADDIU SP, SP, 24
107:                 void UARTSendByteToTXQFromISR(uint8_t byte)
108:                 {
00000000  00000000   NOP
109:                     BaseType_t xHigherPriorityTaskWoken, xResult;
110:                     xHigherPriorityTaskWoken = pdFALSE;
0000000C  00000000   NOP
111:                     xResult = xQueueSendFromISR(UART_TX_Byte_Q, &byte, &xHigherPriorityTaskWoken);
00000010  00000000   NOP
112:                     /* Actual macro used here is port specific. */
113:                     portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
00000024  00000000   NOP
114:                 }
00000040  00000000   NOP
115:                 int UARTReceiveByteFromTXQ(uint8_t *byte)
116:                 {
9D00D63C  27BDFFE8   ADDIU SP, SP, -24
9D00D640  AFBF0014   SW RA, 20(SP)
9D00D644  00802821   ADDU A1, A0, ZERO
117:                     if (xQueueReceive(UART_TX_Byte_Q, byte, portMAX_DELAY) == pdTRUE)
9D00D648  8F8480AC   LW A0, -32596(GP)
9D00D64C  2406FFFF   ADDIU A2, ZERO, -1
9D00D650  0F40165D   JAL xQueueGenericReceive
9D00D654  00003821   ADDU A3, ZERO, ZERO
9D00D658  38420001   XORI V0, V0, 1
118:                        return 1;
119:                    return 0;
120:                 }
9D00D65C  2C420001   SLTIU V0, V0, 1
9D00D660  8FBF0014   LW RA, 20(SP)
9D00D664  03E00008   JR RA
9D00D668  27BD0018   ADDIU SP, SP, 24
121:                 
122:                 void UARTReceiveByteFromTXQFromISR(uint8_t *byte)
123:                 {
00000000  00000000   NOP
124:                     BaseType_t xHigherPriorityTaskWoken, xResult;
125:                     xHigherPriorityTaskWoken = pdFALSE;
0000000C  00000000   NOP
126:                     xResult = xQueueReceiveFromISR(UART_TX_Byte_Q, byte, &xHigherPriorityTaskWoken);
00000010  00000000   NOP
127:                     /* Actual macro used here is port specific. */
128:                     portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
0000001C  00000000   NOP
129:                 }
00000038  00000000   NOP
130:                 
131:                 // *****************************************************************************
132:                 // *****************************************************************************
133:                 // Section: Application Initialization and State Machine Functions
134:                 // *****************************************************************************
135:                 // *****************************************************************************
136:                 
137:                 /*******************************************************************************
138:                   Function:
139:                     void UART_TX_Initialize ( void )
140:                 
141:                   Remarks:
142:                     See prototype in uart_tx.h.
143:                  */
144:                 
145:                 void UART_TX_Initialize ( void )
146:                 {
9D00CEC8  27BDFFE8   ADDIU SP, SP, -24
9D00CECC  AFBF0014   SW RA, 20(SP)
147:                     /* Place the App state machine in its initial state. */
148:                     uart_txData.state = UART_TX_STATE_INIT;
9D00CED0  AF8080A8   SW ZERO, -32600(GP)
149:                 
150:                     
151:                     /* TODO: Initialize your application's state machine and other
152:                      * parameters.
153:                      */
154:                     UART_TX_Comms = DRV_USART_Open(DRV_USART_INDEX_0, DRV_IO_INTENT_WRITE);
9D00CED4  00002021   ADDU A0, ZERO, ZERO
9D00CED8  0F401F48   JAL DRV_USART_Open
9D00CEDC  24050002   ADDIU A1, ZERO, 2
155:                     if (UART_TX_Comms == DRV_HANDLE_INVALID){
9D00CEE0  2403FFFF   ADDIU V1, ZERO, -1
9D00CEE4  14430003   BNE V0, V1, 0x9D00CEF4
9D00CEE8  AF82801C   SW V0, -32740(GP)
156:                         errorHandler(0xFF);
9D00CEEC  0F403681   JAL errorHandler
9D00CEF0  240400FF   ADDIU A0, ZERO, 255
157:                     }
158:                     UART_TX_Byte_Q = xQueueCreate(MAX_WIFLY_SIZE, sizeof(uint8_t));
9D00CEF4  24040200   ADDIU A0, ZERO, 512
9D00CEF8  24050001   ADDIU A1, ZERO, 1
9D00CEFC  0F402DB4   JAL xQueueGenericCreate
9D00CF00  00003021   ADDU A2, ZERO, ZERO
9D00CF04  AF8280AC   SW V0, -32596(GP)
159:                 }
9D00CF08  8FBF0014   LW RA, 20(SP)
9D00CF0C  03E00008   JR RA
9D00CF10  27BD0018   ADDIU SP, SP, 24
160:                 
161:                 
162:                 /******************************************************************************
163:                   Function:
164:                     void UART_TX_Tasks ( void )
165:                 
166:                   Remarks:
167:                     See prototype in uart_tx.h.
168:                  */
169:                 
170:                 void UART_TX_Tasks ( void )
171:                 {
9D00BEF4  27BDFFE0   ADDIU SP, SP, -32
9D00BEF8  AFBF001C   SW RA, 28(SP)
172:                 
173:                     /* Check the application's current state. */
174:                     switch ( uart_txData.state )
9D00BEFC  8F8280A8   LW V0, -32600(GP)
9D00BF00  10400005   BEQ V0, ZERO, 0x9D00BF18
9D00BF04  24030001   ADDIU V1, ZERO, 1
9D00BF08  10430006   BEQ V0, V1, 0x9D00BF24
9D00BF0C  8FBF001C   LW RA, 28(SP)
9D00BF10  0B402FDA   J 0x9D00BF68
9D00BF14  00000000   NOP
175:                     {
176:                         /* Application's initial state. */
177:                         case UART_TX_STATE_INIT:
178:                         {
179:                             bool appInitialized = true;
180:                        
181:                         
182:                             if (appInitialized)
183:                             {
184:                             
185:                                 uart_txData.state = UART_TX_STATE_SERVICE_TASKS;
9D00BF18  24020001   ADDIU V0, ZERO, 1
9D00BF1C  0B402FD9   J 0x9D00BF64
9D00BF20  AF8280A8   SW V0, -32600(GP)
186:                             }
187:                             break;
188:                         }
189:                 
190:                         case UART_TX_STATE_SERVICE_TASKS:
191:                         {
192:                             uint8_t byte;
193:                             dbgOutputLoc(DLOC_UART_TX_WAIT_FOR_QUEUE);
9D00BF24  0F402A43   JAL dbgOutputLoc
9D00BF28  2404000F   ADDIU A0, ZERO, 15
194:                             while(!UARTReceiveByteFromTXQ(&byte));
9D00BF2C  0F40358F   JAL UARTReceiveByteFromTXQ
9D00BF30  27A40010   ADDIU A0, SP, 16
9D00BF34  1040FFFD   BEQ V0, ZERO, 0x9D00BF2C
9D00BF38  00000000   NOP
195:                             dbgOutputLoc(DLOC_UART_TX_GOT_FROM_QUEUE);
9D00BF3C  0F402A43   JAL dbgOutputLoc
9D00BF40  24040010   ADDIU A0, ZERO, 16
196:                             while(PLIB_USART_TransmitterBufferIsFull(USART_ID_1));
9D00BF50  1440FFFD   BNE V0, ZERO, 0x9D00BF48
9D00BF54  00000000   NOP
197:                             DRV_USART_WriteByte(UART_TX_Comms, byte);
9D00BF58  8F84801C   LW A0, -32740(GP)
9D00BF5C  0F40222D   JAL DRV_USART_WriteByte
9D00BF60  93A50010   LBU A1, 16(SP)
198:                             break;
199:                         }
200:                 
201:                         /* TODO: implement your application state machine.*/
202:                         
203:                 
204:                         /* The default state should never be executed. */
205:                         default:
206:                         {
207:                             /* TODO: Handle error in application's state machine. */
208:                             break;
209:                         }
210:                     }
211:                 }
9D00BF64  8FBF001C   LW RA, 28(SP)
9D00BF68  03E00008   JR RA
9D00BF6C  27BD0020   ADDIU SP, SP, 32
212:                 
213:                  
214:                 
215:                 /*******************************************************************************
216:                  End of File
217:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/uart_rx.c  ----------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       uart_rx.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "uart_rx.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  UART_RX_DATA uart_rxData;
80:                  static DRV_HANDLE UART_RX_Comms;
81:                  QueueHandle_t UART_RX_Byte_Q;
82:                  
83:                  // *****************************************************************************
84:                  // *****************************************************************************
85:                  // Section: Application Callback Functions
86:                  // *****************************************************************************
87:                  // *****************************************************************************
88:                  
89:                  /* TODO:  Add any necessary callback functions.
90:                  */
91:                  void APP_USARTReceiveEventHandler(const SYS_MODULE_INDEX index)
92:                  {
9D00C474  27BDFFE0   ADDIU SP, SP, -32
9D00C478  AFBF001C   SW RA, 28(SP)
9D00C47C  AFB10018   SW S1, 24(SP)
9D00C480  AFB00014   SW S0, 20(SP)
93:                      dbgOutputLoc(DLOC_UART_RX_ISR_ENTER);
9D00C484  0F402A43   JAL dbgOutputLoc
9D00C488  24040011   ADDIU A0, ZERO, 17
94:                      while(PLIB_USART_ReceiverDataIsAvailable(USART_ID_1)){
9D00C498  10400009   BEQ V0, ZERO, 0x9D00C4C0
9D00C49C  3C11BF80   LUI S1, -16512
9D00C4B8  1440FFFA   BNE V0, ZERO, PLIB_USART_ReceiverByteReceive
9D00C4BC  00000000   NOP
95:                          uint8_t temp = PLIB_USART_ReceiverByteReceive(USART_ID_1);
96:                          //UARTSendByteTeRXQFromISR(temp);
97:                          processByte(temp);
9D00C4A8  0F402C31   JAL processByte
9D00C4AC  308400FF   ANDI A0, A0, 255
98:                      }
99:                      
100:                     dbgOutputLoc(DLOC_UART_RX_ISR_EXIT);
9D00C4C0  0F402A43   JAL dbgOutputLoc
9D00C4C4  24040012   ADDIU A0, ZERO, 18
101:                 }
9D00C4C8  8FBF001C   LW RA, 28(SP)
9D00C4CC  8FB10018   LW S1, 24(SP)
9D00C4D0  8FB00014   LW S0, 20(SP)
9D00C4D4  03E00008   JR RA
9D00C4D8  27BD0020   ADDIU SP, SP, 32
102:                 // *****************************************************************************
103:                 // *****************************************************************************
104:                 // Section: Application Local Functions
105:                 // *****************************************************************************
106:                 // *****************************************************************************
107:                 
108:                 
109:                 /* TODO:  Add any necessary local functions.
110:                 */
111:                 int UARTSendByteToRXQ(uint8_t byte)
112:                 {
00000000  00000000   NOP
113:                     if (xQueueSend(UART_RX_Byte_Q, &byte, portMAX_DELAY) == pdTRUE)
0000000C  00000000   NOP
114:                         return 1;
115:                     return 0;
116:                 }
00000024  00000000   NOP
117:                 void UARTSendByteTeRXQFromISR(uint8_t byte)
118:                 {
00000000  00000000   NOP
119:                     BaseType_t xHigherPriorityTaskWoken, xResult;
120:                     xHigherPriorityTaskWoken = pdFALSE;
0000000C  00000000   NOP
121:                     xResult = xQueueSendFromISR(UART_RX_Byte_Q, &byte, &xHigherPriorityTaskWoken);
00000010  00000000   NOP
122:                     /* Actual macro used here is port specific. */
123:                     portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
00000024  00000000   NOP
124:                 }
00000040  00000000   NOP
125:                 int UARTReceiveByteFromRXQ(uint8_t *byte)
126:                 {
9D00D66C  27BDFFE8   ADDIU SP, SP, -24
9D00D670  AFBF0014   SW RA, 20(SP)
9D00D674  00802821   ADDU A1, A0, ZERO
127:                     if (xQueueReceive(UART_RX_Byte_Q, byte, portMAX_DELAY) == pdTRUE)
9D00D678  8F8480B4   LW A0, -32588(GP)
9D00D67C  2406FFFF   ADDIU A2, ZERO, -1
9D00D680  0F40165D   JAL xQueueGenericReceive
9D00D684  00003821   ADDU A3, ZERO, ZERO
9D00D688  38420001   XORI V0, V0, 1
128:                        return 1;
129:                    return 0;
130:                 }
9D00D68C  2C420001   SLTIU V0, V0, 1
9D00D690  8FBF0014   LW RA, 20(SP)
9D00D694  03E00008   JR RA
9D00D698  27BD0018   ADDIU SP, SP, 24
131:                 
132:                 static uint16_t byteCount = 0;
133:                 static uint16_t checkSum;
134:                 static uint16_t calcCheckSum;
135:                 static uint16_t messageNumber;
136:                 static uint16_t messageSize;
137:                 static uint8_t dest;
138:                 static uint8_t source;
139:                 static uint8_t message[MAX_WIFLY_SIZE];
140:                 
141:                 int checkStart(uint8_t byte)
142:                 {
143:                     if (byteCount == 0 && byte != ((MSG_START & 0xFF000000) >> 24))
9D00B920  9783802A   LHU V1, -32726(GP)
9D00B924  14600006   BNE V1, ZERO, 0x9D00B940
9D00B928  308400FF   ANDI A0, A0, 255
9D00B92C  2405004C   ADDIU A1, ZERO, 76
9D00B930  1485001D   BNE A0, A1, 0x9D00B9A8
9D00B934  00001021   ADDU V0, ZERO, ZERO
9D00B938  0B402E61   J 0x9D00B984
9D00B93C  24020001   ADDIU V0, ZERO, 1
144:                     {
145:                         return 0;
146:                     }
147:                     if (byteCount == 1 && byte != ((MSG_START & 0x00FF0000) >> 16)){
9D00B940  24020001   ADDIU V0, ZERO, 1
9D00B944  54620007   BNEL V1, V0, 0x9D00B964
9D00B948  24020002   ADDIU V0, ZERO, 2
9D00B94C  24030032   ADDIU V1, ZERO, 50
9D00B950  10830015   BEQ A0, V1, 0x9D00B9A8
9D00B954  00000000   NOP
148:                         byteCount = 0;
9D00B958  A780802A   SH ZERO, -32726(GP)
149:                         return 0;
9D00B95C  03E00008   JR RA
9D00B960  00001021   ADDU V0, ZERO, ZERO
150:                     }
151:                     if (byteCount == 2 && byte != ((MSG_START & 0x0000FF00) >> 8)){
9D00B964  14620007   BNE V1, V0, 0x9D00B984
9D00B968  24020001   ADDIU V0, ZERO, 1
9D00B96C  240300A5   ADDIU V1, ZERO, 165
9D00B970  1083000D   BEQ A0, V1, 0x9D00B9A8
9D00B974  00000000   NOP
152:                         byteCount = 0;
9D00B978  A780802A   SH ZERO, -32726(GP)
153:                         return 0;
9D00B97C  03E00008   JR RA
9D00B980  00001021   ADDU V0, ZERO, ZERO
154:                     }
155:                     if (byteCount == 3 && byte != ((MSG_START & 0x000000FF) >> 0)){
9D00B984  24050003   ADDIU A1, ZERO, 3
9D00B988  14650007   BNE V1, A1, 0x9D00B9A8
9D00B98C  00000000   NOP
9D00B990  240200BD   ADDIU V0, ZERO, 189
9D00B994  50820004   BEQL A0, V0, 0x9D00B9A8
9D00B998  24020001   ADDIU V0, ZERO, 1
156:                         byteCount = 0;
9D00B99C  A780802A   SH ZERO, -32726(GP)
157:                         return 0;
9D00B9A0  03E00008   JR RA
9D00B9A4  00001021   ADDU V0, ZERO, ZERO
158:                     }
159:                     return 1;
160:                 }
9D00B9A8  03E00008   JR RA
9D00B9AC  00000000   NOP
161:                 
162:                 int parseHeader()
163:                 {
164:                     messageNumber = ((uint16_t)message[5] << 8) + (uint16_t)message[4];
9D00C160  3C03A001   LUI V1, -24575
9D00C164  246352E8   ADDIU V1, V1, 21224
9D00C168  90620005   LBU V0, 5(V1)
9D00C16C  00021200   SLL V0, V0, 8
9D00C170  90640004   LBU A0, 4(V1)
9D00C174  00441021   ADDU V0, V0, A0
9D00C178  A7828024   SH V0, -32732(GP)
165:                     dest = message[6];
9D00C17C  90640006   LBU A0, 6(V1)
9D00C180  A3848021   SB A0, -32735(GP)
166:                     source = message[7];
9D00C184  90650007   LBU A1, 7(V1)
9D00C188  A3858020   SB A1, -32736(GP)
167:                     messageSize = ((uint16_t)message[9] << 8) + (uint16_t)message[8];
9D00C18C  90620009   LBU V0, 9(V1)
9D00C190  00021200   SLL V0, V0, 8
9D00C194  90660008   LBU A2, 8(V1)
9D00C198  00461021   ADDU V0, V0, A2
9D00C19C  A7828022   SH V0, -32734(GP)
168:                     checkSum = ((uint16_t)message[11] << 8) + (uint16_t)message[10];
9D00C1A0  9062000B   LBU V0, 11(V1)
9D00C1A4  00021200   SLL V0, V0, 8
9D00C1A8  9063000A   LBU V1, 10(V1)
9D00C1AC  00431021   ADDU V0, V0, V1
9D00C1B0  A7828028   SH V0, -32728(GP)
169:                     calcCheckSum = 0;
9D00C1B4  A7808026   SH ZERO, -32730(GP)
170:                     if (dest != DEVICEID){
9D00C1B8  24030001   ADDIU V1, ZERO, 1
9D00C1BC  14830003   BNE A0, V1, 0x9D00C1CC
9D00C1C0  00001021   ADDU V0, ZERO, ZERO
171:                         return 0;
172:                     }
173:                     if (source == DEVICEID){
9D00C1C4  38A20001   XORI V0, A1, 1
9D00C1C8  0002102B   SLTU V0, ZERO, V0
174:                         return 0;
175:                     }
176:                     return 1;
177:                 }
9D00C1CC  03E00008   JR RA
9D00C1D0  00000000   NOP
178:                 
179:                 void parseMessage()
180:                 {
9D00A5F0  27BDFBF8   ADDIU SP, SP, -1032
9D00A5F4  AFBF0404   SW RA, 1028(SP)
181:                     if(calcCheckSum != checkSum){
9D00A5F8  97838026   LHU V1, -32730(GP)
9D00A5FC  97828028   LHU V0, -32728(GP)
9D00A600  5462002C   BNEL V1, V0, 0x9D00A6B4
9D00A604  A780802A   SH ZERO, -32726(GP)
182:                         //Potentially send an error message to request retry
183:                         byteCount = 0;
184:                         return;
185:                     }
186:                     messageItem_t receivedMsg;
187:                     int i;
188:                     for(i = 0; i < messageSize; i++)
9D00A608  97858022   LHU A1, -32734(GP)
9D00A60C  1CA00003   BGTZ A1, 0x9D00A61C
9D00A610  00001021   ADDU V0, ZERO, ZERO
9D00A638  24420001   ADDIU V0, V0, 1
9D00A63C  0045182A   SLT V1, V0, A1
9D00A640  1460FFF9   BNE V1, ZERO, 0x9D00A628
9D00A644  27A40200   ADDIU A0, SP, 512
189:                     {
190:                         receivedMsg.payload[i] = message[i + MSG_HEADER_SIZE];
9D00A630  9084000C   LBU A0, 12(A0)
9D00A634  A0640000   SB A0, 0(V1)
191:                     }
192:                     receivedMsg.msgSize = messageSize;
9D00A614  0B402993   J 0x9D00A64C
9D00A618  AFA503F4   SW A1, 1012(SP)
9D00A61C  3C06A001   LUI A2, -24575
9D00A620  24C652E8   ADDIU A2, A2, 21224
9D00A624  27A40200   ADDIU A0, SP, 512
9D00A628  00821821   ADDU V1, A0, V0
9D00A62C  00C22021   ADDU A0, A2, V0
9D00A648  AFA503F4   SW A1, 1012(SP)
193:                     //SendMessageForTransmitQ(receivedMsg);
194:                     //send to queue
195:                     JSONParserNewPacket(receivedMsg);
9D00A64C  27A20210   ADDIU V0, SP, 528
9D00A650  27A30010   ADDIU V1, SP, 16
9D00A654  27A403F0   ADDIU A0, SP, 1008
9D00A658  8C480000   LW T0, 0(V0)
9D00A65C  8C470004   LW A3, 4(V0)
9D00A660  8C460008   LW A2, 8(V0)
9D00A664  8C45000C   LW A1, 12(V0)
9D00A668  AC680000   SW T0, 0(V1)
9D00A66C  AC670004   SW A3, 4(V1)
9D00A670  AC660008   SW A2, 8(V1)
9D00A674  AC65000C   SW A1, 12(V1)
9D00A678  24420010   ADDIU V0, V0, 16
9D00A67C  1444FFF6   BNE V0, A0, 0x9D00A658
9D00A680  24630010   ADDIU V1, V1, 16
9D00A684  8C450000   LW A1, 0(V0)
9D00A688  8C440004   LW A0, 4(V0)
9D00A68C  8C420008   LW V0, 8(V0)
9D00A690  AC650000   SW A1, 0(V1)
9D00A694  AC640004   SW A0, 4(V1)
9D00A698  AC620008   SW V0, 8(V1)
9D00A69C  8FA40200   LW A0, 512(SP)
9D00A6A0  8FA50204   LW A1, 516(SP)
9D00A6A4  8FA60208   LW A2, 520(SP)
9D00A6A8  0F4034CF   JAL JSONParserNewPacket
9D00A6AC  8FA7020C   LW A3, 524(SP)
196:                     byteCount = 0;
9D00A6B0  A780802A   SH ZERO, -32726(GP)
197:                 }
9D00A6B4  8FBF0404   LW RA, 1028(SP)
9D00A6B8  03E00008   JR RA
9D00A6BC  27BD0408   ADDIU SP, SP, 1032
198:                 
199:                 void processByte(uint8_t byte)
200:                 {
9D00B0C4  27BDFFE8   ADDIU SP, SP, -24
9D00B0C8  AFBF0014   SW RA, 20(SP)
9D00B0CC  AFB00010   SW S0, 16(SP)
9D00B0D0  309000FF   ANDI S0, A0, 255
201:                     if (!checkStart(byte)){
9D00B0D4  0F402E48   JAL checkStart
9D00B0D8  02002021   ADDU A0, S0, ZERO
9D00B0DC  1040001D   BEQ V0, ZERO, 0x9D00B154
9D00B0E0  9782802A   LHU V0, -32726(GP)
202:                         return;
203:                     }
204:                     message[byteCount] = byte;
9D00B0E4  3C03A001   LUI V1, -24575
9D00B0E8  246352E8   ADDIU V1, V1, 21224
9D00B0EC  00431821   ADDU V1, V0, V1
9D00B0F0  A0700000   SB S0, 0(V1)
205:                     byteCount++;
9D00B0F4  24420001   ADDIU V0, V0, 1
9D00B0F8  3042FFFF   ANDI V0, V0, -1
9D00B0FC  A782802A   SH V0, -32726(GP)
206:                     calcCheckSum += byte;
9D00B100  97838026   LHU V1, -32730(GP)
9D00B104  02038021   ADDU S0, S0, V1
207:                     if(byteCount == MSG_HEADER_SIZE){
9D00B108  2403000C   ADDIU V1, ZERO, 12
9D00B10C  14430007   BNE V0, V1, 0x9D00B12C
9D00B110  A7908026   SH S0, -32730(GP)
208:                         if (!parseHeader()){
9D00B114  0F403058   JAL parseHeader
9D00B118  00000000   NOP
9D00B11C  5040000D   BEQL V0, ZERO, 0x9D00B154
9D00B120  A780802A   SH ZERO, -32726(GP)
209:                             byteCount = 0;
210:                         }
211:                         return;
212:                     }
213:                     if(byteCount == MSG_HEADER_SIZE + messageSize){
9D00B12C  97838022   LHU V1, -32734(GP)
9D00B130  2463000C   ADDIU V1, V1, 12
9D00B134  14430004   BNE V0, V1, 0x9D00B148
9D00B138  9783802A   LHU V1, -32726(GP)
214:                         parseMessage();
9D00B13C  0F40297C   JAL parseMessage
9D00B140  00000000   NOP
215:                     }
216:                     if (byteCount == MAX_WIFLY_SIZE){
9D00B144  9783802A   LHU V1, -32726(GP)
9D00B148  24020200   ADDIU V0, ZERO, 512
9D00B14C  50620001   BEQL V1, V0, 0x9D00B154
9D00B150  A780802A   SH ZERO, -32726(GP)
217:                         byteCount = 0;
218:                     }
219:                 }
9D00B124  0B402C56   J 0x9D00B158
9D00B128  8FBF0014   LW RA, 20(SP)
9D00B154  8FBF0014   LW RA, 20(SP)
9D00B158  8FB00010   LW S0, 16(SP)
9D00B15C  03E00008   JR RA
9D00B160  27BD0018   ADDIU SP, SP, 24
220:                 
221:                 // *****************************************************************************
222:                 // *****************************************************************************
223:                 // Section: Application Initialization and State Machine Functions
224:                 // *****************************************************************************
225:                 // *****************************************************************************
226:                 
227:                 /*******************************************************************************
228:                   Function:
229:                     void UART_RX_Initialize ( void )
230:                 
231:                   Remarks:
232:                     See prototype in uart_rx.h.
233:                  */
234:                 
235:                 void UART_RX_Initialize ( void )
236:                 {
9D00C94C  27BDFFE8   ADDIU SP, SP, -24
9D00C950  AFBF0014   SW RA, 20(SP)
237:                     /* Place the App state machine in its initial state. */
238:                     uart_rxData.state = UART_RX_STATE_INIT;
239:                     enable_dbgOutputLoc();
9D00C954  0F4035B3   JAL enable_dbgOutputLoc
9D00C958  AF8080B0   SW ZERO, -32592(GP)
240:                 
241:                     
242:                     /* TODO: Initialize your application's state machine and other
243:                      * parameters.
244:                      */
245:                     UART_RX_Comms = DRV_USART_Open(DRV_USART_INDEX_0, DRV_IO_INTENT_READ);
9D00C95C  00002021   ADDU A0, ZERO, ZERO
9D00C960  0F401F48   JAL DRV_USART_Open
9D00C964  24050001   ADDIU A1, ZERO, 1
246:                     if (UART_RX_Comms == DRV_HANDLE_INVALID){
9D00C968  2403FFFF   ADDIU V1, ZERO, -1
9D00C96C  14430003   BNE V0, V1, 0x9D00C97C
9D00C970  AF82802C   SW V0, -32724(GP)
247:                         errorHandler(0xFF);
9D00C974  0F403681   JAL errorHandler
9D00C978  240400FF   ADDIU A0, ZERO, 255
248:                     }
249:                     //DRV_USART_ByteTransmitCallbackSet(DRV_USART_INDEX_0, APP_USARTTransmitEventHandler);
250:                     DRV_USART_ByteReceiveCallbackSet(DRV_USART_INDEX_0, APP_USARTReceiveEventHandler);
9D00C97C  00002021   ADDU A0, ZERO, ZERO
9D00C980  3C059D01   LUI A1, -25343
9D00C984  0F4035D7   JAL DRV_USART_ByteReceiveCallbackSet
9D00C988  24A5C474   ADDIU A1, A1, -15244
251:                     
252:                     UART_RX_Byte_Q = xQueueCreate(32, sizeof(uint8_t));
9D00C98C  24040020   ADDIU A0, ZERO, 32
9D00C990  24050001   ADDIU A1, ZERO, 1
9D00C994  0F402DB4   JAL xQueueGenericCreate
9D00C998  00003021   ADDU A2, ZERO, ZERO
9D00C99C  AF8280B4   SW V0, -32588(GP)
253:                 }
9D00C9A0  8FBF0014   LW RA, 20(SP)
9D00C9A4  03E00008   JR RA
9D00C9A8  27BD0018   ADDIU SP, SP, 24
254:                 
255:                 
256:                 /******************************************************************************
257:                   Function:
258:                     void UART_RX_Tasks ( void )
259:                 
260:                   Remarks:
261:                     See prototype in uart_rx.h.
262:                  */
263:                 
264:                 void UART_RX_Tasks ( void )
265:                 {
9D00C884  27BDFFE0   ADDIU SP, SP, -32
9D00C888  AFBF001C   SW RA, 28(SP)
266:                 
267:                     /* Check the application's current state. */
268:                     switch ( uart_rxData.state )
9D00C88C  8F8280B0   LW V0, -32592(GP)
9D00C890  10400005   BEQ V0, ZERO, 0x9D00C8A8
9D00C894  24030001   ADDIU V1, ZERO, 1
9D00C898  10430006   BEQ V0, V1, 0x9D00C8B4
9D00C89C  8FBF001C   LW RA, 28(SP)
9D00C8A0  0B403238   J 0x9D00C8E0
9D00C8A4  00000000   NOP
269:                     {
270:                         /* Application's initial state. */
271:                         case UART_RX_STATE_INIT:
272:                         {
273:                             bool appInitialized = true;
274:                        
275:                         
276:                             if (appInitialized)
277:                             {
278:                             
279:                                 uart_rxData.state = UART_RX_STATE_SERVICE_TASKS;
9D00C8A8  24020001   ADDIU V0, ZERO, 1
9D00C8AC  0B403237   J 0x9D00C8DC
9D00C8B0  AF8280B0   SW V0, -32592(GP)
280:                             }
281:                             break;
282:                         }
283:                 
284:                         case UART_RX_STATE_SERVICE_TASKS:
285:                         {
286:                             uint8_t byte;
287:                             dbgOutputLoc(DLOC_UART_RX_WAIT_FOR_QUEUE);
9D00C8B4  0F402A43   JAL dbgOutputLoc
9D00C8B8  24040017   ADDIU A0, ZERO, 23
288:                             while(!UARTReceiveByteFromRXQ(&byte));
9D00C8BC  0F40359B   JAL UARTReceiveByteFromRXQ
9D00C8C0  27A40010   ADDIU A0, SP, 16
9D00C8C4  1040FFFD   BEQ V0, ZERO, 0x9D00C8BC
9D00C8C8  00000000   NOP
289:                             dbgOutputLoc(DLOC_UART_RX_GOT_FROM_QUEUE);
9D00C8CC  0F402A43   JAL dbgOutputLoc
9D00C8D0  24040018   ADDIU A0, ZERO, 24
290:                             //UARTSendByteToTXQ(byte);
291:                             //processByte(byte);
292:                             dbgOutputLoc(DLOC_UART_RX_SENT_TO_QUEUE);
9D00C8D4  0F402A43   JAL dbgOutputLoc
9D00C8D8  24040019   ADDIU A0, ZERO, 25
293:                             break;
294:                         }
295:                 
296:                         /* TODO: implement your application state machine.*/
297:                         
298:                 
299:                         /* The default state should never be executed. */
300:                         default:
301:                         {
302:                             /* TODO: Handle error in application's state machine. */
303:                             break;
304:                         }
305:                     }
306:                 }
9D00C8DC  8FBF001C   LW RA, 28(SP)
9D00C8E0  03E00008   JR RA
9D00C8E4  27BD0020   ADDIU SP, SP, 32
307:                 
308:                  
309:                 
310:                 /*******************************************************************************
311:                  End of File
312:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/transmit_handler.c  -------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       transmit_handler.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "transmit_handler.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  TRANSMIT_HANDLER_DATA transmit_handlerData;
80:                  static QueueHandle_t TransmitMessage_Q;
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  // Section: Application Callback Functions
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  
87:                  /* TODO:  Add any necessary callback functions.
88:                  */
89:                  
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Application Local Functions
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  
96:                  
97:                  /* TODO:  Add any necessary local functions.
98:                  */
99:                  int SendMessageForTransmitQ(messageItem_t message)
100:                 {
9D00D2FC  27BDFFE8   ADDIU SP, SP, -24
9D00D300  AFBF0014   SW RA, 20(SP)
9D00D304  AFA40018   SW A0, 24(SP)
9D00D308  AFA5001C   SW A1, 28(SP)
9D00D30C  AFA60020   SW A2, 32(SP)
9D00D310  AFA70024   SW A3, 36(SP)
101:                     if (xQueueSend(TransmitMessage_Q, &message, portMAX_DELAY) == pdTRUE)
9D00D314  8F848034   LW A0, -32716(GP)
9D00D318  27A50018   ADDIU A1, SP, 24
9D00D31C  2406FFFF   ADDIU A2, ZERO, -1
9D00D320  0F40199A   JAL xQueueGenericSend
9D00D324  00003821   ADDU A3, ZERO, ZERO
9D00D328  38420001   XORI V0, V0, 1
102:                         return 1;
103:                     return 0;
104:                 }
9D00D32C  2C420001   SLTIU V0, V0, 1
9D00D330  8FBF0014   LW RA, 20(SP)
9D00D334  03E00008   JR RA
9D00D338  27BD0018   ADDIU SP, SP, 24
105:                 void SendMessageForTransmitFromISR(messageItem_t message)
106:                 {
00000000  00000000   NOP
107:                     BaseType_t xHigherPriorityTaskWoken, xResult;
108:                     xHigherPriorityTaskWoken = pdFALSE;
00000018  00000000   NOP
109:                     xResult = xQueueSendFromISR(TransmitMessage_Q, &message, &xHigherPriorityTaskWoken);
0000001C  00000000   NOP
110:                     /* Actual macro used here is port specific. */
111:                     portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
00000030  00000000   NOP
112:                 }
0000004C  00000000   NOP
113:                 int ReceiveMessageForTransmitQ(messageItem_t *message)
114:                 {
9D00D69C  27BDFFE8   ADDIU SP, SP, -24
9D00D6A0  AFBF0014   SW RA, 20(SP)
9D00D6A4  00802821   ADDU A1, A0, ZERO
115:                     if (xQueueReceive(TransmitMessage_Q, message, portMAX_DELAY) == pdTRUE)
9D00D6A8  8F848034   LW A0, -32716(GP)
9D00D6AC  2406FFFF   ADDIU A2, ZERO, -1
9D00D6B0  0F40165D   JAL xQueueGenericReceive
9D00D6B4  00003821   ADDU A3, ZERO, ZERO
9D00D6B8  38420001   XORI V0, V0, 1
116:                        return 1;
117:                    return 0;
118:                 }
9D00D6BC  2C420001   SLTIU V0, V0, 1
9D00D6C0  8FBF0014   LW RA, 20(SP)
9D00D6C4  03E00008   JR RA
9D00D6C8  27BD0018   ADDIU SP, SP, 24
119:                 
120:                 // *****************************************************************************
121:                 // *****************************************************************************
122:                 // Section: Application Initialization and State Machine Functions
123:                 // *****************************************************************************
124:                 // *****************************************************************************
125:                 
126:                 /*******************************************************************************
127:                   Function:
128:                     void TRANSMIT_HANDLER_Initialize ( void )
129:                 
130:                   Remarks:
131:                     See prototype in transmit_handler.h.
132:                  */
133:                 
134:                 void TRANSMIT_HANDLER_Initialize ( void )
135:                 {
9D00D81C  27BDFFE8   ADDIU SP, SP, -24
9D00D820  AFBF0014   SW RA, 20(SP)
136:                     /* Place the App state machine in its initial state. */
137:                     transmit_handlerData.state = TRANSMIT_HANDLER_STATE_INIT;
9D00D824  AF8080B8   SW ZERO, -32584(GP)
138:                 
139:                     
140:                     /* TODO: Initialize your application's state machine and other
141:                      * parameters.
142:                      */
143:                     TransmitMessage_Q = xQueueCreate(4, sizeof(messageItem_t));//sizeof(uint8_t)*MAX_PAYLOAD_SIZE);
9D00D828  24040004   ADDIU A0, ZERO, 4
9D00D82C  240501FC   ADDIU A1, ZERO, 508
9D00D830  0F402DB4   JAL xQueueGenericCreate
9D00D834  00003021   ADDU A2, ZERO, ZERO
9D00D838  AF828034   SW V0, -32716(GP)
144:                 }
9D00D83C  8FBF0014   LW RA, 20(SP)
9D00D840  03E00008   JR RA
9D00D844  27BD0018   ADDIU SP, SP, 24
145:                 
146:                 
147:                 /******************************************************************************
148:                   Function:
149:                     void TRANSMIT_HANDLER_Tasks ( void )
150:                 
151:                   Remarks:
152:                     See prototype in transmit_handler.h.
153:                  */
154:                 static uint16_t messageCount;
155:                 void TRANSMIT_HANDLER_Tasks ( void )
156:                 {
9D008EF4  27BDFBE8   ADDIU SP, SP, -1048
9D008EF8  AFBF0414   SW RA, 1044(SP)
9D008EFC  AFB00410   SW S0, 1040(SP)
157:                 
158:                     /* Check the application's current state. */
159:                     switch ( transmit_handlerData.state )
9D008F00  8F8280B8   LW V0, -32584(GP)
9D008F04  10400005   BEQ V0, ZERO, 0x9D008F1C
9D008F08  24030001   ADDIU V1, ZERO, 1
9D008F0C  10430006   BEQ V0, V1, 0x9D008F28
9D008F10  8FBF0414   LW RA, 1044(SP)
160:                     {
161:                         /* Application's initial state. */
162:                         case TRANSMIT_HANDLER_STATE_INIT:
163:                         {
164:                             bool appInitialized = true;
165:                        
166:                         
167:                             if (appInitialized)
168:                             {
169:                             
170:                                 transmit_handlerData.state = TRANSMIT_HANDLER_STATE_SERVICE_TASKS;
9D008F1C  24020001   ADDIU V0, ZERO, 1
9D008F20  0B402406   J 0x9D009018
9D008F24  AF8280B8   SW V0, -32584(GP)
171:                             }
172:                             break;
173:                         }
174:                 
175:                         case TRANSMIT_HANDLER_STATE_SERVICE_TASKS:
176:                         {
177:                             uint8_t message[MAX_WIFLY_SIZE];
178:                             messageItem_t msgToSend;
179:                             //uint8_t payload[MAX_PAYLOAD_SIZE];
180:                             ReceiveMessageForTransmitQ(&msgToSend);
9D008F28  0F4035A7   JAL ReceiveMessageForTransmitQ
9D008F2C  27A40210   ADDIU A0, SP, 528
181:                             //create message and put header information in with payload
182:                             //4 byte start, 2 byte count, 1 byte size, 2 byte checksum(sum of all payload bytes))
183:                             message[0] = ((MSG_START & 0xFF000000) >> 24);
9D008F30  2402004C   ADDIU V0, ZERO, 76
9D008F34  A3A20010   SB V0, 16(SP)
184:                             message[1] = ((MSG_START & 0x00FF0000) >> 16);
9D008F38  24020032   ADDIU V0, ZERO, 50
9D008F3C  A3A20011   SB V0, 17(SP)
185:                             message[2] = ((MSG_START & 0x0000FF00) >> 8);
9D008F40  2402FFA5   ADDIU V0, ZERO, -91
9D008F44  A3A20012   SB V0, 18(SP)
186:                             message[3] = ((MSG_START & 0x000000FF) >> 0);
9D008F48  2402FFBD   ADDIU V0, ZERO, -67
9D008F4C  A3A20013   SB V0, 19(SP)
187:                             message[4] = messageCount & 0x00FF;
9D008F50  97828030   LHU V0, -32720(GP)
9D008F54  A3A20014   SB V0, 20(SP)
188:                             message[5] = (messageCount & 0xFF00) >> 8;
9D008F58  00021A02   SRL V1, V0, 8
9D008F5C  A3A30015   SB V1, 21(SP)
189:                             message[6] = msgToSend.dest;
9D008F60  93A30408   LBU V1, 1032(SP)
9D008F64  A3A30016   SB V1, 22(SP)
190:                             message[7] = msgToSend.source;
9D008F68  93A30409   LBU V1, 1033(SP)
9D008F6C  A3A30017   SB V1, 23(SP)
191:                             message[8] = (msgToSend.msgSize & 0xFF);
9D008F70  8FA60404   LW A2, 1028(SP)
9D008F74  A3A60018   SB A2, 24(SP)
192:                             message[9] = (msgToSend.msgSize & 0xFF00) >> 8;
9D008F78  7CC33A00   EXT V1, A2, 8, 8
9D008F7C  A3A30019   SB V1, 25(SP)
193:                             uint16_t sum = 0;
194:                             messageCount++;
9D008F80  24420001   ADDIU V0, V0, 1
9D008F84  A7828030   SH V0, -32720(GP)
195:                             int i;
196:                             for(i = MSG_HEADER_SIZE; i < MAX_WIFLY_SIZE; i++)
9D008F9C  2402000D   ADDIU V0, ZERO, 13
9D008FA0  24070200   ADDIU A3, ZERO, 512
9D008FA4  27A50210   ADDIU A1, SP, 528
9D008FA8  00A21821   ADDU V1, A1, V0
9D008FC8  24420001   ADDIU V0, V0, 1
9D008FCC  1447FFF6   BNE V0, A3, 0x9D008FA8
9D008FD0  27A50210   ADDIU A1, SP, 528
197:                             {
198:                                 message[i] = msgToSend.payload[i-MSG_HEADER_SIZE];
9D008F88  93A40210   LBU A0, 528(SP)
9D008FAC  9063FFF4   LBU V1, -12(V1)
9D008FB0  27A80010   ADDIU T0, SP, 16
9D008FB4  01022821   ADDU A1, T0, V0
9D008FB8  A0A30000   SB V1, 0(A1)
199:                                 sum+= message[i];
9D008FBC  00832021   ADDU A0, A0, V1
200:                                 if(i >= msgToSend.msgSize + MSG_HEADER_SIZE){
9D008F8C  24C6000C   ADDIU A2, A2, 12
9D008F90  28C2000D   SLTI V0, A2, 13
9D008F94  1440000F   BNE V0, ZERO, 0x9D008FD4
9D008F98  A3A4001C   SB A0, 28(SP)
9D008FC0  10460004   BEQ V0, A2, 0x9D008FD4
9D008FC4  3084FFFF   ANDI A0, A0, -1
201:                 //                    for (; i < MAX_WIFLY_SIZE; i++)
202:                 //                    {
203:                 //                        message[i] = 0xAA;
204:                 //                        sum+=0xAA;
205:                 //                    }
206:                                     break;
207:                                 }
208:                             }
209:                             message[10] = (sum & 0x00FF);
9D008FD4  A3A4001A   SB A0, 26(SP)
210:                             message[11] = (sum & 0xFF00) >> 8;
9D008FD8  00042202   SRL A0, A0, 8
9D008FDC  A3A4001B   SB A0, 27(SP)
211:                             for(i = 0; i < msgToSend.msgSize + MSG_HEADER_SIZE; i++){
9D008FE0  8FA20404   LW V0, 1028(SP)
9D008FE4  2442000C   ADDIU V0, V0, 12
9D008FE8  1840000B   BLEZ V0, 0x9D009018
9D008FEC  00008021   ADDU S0, ZERO, ZERO
9D008FF0  27A30010   ADDIU V1, SP, 16
9D008FF4  00701021   ADDU V0, V1, S0
9D009000  26100001   ADDIU S0, S0, 1
9D009004  8FA20404   LW V0, 1028(SP)
9D009008  2442000C   ADDIU V0, V0, 12
9D00900C  0202102A   SLT V0, S0, V0
9D009010  1440FFF8   BNE V0, ZERO, 0x9D008FF4
9D009014  27A30010   ADDIU V1, SP, 16
212:                                 UARTSendByteToTXQ(message[i]);
9D008FF8  0F403575   JAL UARTSendByteToTXQ
9D008FFC  90440000   LBU A0, 0(V0)
213:                             }
214:                             break;
215:                         }
216:                 
217:                         /* TODO: implement your application state machine.*/
218:                         
219:                 
220:                         /* The default state should never be executed. */
221:                         default:
222:                         {
223:                             /* TODO: Handle error in application's state machine. */
224:                             break;
225:                         }
226:                     }
227:                 }
9D008F14  0B402408   J 0x9D009020
9D008F18  8FB00410   LW S0, 1040(SP)
9D009018  8FBF0414   LW RA, 1044(SP)
9D00901C  8FB00410   LW S0, 1040(SP)
9D009020  03E00008   JR RA
9D009024  27BD0418   ADDIU SP, SP, 1048
228:                 
229:                  
230:                 
231:                 /*******************************************************************************
232:                  End of File
233:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/system_tasks.c
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       system_tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled state
9:                       machines.
10:                  
11:                    Description:
12:                      This file contains source code necessary to maintain system's polled state
13:                      machines.  It implements the "SYS_Tasks" function that calls the individual
14:                      "Tasks" functions for all the MPLAB Harmony modules in the system.
15:                  
16:                    Remarks:
17:                      This file requires access to the systemObjects global data structure that
18:                      contains the object handles to all MPLAB Harmony module objects executing
19:                      polled in the system.  These handles are passed into the individual module
20:                      "Tasks" functions to identify the instance of the module to maintain.
21:                   *******************************************************************************/
22:                  
23:                  // DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  // Section: Included Files
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  
55:                  #include "system_config.h"
56:                  #include "system_definitions.h"
57:                  #include "uart_tx.h"
58:                  #include "uart_rx.h"
59:                  #include "transmit_handler.h"
60:                  #include "pic_interface.h"
61:                  #include "ping_sensors.h"
62:                  #include "grid_handler.h"
63:                  #include "json_parser.h"
64:                  
65:                  
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  // Section: Local Prototypes
69:                  // *****************************************************************************
70:                  // *****************************************************************************
71:                  
72:                  
73:                   
74:                  static void _SYS_Tasks ( void );
75:                  static void _UART_TX_Tasks(void);
76:                  static void _UART_RX_Tasks(void);
77:                  static void _TRANSMIT_HANDLER_Tasks(void);
78:                  static void _PIC_INTERFACE_Tasks(void);
79:                  static void _PING_SENSORS_Tasks(void);
80:                  static void _GRID_HANDLER_Tasks(void);
81:                  static void _JSON_PARSER_Tasks(void);
82:                  
83:                  
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  // Section: System "Tasks" Routine
87:                  // *****************************************************************************
88:                  // *****************************************************************************
89:                  
90:                  /*******************************************************************************
91:                    Function:
92:                      void SYS_Tasks ( void )
93:                  
94:                    Remarks:
95:                      See prototype in system/common/sys_module.h.
96:                  */
97:                  
98:                  void SYS_Tasks ( void )
99:                  {
9D008064  27BDFFD8   ADDIU SP, SP, -40
9D008068  AFBF0024   SW RA, 36(SP)
9D00806C  AFB00020   SW S0, 32(SP)
100:                     /* Create OS Thread for Sys Tasks. */
101:                     xTaskCreate((TaskFunction_t) _SYS_Tasks,
9D008070  AFA00010   SW ZERO, 16(SP)
9D008074  AFA00014   SW ZERO, 20(SP)
9D008078  AFA00018   SW ZERO, 24(SP)
9D00807C  AFA0001C   SW ZERO, 28(SP)
9D008080  3C049D01   LUI A0, -25343
9D008084  2484DA44   ADDIU A0, A0, -9660
9D008088  3C059D01   LUI A1, -25343
9D00808C  24A5B88C   ADDIU A1, A1, -18292
9D008090  24060400   ADDIU A2, ZERO, 1024
9D008094  0F401A98   JAL xTaskGenericCreate
9D008098  00003821   ADDU A3, ZERO, ZERO
102:                                 "Sys Tasks",
103:                                 1024, NULL, 0, NULL);
104:                 
105:                     /* Create OS Thread for UART_TX Tasks. */
106:                     xTaskCreate((TaskFunction_t) _UART_TX_Tasks,
9D00809C  24100001   ADDIU S0, ZERO, 1
9D0080A0  AFB00010   SW S0, 16(SP)
9D0080A4  AFA00014   SW ZERO, 20(SP)
9D0080A8  AFA00018   SW ZERO, 24(SP)
9D0080AC  AFA0001C   SW ZERO, 28(SP)
9D0080B0  3C049D01   LUI A0, -25343
9D0080B4  2484DC80   ADDIU A0, A0, -9088
9D0080B8  3C059D01   LUI A1, -25343
9D0080BC  24A5B898   ADDIU A1, A1, -18280
9D0080C0  24060400   ADDIU A2, ZERO, 1024
9D0080C4  0F401A98   JAL xTaskGenericCreate
9D0080C8  00003821   ADDU A3, ZERO, ZERO
107:                                 "UART_TX Tasks",
108:                                 1024, NULL, 1, NULL);
109:                 
110:                     /* Create OS Thread for UART_RX Tasks. */
111:                     xTaskCreate((TaskFunction_t) _UART_RX_Tasks,
9D0080CC  AFB00010   SW S0, 16(SP)
9D0080D0  AFA00014   SW ZERO, 20(SP)
9D0080D4  AFA00018   SW ZERO, 24(SP)
9D0080D8  AFA0001C   SW ZERO, 28(SP)
9D0080DC  3C049D01   LUI A0, -25343
9D0080E0  2484DC68   ADDIU A0, A0, -9112
9D0080E4  3C059D01   LUI A1, -25343
9D0080E8  24A5B8A8   ADDIU A1, A1, -18264
9D0080EC  24060400   ADDIU A2, ZERO, 1024
9D0080F0  0F401A98   JAL xTaskGenericCreate
9D0080F4  00003821   ADDU A3, ZERO, ZERO
112:                                 "UART_RX Tasks",
113:                                 1024, NULL, 1, NULL);
114:                 
115:                     /* Create OS Thread for TRANSMIT_HANDLER Tasks. */
116:                     xTaskCreate((TaskFunction_t) _TRANSMIT_HANDLER_Tasks,
9D0080F8  AFB00010   SW S0, 16(SP)
9D0080FC  AFA00014   SW ZERO, 20(SP)
9D008100  AFA00018   SW ZERO, 24(SP)
9D008104  AFA0001C   SW ZERO, 28(SP)
9D008108  3C049D01   LUI A0, -25343
9D00810C  2484DC50   ADDIU A0, A0, -9136
9D008110  3C059D01   LUI A1, -25343
9D008114  24A5B8B8   ADDIU A1, A1, -18248
9D008118  24060400   ADDIU A2, ZERO, 1024
9D00811C  0F401A98   JAL xTaskGenericCreate
9D008120  00003821   ADDU A3, ZERO, ZERO
117:                                 "TRANSMIT_HANDLER Tasks",
118:                                 1024, NULL, 1, NULL);
119:                 
120:                     /* Create OS Thread for PIC_INTERFACE Tasks. */
121:                     xTaskCreate((TaskFunction_t) _PIC_INTERFACE_Tasks,
9D008124  AFB00010   SW S0, 16(SP)
9D008128  AFA00014   SW ZERO, 20(SP)
9D00812C  AFA00018   SW ZERO, 24(SP)
9D008130  AFA0001C   SW ZERO, 28(SP)
9D008134  3C049D01   LUI A0, -25343
9D008138  2484DC38   ADDIU A0, A0, -9160
9D00813C  3C059D01   LUI A1, -25343
9D008140  24A5B8D0   ADDIU A1, A1, -18224
9D008144  24060400   ADDIU A2, ZERO, 1024
9D008148  0F401A98   JAL xTaskGenericCreate
9D00814C  00003821   ADDU A3, ZERO, ZERO
122:                                 "PIC_INTERFACE Tasks",
123:                                 1024, NULL, 1, NULL);
124:                 
125:                     /* Create OS Thread for PING_SENSORS Tasks. */
126:                     xTaskCreate((TaskFunction_t) _PING_SENSORS_Tasks,
9D008150  AFB00010   SW S0, 16(SP)
9D008154  AFA00014   SW ZERO, 20(SP)
9D008158  AFA00018   SW ZERO, 24(SP)
9D00815C  AFA0001C   SW ZERO, 28(SP)
9D008160  3C049D01   LUI A0, -25343
9D008164  2484DC20   ADDIU A0, A0, -9184
9D008168  3C059D01   LUI A1, -25343
9D00816C  24A5B8E4   ADDIU A1, A1, -18204
9D008170  24060400   ADDIU A2, ZERO, 1024
9D008174  0F401A98   JAL xTaskGenericCreate
9D008178  00003821   ADDU A3, ZERO, ZERO
127:                                 "PING_SENSORS Tasks",
128:                                 1024, NULL, 1, NULL);
129:                 
130:                     /* Create OS Thread for GRID_HANDLER Tasks. */
131:                     xTaskCreate((TaskFunction_t) _GRID_HANDLER_Tasks,
9D00817C  AFB00010   SW S0, 16(SP)
9D008180  AFA00014   SW ZERO, 20(SP)
9D008184  AFA00018   SW ZERO, 24(SP)
9D008188  AFA0001C   SW ZERO, 28(SP)
9D00818C  3C049D01   LUI A0, -25343
9D008190  2484DC08   ADDIU A0, A0, -9208
9D008194  3C059D01   LUI A1, -25343
9D008198  24A5B8F8   ADDIU A1, A1, -18184
9D00819C  24061000   ADDIU A2, ZERO, 4096
9D0081A0  0F401A98   JAL xTaskGenericCreate
9D0081A4  00003821   ADDU A3, ZERO, ZERO
132:                                 "GRID_HANDLER Tasks",
133:                                 4096, NULL, 1, NULL);
134:                 
135:                     /* Create OS Thread for JSON_PARSER Tasks. */
136:                     xTaskCreate((TaskFunction_t) _JSON_PARSER_Tasks,
9D0081A8  AFB00010   SW S0, 16(SP)
9D0081AC  AFA00014   SW ZERO, 20(SP)
9D0081B0  AFA00018   SW ZERO, 24(SP)
9D0081B4  AFA0001C   SW ZERO, 28(SP)
9D0081B8  3C049D01   LUI A0, -25343
9D0081BC  2484DBF0   ADDIU A0, A0, -9232
9D0081C0  3C059D01   LUI A1, -25343
9D0081C4  24A5B90C   ADDIU A1, A1, -18164
9D0081C8  24060400   ADDIU A2, ZERO, 1024
9D0081CC  0F401A98   JAL xTaskGenericCreate
9D0081D0  00003821   ADDU A3, ZERO, ZERO
137:                                 "JSON_PARSER Tasks",
138:                                 1024, NULL, 1, NULL);
139:                 
140:                     /**************
141:                      * Start RTOS * 
142:                      **************/
143:                     vTaskStartScheduler(); /* This function never returns. */
9D0081D4  0F402F3C   JAL vTaskStartScheduler
9D0081D8  00000000   NOP
144:                 }
9D0081DC  8FBF0024   LW RA, 36(SP)
9D0081E0  8FB00020   LW S0, 32(SP)
9D0081E4  03E00008   JR RA
9D0081E8  27BD0028   ADDIU SP, SP, 40
145:                 
146:                 
147:                 /*******************************************************************************
148:                   Function:
149:                     void _SYS_Tasks ( void )
150:                 
151:                   Summary:
152:                     Maintains state machines of system modules.
153:                 */
154:                 static void _SYS_Tasks ( void)
155:                 {
9D00DA44  27BDFFE8   ADDIU SP, SP, -24
9D00DA48  AFBF0014   SW RA, 20(SP)
9D00DA4C  AFB00010   SW S0, 16(SP)
156:                     while(1)
157:                     {
158:                         /* Maintain system services */
159:                         SYS_DEVCON_Tasks(sysObj.sysDevcon);
9D00DA50  3C10A000   LUI S0, -24576
9D00DA54  0F40375A   JAL SYS_DEVCON_Tasks
9D00DA58  8E040C88   LW A0, 3208(S0)
9D00DA5C  0B403695   J 0x9D00DA54
9D00DA60  00000000   NOP
160:                 
161:                         /* Maintain Device Drivers */
162:                 
163:                         /* Maintain Middleware */
164:                 
165:                         /* Task Delay */
166:                     }
167:                 }
168:                 
169:                 
170:                 /*******************************************************************************
171:                   Function:
172:                     void _UART_TX_Tasks ( void )
173:                 
174:                   Summary:
175:                     Maintains state machine of UART_TX.
176:                 */
177:                 
178:                 static void _UART_TX_Tasks(void)
179:                 {
9D00DC80  27BDFFE8   ADDIU SP, SP, -24
9D00DC84  AFBF0014   SW RA, 20(SP)
180:                     while(1)
181:                     {
182:                         UART_TX_Tasks();
9D00DC88  0F402FBD   JAL UART_TX_Tasks
9D00DC8C  00000000   NOP
9D00DC90  0B403722   J 0x9D00DC88
9D00DC94  00000000   NOP
183:                     }
184:                 }
185:                 
186:                 
187:                 /*******************************************************************************
188:                   Function:
189:                     void _UART_RX_Tasks ( void )
190:                 
191:                   Summary:
192:                     Maintains state machine of UART_RX.
193:                 */
194:                 
195:                 static void _UART_RX_Tasks(void)
196:                 {
9D00DC68  27BDFFE8   ADDIU SP, SP, -24
9D00DC6C  AFBF0014   SW RA, 20(SP)
197:                     while(1)
198:                     {
199:                         UART_RX_Tasks();
9D00DC70  0F403221   JAL UART_RX_Tasks
9D00DC74  00000000   NOP
9D00DC78  0B40371C   J 0x9D00DC70
9D00DC7C  00000000   NOP
200:                     }
201:                 }
202:                 
203:                 
204:                 /*******************************************************************************
205:                   Function:
206:                     void _TRANSMIT_HANDLER_Tasks ( void )
207:                 
208:                   Summary:
209:                     Maintains state machine of TRANSMIT_HANDLER.
210:                 */
211:                 
212:                 static void _TRANSMIT_HANDLER_Tasks(void)
213:                 {
9D00DC50  27BDFFE8   ADDIU SP, SP, -24
9D00DC54  AFBF0014   SW RA, 20(SP)
214:                     while(1)
215:                     {
216:                         TRANSMIT_HANDLER_Tasks();
9D00DC58  0F4023BD   JAL TRANSMIT_HANDLER_Tasks
9D00DC5C  00000000   NOP
9D00DC60  0B403716   J 0x9D00DC58
9D00DC64  00000000   NOP
217:                     }
218:                 }
219:                 
220:                 
221:                 /*******************************************************************************
222:                   Function:
223:                     void _PIC_INTERFACE_Tasks ( void )
224:                 
225:                   Summary:
226:                     Maintains state machine of PIC_INTERFACE.
227:                 */
228:                 
229:                 static void _PIC_INTERFACE_Tasks(void)
230:                 {
9D00DC38  27BDFFE8   ADDIU SP, SP, -24
9D00DC3C  AFBF0014   SW RA, 20(SP)
231:                     while(1)
232:                     {
233:                         PIC_INTERFACE_Tasks();
9D00DC40  0F402534   JAL PIC_INTERFACE_Tasks
9D00DC44  00000000   NOP
9D00DC48  0B403710   J 0x9D00DC40
9D00DC4C  00000000   NOP
234:                     }
235:                 }
236:                 
237:                 
238:                 /*******************************************************************************
239:                   Function:
240:                     void _PING_SENSORS_Tasks ( void )
241:                 
242:                   Summary:
243:                     Maintains state machine of PING_SENSORS.
244:                 */
245:                 
246:                 static void _PING_SENSORS_Tasks(void)
247:                 {
9D00DC20  27BDFFE8   ADDIU SP, SP, -24
9D00DC24  AFBF0014   SW RA, 20(SP)
248:                     while(1)
249:                     {
250:                         PING_SENSORS_Tasks();
9D00DC28  0F402320   JAL PING_SENSORS_Tasks
9D00DC2C  00000000   NOP
9D00DC30  0B40370A   J 0x9D00DC28
9D00DC34  00000000   NOP
251:                     }
252:                 }
253:                 
254:                 
255:                 /*******************************************************************************
256:                   Function:
257:                     void _GRID_HANDLER_Tasks ( void )
258:                 
259:                   Summary:
260:                     Maintains state machine of GRID_HANDLER.
261:                 */
262:                 
263:                 static void _GRID_HANDLER_Tasks(void)
264:                 {
9D00DC08  27BDFFE8   ADDIU SP, SP, -24
9D00DC0C  AFBF0014   SW RA, 20(SP)
265:                     while(1)
266:                     {
267:                         GRID_HANDLER_Tasks();
9D00DC10  0F401482   JAL GRID_HANDLER_Tasks
9D00DC14  00000000   NOP
9D00DC18  0B403704   J 0x9D00DC10
9D00DC1C  00000000   NOP
268:                     }
269:                 }
270:                 
271:                 
272:                 /*******************************************************************************
273:                   Function:
274:                     void _JSON_PARSER_Tasks ( void )
275:                 
276:                   Summary:
277:                     Maintains state machine of JSON_PARSER.
278:                 */
279:                 
280:                 static void _JSON_PARSER_Tasks(void)
281:                 {
9D00DBF0  27BDFFE8   ADDIU SP, SP, -24
9D00DBF4  AFBF0014   SW RA, 20(SP)
282:                     while(1)
283:                     {
284:                         JSON_PARSER_Tasks();
9D00DBF8  0F402912   JAL JSON_PARSER_Tasks
285:                     }
286:                 }
287:                 
288:                 
289:                 /*******************************************************************************
290:                  End of File
291:                  */
292:                 
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/system_interrupt.c
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     File Name:
5:                       system_interrupt.c
6:                   
7:                     Summary:
8:                       Raw ISR definitions.
9:                   
10:                    Description:
11:                      This file contains a definitions of the raw ISRs required to support the
12:                      interrupt sub-system.
13:                  
14:                    Summary:
15:                      This file contains source code for the interrupt vector functions in the
16:                      system.
17:                  
18:                    Description:
19:                      This file contains source code for the interrupt vector functions in the
20:                      system.  It implements the system and part specific vector "stub" functions
21:                      from which the individual "Tasks" functions are called for any modules
22:                      executing interrupt-driven in the MPLAB Harmony system.
23:                  
24:                    Remarks:
25:                      This file requires access to the systemObjects global data structure that
26:                      contains the object handles to all MPLAB Harmony module objects executing
27:                      interrupt-driven in the system.  These handles are passed into the individual
28:                      module "Tasks" functions to identify the instance of the module to maintain.
29:                   *******************************************************************************/
30:                  
31:                  // DOM-IGNORE-BEGIN
32:                  /*******************************************************************************
33:                  Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
34:                  
35:                  Microchip licenses to you the right to use, modify, copy and distribute
36:                  Software only when embedded on a Microchip microcontroller or digital signal
37:                  controller that is integrated into your product or third party product
38:                  (pursuant to the sublicense terms in the accompanying license agreement).
39:                  
40:                  You should refer to the license agreement accompanying this Software for
41:                  additional information regarding your rights and obligations.
42:                  
43:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
44:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
45:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
46:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
47:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
48:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
49:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
50:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
51:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
52:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
53:                   *******************************************************************************/
54:                  // DOM-IGNORE-END
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  
62:                  #include <xc.h>
63:                  #include <sys/attribs.h>
64:                  #include "uart_tx.h"
65:                  #include "uart_rx.h"
66:                  #include "transmit_handler.h"
67:                  #include "pic_interface.h"
68:                  #include "ping_sensors.h"
69:                  #include "grid_handler.h"
70:                  #include "json_parser.h"
71:                  #include "system_definitions.h"
72:                  
73:                  // *****************************************************************************
74:                  // *****************************************************************************
75:                  // Section: System Interrupt Vector Functions
76:                  // *****************************************************************************
77:                  // *****************************************************************************
78:                  
79:                      
80:                  void IntHandlerDrvTmrInstance0(void)
81:                  {
9D00AB48  27BDFFE8   ADDIU SP, SP, -24
9D00AB4C  AFBF0014   SW RA, 20(SP)
82:                      dbgOutputLoc (0xB0);
9D00AB50  0F402A43   JAL dbgOutputLoc
9D00AB54  240400B0   ADDIU A0, ZERO, 176
83:                      int check = whichOC();
9D00AB58  0F402EFA   JAL whichOC
9D00AB5C  00000000   NOP
84:                      if (check == 0) {
9D00AB60  54400009   BNEL V0, ZERO, 0x9D00AB88
9D00AB64  24030001   ADDIU V1, ZERO, 1
85:                          dbgOutputLoc (0xBB);
9D00AB68  0F402A43   JAL dbgOutputLoc
9D00AB6C  240400BB   ADDIU A0, ZERO, 187
86:                          DRV_OC1_Stop ();
9D00AB70  0F4036DE   JAL DRV_OC1_Stop
9D00AB74  00000000   NOP
87:                          DRV_OC0_Start ();
9D00AB78  0F4036CC   JAL DRV_OC0_Start
9D00AB7C  00000000   NOP
9D00AB80  0B402AFB   J 0x9D00ABEC
9D00AB84  24030100   ADDIU V1, ZERO, 256
88:                      }
89:                      else if (check == 1) {
9D00AB88  54430009   BNEL V0, V1, 0x9D00ABB0
9D00AB8C  24030002   ADDIU V1, ZERO, 2
90:                          dbgOutputLoc (0xBA);
9D00AB90  0F402A43   JAL dbgOutputLoc
9D00AB94  240400BA   ADDIU A0, ZERO, 186
91:                          DRV_OC0_Stop ();
9D00AB98  0F4036D2   JAL DRV_OC0_Stop
9D00AB9C  00000000   NOP
92:                          DRV_OC2_Start ();
9D00ABA0  0F4036E4   JAL DRV_OC2_Start
9D00ABA4  00000000   NOP
9D00ABA8  0B402AFB   J 0x9D00ABEC
9D00ABAC  24030100   ADDIU V1, ZERO, 256
93:                      }
94:                      else if (check == 2) {
9D00ABB0  54430007   BNEL V0, V1, 0x9D00ABD0
9D00ABB4  24030003   ADDIU V1, ZERO, 3
95:                          DRV_OC2_Stop ();
9D00ABB8  0F4036EA   JAL DRV_OC2_Stop
9D00ABBC  00000000   NOP
96:                          DRV_OC3_Start ();
9D00ABC0  0F4036F0   JAL DRV_OC3_Start
9D00ABC4  00000000   NOP
9D00ABC8  0B402AFB   J 0x9D00ABEC
9D00ABCC  24030100   ADDIU V1, ZERO, 256
97:                      }
98:                      else if (check == 3) {
9D00ABD0  14430006   BNE V0, V1, 0x9D00ABEC
9D00ABD4  24030100   ADDIU V1, ZERO, 256
99:                          DRV_OC3_Stop ();
9D00ABD8  0F4036F6   JAL DRV_OC3_Stop
9D00ABDC  00000000   NOP
100:                         DRV_OC1_Start ();
9D00ABE0  0F4036D8   JAL DRV_OC1_Start
9D00ABE4  00000000   NOP
101:                     }
102:                     PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_TIMER_2);
103:                 }
9D00ABF8  8FBF0014   LW RA, 20(SP)
9D00ABFC  03E00008   JR RA
9D00AC00  27BD0018   ADDIU SP, SP, 24
104:                  void IntHandlerDrvUsartInstance0(void)
105:                 {
9D00D4EC  27BDFFE8   ADDIU SP, SP, -24
9D00D4F0  AFBF0014   SW RA, 20(SP)
9D00D4F4  AFB00010   SW S0, 16(SP)
106:                     DRV_USART_TasksTransmit(sysObj.drvUsart0);
9D00D4F8  3C10A000   LUI S0, -24576
9D00D4FC  26100C88   ADDIU S0, S0, 3208
9D00D500  0F402B87   JAL DRV_USART_TasksTransmit
9D00D504  8E040008   LW A0, 8(S0)
107:                     DRV_USART_TasksReceive(sysObj.drvUsart0);
9D00D508  0F402BB2   JAL DRV_USART_TasksReceive
9D00D50C  8E040008   LW A0, 8(S0)
108:                     DRV_USART_TasksError(sysObj.drvUsart0);
9D00D510  0F401918   JAL DRV_USART_TasksError
9D00D514  8E040008   LW A0, 8(S0)
109:                 }
9D00D518  8FBF0014   LW RA, 20(SP)
9D00D51C  8FB00010   LW S0, 16(SP)
9D00D520  03E00008   JR RA
9D00D524  27BD0018   ADDIU SP, SP, 24
110:                  
111:                  
112:                  
113:                 
114:                 void IntHandlerDrvUsartInstance1(void)
115:                 {
9D00D528  27BDFFE8   ADDIU SP, SP, -24
9D00D52C  AFBF0014   SW RA, 20(SP)
9D00D530  AFB00010   SW S0, 16(SP)
116:                     DRV_USART_TasksTransmit(sysObj.drvUsart1);
9D00D534  3C10A000   LUI S0, -24576
9D00D538  26100C88   ADDIU S0, S0, 3208
9D00D53C  0F402B87   JAL DRV_USART_TasksTransmit
9D00D540  8E04000C   LW A0, 12(S0)
117:                     DRV_USART_TasksReceive(sysObj.drvUsart1);
9D00D544  0F402BB2   JAL DRV_USART_TasksReceive
9D00D548  8E04000C   LW A0, 12(S0)
118:                     DRV_USART_TasksError(sysObj.drvUsart1);
9D00D54C  0F401918   JAL DRV_USART_TasksError
9D00D550  8E04000C   LW A0, 12(S0)
119:                 }
9D00D554  8FBF0014   LW RA, 20(SP)
9D00D558  8FB00010   LW S0, 16(SP)
9D00D55C  03E00008   JR RA
9D00D560  27BD0018   ADDIU SP, SP, 24
120:                  
121:                  
122:                  
123:                 
124:                  
125:                 
126:                  
127:                 
128:                  
129:                 
130:                  
131:                  
132:                 void IntHandlerDrvICInstance0(void)
133:                 {
9D00CDD4  27BDFFE0   ADDIU SP, SP, -32
9D00CDD8  AFBF001C   SW RA, 28(SP)
134:                     dbgOutputLoc (0x40);
9D00CDDC  0F402A43   JAL dbgOutputLoc
9D00CDE0  24040040   ADDIU A0, ZERO, 64
135:                 //    PLIB_PORTS_Write (PORTS_ID_0, PORT_CHANNEL_E, 0x00FF & 0x91);
136:                     VALUES_t vals;
137:                     vals.sensor = 0x00;
138:                     vals.val1 = DRV_IC0_Capture16BitDataRead();
9D00CDE4  0F403744   JAL DRV_IC0_Capture16BitDataRead
9D00CDE8  A3A00010   SB ZERO, 16(SP)
139:                     vals.val2 = DRV_IC0_Capture16BitDataRead();
9D00CDEC  0F403744   JAL DRV_IC0_Capture16BitDataRead
9D00CDF0  A7A20012   SH V0, 18(SP)
9D00CDF4  A7A20014   SH V0, 20(SP)
140:                     QSendFromISR (vals);
9D00CDF8  8FA40010   LW A0, 16(SP)
9D00CDFC  0F403137   JAL QSendFromISR
9D00CE00  8FA50014   LW A1, 20(SP)
141:                     dbgOutputLoc (0x4C);
9D00CE04  0F402A43   JAL dbgOutputLoc
9D00CE08  2404004C   ADDIU A0, ZERO, 76
142:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_3);
143:                 }
9D00CE1C  8FBF001C   LW RA, 28(SP)
9D00CE20  03E00008   JR RA
9D00CE24  27BD0020   ADDIU SP, SP, 32
144:                 void IntHandlerDrvICInstance1(void)
145:                 {
9D00CC2C  27BDFFE0   ADDIU SP, SP, -32
9D00CC30  AFBF001C   SW RA, 28(SP)
146:                     dbgOutputLoc(0xC0);
9D00CC34  0F402A43   JAL dbgOutputLoc
9D00CC38  240400C0   ADDIU A0, ZERO, 192
147:                     VALUES_t vals;
148:                     vals.sensor = 0x11;
9D00CC3C  24020011   ADDIU V0, ZERO, 17
149:                     vals.val1 = DRV_IC1_Capture16BitDataRead();
9D00CC40  0F403748   JAL DRV_IC1_Capture16BitDataRead
9D00CC44  A3A20010   SB V0, 16(SP)
150:                     vals.val2 = DRV_IC1_Capture16BitDataRead();
9D00CC48  0F403748   JAL DRV_IC1_Capture16BitDataRead
9D00CC4C  A7A20012   SH V0, 18(SP)
9D00CC50  A7A20014   SH V0, 20(SP)
151:                     QSendFromISR (vals);
9D00CC54  8FA40010   LW A0, 16(SP)
9D00CC58  0F403137   JAL QSendFromISR
9D00CC5C  8FA50014   LW A1, 20(SP)
152:                     dbgOutputLoc (0xC5);
9D00CC60  0F402A43   JAL dbgOutputLoc
9D00CC64  240400C5   ADDIU A0, ZERO, 197
153:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_1);
154:                 }
9D00CC78  8FBF001C   LW RA, 28(SP)
9D00CC7C  03E00008   JR RA
9D00CC80  27BD0020   ADDIU SP, SP, 32
155:                 void IntHandlerDrvICInstance2(void)
156:                 {
9D00D088  27BDFFE0   ADDIU SP, SP, -32
9D00D08C  AFBF001C   SW RA, 28(SP)
157:                     VALUES_t vals;
158:                     vals.sensor = 0x22;
9D00D090  24020022   ADDIU V0, ZERO, 34
159:                     vals.val1 = DRV_IC2_Capture16BitDataRead();
9D00D094  0F40374C   JAL DRV_IC2_Capture16BitDataRead
9D00D098  A3A20010   SB V0, 16(SP)
160:                     vals.val2 = DRV_IC2_Capture16BitDataRead();
9D00D09C  0F40374C   JAL DRV_IC2_Capture16BitDataRead
9D00D0A0  A7A20012   SH V0, 18(SP)
9D00D0A4  A7A20014   SH V0, 20(SP)
161:                     QSendFromISR (vals);
9D00D0A8  8FA40010   LW A0, 16(SP)
9D00D0AC  0F403137   JAL QSendFromISR
9D00D0B0  8FA50014   LW A1, 20(SP)
162:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_4);
163:                 }
9D00D0C4  8FBF001C   LW RA, 28(SP)
9D00D0C8  03E00008   JR RA
9D00D0CC  27BD0020   ADDIU SP, SP, 32
164:                 void IntHandlerDrvICInstance3(void)
165:                 
166:                 {
9D00D0D0  27BDFFE0   ADDIU SP, SP, -32
9D00D0D4  AFBF001C   SW RA, 28(SP)
167:                     VALUES_t vals;
168:                     vals.sensor = 0x33;
9D00D0D8  24020033   ADDIU V0, ZERO, 51
169:                     vals.val1 = DRV_IC3_Capture16BitDataRead();
9D00D0DC  0F403750   JAL DRV_IC3_Capture16BitDataRead
9D00D0E0  A3A20010   SB V0, 16(SP)
170:                     vals.val2 = DRV_IC3_Capture16BitDataRead();
9D00D0E4  0F403750   JAL DRV_IC3_Capture16BitDataRead
9D00D0E8  A7A20012   SH V0, 18(SP)
9D00D0EC  A7A20014   SH V0, 20(SP)
171:                     QSendFromISR (vals);
9D00D0F0  8FA40010   LW A0, 16(SP)
9D00D0F4  0F403137   JAL QSendFromISR
9D00D0F8  8FA50014   LW A1, 20(SP)
172:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_5);
173:                 }
9D00D10C  8FBF001C   LW RA, 28(SP)
9D00D110  03E00008   JR RA
9D00D114  27BD0020   ADDIU SP, SP, 32
174:                 
175:                  
176:                 /*******************************************************************************
177:                  End of File
178:                 */
179:                 
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/system_init.c
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       system_init.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits, 
13:                      and allocates any necessary global system resources, such as the 
14:                      sysObj structure that contains the object handles to all the MPLAB Harmony 
15:                      module objects in the system.
16:                   *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system_config.h"
50:                  #include "system_definitions.h"
51:                  
52:                  
53:                  // ****************************************************************************
54:                  // ****************************************************************************
55:                  // Section: Configuration Bits
56:                  // ****************************************************************************
57:                  // ****************************************************************************
58:                  // <editor-fold defaultstate="collapsed" desc="Configuration Bits">
59:                  
60:                  /*** DEVCFG0 ***/
61:                  
62:                  #pragma config DEBUG =      ON
63:                  #pragma config ICESEL =     ICS_PGx2
64:                  #pragma config PWP =        OFF
65:                  #pragma config BWP =        OFF
66:                  #pragma config CP =         OFF
67:                  
68:                  /*** DEVCFG1 ***/
69:                  
70:                  #pragma config FNOSC =      FRCPLL
71:                  #pragma config FSOSCEN =    ON
72:                  #pragma config IESO =       ON
73:                  #pragma config POSCMOD =    OFF
74:                  #pragma config OSCIOFNC =   OFF
75:                  #pragma config FPBDIV =     DIV_1
76:                  #pragma config FCKSM =      CSECMD
77:                  #pragma config WDTPS =      PS1048576
78:                  #pragma config FWDTEN =     OFF
79:                  /*** DEVCFG2 ***/
80:                  
81:                  #pragma config FPLLIDIV =   DIV_2
82:                  #pragma config FPLLMUL =    MUL_20
83:                  #pragma config FPLLODIV =   DIV_1
84:                  #pragma config UPLLIDIV =   DIV_2
85:                  #pragma config UPLLEN =     OFF
86:                  /*** DEVCFG3 ***/
87:                  
88:                  #pragma config USERID =     0xffff
89:                  #pragma config FSRSSEL =    PRIORITY_7
90:                  #pragma config FMIIEN =     ON
91:                  #pragma config FETHIO =     ON
92:                  #pragma config FCANIO =     ON
93:                  #pragma config FUSBIDIO =   ON
94:                  #pragma config FVBUSONIO =  ON
95:                  // </editor-fold>
96:                  
97:                  // *****************************************************************************
98:                  // *****************************************************************************
99:                  // Section: Driver Initialization Data
100:                 // *****************************************************************************
101:                 // *****************************************************************************
102:                 // <editor-fold defaultstate="collapsed" desc="DRV_Timer Initialization Data">
103:                 // </editor-fold>
104:                 // <editor-fold defaultstate="collapsed" desc="DRV_USART Initialization Data">
105:                 
106:                 const DRV_USART_INIT drvUsart0InitData =
107:                 {
108:                     .moduleInit.value = DRV_USART_POWER_STATE_IDX0,
109:                     .usartID = DRV_USART_PERIPHERAL_ID_IDX0, 
110:                     .mode = DRV_USART_OPER_MODE_IDX0,
111:                     .flags = DRV_USART_INIT_FLAGS_IDX0,
112:                     .brgClock = DRV_USART_BRG_CLOCK_IDX0,
113:                     .lineControl = DRV_USART_LINE_CNTRL_IDX0,
114:                     .baud = DRV_USART_BAUD_RATE_IDX0,
115:                     .handshake = DRV_USART_HANDSHAKE_MODE_IDX0,
116:                     .interruptTransmit = DRV_USART_XMIT_INT_SRC_IDX0,
117:                     .interruptReceive = DRV_USART_RCV_INT_SRC_IDX0,
118:                     .interruptError = DRV_USART_ERR_INT_SRC_IDX0,
119:                     .dmaChannelTransmit = DMA_CHANNEL_NONE,
120:                     .dmaInterruptTransmit = DRV_USART_XMIT_INT_SRC_IDX0,    
121:                     .dmaChannelReceive = DMA_CHANNEL_NONE,
122:                     .dmaInterruptReceive = DRV_USART_RCV_INT_SRC_IDX0,    
123:                 };
124:                 
125:                 const DRV_USART_INIT drvUsart1InitData =
126:                 {
127:                     .moduleInit.value = DRV_USART_POWER_STATE_IDX1,
128:                     .usartID = DRV_USART_PERIPHERAL_ID_IDX1, 
129:                     .mode = DRV_USART_OPER_MODE_IDX1,
130:                     .flags = DRV_USART_INIT_FLAGS_IDX1,
131:                     .brgClock = DRV_USART_BRG_CLOCK_IDX1,
132:                     .lineControl = DRV_USART_LINE_CNTRL_IDX1,
133:                     .baud = DRV_USART_BAUD_RATE_IDX1,
134:                     .handshake = DRV_USART_HANDSHAKE_MODE_IDX1,
135:                     .interruptTransmit = DRV_USART_XMIT_INT_SRC_IDX1,
136:                     .interruptReceive = DRV_USART_RCV_INT_SRC_IDX1,
137:                     .interruptError = DRV_USART_ERR_INT_SRC_IDX1,
138:                     .dmaChannelTransmit = DMA_CHANNEL_NONE,
139:                     .dmaInterruptTransmit = DRV_USART_XMIT_INT_SRC_IDX1,
140:                     .dmaChannelReceive = DMA_CHANNEL_NONE,
141:                     .dmaInterruptReceive= DRV_USART_RCV_INT_SRC_IDX1,
142:                 };
143:                 // </editor-fold>
144:                 
145:                 // *****************************************************************************
146:                 // *****************************************************************************
147:                 // Section: System Data
148:                 // *****************************************************************************
149:                 // *****************************************************************************
150:                 
151:                 /* Structure to hold the object handles for the modules in the system. */
152:                 SYSTEM_OBJECTS sysObj;
153:                 
154:                 // *****************************************************************************
155:                 // *****************************************************************************
156:                 // Section: Module Initialization Data
157:                 // *****************************************************************************
158:                 // *****************************************************************************
159:                 //<editor-fold defaultstate="collapsed" desc="SYS_DEVCON Initialization Data">
160:                 /*******************************************************************************
161:                   Device Control System Service Initialization Data
162:                 */
163:                 
164:                 const SYS_DEVCON_INIT sysDevconInit =
165:                 {
166:                     .moduleInit = {0},
167:                 };
168:                 
169:                 // </editor-fold>
170:                 
171:                 // *****************************************************************************
172:                 // *****************************************************************************
173:                 // Section: Library/Stack Initialization Data
174:                 // *****************************************************************************
175:                 // *****************************************************************************
176:                 
177:                 // *****************************************************************************
178:                 // *****************************************************************************
179:                 // Section: Static Initialization Functions
180:                 // *****************************************************************************
181:                 // *****************************************************************************
182:                 
183:                 
184:                 // *****************************************************************************
185:                 // *****************************************************************************
186:                 // Section: System Initialization
187:                 // *****************************************************************************
188:                 // *****************************************************************************
189:                 
190:                 /*******************************************************************************
191:                   Function:
192:                     void SYS_Initialize ( void *data )
193:                 
194:                   Summary:
195:                     Initializes the board, services, drivers, application and other modules.
196:                 
197:                   Remarks:
198:                     See prototype in system/common/sys_module.h.
199:                  */
200:                 
201:                 void SYS_Initialize ( void* data )
202:                 {
9D008764  27BDFFE8   ADDIU SP, SP, -24
9D008768  AFBF0014   SW RA, 20(SP)
9D00876C  AFB00010   SW S0, 16(SP)
203:                     /* Core Processor Initialization */
204:                     SYS_CLK_Initialize( NULL );
9D008770  0F4032F5   JAL SYS_CLK_Initialize
9D008774  00002021   ADDU A0, ZERO, ZERO
205:                     sysObj.sysDevcon = SYS_DEVCON_Initialize(SYS_DEVCON_INDEX_0, (SYS_MODULE_INIT*)&sysDevconInit);
9D008778  00002021   ADDU A0, ZERO, ZERO
9D00877C  3C059D01   LUI A1, -25343
9D008780  0F403731   JAL SYS_DEVCON_Initialize
9D008784  24A5B7F8   ADDIU A1, A1, -18440
9D008788  3C10A000   LUI S0, -24576
206:                     SYS_DEVCON_PerformanceConfig(SYS_CLK_SystemFrequencyGet());
9D00878C  0F403757   JAL SYS_CLK_SystemFrequencyGet
9D008790  AE020C88   SW V0, 3208(S0)
9D008794  0F40286E   JAL SYS_DEVCON_PerformanceConfig
9D008798  00402021   ADDU A0, V0, ZERO
207:                     SYS_DEVCON_JTAGDisable();
9D00879C  0F4036A0   JAL SYS_DEVCON_JTAGDisable
9D0087A0  26100C88   ADDIU S0, S0, 3208
208:                     SYS_PORTS_Initialize();
9D0087A4  0F4034EF   JAL SYS_PORTS_Initialize
9D0087A8  00000000   NOP
209:                 
210:                     /* Initialize Drivers */
211:                     /* Initialize the IC Driver */
212:                     DRV_IC0_Initialize();
9D0087AC  0F402CF7   JAL DRV_IC0_Initialize
9D0087B0  00000000   NOP
213:                     DRV_IC1_Initialize();
9D0087B4  0F402D1D   JAL DRV_IC1_Initialize
9D0087B8  00000000   NOP
214:                     DRV_IC2_Initialize();
9D0087BC  0F402D43   JAL DRV_IC2_Initialize
9D0087C0  00000000   NOP
215:                     DRV_IC3_Initialize();
9D0087C4  0F402D69   JAL DRV_IC3_Initialize
9D0087C8  00000000   NOP
216:                     /* Initialize the OC Driver */
217:                     DRV_OC0_Initialize();
9D0087CC  0F40316B   JAL DRV_OC0_Initialize
9D0087D0  00000000   NOP
218:                     DRV_OC1_Initialize();
9D0087D4  0F403185   JAL DRV_OC1_Initialize
9D0087D8  00000000   NOP
219:                     DRV_OC2_Initialize();
9D0087DC  0F40319F   JAL DRV_OC2_Initialize
9D0087E0  00000000   NOP
220:                     DRV_OC3_Initialize();
9D0087E4  0F4031B9   JAL DRV_OC3_Initialize
9D0087E8  00000000   NOP
221:                     /*Initialize TMR0 */
222:                     DRV_TMR0_Initialize();
9D0087EC  0F40301A   JAL DRV_TMR0_Initialize
9D0087F0  00000000   NOP
223:                  
224:                      sysObj.drvUsart0 = DRV_USART_Initialize(DRV_USART_INDEX_0, (SYS_MODULE_INIT *)&drvUsart0InitData);
9D0087F4  00002021   ADDU A0, ZERO, ZERO
9D0087F8  3C059D01   LUI A1, -25343
9D0087FC  0F401213   JAL DRV_USART_Initialize
9D008800  24A5B844   ADDIU A1, A1, -18364
9D008804  AE020008   SW V0, 8(S0)
225:                     sysObj.drvUsart1 = DRV_USART_Initialize(DRV_USART_INDEX_1, (SYS_MODULE_INIT *)&drvUsart1InitData);
9D008808  24040001   ADDIU A0, ZERO, 1
9D00880C  3C059D01   LUI A1, -25343
9D008810  0F401213   JAL DRV_USART_Initialize
9D008814  24A5B7FC   ADDIU A1, A1, -18436
9D008818  AE02000C   SW V0, 12(S0)
226:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART1, INT_PRIORITY_LEVEL1);
227:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART1, INT_SUBPRIORITY_LEVEL0);
228:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART2, INT_PRIORITY_LEVEL1);
229:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART2, INT_SUBPRIORITY_LEVEL0);
230:                 
231:                     /* Initialize System Services */
232:                 
233:                     /*** Interrupt Service Initialization Code ***/
234:                     SYS_INT_Initialize();
9D008864  0F4036AE   JAL SYS_INT_Initialize
9D008868  00000000   NOP
235:                   
236:                     /* Initialize Middleware */
237:                 
238:                 
239:                     /* Initialize the Application */
240:                     UART_TX_Initialize();
9D00886C  0F4033B2   JAL UART_TX_Initialize
9D008870  00000000   NOP
241:                     UART_RX_Initialize();
9D008874  0F403253   JAL UART_RX_Initialize
9D008878  00000000   NOP
242:                     TRANSMIT_HANDLER_Initialize();
9D00887C  0F403607   JAL TRANSMIT_HANDLER_Initialize
9D008880  00000000   NOP
243:                     PIC_INTERFACE_Initialize();
9D008884  0F40323A   JAL PIC_INTERFACE_Initialize
9D008888  00000000   NOP
244:                     PING_SENSORS_Initialize();
9D00888C  0F4030E7   JAL PING_SENSORS_Initialize
9D008890  00000000   NOP
245:                     GRID_HANDLER_Initialize();
9D008894  0F403699   JAL GRID_HANDLER_Initialize
9D008898  00000000   NOP
246:                     JSON_PARSER_Initialize();
9D00889C  0F403559   JAL JSON_PARSER_Initialize
9D0088A0  00000000   NOP
247:                 }
9D0088A4  8FBF0014   LW RA, 20(SP)
9D0088A8  8FB00010   LW S0, 16(SP)
9D0088AC  03E00008   JR RA
9D0088B0  27BD0018   ADDIU SP, SP, 24
248:                 
249:                 
250:                 /*******************************************************************************
251:                  End of File
252:                 */
253:                 
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/system_exceptions.c
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       system_exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the deafult _weak_ exception 
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occured.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  
45:                  #include <xc.h>                 /* Defines special funciton registers, CP0 regs  */
46:                  #include "system_config.h"
47:                  #include "system_definitions.h"
48:                  #include "system/debug/sys_debug.h"
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data Definitions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /*******************************************************************************
58:                    Exception Reason Data
59:                    
60:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
61:                    
62:                    Remarks:
63:                      These global static items are used instead of local variables in the 
64:                      _general_exception_handler function because the stack may not be available
65:                      if an exception has occured.
66:                  */
67:                  
68:                  /* Code identifying the cause of the exception (CP0 Cause register). */
69:                  static unsigned int _excep_code;
70:                  
71:                  /* Address of instruction that caused the exception. */
72:                  static unsigned int _excep_addr;
73:                  
74:                  /* Pointer to the string describing the cause of the exception. */
75:                  static char *_cause_str;
76:                  
77:                  /* Array identifying the cause (indexed by _exception_code). */
78:                  static char *cause[] = 
79:                  {
80:                      "Interrupt",
81:                      "Undefined",
82:                      "Undefined",
83:                      "Undefined",
84:                      "Load/fetch address error",
85:                      "Store address error",
86:                      "Instruction bus error",
87:                      "Data bus error",
88:                      "Syscall",
89:                      "Breakpoint",
90:                      "Reserved instruction",
91:                      "Coprocessor unusable",
92:                      "Arithmetic overflow",
93:                      "Trap",
94:                      "Reserved",
95:                      "Reserved",
96:                      "Reserved",
97:                      "Reserved",
98:                      "Reserved"
99:                  };
100:                 
101:                 // </editor-fold>
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Exception Handling
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void _general_exception_handler ( void )
113:                 
114:                   Summary:
115:                     Overrides the XC32 _weak_ _generic_exception_handler.
116:                     
117:                   Description:
118:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
119:                 
120:                   Remarks:
121:                     Refer to the XC32 User's Guide for additional information.
122:                  */
123:                 
124:                 void _general_exception_handler ( void )
125:                 {
9D00D274  27BDFFF8   ADDIU SP, SP, -8
9D00D278  AFBF0004   SW RA, 4(SP)
126:                     /* Mask off Mask of the ExcCode Field from the Cause Register
127:                     Refer to the MIPs Software User's manual */
128:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D00D27C  40026800   MFC0 V0, Cause
9D00D280  7C422080   EXT V0, V0, 2, 5
9D00D284  AF8280A4   SW V0, -32604(GP)
129:                     _excep_addr = _CP0_GET_EPC();
9D00D288  40027000   MFC0 V0, EPC
9D00D28C  AF8280A0   SW V0, -32608(GP)
130:                     _cause_str  = cause[_excep_code];
9D00D290  8F8380A4   LW V1, -32604(GP)
9D00D294  00031880   SLL V1, V1, 2
9D00D298  3C029D01   LUI V0, -25343
9D00D29C  24429484   ADDIU V0, V0, -27516
9D00D2A0  00621021   ADDU V0, V1, V0
9D00D2A4  8C420000   LW V0, 0(V0)
9D00D2A8  AF82809C   SW V0, -32612(GP)
131:                 
132:                     SYS_DEBUG_PRINT(SYS_ERROR_ERROR, "\nGeneral Exception %s (cause=%d, addr=%x).\n", 
133:                                     _cause_str, _excep_code, _excep_addr);
134:                 
135:                     while (1)
136:                     {
137:                         SYS_DEBUG_BreakPoint();
9D00D2AC  7000003F   SDBBP 0
9D00D2B0  0B4034AB   J 0x9D00D2AC
9D00D2B4  00000000   NOP
138:                     }
139:                 }
140:                 
141:                 /*******************************************************************************
142:                  End of File
143:                 */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/rtos_hooks.c
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       rtos_hooks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary for rtos hooks
9:                   
10:                    Description:
11:                  
12:                    Remarks:
13:                   *******************************************************************************/
14:                  
15:                  // DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
18:                  
19:                  Microchip licenses to you the right to use, modify, copy and distribute
20:                  Software only when embedded on a Microchip microcontroller or digital signal
21:                  controller that is integrated into your product or third party product
22:                  (pursuant to the sublicense terms in the accompanying license agreement).
23:                  
24:                  You should refer to the license agreement accompanying this Software for
25:                  additional information regarding your rights and obligations.
26:                  
27:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
28:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
29:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
30:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
31:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
32:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
33:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
34:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
35:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
36:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
37:                   *******************************************************************************/
38:                  // DOM-IGNORE-END
39:                  #include "FreeRTOS.h"
40:                  #include "task.h"
41:                  
42:                  /*
43:                  *********************************************************************************************************
44:                  *                                          vApplicationStackOverflowHook()
45:                  *
46:                  * Description : Hook function called by FreeRTOS if a stack overflow happens.
47:                  *
48:                  * Argument(s) : none
49:                  *
50:                  * Return(s)   : none
51:                  *
52:                  * Caller(s)   : APP_StateReset()
53:                  *
54:                  * Note(s)     : none.
55:                  *********************************************************************************************************
56:                  */
57:                  void vApplicationStackOverflowHook( TaskHandle_t pxTask, signed char *pcTaskName )
58:                  {
9D00D8A0  27BDFFF8   ADDIU SP, SP, -8
9D00D8A4  AFBF0004   SW RA, 4(SP)
59:                     ( void ) pcTaskName;
60:                     ( void ) pxTask;
61:                  
62:                     /* Run time task stack overflow checking is performed if
63:                     configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook	function is
64:                     called if a task stack overflow is detected.  Note the system/interrupt
65:                     stack is not checked. */
66:                     taskDISABLE_INTERRUPTS();
9D00D8A8  40026000   MFC0 V0, Status
9D00D8AC  3C03FFFF   LUI V1, -1
9D00D8B0  246303FF   ADDIU V1, V1, 1023
9D00D8B4  00431024   AND V0, V0, V1
9D00D8B8  34420C00   ORI V0, V0, 3072
9D00D8BC  40826000   MTC0 V0, Status
9D00D8C0  000000C0   EHB
9D00D8C4  0B403631   J 0x9D00D8C4
9D00D8C8  00000000   NOP
67:                     for( ;; );
68:                  }
69:                  
70:                  /*
71:                  *********************************************************************************************************
72:                  *                                     vApplicationMallocFailedHook()
73:                  *
74:                  * Description : vApplicationMallocFailedHook() will only be called if
75:                  *               configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h.
76:                  *               It is a hook function that will get called if a call to
77:                  *               pvPortMalloc() fails.  pvPortMalloc() is called internally by
78:                  *               the kernel whenever a task, queue, timer or semaphore is
79:                  *               created.  It is also called by various parts of the demo
80:                  *               application.  If heap_1.c or heap_2.c are used, then the size of
81:                  *               the heap available to pvPortMalloc() is defined by
82:                  *               configTOTAL_HEAP_SIZE in FreeRTOSConfig.h, and the
83:                  *               xPortGetFreeHeapSize() API function can be used to query the
84:                  *               size of free heap space that remains (although it does not
85:                  *               provide information on how the remaining heap might be
86:                  *               fragmented).
87:                  *
88:                  * Argument(s) : none
89:                  *
90:                  * Return(s)   : none
91:                  *
92:                  * Caller(s)   : APP_StateReset()
93:                  *
94:                  * Note(s)     : none.
95:                  *********************************************************************************************************
96:                  */
97:                  
98:                  void vApplicationMallocFailedHook( void )
99:                  {
9D00D8CC  27BDFFF8   ADDIU SP, SP, -8
9D00D8D0  AFBF0004   SW RA, 4(SP)
100:                    /* vApplicationMallocFailedHook() will only be called if
101:                       configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h.  It is a hook
102:                       function that will get called if a call to pvPortMalloc() fails.
103:                       pvPortMalloc() is called internally by the kernel whenever a task, queue,
104:                       timer or semaphore is created.  It is also called by various parts of the
105:                       demo application.  If heap_1.c or heap_2.c are used, then the size of the
106:                       heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
107:                       FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
108:                       to query the size of free heap space that remains (although it does not
109:                       provide information on how the remaining heap might be fragmented). */
110:                    taskDISABLE_INTERRUPTS();
9D00D8D4  40026000   MFC0 V0, Status
9D00D8D8  3C03FFFF   LUI V1, -1
9D00D8DC  246303FF   ADDIU V1, V1, 1023
9D00D8E0  00431024   AND V0, V0, V1
9D00D8E4  34420C00   ORI V0, V0, 3072
9D00D8E8  40826000   MTC0 V0, Status
9D00D8EC  000000C0   EHB
9D00D8F0  0B40363C   J 0x9D00D8F0
9D00D8F4  00000000   NOP
111:                    for( ;; );
112:                 }
113:                 
114:                 
115:                 
116:                 /*******************************************************************************
117:                  End of File
118:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/framework/system/ports/src/sys_ports_static.c
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_ports_static.c
9:                   
10:                    Summary:
11:                      SYS PORTS static function implementations for the Ports System Service.
12:                  
13:                    Description:
14:                      The Ports System Service provides a simple interface to manage the ports
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Ports System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system ports configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                  
24:                  *******************************************************************************/
25:                  
26:                  //DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                  *******************************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  #include "system_config.h"
52:                  #include "system/ports/sys_ports.h"
53:                  #include "peripheral/devcon/plib_devcon.h"
54:                  #include "peripheral/ports/plib_ports.h"
55:                  #include "peripheral/int/plib_int.h"
56:                  
57:                  /******************************************************************************
58:                    Function:
59:                      SYS_PORTS_Initialize(void)
60:                  
61:                    Summary:
62:                      Initializes Ports System Service
63:                  
64:                    Description:
65:                      This function initializes different port pins/channels to the desired state.
66:                      It also remaps the pins to the desired specific function.
67:                  
68:                    Remarks:
69:                      None.
70:                  */
71:                  void SYS_PORTS_Initialize(void)
72:                  {
73:                      /* AN and CN Pins Initialization */
74:                      PLIB_PORTS_AnPinsModeSelect(PORTS_ID_0, SYS_PORT_AD1PCFG, PORTS_PIN_MODE_DIGITAL);
75:                      PLIB_PORTS_CnPinsPullUpEnable(PORTS_ID_0, SYS_PORT_CNPUE);
76:                      PLIB_PORTS_CnPinsEnable(PORTS_ID_0, SYS_PORT_CNEN);
77:                      PLIB_PORTS_ChangeNoticeEnable(PORTS_ID_0);
78:                  
79:                      
80:                      
81:                  }
82:                  
83:                  /******************************************************************************
84:                    Function:
85:                      PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
86:                  
87:                    Summary:
88:                      Reads the data from the I/O port.
89:                  
90:                    Description:
91:                      This function reads the data from the I/O port.
92:                  
93:                    Remarks:
94:                      None.
95:                  */
96:                  
97:                  PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
98:                  {
99:                      return PLIB_PORTS_Read( index, channel );
100:                 }
00000030  00000000   NOP
101:                 
102:                 
103:                 /******************************************************************************
104:                   Function:
105:                     void SYS_PORTS_Write( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
106:                                       		PORTS_DATA_TYPE value )
107:                 
108:                   Summary:
109:                     Writes the data from the I/O port.
110:                 
111:                   Description:
112:                     This function writes the data to the I/O port.
113:                 
114:                   Remarks:
115:                     None.
116:                 */
117:                 
118:                 void SYS_PORTS_Write( PORTS_MODULE_ID index,
119:                                       PORTS_CHANNEL channel,
120:                                       PORTS_DATA_TYPE value )
121:                 {
122:                     PLIB_PORTS_Write( index, channel, value );
123:                 }
124:                 
125:                 
126:                 /******************************************************************************
127:                   Function:
128:                     void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
129:                 	                         PORTS_DATA_TYPE value,
130:                                          PORTS_DATA_MASK mask )
131:                 
132:                   Summary:
133:                     Sets the selected digital port/latch based on the mask.
134:                 
135:                   Description:
136:                     This function sets the selected digital port/latch relative to the mask.
137:                 
138:                   Remarks:
139:                     None.
140:                 */
141:                 
142:                 void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
143:                                     PORTS_DATA_TYPE value,
144:                                     PORTS_DATA_MASK mask )
145:                 {
146:                     PLIB_PORTS_Set( index, channel, value, mask );
147:                 }
148:                 
149:                 
150:                 /******************************************************************************
151:                   Function:
152:                     void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
153:                                            PORTS_DATA_MASK clearMask )
154:                 
155:                   Summary:
156:                     Clears the selected digital port.
157:                 
158:                   Description:
159:                     This function clears the selected digital port.
160:                 
161:                   Remarks:
162:                     None.
163:                 */
164:                 
165:                 void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
166:                                            PORTS_DATA_MASK clearMask )
167:                 {
168:                     PLIB_PORTS_Clear ( index, channel, clearMask );
169:                 }
170:                 
171:                 
172:                 /******************************************************************************
173:                   Function:
174:                     void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
175:                 								SYS_PORTS_PIN_DIRECTION pinDir,
176:                 								PORTS_CHANNEL channel,
177:                 								PORTS_DATA_MASK mask )
178:                   Summary:
179:                     Enables the direction for the selected port.
180:                 
181:                   Description:
182:                     This function enables the direction for the selected port.
183:                 
184:                   Remarks:
185:                     None.
186:                 */
187:                 
188:                 void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
189:                                              SYS_PORTS_PIN_DIRECTION pinDir,
190:                                              PORTS_CHANNEL channel,
191:                                              PORTS_DATA_MASK mask )
192:                 {
193:                     if (pinDir == SYS_PORTS_DIRECTION_INPUT)
00000000  00000000   NOP
194:                     {
195:                         PLIB_PORTS_DirectionInputSet(index, channel, mask);
196:                     }
197:                     else
198:                     {
199:                         PLIB_PORTS_DirectionOutputSet(index, channel, mask);
200:                     }
201:                 }
202:                 
203:                 
204:                 /******************************************************************************
205:                   Function:
206:                     PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index,
207:                                                             PORTS_CHANNEL channel )
208:                 
209:                   Summary:
210:                     Reads the port direction for the selected port.
211:                 
212:                   Description:
213:                     This function reads the port direction for the selected port.
214:                 
215:                   Remarks:
216:                     None.
217:                 */
218:                 
219:                 PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
220:                 {
221:                     return PLIB_PORTS_DirectionGet( index, channel );
222:                 }
00000030  00000000   NOP
223:                 
224:                 
225:                 /******************************************************************************
226:                   Function:
227:                     void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
228:                                            PORTS_DATA_MASK toggleMask )
229:                 
230:                   Summary:
231:                     Toggles the selected digital port pins.
232:                 
233:                   Description:
234:                     This function toggles the selected digital port pins.
235:                 
236:                   Remarks:
237:                     None.
238:                 */
239:                 
240:                 void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
241:                                        PORTS_DATA_MASK toggleMask )
242:                 {
243:                     PLIB_PORTS_Toggle( index, channel, toggleMask );
244:                 }
245:                 
246:                 
247:                 /******************************************************************************
248:                   Function:
249:                     void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
250:                                                      PORTS_DATA_MASK mask )
251:                 
252:                   Summary:
253:                     Enables the open drain functionality for the selected port.
254:                 
255:                   Description:
256:                     This function enables the open drain functionality for the selected port.
257:                 
258:                   Remarks:
259:                     None.
260:                 */
261:                 
262:                 void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
263:                                                 PORTS_DATA_MASK mask )
264:                 {
265:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
266:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
267:                     {
268:                         PLIB_PORTS_OpenDrainEnable( index, channel, mask );
269:                     }
270:                 #endif
271:                 }
272:                 
273:                 
274:                 /******************************************************************************
275:                   Function:
276:                     void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
277:                                                      PORTS_DATA_MASK mask )
278:                 
279:                   Summary:
280:                     Disables the open drain functionality for the selected port.
281:                 
282:                   Description:
283:                     This function disables the open drain functionality for the selected port.
284:                 
285:                   Remarks:
286:                     None.
287:                 */
288:                 
289:                 void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
290:                                                  PORTS_DATA_MASK mask )
291:                 {
292:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
293:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
294:                     {
295:                         PLIB_PORTS_OpenDrainDisable( index, channel, mask );
296:                     }
297:                 #endif
298:                 }
299:                 
300:                 
301:                 // *****************************************************************************
302:                 // *****************************************************************************
303:                 // Section: SYS Change Notification Pins Routines
304:                 // *****************************************************************************
305:                 // *****************************************************************************
306:                 
307:                 /******************************************************************************
308:                   Function:
309:                     void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
310:                 
311:                   Summary:
312:                     Globally enables the change notification.
313:                 
314:                   Description:
315:                     This function globally enables the change notification.
316:                 
317:                   Remarks:
318:                     None.
319:                 */
320:                 
321:                 void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
322:                 {
323:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
324:                     if(PLIB_PORTS_ExistsChangeNotice(index))
325:                     {
326:                         PLIB_PORTS_ChangeNoticeEnable( index );
327:                     }
328:                 #endif
329:                 }
330:                 
331:                 /******************************************************************************
332:                   Function:
333:                     void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
334:                 
335:                   Summary:
336:                     Globally disables the change notification.
337:                 
338:                   Description:
339:                     This function globally disables the change notification.
340:                 
341:                   Remarks:
342:                     None.
343:                 */
344:                 
345:                 void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
346:                 {
347:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
348:                     if(PLIB_PORTS_ExistsChangeNotice(index))
349:                     {
350:                         PLIB_PORTS_ChangeNoticeDisable( index );
351:                     }
352:                 #endif
353:                 }
354:                 
355:                 /******************************************************************************
356:                   Function:
357:                     void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
358:                 
359:                   Summary:
360:                     Globally disables the change notification for the selected port.
361:                 
362:                   Description:
363:                     This function globally disables the change notification for the selected port.
364:                 
365:                   Remarks:
366:                     None.
367:                 */
368:                 
369:                 void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
370:                 {
371:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
372:                     if(PLIB_PORTS_ExistsChangeNotice(index))
373:                     {
374:                         PLIB_PORTS_ChangeNoticeDisable( index );
375:                     }
376:                 #endif
377:                 }
378:                 
379:                 
380:                 /******************************************************************************
381:                   Function:
382:                     void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
383:                                                              PORTS_CHANGE_NOTICE_PIN pinNum,
384:                                                              SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
385:                 
386:                   Summary:
387:                     Enables the change notification for the selected port.
388:                 
389:                   Description:
390:                     This function enables the change notification for the selected port.
391:                 
392:                   Remarks:
393:                     None.
394:                 */
395:                 
396:                 void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
397:                                                          PORTS_CHANGE_NOTICE_PIN pinNum,
398:                                                          SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
399:                 {
400:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
401:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
402:                     {
403:                         switch(value)
00000008  00000000   NOP
404:                         {
405:                             case SYS_PORTS_PULLUP_DISABLE:
406:                                 PLIB_PORTS_ChangeNoticePullUpDisable(index, pinNum);
407:                                 break;
408:                             case SYS_PORTS_PULLUP_ENABLE:
409:                                 PLIB_PORTS_ChangeNoticePullUpEnable(index, pinNum);
410:                                 break;
411:                         }
412:                     }
413:                 #endif
414:                 
415:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
416:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
417:                     {
418:                         PLIB_PORTS_PinChangeNoticeEnable( index, pinNum );
419:                     }
420:                 #endif
421:                 }
422:                 
423:                 
424:                 /******************************************************************************
425:                   Function:
426:                     void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
427:                                                               PORTS_CHANGE_NOTICE_PIN pinNum )
428:                 
429:                   Summary:
430:                     Disables the change notification for the selected port.
431:                 
432:                   Description:
433:                     This function disables the change notification for the selected port.
434:                 
435:                   Remarks:
436:                     None.
437:                 */
438:                 
439:                 void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
440:                                                           PORTS_CHANGE_NOTICE_PIN pinNum )
441:                 {
442:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
443:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
444:                     {
445:                         PLIB_PORTS_PinChangeNoticeDisable( index, pinNum );
446:                     }
447:                 #endif
448:                 }
449:                 
450:                 
451:                 /******************************************************************************
452:                   Function:
453:                     void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
454:                 
455:                   Summary:
456:                     Enables the change notification for the selected port in Sleep or Idle mode.
457:                 
458:                   Description:
459:                     This function enables the change notification for the selected port in Sleep
460:                     or Idle mode.
461:                 
462:                   Remarks:
463:                     None.
464:                 */
465:                 
466:                 void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
467:                 {
468:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
469:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
470:                     {
471:                         PLIB_PORTS_ChangeNoticeInIdleEnable( index );
472:                     }
473:                 #endif
474:                 }
475:                 
476:                 
477:                 // *****************************************************************************
478:                 /* Function:
479:                     void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index)
480:                 
481:                   Summary:
482:                     Disables the change notification for the selected port in Sleep or Idle mode.
483:                 
484:                   Description:
485:                     This function disables the change notification for the selected port in Sleep
486:                     or Idle mode.
487:                 
488:                   Remarks:
489:                     None.
490:                 */
491:                 
492:                 void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index )
493:                 {
494:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
495:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
496:                     {
497:                         PLIB_PORTS_ChangeNoticeInIdleDisable( index );
498:                     }
499:                 #endif
500:                 }
501:                 
502:                 
503:                 // *****************************************************************************
504:                 /* Function:
505:                     void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
506:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
507:                 
508:                   Summary:
509:                     Enables weak pull-up on change notification pin.
510:                 
511:                   Description:
512:                     This function enables weak pull-up on change notification pin.
513:                 
514:                   Remarks:
515:                     None.
516:                 */
517:                 
518:                 void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
519:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
520:                 {
521:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
522:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
523:                     {
524:                         PLIB_PORTS_ChangeNoticePullUpEnable ( index, pinNum );
525:                     }
526:                 #endif
527:                 }
528:                 
529:                 
530:                 // *****************************************************************************
531:                 /* Function:
532:                     void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
533:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
534:                 
535:                   Summary:
536:                     Disables pull-up on input change.
537:                 
538:                   Description:
539:                     This function disables pull-up on input change.
540:                 
541:                   Remarks:
542:                     None.
543:                 */
544:                 
545:                 void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
546:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
547:                 {
548:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
549:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
550:                     {
551:                         PLIB_PORTS_ChangeNoticePullUpDisable ( index, pinNum );
552:                     }
553:                 #endif
554:                 }
555:                 
556:                 
557:                 // *****************************************************************************
558:                 // *****************************************************************************
559:                 // Section: SYS PORT PINS Control Routines
560:                 // *****************************************************************************
561:                 // *****************************************************************************
562:                 
563:                 // *****************************************************************************
564:                 /* Function:
565:                     void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
566:                     								PORTS_PIN_MODE mode)
567:                 
568:                   Summary:
569:                     Enables the selected pin as analog or digital.
570:                 
571:                   Description:
572:                     This function enables the selected pin as analog or digital.
573:                 
574:                  Remarks:
575:                     None.
576:                 */
577:                 
578:                 void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
579:                 								PORTS_PIN_MODE mode)
580:                 {
581:                 #if defined(PLIB_PORTS_ExistsPinMode)
582:                     if(PLIB_PORTS_ExistsPinMode(index))
583:                     {
584:                         PLIB_PORTS_PinModeSelect ( index, pin, mode);
585:                     }
586:                 #endif
587:                 }
588:                 
589:                 
590:                 // *****************************************************************************
591:                 /* Function:
592:                     void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
593:                                               PORTS_CHANNEL channel,
594:                                               PORTS_BIT_POS bitPos
595:                                               bool value )
596:                   Summary:
597:                     Writes the selected digital pin.
598:                 
599:                   Description:
600:                     This function writes the selected digital pin.
601:                 
602:                   Remarks:
603:                     None.
604:                 */
605:                 
606:                 void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
607:                                           PORTS_CHANNEL channel,
608:                                           PORTS_BIT_POS bitPos,
609:                                           bool value )
610:                 {
611:                     PLIB_PORTS_PinWrite ( index, channel, bitPos, value );
612:                 }
613:                 
614:                 
615:                 // *****************************************************************************
616:                 /* Function:
617:                     bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
618:                                              PORTS_CHANNEL channel,
619:                                              PORTS_BIT_POS bitPos )
620:                 
621:                   Summary:
622:                     Reads the selected digital pin.
623:                 
624:                   Description:
625:                     This function reads the selected digital pin.
626:                 
627:                   Remarks:
628:                     None.
629:                 */
630:                 
631:                 bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
632:                                          PORTS_CHANNEL channel,
633:                                          PORTS_BIT_POS bitPos )
634:                 {
635:                     return PLIB_PORTS_PinGet ( index, channel, bitPos );
636:                 }
0000003C  00000000   NOP
637:                 
638:                 
639:                 // *****************************************************************************
640:                 /* Function:
641:                     void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
642:                                                PORTS_CHANNEL channel,
643:                                                PORTS_BIT_POS bitPos )
644:                 
645:                   Summary:
646:                     Toggles the selected digital pin.
647:                 
648:                   Description:
649:                     This function toggles the selected digital pin.
650:                 
651:                   Remarks:
652:                     None.
653:                 */
654:                 
655:                 void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
656:                                            PORTS_CHANNEL channel,
657:                                            PORTS_BIT_POS bitPos )
658:                 {
659:                     PLIB_PORTS_PinToggle ( index, channel, bitPos );
660:                 }
661:                 
662:                 
663:                 // *****************************************************************************
664:                 /* Function:
665:                     void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
666:                                            PORTS_CHANNEL channel,
667:                                            PORTS_BIT_POS bitPos )
668:                 
669:                   Summary:
670:                     Sets the selected digital pin/latch.
671:                 
672:                   Description:
673:                     This function sets the selected digital pin/latch.
674:                 
675:                   Remarks:
676:                     None.
677:                 */
678:                 
679:                 void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
680:                                        PORTS_CHANNEL channel,
681:                                        PORTS_BIT_POS bitPos )
682:                 {
683:                     PLIB_PORTS_PinSet( index, channel, bitPos );
684:                 }
685:                 
686:                 
687:                 // *****************************************************************************
688:                 /* Function:
689:                     void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
690:                                               PORTS_CHANNEL channel,
691:                                               PORTS_BIT_POS bitPos )
692:                 
693:                   Summary:
694:                     Clears the selected digital pin.
695:                 
696:                   Description:
697:                     This function clears the selected digital pin.
698:                 
699:                   Remarks:
700:                     None.
701:                 */
702:                 
703:                 void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
704:                                           PORTS_CHANNEL channel,
705:                                           PORTS_BIT_POS bitPos )
706:                 {
707:                     PLIB_PORTS_PinClear ( index, channel, bitPos );
708:                 }
709:                 
710:                 
711:                 // *****************************************************************************
712:                 /* Function:
713:                     void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
714:                                                      SYS_PORTS_PIN_DIRECTION pinDir,
715:                                                      PORTS_CHANNEL channel,
716:                                                      PORTS_BIT_POS bitPos )
717:                   Summary:
718:                     Enables the direction for the selected pin.
719:                 
720:                   Description:
721:                     This function enables the direction for the selected pin.
722:                 
723:                   Remarks:
724:                     None.
725:                 */
726:                 
727:                 void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
728:                                                  SYS_PORTS_PIN_DIRECTION pinDir,
729:                                                  PORTS_CHANNEL channel,
730:                                                  PORTS_BIT_POS bitPos )
731:                 {
732:                     if (pinDir == SYS_PORTS_DIRECTION_OUTPUT)
733:                     {
734:                         PLIB_PORTS_PinDirectionOutputSet(index, channel, bitPos);
735:                     }
736:                     else
737:                     {
738:                         PLIB_PORTS_PinDirectionInputSet(index, channel, bitPos);
739:                     }
740:                 }
741:                 
742:                 
743:                 // *****************************************************************************
744:                 /* Function:
745:                     void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
746:                                                         PORTS_CHANNEL channel,
747:                                                         PORTS_BIT_POS bitPos )
748:                 
749:                   Summary:
750:                     Enables the open-drain functionality for the selected pin.
751:                 
752:                   Description:
753:                     This function enables the open-drain functionality for the selected pin.
754:                 
755:                   Remarks:
756:                     None.
757:                 */
758:                 
759:                 void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
760:                                                     PORTS_CHANNEL channel,
761:                                                     PORTS_BIT_POS bitPos )
762:                 {
763:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
764:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
765:                     {
766:                         PLIB_PORTS_PinOpenDrainEnable ( index, channel, bitPos );
767:                     }
768:                 #endif
769:                 }
770:                 
771:                 
772:                 // *****************************************************************************
773:                 /* Function:
774:                     void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
775:                                                          PORTS_CHANNEL channel,
776:                                                          PORTS_BIT_POS bitPos )
777:                 
778:                   Summary:
779:                     Disables the open-drain functionality for the selected pin.
780:                 
781:                   Description:
782:                     This function disables the open-drain functionality for the selected pin.
783:                 
784:                   Remarks:
785:                     None.
786:                 */
787:                 
788:                 void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
789:                                                      PORTS_CHANNEL channel,
790:                                                      PORTS_BIT_POS bitPos )
791:                 {
792:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
793:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
794:                     {
795:                         PLIB_PORTS_PinOpenDrainDisable ( index, channel, bitPos );
796:                     }
797:                 #endif
798:                 }
799:                 
800:                 
801:                 // *****************************************************************************
802:                 /* Function:
803:                     void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
804:                 							  PORTS_REMAP_INPUT_FUNCTION function,
805:                 							  PORTS_REMAP_INPUT_PIN      remapPin )
806:                 
807:                   Summary:
808:                     Input/Output (I/O) function remapping.
809:                 
810:                   Description:
811:                     This function controls the I/O function remapping.
812:                 
813:                   Precondition:
814:                     None.
815:                 */	
816:                 void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
817:                 						   PORTS_REMAP_INPUT_FUNCTION function,
818:                 						   PORTS_REMAP_INPUT_PIN      remapPin )
819:                 {
820:                 #if defined(PLIB_PORTS_ExistsRemapInput)
821:                     if(PLIB_PORTS_ExistsRemapInput(index))
822:                     {
823:                         PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
824:                         PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
825:                         PLIB_PORTS_RemapInput( index, function, remapPin);
826:                     }
827:                 #endif
828:                 }
829:                 
830:                 // *****************************************************************************
831:                 /* Function:
832:                     void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
833:                                                       PORTS_REMAP_OUTPUT_FUNCTION function,
834:                                                       PORTS_REMAP_OUTPUT_PIN      remapPin )
835:                 
836:                   Summary:
837:                     Input/Output (I/O) function remapping.
838:                 
839:                   Description:
840:                     This function controls the I/O function remapping.
841:                 
842:                   Precondition:
843:                     None.
844:                 */
845:                 void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
846:                 						    PORTS_REMAP_OUTPUT_FUNCTION function,
847:                 						    PORTS_REMAP_OUTPUT_PIN      remapPin )
848:                 {
00000000  00000000   NOP
849:                 #if defined(PLIB_PORTS_ExistsRemapOutput)
850:                     if(PLIB_PORTS_ExistsRemapOutput(index))
851:                     {
852:                         PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
853:                         PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
854:                         PLIB_PORTS_RemapOutput( index, function, remapPin);
855:                     }
856:                 #endif
857:                 }
858:                 
859:                 /*******************************************************************************
860:                  End of File
861:                 */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/framework/system/clk/src/sys_clk_static.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_clk_static.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the oscillators
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Clock System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                      
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  //DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include "system_config.h"
59:                  #include "system_definitions.h"
60:                  #include "peripheral/osc/plib_osc.h"
61:                  #include "system/devcon/sys_devcon.h"
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: File Scope Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  /* Function:
71:                      void SYS_CLK_Static_Initialize ( const SYS_CLK_INIT const * clkInit )
72:                  
73:                    Summary:
74:                      Initializes hardware and internal data structure of the System Clock.
75:                  
76:                    Description:
77:                      This function initializes the hardware and internal data structure of System
78:                      Clock Service.
79:                  
80:                    Remarks:
81:                      This is configuration values for the static version of the Clock System Service 
82:                      module is determined by the user via the Microchip Harmony Configurator GUI.
83:                      This template will build a sys_clk_static.h and sys_clk_static.c file with 
84:                      the configuration per the user's choice.
85:                  
86:                      The objective is to eliminate the user's need to be knowledgeable in the function of
87:                      the 'configuration bits' to configure the system oscillators. 
88:                  */
89:                  
90:                  void SYS_CLK_Initialize( const SYS_CLK_INIT const * clkInit )
91:                  {
9D00CBD4  27BDFFE8   ADDIU SP, SP, -24
9D00CBD8  AFBF0014   SW RA, 20(SP)
92:                      SYS_DEVCON_SystemUnlock ( );
9D00CBDC  0F4032C9   JAL SYS_DEVCON_SystemUnlock
9D00CBE0  00000000   NOP
93:                      
94:                      PLIB_OSC_FRCDivisorSelect( OSC_ID_0, OSC_FRC_DIV_2);
95:                  
96:                      /* Enable Peripheral Bus 1 */
97:                      PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 0, 1 );
98:                  
99:                  
100:                 
101:                 
102:                 
103:                 
104:                 
105:                     SYS_DEVCON_SystemLock ( );
9D00CC18  0F403410   JAL SYS_DEVCON_SystemLock
9D00CC1C  00000000   NOP
106:                 }
9D00CC20  8FBF0014   LW RA, 20(SP)
9D00CC24  03E00008   JR RA
9D00CC28  27BD0018   ADDIU SP, SP, 24
107:                 
108:                 //******************************************************************************
109:                 /* Function:
110:                     inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
111:                 
112:                   Summary:
113:                     Gets the system clock frequency in Hertz.
114:                 
115:                   Description:
116:                     This function gets the System clock frequency in Hertz.
117:                 
118:                   Precondition:
119:                     None.
120:                 
121:                   Parameters:
122:                     None.
123:                 
124:                   Returns:
125:                     System clock frequency in Hertz.
126:                 
127:                   Example:
128:                     <code>
129:                     uint32_t sysClockHz;
130:                 
131:                     sysClockHz = SYS_CLK_SystemFrequencyGet ( );
132:                     </code>
133:                 
134:                   Remarks:
135:                  */
136:                 
137:                 inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
138:                 {
139:                     return SYS_CLK_FREQ;
140:                 }
9D00DD5C  3C0204C4   LUI V0, 1220
9D00DD60  03E00008   JR RA
9D00DD64  3442B400   ORI V0, V0, -19456
141:                 
142:                 //******************************************************************************
143:                 /* Function:
144:                     inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
145:                 
146:                   Summary:
147:                     Gets the selected clock peripheral bus frequency in Hertz.
148:                 
149:                   Description:
150:                     This function gets the selected peripheral bus clock frequency in Hertz.
151:                 
152:                   Precondition:
153:                     None.
154:                 
155:                   Parameters:
156:                 	peripheralBus - Reference clock bus selection. One of the possible value from
157:                 				CLK_BUSES_PERIPHERAL enum. For devices that do not have multiple
158:                 				clock channels for Reference clock, CLK_BUS_PERIPHERAL_1 should be
159:                 				the selection.
160:                 
161:                   Returns:
162:                     Clock frequency in Hertz.
163:                 
164:                   Example:
165:                     <code>
166:                     unsigned long peripheralClockHz;
167:                 
168:                     peripheralClockHz = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_5 );
169:                     </code>
170:                 
171:                   Remarks:
172:                 	Most of the devices doesn't have multiple Peripheral clock buses. In that case, 
173:                 	pass CLK_USB_PERIPHERAL_1 as the bus number.
174:                  */
175:                 
176:                 inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
177:                 {
178:                     return SYS_CLK_BUS_PERIPHERAL_1;
179:                 }
180:                 
181:                 
182:                 //******************************************************************************
183:                 /* Function:
184:                     inline uint32_t SYS_CLK_ReferenceClockFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
185:                 
186:                   Summary:
187:                     Gets the selected Reference clock bus frequency in Hertz.
188:                 
189:                   Description:
190:                     This function gets frequency of the selected Reference clock bus in Hertz.
191:                 
192:                   Precondition:
193:                     None.
194:                 
195:                   Parameters:
196:                 	peripheralBus - Reference clock bus selection. One of the possible value from
197:                 				CLK_BUSES_REFERENCE enum. For devices that do not have multiple
198:                 				clock channels for Reference clock, CLK_BUS_REFERENCE_1 should be
199:                 				the selection.
200:                 
201:                   Returns:
202:                     Clock frequency in Hz.
203:                 
204:                   Example:
205:                     <code>
206:                     unsigned long sysClockOutputHz;
207:                 
208:                     sysClockOutputHz = SYS_CLK_ReferenceClockFrequencyGet ( CLK_BUS_REFERENCE_3 );
209:                     </code>
210:                 
211:                   Remarks:
212:                  */
213:                 
214:                 inline uint32_t SYS_CLK_ReferenceClockFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
215:                 {
216:                 	return 0;
217:                 }
00000000  00000000   NOP
218:                 
219:                 /******************************************************************************
220:                   Function:
221:                     void SYS_CLK_SecondaryOscillatorEnable ( void )
222:                 
223:                   Summary:
224:                     Enables the secondary oscillator.
225:                 
226:                   Description:
227:                     This function enables the secondary oscillator.
228:                 
229:                   Remarks:
230:                     For more details refer sys_clk.h.
231:                 */
232:                 
233:                 void SYS_CLK_SecondaryOscillatorEnable ( void )
234:                 {
00000014  00000000   NOP
235:                     /* Check for secondary oscillator status */
236:                     if (!PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
0000000C  00000000   NOP
237:                     {    
238:                         /* Unlock and enable secondary oscillator */
239:                         SYS_DEVCON_SystemUnlock();
0000001C  00000000   NOP
240:                         
241:                         PLIB_OSC_SecondaryEnable(OSC_ID_0);
242:                         
243:                         SYS_DEVCON_SystemLock();
00000034  00000000   NOP
244:                     }
245:                 }
0000003C  00000000   NOP
246:                 
247:                 /******************************************************************************
248:                   Function:
249:                     void SYS_CLK_SecondaryOscillatorDisable ( void )
250:                 
251:                   Summary:
252:                     Disables the secondary oscillator.
253:                 
254:                   Description:
255:                     This function disables the secondary oscillator.
256:                 
257:                   Remarks:
258:                     For more details refer sys_clk.h.
259:                 */
260:                 
261:                 void SYS_CLK_SecondaryOscillatorDisable ( void )
262:                 {
00000014  00000000   NOP
263:                     /* Check for secondary oscillator status */
264:                     if (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
0000000C  00000000   NOP
265:                     {    
266:                         /* Unlock and disable secondary oscillator*/
267:                         SYS_DEVCON_SystemUnlock();
0000001C  00000000   NOP
268:                         
269:                         PLIB_OSC_SecondaryDisable(OSC_ID_0);
270:                         
271:                         SYS_DEVCON_SystemLock();
00000034  00000000   NOP
272:                     }
273:                 }
0000003C  00000000   NOP
274:                 
275:                 /******************************************************************************
276:                   Function:
277:                     bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
278:                 
279:                   Summary:
280:                     Identifies whether secondary oscillator is enabled or disabled.
281:                 
282:                   Description:
283:                     This function identifies whether the secondary oscillator is enabled or 
284:                     disabled.
285:                     
286:                   Remarks:
287:                     For more details refer sys_clk.h.
288:                 */
289:                 
290:                 bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
291:                 {
292:                     return (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0));
293:                 }
00000008  00000000   NOP
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_static.c
1:                   /*******************************************************************************
2:                     Timer Static Driver File
3:                   
4:                     File Name:
5:                       drv_tmr_static.c
6:                   
7:                     Company:
8:                       Microchip Technology Inc.   
9:                   
10:                    Summary:
11:                      Timer driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      None
19:                   *******************************************************************************/
20:                  
21:                  /*******************************************************************************
22:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublTMRense terms in the accompanying lTMRense agreement).
28:                  
29:                  You should refer to the lTMRense agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTTMRULAR PURPOSE.
35:                  IN NO EVENT SHALL MTMRROCHIP OR ITS LTMRENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRTMRT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVTMRES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                   *******************************************************************************/
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Header Includes
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include "driver/tmr/drv_tmr_static.h"
50:                  #include "driver/tmr/src/drv_tmr_variant_mapping.h"
51:                  
52:                  typedef struct
53:                  {
54:                      DRV_TMR_CALLBACK alarmFunc;  // For alarm registering
55:                      uint32_t alarmCount;    // For AlarmHasElapsed function
56:                      bool    alarmEnabled;   // For Enable/Disable function
57:                      bool    alarmPeriodic;      // Keep Alarm enabled or disable it
58:                      uintptr_t   alarmContext;   // For Alarm Callback
59:                      uint32_t    alarmPeriod;    // For Period Set/Get
60:                  } DRV_TMR_ALARM_OBJ;
61:                  
62:                  static bool _DRV_TMR_ClockSourceSet(TMR_MODULE_ID timerId, DRV_TMR_CLK_SOURCES clockSource)
63:                  {
64:                      bool clockSet = true;
65:                      /* Clock Source Selection */
66:                      if(clockSource == DRV_TMR_CLKSOURCE_INTERNAL)
00000030  00000000   NOP
67:                      {
68:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
69:                          {               
70:                              PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );           
71:                          }
72:                          else
73:                          {
74:                              /* If clock source feature doesn't exist for any specific timer module instance,
75:                              then by default internal peripheral clock is considered as timer source, so do nothing */ 
76:                          }
77:                      }
78:                      /* External Synchronous Clock Source Selection */
79:                      else if(!(clockSource & 0x10))
00000050  00000000   NOP
80:                      {
81:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
82:                          {               
83:                              if ( PLIB_TMR_ExistsClockSourceSync ( timerId )  )
84:                              {
85:                                  PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );                
86:                                  PLIB_TMR_ClockSourceExternalSyncEnable ( timerId );                    
87:                              }
88:                              /* If Synchronization feature doesn't exist for any specific timer module 
89:                              instance with external clock source then it is synchronous by default */
90:                              else if (clockSource == DRV_TMR_CLKSOURCE_EXTERNAL_SYNCHRONOUS)
00000058  00000000   NOP
91:                              {
92:                                  PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_EXTERNAL_INPUT_PIN );
93:                              }
94:                              else
95:                              {
96:                                  clockSet = false;
97:                              }  
98:                          }
99:                          else
100:                         {
101:                             clockSet = false;
102:                         }        
103:                     }
104:                     /* External Asynchronous Clock Source Selection */
105:                     else if(clockSource & 0x10)
106:                     {
107:                         if ( PLIB_TMR_ExistsClockSourceSync ( timerId ) )
108:                         {
109:                             PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );
110:                             PLIB_TMR_ClockSourceExternalSyncDisable ( timerId );
111:                         }
112:                         else
113:                         {
114:                             clockSet = false;
115:                         }        
116:                     }
117:                     
118:                     return clockSet;
119:                 }
120:                 
121:                 // Prescaler selection
122:                 static bool _DRV_TMR_ClockPrescaleSet(TMR_MODULE_ID timerId, TMR_PRESCALE  prescale)
123:                 {
124:                     if( PLIB_TMR_ExistsPrescale( timerId ) )
125:                     {
126:                         PLIB_TMR_PrescaleSelect( timerId , prescale );
127:                         return true;
128:                     }
129:                     return false;
130:                 }
131:                 
132:                 
133:                 
134:                 // *****************************************************************************
135:                 // *****************************************************************************
136:                 // Section: Instance 0 static driver data
137:                 // *****************************************************************************
138:                 // *****************************************************************************
139:                 
140:                 static bool                   DRV_TMR0_Running;
141:                 
142:                 // *****************************************************************************
143:                 // *****************************************************************************
144:                 // Section: Instance 0 static driver functions
145:                 // *****************************************************************************
146:                 // *****************************************************************************
147:                 void DRV_TMR0_Initialize(void)
148:                 {   
149:                     /* Initialize Timer Instance0 */
150:                     /* Disable Timer */
151:                     PLIB_TMR_Stop(TMR_ID_2);
152:                     /* Select clock source */
153:                     PLIB_TMR_ClockSourceSelect(TMR_ID_2, DRV_TMR_CLKSOURCE_INTERNAL);
154:                     /* Select prescalar value */
155:                     PLIB_TMR_PrescaleSelect(TMR_ID_2, TMR_PRESCALE_VALUE_64);
156:                     /* Enable 16 bit mode */
157:                     PLIB_TMR_Mode16BitEnable(TMR_ID_2);
158:                     /* Clear counter */ 
159:                     PLIB_TMR_Counter16BitClear(TMR_ID_2);
160:                     /*Set period */ 
161:                     PLIB_TMR_Period16BitSet(TMR_ID_2, 65535);
162:                     /* Setup Interrupt */   
163:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_T2, INT_PRIORITY_LEVEL1);
164:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_T2, INT_SUBPRIORITY_LEVEL0);          
165:                 }
166:                 
167:                 static void _DRV_TMR0_Resume(bool resume)
168:                 {
169:                     if (resume)
00000078  00000000   NOP
170:                     {
171:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_2);
172:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_2);
173:                         PLIB_TMR_Start(TMR_ID_2);
174:                     }
175:                 }
176:                 
177:                 bool DRV_TMR0_Start(void)
178:                 {
179:                     /* Start Timer*/
180:                     _DRV_TMR0_Resume(true);
181:                     DRV_TMR0_Running = true;
9D00D4DC  24020001   ADDIU V0, ZERO, 1
9D00D4E0  A3828098   SB V0, -32616(GP)
182:                     
183:                     return true;
184:                 }
9D00D4E4  03E00008   JR RA
9D00D4E8  24020001   ADDIU V0, ZERO, 1
185:                 
186:                 static bool _DRV_TMR0_Suspend(void)
187:                 {
188:                     if (DRV_TMR0_Running)
00000000  00000000   NOP
189:                     {
190:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_2);
191:                         PLIB_TMR_Stop(TMR_ID_2);
192:                         return (true);
0000002C  00000000   NOP
193:                     }
194:                     
195:                     return (false);
196:                 }
197:                 
198:                 void DRV_TMR0_Stop(void)
199:                 {
200:                     _DRV_TMR0_Suspend();
201:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_2);
202:                     DRV_TMR0_Running = false;
00000038  00000000   NOP
203:                 }
204:                 
205:                 DRV_TMR_CLIENT_STATUS DRV_TMR0_ClientStatus ( void )
206:                 {
207:                     if (DRV_TMR0_Running)
00000000  00000000   NOP
208:                         return DRV_TMR_CLIENT_STATUS_RUNNING;
209:                     else
210:                         return DRV_TMR_CLIENT_STATUS_READY;
211:                 }
00000004  00000000   NOP
212:                 
213:                 void DRV_TMR0_CounterValueSet(uint32_t value)
214:                 {
00000000  00000000   NOP
215:                     /* Set 16-bit counter value*/
216:                     PLIB_TMR_Counter16BitSet(TMR_ID_2, (uint16_t)value);
217:                 }
218:                 
219:                 uint32_t DRV_TMR0_CounterValueGet(void)
220:                 {
221:                     /* Get 16-bit counter value*/
222:                     return (uint32_t) PLIB_TMR_Counter16BitGet(TMR_ID_2);
223:                 }
00000008  00000000   NOP
224:                 
225:                 void DRV_TMR0_CounterClear(void)
226:                 {
227:                     /* Clear 16-bit counter value*/
228:                     PLIB_TMR_Counter16BitClear(TMR_ID_2);
229:                 }
230:                 
231:                 uint32_t DRV_TMR0_CounterFrequencyGet(void)
232:                 {
00000000  00000000   NOP
233:                     uint32_t prescale, tmrBaseFreq;
234:                     
235:                     tmrBaseFreq = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_FOR_TIMER_PERIPHERAL );
00000008  00000000   NOP
236:                     prescale = PLIB_TMR_PrescaleGet(TMR_ID_2);
237:                     return ( tmrBaseFreq / prescale );
238:                 }
00000034  00000000   NOP
239:                 
240:                 TMR_PRESCALE DRV_TMR0_PrescalerGet(void)
241:                 {
242:                     uint16_t prescale_value;
243:                     /* Call the PLIB directly */
244:                     prescale_value = PLIB_TMR_PrescaleGet(TMR_ID_2);
245:                     
246:                     switch(prescale_value)
00000024  00000000   NOP
00000068  00000000   NOP
247:                     {
248:                         case 1: return TMR_PRESCALE_VALUE_1;
00000060  00000000   NOP
00000088  00000000   NOP
249:                         case 2: return TMR_PRESCALE_VALUE_2;
250:                         case 4: return TMR_PRESCALE_VALUE_4;
00000090  00000000   NOP
251:                         case 8: return TMR_PRESCALE_VALUE_8;
252:                         case 16: return TMR_PRESCALE_VALUE_16;
00000098  00000000   NOP
253:                         case 32: return TMR_PRESCALE_VALUE_32;
254:                         case 64: return TMR_PRESCALE_VALUE_64;
255:                         case 256: return TMR_PRESCALE_VALUE_256;
256:                         default: return TMR_PRESCALE_VALUE_1;
257:                     }
258:                 }
000000A0  00000000   NOP
259:                 
260:                 void DRV_TMR0_PeriodValueSet(uint32_t value)
261:                 {
00000000  00000000   NOP
262:                     /* Set 16-bit counter value*/
263:                     PLIB_TMR_Period16BitSet(TMR_ID_2, (uint16_t)value);
264:                 }
265:                 
266:                 uint32_t DRV_TMR0_PeriodValueGet(void)
267:                 {
268:                     /* Get 16-bit counter value*/
269:                     return (uint32_t) PLIB_TMR_Period16BitGet(TMR_ID_2);
270:                 }
00000008  00000000   NOP
271:                 
272:                 void DRV_TMR0_StopInIdleDisable(void)
273:                 {
274:                     PLIB_TMR_StopInIdleDisable(TMR_ID_2);
275:                 }
276:                 
277:                 void DRV_TMR0_StopInIdleEnable(void)
278:                 {
279:                     PLIB_TMR_StopInIdleDisable(TMR_ID_2);
280:                 }
281:                 
282:                 bool DRV_TMR0_ClockSet
283:                 (
284:                     DRV_TMR_CLK_SOURCES clockSource,
285:                     TMR_PRESCALE        preScale
286:                 )
287:                 {
288:                     bool success = false;
289:                     bool resume = _DRV_TMR0_Suspend();
290:                     
291:                     if (_DRV_TMR_ClockSourceSet(TMR_ID_2, clockSource) &&
292:                         _DRV_TMR_ClockPrescaleSet(TMR_ID_2, preScale))
293:                     {
294:                         success = true;
000000CC  00000000   NOP
295:                     }
296:                     
297:                     _DRV_TMR0_Resume(resume);
298:                     return success;
299:                 }
300:                 
301:                  
302:                  
303:                 /*******************************************************************************
304:                  End of File
305:                 */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_mapping.c
1:                   /*******************************************************************************
2:                     Timer Driver Interface Mapping Dynamic APIs to Static APIs           
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr_mapping.h
9:                   
10:                    Summary:
11:                      This file allows maintaining a single set of APIs for all Timer transactions  
12:                      by making the type of implementation transparent to the application. In case
13:                      where static implementation of Timer driver is selected, this file maps the 
14:                      API functions to a particular driver instance-specific static implementation
15:                      function, eliminating unnecessary dynamic parameters. 
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #include "driver/tmr/drv_tmr.h"
44:                  #include "driver/tmr/drv_tmr_static.h"
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: TMR Driver Client Functions
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  // *****************************************************************************
53:                  /* Function:
54:                      DRV_HANDLE DRV_TMR_Open 
55:                      ( 
56:                          const SYS_MODULE_INDEX index,
57:                          const DRV_IO_INTENT    intent
58:                      )
59:                  
60:                    Summary:
61:                      Opens the specified Timer driver instance and returns a handle to it.
62:                    
63:                    Description:
64:                      This function opens the specified Timer driver instance and provides a
65:                      handle that must be provided to all other client-level operations to
66:                      identify the caller and the instance of the driver.  Timer driver does not
67:                      support multiple clients. If two tasks want to use the timer, one should
68:                      wait until the other one gets closed. 
69:                  
70:                    Remarks:
71:                      Refer to drv_tmr.h for usage information.
72:                  */
73:                  
74:                  DRV_HANDLE DRV_TMR_Open 
75:                  ( 
76:                      const SYS_MODULE_INDEX index, 
77:                      const DRV_IO_INTENT intent 
78:                  )
79:                  {
80:                      switch (index)
81:                      {
82:                                  case DRV_TMR_INDEX_0:
83:                          {
84:                              return (DRV_HANDLE)DRV_TMR_INDEX_0;
85:                              break;
86:                          }
87:                          default:
88:                          {
89:                              break;
90:                          }
91:                      }
92:                      
93:                      return (DRV_HANDLE)NULL;
94:                  }
00000000  00000000   NOP
95:                  
96:                  // *****************************************************************************
97:                  /* Function:
98:                      void DRV_TMR_Close ( DRV_HANDLE handle )
99:                  
100:                   Summary:
101:                     Closes an opened instance of the Timer driver.
102:                 
103:                   Description:
104:                     This function closes an opened instance of the Timer driver, invalidating
105:                     the handle.
106:                   
107:                   Remarks:
108:                     Refer to drv_tmr.h for usage information.
109:                 */
110:                 
111:                 void DRV_TMR_Close ( DRV_HANDLE handle )
112:                 {
00000008  00000000   NOP
113:                     switch (handle)
00000000  00000000   NOP
114:                     {
115:                         case DRV_TMR_INDEX_0:
116:                         {
117:                             DRV_TMR0_Close();
118:                             break;
119:                         }
120:                         default:
121:                         {
122:                             break;
123:                         }
124:                     }
125:                 }
00000018  00000000   NOP
126:                 
127:                 // *****************************************************************************
128:                 /* Function:
129:                     DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus ( DRV_HANDLE handle )
130:                 
131:                   Summary:
132:                     Gets the status of the client operation.
133:                 
134:                   Description:
135:                     This function gets the status of the recently completed client level
136:                     operation.
137:                 
138:                   Remarks:
139:                     Refer to drv_tmr.h for usage information.
140:                 */
141:                 
142:                 DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus 
143:                 ( DRV_HANDLE handle )
144:                 {
00000008  00000000   NOP
145:                     switch (handle)
00000000  00000000   NOP
146:                     {
147:                         case DRV_TMR_INDEX_0:
148:                         {
149:                             return DRV_TMR0_ClientStatus();
00000010  00000000   NOP
150:                             break;
151:                         }
152:                         default:
153:                         {
154:                             break;
155:                         }
156:                     }
157:                 
158:                     return DRV_TMR_CLIENT_STATUS_INVALID;
00000020  00000000   NOP
159:                 }
00000028  00000000   NOP
160:                 
161:                 // *****************************************************************************
162:                 // *****************************************************************************
163:                 // Section: TMR Driver Counter functions
164:                 // *****************************************************************************
165:                 // *****************************************************************************
166:                 
167:                 // *****************************************************************************
168:                 /* Function:
169:                     void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
170:                 
171:                   Summary:
172:                     Updates the Timer's counter register.
173:                 
174:                   Description:
175:                     This function updates the Timer's value in the counter register.
176:                 
177:                   Remarks:
178:                     Refer to drv_tmr.h for usage information.
179:                 */
180:                 
181:                 void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
182:                 {
00000008  00000000   NOP
183:                     switch (handle)
00000000  00000000   NOP
184:                     {
185:                         case DRV_TMR_INDEX_0:
186:                         {
187:                             DRV_TMR0_CounterValueSet(counterPeriod);
00000010  00000000   NOP
188:                             break;
189:                         }
190:                         default:
191:                         {
192:                             break;
193:                         }
194:                     }
195:                 }
00000018  00000000   NOP
196:                 
197:                 // *****************************************************************************
198:                 /* Function:
199:                     uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
200:                 
201:                   Summary:
202:                     Reads the Timer's counter register.
203:                 
204:                   Description:
205:                     This function returns the Timer's value in the counter register.
206:                 
207:                   Remarks:
208:                     Refer to drv_tmr.h for usage information.
209:                 */
210:                 
211:                 uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
212:                 {
00000008  00000000   NOP
213:                     switch (handle)
00000000  00000000   NOP
214:                     {
215:                         case DRV_TMR_INDEX_0:
216:                         {
217:                             return DRV_TMR0_CounterValueGet();
00000010  00000000   NOP
218:                             break;
219:                         }
220:                         default:
221:                         {
222:                             break;
223:                         }
224:                     }
225:                 
226:                     return 0;
00000020  00000000   NOP
227:                 }
00000028  00000000   NOP
228:                 
229:                 // *****************************************************************************
230:                 /* Function:
231:                     void DRV_TMR_CounterClear ( DRV_HANDLE handle )
232:                 
233:                   Summary:
234:                     Clears the Timer's counter register.
235:                 
236:                   Description:
237:                     This function clears the Timer's value in the counter register.
238:                 
239:                   Remarks:
240:                     Refer to drv_tmr.h for usage information.
241:                 */
242:                 
243:                 void DRV_TMR_CounterClear ( DRV_HANDLE handle )
244:                 {
00000008  00000000   NOP
245:                     switch (handle)
00000000  00000000   NOP
246:                     {
247:                         case DRV_TMR_INDEX_0:
248:                         {
249:                             DRV_TMR0_CounterClear();
00000010  00000000   NOP
250:                             break;
251:                         }
252:                         default:
253:                         {
254:                             break;
255:                         }
256:                     }
257:                 }
00000018  00000000   NOP
258:                 
259:                 // *****************************************************************************
260:                 // *****************************************************************************
261:                 // Section: TMR Driver Alarm functions
262:                 // *****************************************************************************
263:                 // *****************************************************************************
264:                 
265:                 // *****************************************************************************
266:                 /* Function:
267:                     bool DRV_TMR_AlarmRegister 
268:                     ( 
269:                         DRV_HANDLE handle, 
270:                         uint32_t divider, 
271:                         bool isPeriodic, 
272:                         uintptr_t context, 
273:                         DRV_TMR_CALLBACK callBack 
274:                     )
275:                 
276:                   Summary:
277:                     Sets up an alarm.
278:                 
279:                   Description:
280:                     This function sets up an alarm, allowing the client to receive a callback
281:                     from the driver when the timer counter reaches zero.  Alarms can be one-shot
282:                     or periodic.  A periodic alarm will reload the timer and generate alarm
283:                     until stopped.  The alarm frequency is: DRV_TMR_CounterFrequencyGet() /
284:                     divider;
285:                 
286:                   Remarks:
287:                     Refer to drv_tmr.h for usage information.
288:                 */
289:                 
290:                 bool DRV_TMR_AlarmRegister 
291:                 (
292:                     DRV_HANDLE handle, 
293:                     uint32_t divider, 
294:                     bool isPeriodic, 
295:                     uintptr_t context, 
296:                     DRV_TMR_CALLBACK callBack 
297:                 )
298:                 {
299:                     switch (handle)
300:                     {
301:                         default:
302:                         {
303:                             break;
304:                         }
305:                     }
306:                 
307:                     return false;
308:                 }
309:                 
310:                 // *****************************************************************************
311:                 /* Function:
312:                     bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle);
313:                 
314:                   Summary:
315:                     Disables an alarm signal.
316:                 
317:                   Description:
318:                     This function allows the client to disable an alarm generation.
319:                     Use DRV_TMR_AlarmEnable to re-enable.
320:                 
321:                   Remarks:
322:                     Refer to drv_tmr.h for usage information.
323:                 */
324:                 
325:                 bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle)
326:                 {
327:                     switch (handle)
328:                     {
329:                         default:
330:                         {
331:                             break;
332:                         }
333:                     }
334:                 
335:                     return false;
336:                 }
337:                 
338:                 // *****************************************************************************
339:                 /* Function:
340:                     void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable );
341:                 
342:                   Summary:
343:                     Re-enables an alarm signal.
344:                 
345:                   Description:
346:                     This function allows the client to re-enable an alarm after it has been
347:                     disabled by a DRV_TMR_AlarmDisable call.
348:                 
349:                   Remarks:
350:                     Refer to drv_tmr.h for usage information.
351:                 */
352:                 
353:                 void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable )
354:                 {
355:                     switch (handle)
356:                     {
357:                         default:
358:                         {
359:                             break;
360:                         }
361:                     }
362:                 }
363:                 
364:                 // *****************************************************************************
365:                 /* Function:
366:                     void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
367:                 
368:                   Summary:
369:                     Updates the Timer's period.
370:                 
371:                   Description:
372:                     This function updates the Timer's period.
373:                 
374:                   Remarks:
375:                     Refer to drv_tmr.h for usage information.
376:                 */
377:                 
378:                 void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
379:                 {
380:                     switch (handle)
381:                     {
382:                         default:
383:                         {
384:                             break;
385:                         }
386:                     }
387:                 }
388:                 
389:                 // *****************************************************************************
390:                 /* Function:
391:                     uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
392:                 
393:                   Summary:
394:                     Provides the Timer's period.
395:                 
396:                   Description:
397:                     This function gets the Timer's period.
398:                 
399:                   Remarks:
400:                     Refer to drv_tmr.h for usage information.
401:                 */
402:                 
403:                 uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
404:                 {
405:                     switch (handle)
406:                     {
407:                         default:
408:                         {
409:                             break;
410:                         }
411:                     }
412:                 
413:                     return 0;
414:                 }
415:                 
416:                 // *****************************************************************************
417:                 /* Function:
418:                     void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
419:                 
420:                   Summary:
421:                     Removes a previously set alarm.
422:                 
423:                   Description:
424:                     This function removes a previously set alarm.
425:                 
426:                   Remarks:
427:                     Refer to drv_tmr.h for usage information.
428:                 */
429:                 
430:                 void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
431:                 {
00000000  00000000   NOP
432:                     switch (handle)
433:                     {
434:                         default:
435:                         {
436:                             break;
437:                         }
438:                     }
439:                 }
440:                 
441:                 // *****************************************************************************
442:                 // *****************************************************************************
443:                 // Section: TMR Driver Operation Control functions
444:                 // *****************************************************************************
445:                 // *****************************************************************************
446:                 
447:                 // *****************************************************************************
448:                 /* Function:
449:                     bool DRV_TMR_Start ( DRV_HANDLE handle )
450:                 
451:                   Summary:
452:                     Starts the Timer counting.
453:                 
454:                   Description:
455:                     This function starts the Timer counting.
456:                 
457:                   Remarks:
458:                     Refer to drv_tmr.h for usage information.
459:                 */
460:                 
461:                 bool DRV_TMR_Start ( DRV_HANDLE handle )
462:                 {
00000008  00000000   NOP
463:                     switch (handle)
00000000  00000000   NOP
464:                     {
465:                         case DRV_TMR_INDEX_0:
466:                         {
467:                             return DRV_TMR0_Start();
00000010  00000000   NOP
468:                             break;
469:                         }
470:                         default:
471:                         {
472:                             break;
473:                         }
474:                     }
475:                 
476:                     return false;
00000020  00000000   NOP
477:                 }
00000028  00000000   NOP
478:                 
479:                 // *****************************************************************************
480:                 /* Function:
481:                     void DRV_TMR_Stop ( DRV_HANDLE handle )
482:                 
483:                   Summary:
484:                     Stops the Timer from counting.
485:                 
486:                   Description:
487:                     This function stops the running Timer from counting.
488:                 
489:                   Remarks:
490:                     Refer to drv_tmr.h for usage information.
491:                 */
492:                 
493:                 void DRV_TMR_Stop ( DRV_HANDLE handle )
494:                 {
00000008  00000000   NOP
495:                     switch (handle)
00000000  00000000   NOP
496:                     {
497:                         case DRV_TMR_INDEX_0:
498:                         {
499:                             DRV_TMR0_Stop();
00000010  00000000   NOP
500:                             break;
501:                         }
502:                         default:
503:                         {
504:                             break;
505:                         }
506:                     }
507:                 }
00000018  00000000   NOP
508:                 
509:                 // *****************************************************************************
510:                 /* Function:
511:                     uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
512:                 
513:                   Summary:
514:                     Provides the status of Timer's period elapse.
515:                 
516:                   Description:
517:                     This function returns the number of times Timer's period has elapsed since
518:                     last call to this API has made. On calling this API, the internally
519:                     maintained counter will be cleared and count will be started again from next
520:                     elapse.
521:                 
522:                   Remarks:
523:                     Refer to drv_tmr.h for usage information.
524:                 */
525:                 
526:                 uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
527:                 {
528:                     switch (handle)
529:                     {
530:                         default:
531:                         {
532:                             break;
533:                         }
534:                     }
535:                 
536:                     return 0;
537:                 }
538:                 
539:                 // *****************************************************************************
540:                 /* Function:
541:                     DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
542:                 
543:                   Summary:
544:                     This function gets the currently selected operation mode.
545:                 
546:                   Description:
547:                     This function gets the currently selected 16/32 bit operation mode.
548:                 
549:                   Remarks:
550:                     Refer to drv_tmr.h for usage information.
551:                 */
552:                 
553:                 DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
554:                 {
555:                     switch (handle)
556:                     {
557:                         case DRV_TMR_INDEX_0:
558:                         {
559:                             return DRV_TMR0_OperationModeGet();
560:                             break;
561:                         }
562:                         default:
563:                         {
564:                             break;
565:                         }
566:                     }
567:                 
568:                     return DRV_TMR_OPERATION_MODE_NONE;
569:                 }
00000000  00000000   NOP
570:                 
571:                 // *****************************************************************************
572:                 // *****************************************************************************
573:                 // Section: TMR Driver Miscellaneous information functions
574:                 // *****************************************************************************
575:                 // *****************************************************************************
576:                 
577:                 // *****************************************************************************
578:                 /* Function:
579:                     bool DRV_TMR_ClockSet 
580:                     ( 
581:                         DRV_HANDLE handle, 
582:                         DRV_TMR_CLK_SOURCES clockSource, 
583:                         TMR_PRESCALE  preScale 
584:                     )
585:                 
586:                   Summary:
587:                     Sets the timers clock by selecting the source and prescaler.
588:                 
589:                   Description:
590:                     This function sets the timers clock by selecting the source and prescaler.
591:                 
592:                   Remarks:
593:                     Refer to drv_tmr.h for usage information.
594:                 */
595:                 
596:                 bool DRV_TMR_ClockSet 
597:                 ( 
598:                     DRV_HANDLE handle, 
599:                     DRV_TMR_CLK_SOURCES clockSource, 
600:                     TMR_PRESCALE  preScale 
601:                 )
602:                 {
00000008  00000000   NOP
603:                     switch (handle)
00000000  00000000   NOP
604:                     {
605:                         case DRV_TMR_INDEX_0:
606:                         {
607:                             return DRV_TMR0_ClockSet(clockSource, preScale);
00000010  00000000   NOP
608:                             break;
609:                         }
610:                         default:
611:                         {
612:                             break;
613:                         }
614:                     }
615:                 
616:                     return false;
00000020  00000000   NOP
617:                 }
00000028  00000000   NOP
618:                 
619:                 // *****************************************************************************
620:                 /* Function:
621:                     TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
622:                 
623:                   Summary:
624:                     This function gets the currently selected prescaler.
625:                 
626:                   Description:
627:                     This function gets the currently selected prescaler.
628:                 
629:                   Remarks:
630:                     Refer to drv_tmr.h for usage information.
631:                 */
632:                 
633:                 TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
634:                 {
00000008  00000000   NOP
635:                     switch (handle)
00000000  00000000   NOP
636:                     {
637:                         case DRV_TMR_INDEX_0:
638:                         {
639:                             return DRV_TMR0_PrescalerGet();
00000010  00000000   NOP
640:                             break;
641:                         }
642:                         default:
643:                         {
644:                             break;
645:                         }
646:                     }
647:                 
648:                     return -1;
00000020  00000000   NOP
649:                 }
00000028  00000000   NOP
650:                 
651:                 // *****************************************************************************
652:                 /* Function:
653:                     bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
654:                 
655:                   Summary:
656:                     Enables the Gate mode.
657:                 
658:                   Description:
659:                     This function enables the Gated mode of Timer. User can measure the duration
660:                     of an external signal in this mode. Once the Gate mode is enabled, Timer
661:                     will start on the raising edge of the external signal. It will keep counting
662:                     until the next falling edge. 
663:                 
664:                   Remarks:
665:                     Refer to drv_tmr.h for usage information.
666:                 */
667:                 
668:                 bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
669:                 {
670:                     switch (handle)
671:                     {
672:                         default:
673:                         {
674:                             break;
675:                         }
676:                     }
677:                 
678:                     return false;
679:                 }
680:                 
681:                 // *****************************************************************************
682:                 /* Function:
683:                     bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
684:                 
685:                   Summary:
686:                     Enables the Gate mode.
687:                 
688:                   Description:
689:                     This function enables the Gated mode of Timer. User can measure the duration
690:                     of an external signal in this mode. Once the Gate mode is enabled, Timer
691:                     will start on the raising edge of the external signal. It will keep counting
692:                     until the next falling edge. 
693:                 
694:                   Remarks:
695:                     Refer to drv_tmr.h for usage information.
696:                 */
697:                 
698:                 bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
699:                 {
700:                     switch (handle)
701:                     {
702:                         default:
703:                         {
704:                             break;
705:                         }
706:                     }
707:                 
708:                     return false;
709:                 }
00000000  00000000   NOP
710:                 
711:                 // *****************************************************************************
712:                 /* Function:
713:                     uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
714:                 
715:                   Summary:
716:                     Provides the Timer input frequency.
717:                 
718:                   Description:
719:                     This function provides the Timer input frequency. Input frequency is the
720:                     clock to the Timer register and it is considering the prescaler divisor. 
721:                 
722:                   Remarks:
723:                     Refer to drv_tmr.h for usage information.
724:                 */
725:                 
726:                 uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
727:                 {
00000008  00000000   NOP
728:                     switch (handle)
00000000  00000000   NOP
729:                     {
730:                         case DRV_TMR_INDEX_0:
731:                         {
732:                             return DRV_TMR0_CounterFrequencyGet();
00000010  00000000   NOP
733:                             break;
734:                         }
735:                         default:
736:                         {
737:                             break;
738:                         }
739:                     }
740:                 
741:                     return 0;
00000020  00000000   NOP
742:                 }
00000028  00000000   NOP
743:                 
744:                 // *****************************************************************************
745:                 /* Function:
746:                     DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
747:                     ( 
748:                         DRV_HANDLE handle, 
749:                         DRV_TMR_DIVIDER_RANGE* pDivRange
750:                     )
751:                 
752:                   Summary:
753:                     Returns the Timer divider values.
754:                 
755:                   Description:
756:                     This function provides the Timer operating mode and divider range.
757:                 
758:                   Remarks:
759:                     Refer to drv_tmr.h for usage information.
760:                 */
761:                 
762:                 DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
763:                 ( 
764:                     DRV_HANDLE handle,
765:                     DRV_TMR_DIVIDER_RANGE* pDivRange
766:                 )
767:                 {
00000008  00000000   NOP
768:                     switch (handle)
00000000  00000000   NOP
769:                     {
770:                         case DRV_TMR_INDEX_0:
771:                         {
772:                             return DRV_TMR0_DividerRangeGet(pDivRange);
00000010  00000000   NOP
773:                             break;
774:                         }
775:                         default:
776:                         {
777:                             break;
778:                         }
779:                     }
780:                 
781:                     return DRV_TMR_OPERATION_MODE_NONE;
00000020  00000000   NOP
782:                 }
00000028  00000000   NOP
783:                 
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/framework/driver/tmr/drv_tmr_static.h
1:                   /*******************************************************************************
2:                     Timer Driver Interface Declarations for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr_static.h
9:                   
10:                    Summary:
11:                      Timer driver interface declarations for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers. This file defines the interface
16:                      Declarations for the TMR driver.
17:                      
18:                    Remarks:
19:                      Static interfaces incorporate the driver instance number within the names
20:                      of the routines, eliminating the need for an object ID or object handle.
21:                      
22:                      Static single-open interfaces also eliminate the need for the open handle.
23:                  *******************************************************************************/
24:                  
25:                  //DOM-IGNORE-BEGIN
26:                  /*******************************************************************************
27:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
28:                  
29:                  Microchip licenses to you the right to use, modify, copy and distribute
30:                  Software only when embedded on a Microchip microcontroller or digital signal
31:                  controller that is integrated into your product or third party product
32:                  (pursuant to the sublicense terms in the accompanying license agreement).
33:                  
34:                  You should refer to the license agreement accompanying this Software for
35:                  additional information regarding your rights and obligations.
36:                  
37:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
38:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
39:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTOCULAR PURPOSE.
40:                  IN NO EVENT SHALL MOCROCHIP OR ITS LOCENSORS BE LIABLE OR OBLIGATED UNDER
41:                  CONTRACT, NEGLIGENCE, STROCT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
42:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
43:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
44:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVOCES, OR ANY CLAIMS BY THIRD PARTIES
46:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                  *******************************************************************************/
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _DRV_TMR_STATIC_H
51:                  #define _DRV_TMR_STATIC_H
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Headers
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  #include <stdint.h>
58:                  #include "driver/tmr/drv_tmr.h"
59:                  #include "peripheral/tmr/plib_tmr.h"
60:                  #include "peripheral/int/plib_int.h"
61:                  
62:                  // maximum divider value for 32 bit operation mode
63:                  #define     DRV_TIMER_DIVIDER_MAX_32BIT     0xffffffff
64:                  
65:                  // minimum divider value for 32 bit operation mode
66:                  #define     DRV_TIMER_DIVIDER_MIN_32BIT     0x2
67:                  
68:                  // maximum divider value for 16 bit operation mode
69:                  #define     DRV_TIMER_DIVIDER_MAX_16BIT     0x10000
70:                  
71:                  // minimum divider value for 16 bit operation mode
72:                  #define     DRV_TIMER_DIVIDER_MIN_16BIT     0x2
73:                  
74:                  
75:                  // *****************************************************************************
76:                  // *****************************************************************************
77:                  // Section: Interface Headers for Instance 0 for the static driver
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  
81:                  void DRV_TMR0_Initialize(void);
82:                  bool DRV_TMR0_Start(void);
83:                  void DRV_TMR0_Stop(void);
84:                  static inline void DRV_TMR0_DeInitialize(void)
85:                  {
86:                  	DRV_TMR0_Stop();
87:                  }
88:                  static inline void DRV_TMR0_Open(void) {}
89:                  DRV_TMR_CLIENT_STATUS DRV_TMR0_ClientStatus ( void );
90:                  static inline DRV_TMR_OPERATION_MODE DRV_TMR0_OperationModeGet(void)
91:                  {
92:                      return DRV_TMR_OPERATION_MODE_16_BIT;
93:                  }
94:                  static inline void DRV_TMR0_Close(void) 
95:                  {
96:                      DRV_TMR0_Stop();
00000010  00000000   NOP
97:                  }
98:                  bool DRV_TMR0_ClockSet
99:                  (
100:                     DRV_TMR_CLK_SOURCES clockSource, 
101:                     TMR_PRESCALE  prescale 
102:                 );
103:                 void DRV_TMR0_CounterValueSet(uint32_t value);
104:                 uint32_t DRV_TMR0_CounterValueGet(void);
105:                 void DRV_TMR0_CounterClear(void);
106:                 TMR_PRESCALE DRV_TMR0_PrescalerGet(void);
107:                 void DRV_TMR0_PeriodValueSet(uint32_t value);
108:                 uint32_t DRV_TMR0_PeriodValueGet(void);
109:                 void DRV_TMR0_StopInIdleDisable(void);
110:                 void DRV_TMR0_StopInIdleEnable(void);
111:                 static inline void DRV_TMR0_Tasks(void) {}
112:                 uint32_t DRV_TMR0_CounterFrequencyGet(void);
113:                 DRV_TMR_OPERATION_MODE DRV_TMR0_DividerRangeGet
114:                 (
115:                     DRV_TMR_DIVIDER_RANGE * pDivRange
116:                 );
117:                 #endif // #ifndef _DRV_TMR_STATIC_H
118:                 
119:                 /*******************************************************************************
120:                  End of File
121:                 */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/framework/driver/oc/src/drv_oc_static.c
1:                   /*******************************************************************************
2:                     OC Driver Functions for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_oc_static.c
9:                   
10:                    Summary:
11:                      OC driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The OC device driver provides a simple interface to manage the OC
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                      Static single-open interfaces also eliminate the need for the open handle.
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTOCULAR PURPOSE.
38:                  IN NO EVENT SHALL MOCROCHIP OR ITS LOCENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STROCT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVOCES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  //DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Header Includes
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  #include "peripheral/oc/plib_oc.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Instance 0 static driver functions
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  void DRV_OC0_Initialize(void)
61:                  {
62:                      /* Setup OC0 Instance */
63:                      PLIB_OC_ModeSelect(OC_ID_2, OC_DUAL_COMPARE_CONTINUOUS_PULSE_MODE);
64:                      PLIB_OC_BufferSizeSelect(OC_ID_2, OC_BUFFER_SIZE_16BIT);
65:                      PLIB_OC_TimerSelect(OC_ID_2, OC_TIMER_16BIT_TMR2);
66:                      PLIB_OC_Buffer16BitSet(OC_ID_2, 3000);
67:                      PLIB_OC_PulseWidth16BitSet(OC_ID_2, 15);
68:                      OC2R = 30000;
9D00C5FC  24047530   ADDIU A0, ZERO, 30000
9D00C600  AC643210   SW A0, 12816(V1)
69:                      OC2RS = 30020;
9D00C604  24037544   ADDIU V1, ZERO, 30020
9D00C608  AC433220   SW V1, 12832(V0)
9D00C60C  03E00008   JR RA
9D00C610  00000000   NOP
70:                  }
71:                  
72:                  void DRV_OC0_Enable(void)
73:                  {
74:                     PLIB_OC_Enable(OC_ID_2);
75:                  }
76:                  
77:                  void DRV_OC0_Disable(void)
78:                  {
79:                     PLIB_OC_Disable(OC_ID_2);
80:                  }
81:                  
82:                  void DRV_OC0_Start(void)
83:                  {
84:                     PLIB_OC_Enable(OC_ID_2);
85:                  }
86:                  
87:                  void DRV_OC0_Stop(void)
88:                  {
89:                     PLIB_OC_Disable(OC_ID_2);
90:                  }
91:                  
92:                  bool DRV_OC0_FaultHasOccurred(void)
93:                  {
94:                     return PLIB_OC_FaultHasOccurred(OC_ID_2);
95:                  }
00000008  00000000   NOP
96:                  
97:                  // *****************************************************************************
98:                  // *****************************************************************************
99:                  // Section: Instance 1 static driver functions
100:                 // *****************************************************************************
101:                 // *****************************************************************************
102:                 void DRV_OC1_Initialize(void)
103:                 {
104:                     /* Setup OC0 Instance */
105:                     PLIB_OC_ModeSelect(OC_ID_5, OC_DUAL_COMPARE_CONTINUOUS_PULSE_MODE);
106:                     PLIB_OC_BufferSizeSelect(OC_ID_5, OC_BUFFER_SIZE_16BIT);
107:                     PLIB_OC_TimerSelect(OC_ID_5, OC_TIMER_16BIT_TMR2);
108:                     PLIB_OC_Buffer16BitSet(OC_ID_5, 3000);
109:                     PLIB_OC_PulseWidth16BitSet(OC_ID_5, 15);
110:                     OC5R = 30000;
9D00C664  24047530   ADDIU A0, ZERO, 30000
9D00C668  AC643810   SW A0, 14352(V1)
111:                     OC5RS = 30020;
9D00C66C  24037544   ADDIU V1, ZERO, 30020
9D00C670  AC433820   SW V1, 14368(V0)
9D00C674  03E00008   JR RA
9D00C678  00000000   NOP
112:                 }
113:                 
114:                 void DRV_OC1_Enable(void)
115:                 {
116:                    PLIB_OC_Enable(OC_ID_5);
117:                 }
118:                 
119:                 void DRV_OC1_Disable(void)
120:                 {
121:                    PLIB_OC_Disable(OC_ID_5);
122:                 }
123:                 
124:                 void DRV_OC1_Start(void)
125:                 {
126:                    PLIB_OC_Enable(OC_ID_5);
127:                 }
128:                 
129:                 void DRV_OC1_Stop(void)
130:                 {
131:                    PLIB_OC_Disable(OC_ID_5);
132:                 }
133:                 
134:                 bool DRV_OC1_FaultHasOccurred(void)
135:                 {
136:                    return PLIB_OC_FaultHasOccurred(OC_ID_5);
137:                 }
00000008  00000000   NOP
138:                 
139:                 // *****************************************************************************
140:                 // *****************************************************************************
141:                 // Section: Instance 2 static driver functions
142:                 // *****************************************************************************
143:                 // *****************************************************************************
144:                 void DRV_OC2_Initialize(void)
145:                 {
146:                     /* Setup OC0 Instance */
147:                     PLIB_OC_ModeSelect(OC_ID_3, OC_DUAL_COMPARE_CONTINUOUS_PULSE_MODE);
148:                     PLIB_OC_BufferSizeSelect(OC_ID_3, OC_BUFFER_SIZE_16BIT);
149:                     PLIB_OC_TimerSelect(OC_ID_3, OC_TIMER_16BIT_TMR2);
150:                     PLIB_OC_Buffer16BitSet(OC_ID_3, 3000);
151:                     PLIB_OC_PulseWidth16BitSet(OC_ID_3, 15);
152:                     OC3R = 30000;
9D00C6CC  24047530   ADDIU A0, ZERO, 30000
9D00C6D0  AC643410   SW A0, 13328(V1)
153:                     OC3RS = 30020;
9D00C6D4  24037544   ADDIU V1, ZERO, 30020
9D00C6D8  AC433420   SW V1, 13344(V0)
9D00C6DC  03E00008   JR RA
9D00C6E0  00000000   NOP
154:                 }
155:                 
156:                 void DRV_OC2_Enable(void)
157:                 {
158:                    PLIB_OC_Enable(OC_ID_3);
159:                 }
160:                 
161:                 void DRV_OC2_Disable(void)
162:                 {
163:                    PLIB_OC_Disable(OC_ID_3);
164:                 }
165:                 
166:                 void DRV_OC2_Start(void)
167:                 {
168:                    PLIB_OC_Enable(OC_ID_3);
169:                 }
170:                 
171:                 void DRV_OC2_Stop(void)
172:                 {
173:                    PLIB_OC_Disable(OC_ID_3);
174:                 }
175:                 
176:                 bool DRV_OC2_FaultHasOccurred(void)
177:                 {
178:                    return PLIB_OC_FaultHasOccurred(OC_ID_3);
179:                 }
00000008  00000000   NOP
180:                 
181:                 // *****************************************************************************
182:                 // *****************************************************************************
183:                 // Section: Instance 3 static driver functions
184:                 // *****************************************************************************
185:                 // *****************************************************************************
186:                 void DRV_OC3_Initialize(void)
187:                 {
188:                     /* Setup OC0 Instance */
189:                     PLIB_OC_ModeSelect(OC_ID_4, OC_DUAL_COMPARE_CONTINUOUS_PULSE_MODE);
190:                     PLIB_OC_BufferSizeSelect(OC_ID_4, OC_BUFFER_SIZE_16BIT);
191:                     PLIB_OC_TimerSelect(OC_ID_4, OC_TIMER_16BIT_TMR2);
192:                     PLIB_OC_Buffer16BitSet(OC_ID_4, 3000);
193:                     PLIB_OC_PulseWidth16BitSet(OC_ID_4, 15);
194:                     OC4R = 30000;
9D00C734  24047530   ADDIU A0, ZERO, 30000
9D00C738  AC643610   SW A0, 13840(V1)
195:                     OC4RS = 30020;
9D00C73C  24037544   ADDIU V1, ZERO, 30020
9D00C740  AC433620   SW V1, 13856(V0)
9D00C744  03E00008   JR RA
9D00C748  00000000   NOP
196:                 }
197:                 
198:                 void DRV_OC3_Enable(void)
199:                 {
200:                    PLIB_OC_Enable(OC_ID_4);
201:                 }
202:                 
203:                 void DRV_OC3_Disable(void)
204:                 {
205:                    PLIB_OC_Disable(OC_ID_4);
206:                 }
207:                 
208:                 void DRV_OC3_Start(void)
209:                 {
210:                    PLIB_OC_Enable(OC_ID_4);
211:                 }
212:                 
213:                 void DRV_OC3_Stop(void)
214:                 {
215:                    PLIB_OC_Disable(OC_ID_4);
216:                 }
217:                 
218:                 bool DRV_OC3_FaultHasOccurred(void)
219:                 {
220:                    return PLIB_OC_FaultHasOccurred(OC_ID_4);
221:                 }
00000008  00000000   NOP
222:                 
223:                 /*******************************************************************************
224:                  End of File
225:                 */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/framework/driver/oc/src/drv_oc_mapping.c
1:                   /*******************************************************************************
2:                     OC Driver Dynamic to Static mapping
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_oc_mapping.c
9:                   
10:                    Summary:
11:                      Source code for the OC driver dynamic APIs to static API mapping.
12:                  
13:                    Description:
14:                      This file contains code that maps dynamic APIs to static whenever
15:                      the static mode of the driver is selected..
16:                  
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                  
21:                      Static single-open interfaces also eliminate the need for the open handle.
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTOCULAR PURPOSE.
39:                  IN NO EVENT SHALL MOCROCHIP OR ITS LOCENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STROCT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVOCES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  //DOM-IGNORE-END
48:                  
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  // Section: Included Files
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  SYS_MODULE_OBJ DRV_OC_Initialize(const SYS_MODULE_INDEX index,const SYS_MODULE_INIT * const init)
59:                  {
00000000  00000000   NOP
60:                      SYS_MODULE_OBJ returnValue = index;
61:                  
62:                      switch(index)
00000010  00000000   NOP
63:                      {
64:                          case DRV_OC_INDEX_0:
65:                          {
66:                              DRV_OC0_Initialize();
00000044  00000000   NOP
67:                              break;
0000004C  00000000   NOP
68:                          }
69:                          case DRV_OC_INDEX_1:
70:                          {
71:                              DRV_OC1_Initialize();
00000054  00000000   NOP
72:                              break;
0000005C  00000000   NOP
73:                          }
74:                          case DRV_OC_INDEX_2:
75:                          {
76:                              DRV_OC2_Initialize();
00000064  00000000   NOP
77:                              break;
0000006C  00000000   NOP
78:                          }
79:                          case DRV_OC_INDEX_3:
80:                          {
81:                              DRV_OC3_Initialize();
00000074  00000000   NOP
82:                              break;
0000007C  00000000   NOP
83:                          }
84:                          default:
85:                          {
86:                              returnValue = SYS_MODULE_OBJ_INVALID;
0000003C  00000000   NOP
87:                              break;
88:                          }
89:                      }
90:                      return returnValue;
91:                  }
00000084  00000000   NOP
92:                  
93:                  DRV_HANDLE DRV_OC_Start(const SYS_MODULE_INDEX drvIndex, const DRV_IO_INTENT intent)
94:                  {
00000000  00000000   NOP
95:                      SYS_MODULE_OBJ returnValue = drvIndex;
96:                  
97:                      switch(drvIndex)
00000010  00000000   NOP
98:                      {
99:                          case DRV_OC_INDEX_0:
100:                         {
101:                             DRV_OC0_Start();
00000044  00000000   NOP
102:                             break;
0000004C  00000000   NOP
103:                         }
104:                         case DRV_OC_INDEX_1:
105:                         {
106:                             DRV_OC1_Start();
00000054  00000000   NOP
107:                             break;
0000005C  00000000   NOP
108:                         }
109:                         case DRV_OC_INDEX_2:
110:                         {
111:                             DRV_OC2_Start();
00000064  00000000   NOP
112:                             break;
0000006C  00000000   NOP
113:                         }
114:                         case DRV_OC_INDEX_3:
115:                         {
116:                             DRV_OC3_Start();
00000074  00000000   NOP
117:                             break;
0000007C  00000000   NOP
118:                         }
119:                         default:
120:                         {
121:                             returnValue = SYS_MODULE_OBJ_INVALID;
0000003C  00000000   NOP
122:                             break;
123:                         }
124:                     }
125:                     return returnValue;
126:                 }
00000084  00000000   NOP
127:                 
128:                 
129:                 void DRV_OC_Stop(DRV_HANDLE handle)
130:                 {
00000000  00000000   NOP
131:                     switch(handle)
00000004  00000000   NOP
132:                     {
133:                         case DRV_OC_INDEX_0:
134:                         {
135:                             DRV_OC0_Stop();
00000030  00000000   NOP
136:                             break;
00000038  00000000   NOP
137:                         }
138:                         case DRV_OC_INDEX_1:
139:                         {
140:                             DRV_OC1_Stop();
00000040  00000000   NOP
141:                             break;
00000048  00000000   NOP
142:                         }
143:                         case DRV_OC_INDEX_2:
144:                         {
145:                             DRV_OC2_Stop();
00000050  00000000   NOP
146:                             break;
00000058  00000000   NOP
147:                         }
148:                         case DRV_OC_INDEX_3:
149:                         {
150:                             DRV_OC3_Stop();
00000060  00000000   NOP
151:                             break;
152:                         }
153:                         default:
154:                         {
155:                             break;
156:                         }
157:                     }
158:                 }
00000068  00000000   NOP
159:                 
160:                 bool DRV_OC_FaultHasOccurred(DRV_HANDLE handle)
161:                 {
00000000  00000000   NOP
162:                     bool returnValue = true;  // Default state of buffer is empty.
00000030  00000000   NOP
163:                 
164:                     switch(handle)
00000004  00000000   NOP
165:                     {
166:                         case DRV_OC_INDEX_0:
167:                         {
168:                             returnValue = DRV_OC0_FaultHasOccurred();
00000038  00000000   NOP
169:                             break;
00000040  00000000   NOP
170:                         }
171:                         case DRV_OC_INDEX_1:
172:                         {
173:                             returnValue = DRV_OC1_FaultHasOccurred();
00000048  00000000   NOP
174:                             break;
00000050  00000000   NOP
175:                         }
176:                         case DRV_OC_INDEX_2:
177:                         {
178:                             returnValue = DRV_OC2_FaultHasOccurred();
00000058  00000000   NOP
179:                             break;
00000060  00000000   NOP
180:                         }
181:                         case DRV_OC_INDEX_3:
182:                         {
183:                             returnValue = DRV_OC3_FaultHasOccurred();
00000068  00000000   NOP
184:                             break;
00000070  00000000   NOP
185:                         }
186:                         default:
187:                         {
188:                             break;
189:                         }
190:                     }
191:                     return returnValue;
192:                 }
00000078  00000000   NOP
193:                 
194:                 /*******************************************************************************
195:                  End of File
196:                 */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/framework/driver/ic/src/drv_ic_static.c
1:                   /*******************************************************************************
2:                     IC Driver Functions for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_ic_static.c
9:                   
10:                    Summary:
11:                      IC driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The IC device driver provides a simple interface to manage the IC
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                      Static single-open interfaces also eliminate the need for the open handle.
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  //DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Header Includes
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  #include "peripheral/ic/plib_ic.h"
54:                  #include "peripheral/int/plib_int.h"
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Instance 0 static driver functions
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  void DRV_IC0_Initialize(void)
62:                  {	
63:                      PLIB_IC_ModeSelect(IC_ID_3, IC_INPUT_CAPTURE_EDGE_DETECT_MODE);
64:                      PLIB_IC_FirstCaptureEdgeSelect(IC_ID_3, IC_EDGE_RISING);
65:                      PLIB_IC_TimerSelect(IC_ID_3, IC_TIMER_TMR2);
66:                      PLIB_IC_BufferSizeSelect(IC_ID_3, IC_BUFFER_SIZE_16BIT);
67:                      PLIB_IC_EventsPerInterruptSelect(IC_ID_3, IC_INTERRUPT_ON_EVERY_2ND_CAPTURE_EVENT);   
68:                  
69:                      /* Setup Interrupt */   
70:                      PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_3);
71:                      PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_IC3, INT_PRIORITY_LEVEL1);
72:                      PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_IC3, INT_SUBPRIORITY_LEVEL0);          
73:                  }
74:                  
75:                  void DRV_IC0_Start(void)
76:                  {
77:                     PLIB_IC_Enable(IC_ID_3);
78:                  }
79:                  
80:                  void DRV_IC0_Stop(void)
81:                  {
82:                     PLIB_IC_Disable(IC_ID_3);
83:                  }
84:                  
85:                  void DRV_IC0_Open(void)
86:                  {
87:                  }
88:                  
89:                  void DRV_IC0_Close(void)
90:                  {
00000000  00000000   NOP
91:                  }
92:                  uint32_t DRV_IC0_Capture32BitDataRead(void)
93:                  {
94:                     return PLIB_IC_Buffer32BitGet(IC_ID_3);
95:                  }
00000008  00000000   NOP
96:                  
97:                  uint16_t DRV_IC0_Capture16BitDataRead(void)
98:                  {
99:                     return PLIB_IC_Buffer16BitGet(IC_ID_3);
100:                 }
9D00DD18  03E00008   JR RA
9D00DD1C  3042FFFF   ANDI V0, V0, -1
101:                 
102:                 bool DRV_IC0_BufferIsEmpty(void)
103:                 {
104:                    return PLIB_IC_BufferIsEmpty(IC_ID_3);
105:                 }
0000000C  00000000   NOP
106:                 
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 // Section: Instance 1 static driver functions
110:                 // *****************************************************************************
111:                 // *****************************************************************************
112:                 void DRV_IC1_Initialize(void)
113:                 {	
114:                     PLIB_IC_ModeSelect(IC_ID_1, IC_INPUT_CAPTURE_EDGE_DETECT_MODE);
115:                     PLIB_IC_FirstCaptureEdgeSelect(IC_ID_1, IC_EDGE_RISING);
116:                     PLIB_IC_TimerSelect(IC_ID_1, IC_TIMER_TMR2);
117:                     PLIB_IC_BufferSizeSelect(IC_ID_1, IC_BUFFER_SIZE_16BIT);
118:                     PLIB_IC_EventsPerInterruptSelect(IC_ID_1, IC_INTERRUPT_ON_EVERY_2ND_CAPTURE_EVENT);   
119:                 
120:                     /* Setup Interrupt */   
121:                     PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_1);
122:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_IC1, INT_PRIORITY_LEVEL1);
123:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_IC1, INT_SUBPRIORITY_LEVEL0);          
124:                 }
125:                 
126:                 void DRV_IC1_Start(void)
127:                 {
128:                    PLIB_IC_Enable(IC_ID_1);
129:                 }
130:                 
131:                 void DRV_IC1_Stop(void)
132:                 {
133:                    PLIB_IC_Disable(IC_ID_1);
134:                 }
135:                 
136:                 void DRV_IC1_Open(void)
137:                 {
138:                 }
139:                 
140:                 void DRV_IC1_Close(void)
141:                 {
00000000  00000000   NOP
142:                 }
143:                 uint32_t DRV_IC1_Capture32BitDataRead(void)
144:                 {
145:                    return PLIB_IC_Buffer32BitGet(IC_ID_1);
146:                 }
00000008  00000000   NOP
147:                 
148:                 uint16_t DRV_IC1_Capture16BitDataRead(void)
149:                 {
150:                    return PLIB_IC_Buffer16BitGet(IC_ID_1);
151:                 }
9D00DD28  03E00008   JR RA
9D00DD2C  3042FFFF   ANDI V0, V0, -1
152:                 
153:                 bool DRV_IC1_BufferIsEmpty(void)
154:                 {
155:                    return PLIB_IC_BufferIsEmpty(IC_ID_1);
156:                 }
0000000C  00000000   NOP
157:                 
158:                 // *****************************************************************************
159:                 // *****************************************************************************
160:                 // Section: Instance 2 static driver functions
161:                 // *****************************************************************************
162:                 // *****************************************************************************
163:                 void DRV_IC2_Initialize(void)
164:                 {	
165:                     PLIB_IC_ModeSelect(IC_ID_4, IC_INPUT_CAPTURE_EDGE_DETECT_MODE);
166:                     PLIB_IC_FirstCaptureEdgeSelect(IC_ID_4, IC_EDGE_RISING);
167:                     PLIB_IC_TimerSelect(IC_ID_4, IC_TIMER_TMR2);
168:                     PLIB_IC_BufferSizeSelect(IC_ID_4, IC_BUFFER_SIZE_16BIT);
169:                     PLIB_IC_EventsPerInterruptSelect(IC_ID_4, IC_INTERRUPT_ON_EVERY_2ND_CAPTURE_EVENT);   
170:                 
171:                     /* Setup Interrupt */   
172:                     PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_4);
173:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_IC4, INT_PRIORITY_LEVEL1);
174:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_IC4, INT_SUBPRIORITY_LEVEL0);          
175:                 }
176:                 
177:                 void DRV_IC2_Start(void)
178:                 {
179:                    PLIB_IC_Enable(IC_ID_4);
180:                 }
181:                 
182:                 void DRV_IC2_Stop(void)
183:                 {
184:                    PLIB_IC_Disable(IC_ID_4);
185:                 }
186:                 
187:                 void DRV_IC2_Open(void)
188:                 {
189:                 }
190:                 
191:                 void DRV_IC2_Close(void)
192:                 {
00000000  00000000   NOP
193:                 }
194:                 uint32_t DRV_IC2_Capture32BitDataRead(void)
195:                 {
196:                    return PLIB_IC_Buffer32BitGet(IC_ID_4);
197:                 }
00000008  00000000   NOP
198:                 
199:                 uint16_t DRV_IC2_Capture16BitDataRead(void)
200:                 {
201:                    return PLIB_IC_Buffer16BitGet(IC_ID_4);
202:                 }
9D00DD38  03E00008   JR RA
9D00DD3C  3042FFFF   ANDI V0, V0, -1
203:                 
204:                 bool DRV_IC2_BufferIsEmpty(void)
205:                 {
206:                    return PLIB_IC_BufferIsEmpty(IC_ID_4);
207:                 }
0000000C  00000000   NOP
208:                 
209:                 // *****************************************************************************
210:                 // *****************************************************************************
211:                 // Section: Instance 3 static driver functions
212:                 // *****************************************************************************
213:                 // *****************************************************************************
214:                 void DRV_IC3_Initialize(void)
215:                 {	
216:                     PLIB_IC_ModeSelect(IC_ID_5, IC_INPUT_CAPTURE_EDGE_DETECT_MODE);
217:                     PLIB_IC_FirstCaptureEdgeSelect(IC_ID_5, IC_EDGE_RISING);
218:                     PLIB_IC_TimerSelect(IC_ID_5, IC_TIMER_TMR2);
219:                     PLIB_IC_BufferSizeSelect(IC_ID_5, IC_BUFFER_SIZE_16BIT);
220:                     PLIB_IC_EventsPerInterruptSelect(IC_ID_5, IC_INTERRUPT_ON_EVERY_2ND_CAPTURE_EVENT);   
221:                 
222:                     /* Setup Interrupt */   
223:                     PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_INPUT_CAPTURE_5);
224:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_IC5, INT_PRIORITY_LEVEL1);
225:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_IC5, INT_SUBPRIORITY_LEVEL0);          
226:                 }
227:                 
228:                 void DRV_IC3_Start(void)
229:                 {
230:                    PLIB_IC_Enable(IC_ID_5);
231:                 }
232:                 
233:                 void DRV_IC3_Stop(void)
234:                 {
235:                    PLIB_IC_Disable(IC_ID_5);
236:                 }
237:                 
238:                 void DRV_IC3_Open(void)
239:                 {
240:                 }
241:                 
242:                 void DRV_IC3_Close(void)
243:                 {
00000000  00000000   NOP
244:                 }
245:                 uint32_t DRV_IC3_Capture32BitDataRead(void)
246:                 {
247:                    return PLIB_IC_Buffer32BitGet(IC_ID_5);
248:                 }
00000008  00000000   NOP
249:                 
250:                 uint16_t DRV_IC3_Capture16BitDataRead(void)
251:                 {
252:                    return PLIB_IC_Buffer16BitGet(IC_ID_5);
253:                 }
9D00DD48  03E00008   JR RA
9D00DD4C  3042FFFF   ANDI V0, V0, -1
254:                 
255:                 bool DRV_IC3_BufferIsEmpty(void)
256:                 {
257:                    return PLIB_IC_BufferIsEmpty(IC_ID_5);
258:                 }
0000000C  00000000   NOP
259:                 
260:                 /*******************************************************************************
261:                  End of File
262:                 */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/system_config/default/framework/driver/ic/src/drv_ic_mapping.c
1:                   /*******************************************************************************
2:                     IC Driver Dynamic to Static mapping
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_ic_mapping.c
9:                   
10:                    Summary:
11:                      Source code for the IC driver dynamic APIs to static API mapping.
12:                  
13:                    Description:
14:                      This file contains code that maps dynamic APIs to static whenever
15:                      the static mode of the driver is selected..
16:                  
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                  
21:                      Static single-open interfaces also eliminate the need for the open handle.
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  //DOM-IGNORE-END
48:                  
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  // Section: Included Files
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  SYS_MODULE_OBJ DRV_IC_Initialize(const SYS_MODULE_INDEX index,const SYS_MODULE_INIT * const init)
59:                  {
00000000  00000000   NOP
60:                      SYS_MODULE_OBJ returnValue = index;
61:                  
62:                      switch(index)
00000010  00000000   NOP
63:                      {
64:                          case DRV_IC_INDEX_0:
65:                          {
66:                              DRV_IC0_Initialize();
00000044  00000000   NOP
67:                              break;
0000004C  00000000   NOP
68:                          }
69:                          case DRV_IC_INDEX_1:
70:                          {
71:                              DRV_IC1_Initialize();
00000054  00000000   NOP
72:                              break;
0000005C  00000000   NOP
73:                          }
74:                          case DRV_IC_INDEX_2:
75:                          {
76:                              DRV_IC2_Initialize();
00000064  00000000   NOP
77:                              break;
0000006C  00000000   NOP
78:                          }
79:                          case DRV_IC_INDEX_3:
80:                          {
81:                              DRV_IC3_Initialize();
00000074  00000000   NOP
82:                              break;
0000007C  00000000   NOP
83:                          }
84:                          default:
85:                          {
86:                              returnValue = SYS_MODULE_OBJ_INVALID;
0000003C  00000000   NOP
87:                              break;
88:                          }
89:                      }
90:                      return returnValue;
91:                  }
00000084  00000000   NOP
92:                  
93:                  DRV_HANDLE DRV_IC_Start(const SYS_MODULE_INDEX drvIndex, const DRV_IO_INTENT intent)
94:                  {
00000000  00000000   NOP
95:                      SYS_MODULE_OBJ returnValue = drvIndex;
96:                  
97:                      switch(drvIndex)
00000010  00000000   NOP
98:                      {
99:                          case DRV_IC_INDEX_0:
100:                         {
101:                             DRV_IC0_Start();
00000044  00000000   NOP
102:                             break;
0000004C  00000000   NOP
103:                         }
104:                         case DRV_IC_INDEX_1:
105:                         {
106:                             DRV_IC1_Start();
00000054  00000000   NOP
107:                             break;
0000005C  00000000   NOP
108:                         }
109:                         case DRV_IC_INDEX_2:
110:                         {
111:                             DRV_IC2_Start();
00000064  00000000   NOP
112:                             break;
0000006C  00000000   NOP
113:                         }
114:                         case DRV_IC_INDEX_3:
115:                         {
116:                             DRV_IC3_Start();
00000074  00000000   NOP
117:                             break;
0000007C  00000000   NOP
118:                         }
119:                         default:
120:                         {
121:                             returnValue = SYS_MODULE_OBJ_INVALID;
0000003C  00000000   NOP
122:                             break;
123:                         }
124:                     }
125:                     return returnValue;
126:                 }
00000084  00000000   NOP
127:                 
128:                 
129:                 void DRV_IC_Stop(DRV_HANDLE handle)
130:                 {
00000000  00000000   NOP
131:                     switch(handle)
00000004  00000000   NOP
132:                     {
133:                         case DRV_IC_INDEX_0:
134:                         {
135:                             DRV_IC0_Stop();
00000030  00000000   NOP
136:                             break;
00000038  00000000   NOP
137:                         }
138:                         case DRV_IC_INDEX_1:
139:                         {
140:                             DRV_IC1_Stop();
00000040  00000000   NOP
141:                             break;
00000048  00000000   NOP
142:                         }
143:                         case DRV_IC_INDEX_2:
144:                         {
145:                             DRV_IC2_Stop();
00000050  00000000   NOP
146:                             break;
00000058  00000000   NOP
147:                         }
148:                         case DRV_IC_INDEX_3:
149:                         {
150:                             DRV_IC3_Stop();
00000060  00000000   NOP
151:                             break;
152:                         }
153:                         default:
154:                         {
155:                             break;
156:                         }
157:                     }
158:                 }
00000068  00000000   NOP
159:                 
160:                 uint32_t DRV_IC_Capture32BitDataRead(DRV_HANDLE handle)
161:                 {
00000000  00000000   NOP
162:                     uint32_t returnValue;
163:                 
164:                     switch(handle)
00000004  00000000   NOP
165:                     {
166:                         case DRV_IC_INDEX_0:
167:                         {
168:                             returnValue = DRV_IC0_Capture32BitDataRead();
00000038  00000000   NOP
169:                             break;
00000040  00000000   NOP
170:                         }
171:                         case DRV_IC_INDEX_1:
172:                         {
173:                             returnValue = DRV_IC1_Capture32BitDataRead();
00000048  00000000   NOP
174:                             break;
00000050  00000000   NOP
175:                         }
176:                         case DRV_IC_INDEX_2:
177:                         {
178:                             returnValue = DRV_IC2_Capture32BitDataRead();
00000058  00000000   NOP
179:                             break;
00000060  00000000   NOP
180:                         }
181:                         case DRV_IC_INDEX_3:
182:                         {
183:                             returnValue = DRV_IC3_Capture32BitDataRead();
00000068  00000000   NOP
184:                             break;
00000070  00000000   NOP
185:                         }
186:                         default:
187:                         {
188:                             returnValue = 0;
00000030  00000000   NOP
189:                             break;
190:                         }
191:                     }
192:                     return returnValue;
193:                 }
00000078  00000000   NOP
194:                 
195:                 
196:                 uint16_t DRV_IC_Capture16BitDataRead(DRV_HANDLE handle)
197:                 {
00000000  00000000   NOP
198:                     uint16_t returnValue;
199:                 
200:                     switch(handle)
00000004  00000000   NOP
201:                     {
202:                         case DRV_IC_INDEX_0:
203:                         {
204:                             returnValue = DRV_IC0_Capture16BitDataRead();
00000038  00000000   NOP
205:                             break;
00000040  00000000   NOP
206:                         }
207:                         case DRV_IC_INDEX_1:
208:                         {
209:                             returnValue = DRV_IC1_Capture16BitDataRead();
00000048  00000000   NOP
210:                             break;
00000050  00000000   NOP
211:                         }
212:                         case DRV_IC_INDEX_2:
213:                         {
214:                             returnValue = DRV_IC2_Capture16BitDataRead();
00000058  00000000   NOP
215:                             break;
00000060  00000000   NOP
216:                         }
217:                         case DRV_IC_INDEX_3:
218:                         {
219:                             returnValue = DRV_IC3_Capture16BitDataRead();
00000068  00000000   NOP
220:                             break;
00000070  00000000   NOP
221:                         }
222:                         default:
223:                         {
224:                             returnValue = 0;
00000030  00000000   NOP
225:                             break;
226:                         }
227:                     }
228:                     return returnValue;
229:                 }
00000078  00000000   NOP
230:                 
231:                 
232:                 bool DRV_IC_BufferIsEmpty(DRV_HANDLE handle)
233:                 {
00000000  00000000   NOP
234:                     bool returnValue = true;  // Default state of buffer is empty.
00000030  00000000   NOP
235:                 
236:                     switch(handle)
00000004  00000000   NOP
237:                     {
238:                         case DRV_IC_INDEX_0:
239:                         {
240:                             returnValue = DRV_IC0_BufferIsEmpty();
00000038  00000000   NOP
241:                             break;
00000040  00000000   NOP
242:                         }
243:                         case DRV_IC_INDEX_1:
244:                         {
245:                             returnValue = DRV_IC1_BufferIsEmpty();
00000048  00000000   NOP
246:                             break;
00000050  00000000   NOP
247:                         }
248:                         case DRV_IC_INDEX_2:
249:                         {
250:                             returnValue = DRV_IC2_BufferIsEmpty();
00000058  00000000   NOP
251:                             break;
00000060  00000000   NOP
252:                         }
253:                         case DRV_IC_INDEX_3:
254:                         {
255:                             returnValue = DRV_IC3_BufferIsEmpty();
00000068  00000000   NOP
256:                             break;
00000070  00000000   NOP
257:                         }
258:                         default:
259:                         {
260:                             break;
261:                         }
262:                     }
263:                     return returnValue;
264:                 }
00000078  00000000   NOP
265:                 
266:                 /*******************************************************************************
267:                  End of File
268:                 */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/ping_sensors.c  -----------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       ping_sensors.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "ping_sensors.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  PING_SENSORS_DATA ping_sensorsData;
80:                  
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  // Section: Application Callback Functions
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  
87:                  /* TODO:  Add any necessary callback functions.
88:                  */
89:                  
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Application Local Functions
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  
96:                  
97:                  /* TODO:  Add any necessary local functions.
98:                  */
99:                  QueueHandle_t Q;
100:                 int OCenabled;
101:                 
102:                 
103:                 void Qinit ()
104:                 {
9D00D8F8  27BDFFE8   ADDIU SP, SP, -24
9D00D8FC  AFBF0014   SW RA, 20(SP)
105:                     Q = xQueueCreate (5, sizeof (VALUES_t));
9D00D900  24040005   ADDIU A0, ZERO, 5
9D00D904  24050006   ADDIU A1, ZERO, 6
9D00D908  0F402DB4   JAL xQueueGenericCreate
9D00D90C  00003021   ADDU A2, ZERO, ZERO
9D00D910  AF8280E0   SW V0, -32544(GP)
106:                 }
9D00D914  8FBF0014   LW RA, 20(SP)
9D00D918  03E00008   JR RA
9D00D91C  27BD0018   ADDIU SP, SP, 24
107:                 
108:                 void QSendFromISR (VALUES_t tmrvals)
109:                 {
9D00C4DC  27BDFFE0   ADDIU SP, SP, -32
9D00C4E0  AFBF001C   SW RA, 28(SP)
9D00C4E4  AFA40020   SW A0, 32(SP)
9D00C4E8  AFA50024   SW A1, 36(SP)
110:                     /* Check for whether the task needs to do a context switch */
111:                     BaseType_t conSwitch;
112:                     conSwitch = pdFALSE;
9D00C4EC  AFA00010   SW ZERO, 16(SP)
113:                     
114:                     /* Send to the Queue from an ISR */
115:                     if ((xQueueOverwriteFromISR (Q, &tmrvals, &conSwitch)) == errQUEUE_FULL) {
9D00C4F0  8F8480E0   LW A0, -32544(GP)
9D00C4F4  27A50020   ADDIU A1, SP, 32
9D00C4F8  27A60010   ADDIU A2, SP, 16
9D00C4FC  0F40278B   JAL xQueueGenericSendFromISR
9D00C500  24070002   ADDIU A3, ZERO, 2
9D00C504  14400006   BNE V0, ZERO, 0x9D00C520
9D00C508  8FA20010   LW V0, 16(SP)
116:                         PLIB_PORTS_Write (PORTS_ID_0, PORT_CHANNEL_E, 0x00FA);
117:                 //        xQueueReset(Q);
118:                     }
119:                     
120:                     /* Switch if needed */
121:                     portEND_SWITCHING_ISR(conSwitch);
9D00C51C  8FA20010   LW V0, 16(SP)
9D00C520  10400006   BEQ V0, ZERO, 0x9D00C53C
9D00C524  8FBF001C   LW RA, 28(SP)
9D00C528  40026800   MFC0 V0, Cause
9D00C52C  34420100   ORI V0, V0, 256
9D00C530  40826800   MTC0 V0, Cause
9D00C534  000000C0   EHB
122:                 }
9D00C538  8FBF001C   LW RA, 28(SP)
9D00C53C  03E00008   JR RA
9D00C540  27BD0020   ADDIU SP, SP, 32
123:                 
124:                 VALUES_t QReceive ()
125:                 {
9D00CF14  27BDFFE0   ADDIU SP, SP, -32
9D00CF18  AFBF001C   SW RA, 28(SP)
9D00CF1C  AFB00018   SW S0, 24(SP)
9D00CF20  00808021   ADDU S0, A0, ZERO
126:                     VALUES_t ret;
127:                     xQueueReceive (Q, &ret, portMAX_DELAY);
9D00CF24  8F8480E0   LW A0, -32544(GP)
9D00CF28  27A50010   ADDIU A1, SP, 16
9D00CF2C  2406FFFF   ADDIU A2, ZERO, -1
9D00CF30  0F40165D   JAL xQueueGenericReceive
9D00CF34  00003821   ADDU A3, ZERO, ZERO
128:                     return ret;
9D00CF38  8FA20010   LW V0, 16(SP)
9D00CF3C  AA020003   SWL V0, 3(S0)
9D00CF40  BA020000   SWR V0, 0(S0)
9D00CF44  97A20014   LHU V0, 20(SP)
9D00CF48  A6020004   SH V0, 4(S0)
129:                 }
9D00CF4C  02001021   ADDU V0, S0, ZERO
9D00CF50  8FBF001C   LW RA, 28(SP)
9D00CF54  8FB00018   LW S0, 24(SP)
9D00CF58  03E00008   JR RA
9D00CF5C  27BD0020   ADDIU SP, SP, 32
130:                 
131:                 int whichOC ()
132:                 {
9D00BBE8  27BDFFE8   ADDIU SP, SP, -24
9D00BBEC  AFBF0014   SW RA, 20(SP)
133:                     if (OCenabled == 0) {
9D00BBF0  8F8280E8   LW V0, -32536(GP)
9D00BBF4  14400007   BNE V0, ZERO, 0x9D00BC14
9D00BBF8  24030001   ADDIU V1, ZERO, 1
134:                         OCenabled = 1;
9D00BBFC  24020001   ADDIU V0, ZERO, 1
9D00BC00  AF8280E8   SW V0, -32536(GP)
135:                         dbgOutputLoc (0xEA);
9D00BC04  0F402A43   JAL dbgOutputLoc
9D00BC08  240400EA   ADDIU A0, ZERO, 234
136:                         return 0;
9D00BC0C  0B402F18   J 0x9D00BC60
9D00BC10  00001021   ADDU V0, ZERO, ZERO
137:                     }
138:                     else if (OCenabled == 1) {
9D00BC14  14430007   BNE V0, V1, 0x9D00BC34
9D00BC18  24030002   ADDIU V1, ZERO, 2
139:                         dbgOutputLoc (0xEB);
9D00BC1C  0F402A43   JAL dbgOutputLoc
9D00BC20  240400EB   ADDIU A0, ZERO, 235
140:                         OCenabled = 2;
9D00BC24  24020002   ADDIU V0, ZERO, 2
9D00BC28  AF8280E8   SW V0, -32536(GP)
141:                         return 1;
9D00BC2C  0B402F18   J 0x9D00BC60
9D00BC30  24020001   ADDIU V0, ZERO, 1
142:                     }
143:                     else if (OCenabled == 2) {
9D00BC34  14430005   BNE V0, V1, 0x9D00BC4C
9D00BC38  24030003   ADDIU V1, ZERO, 3
144:                         OCenabled = 3;
9D00BC3C  24020003   ADDIU V0, ZERO, 3
9D00BC40  AF8280E8   SW V0, -32536(GP)
145:                         return 2;
9D00BC44  0B402F18   J 0x9D00BC60
9D00BC48  24020002   ADDIU V0, ZERO, 2
146:                     }
147:                     else if (OCenabled == 3) {
9D00BC4C  14430003   BNE V0, V1, 0x9D00BC5C
9D00BC50  AF8080E8   SW ZERO, -32536(GP)
148:                         OCenabled = 0;
149:                         return 3;
9D00BC54  0B402F18   J 0x9D00BC60
9D00BC58  24020003   ADDIU V0, ZERO, 3
150:                     }
151:                     OCenabled = 0;
152:                     return 2;
9D00BC5C  24020002   ADDIU V0, ZERO, 2
153:                 }
9D00BC60  8FBF0014   LW RA, 20(SP)
9D00BC64  03E00008   JR RA
9D00BC68  27BD0018   ADDIU SP, SP, 24
154:                 
155:                 
156:                 // *****************************************************************************
157:                 // *****************************************************************************
158:                 // Section: Application Initialization and State Machine Functions
159:                 // *****************************************************************************
160:                 // *****************************************************************************
161:                 
162:                 /*******************************************************************************
163:                   Function:
164:                     void PING_SENSORS_Initialize ( void )
165:                 
166:                   Remarks:
167:                     See prototype in ping_sensors.h.
168:                  */
169:                 
170:                 void PING_SENSORS_Initialize ( void )
171:                 {
9D00C39C  27BDFFE8   ADDIU SP, SP, -24
9D00C3A0  AFBF0014   SW RA, 20(SP)
172:                     /* Place the App state machine in its initial state. */
173:                     ping_sensorsData.state = PING_SENSORS_STATE_INIT;
174:                 
175:                     
176:                     /* TODO: Initialize your application's state machine and other
177:                      * parameters.
178:                      */
179:                     DRV_TMR0_Initialize (); /* Initialize the driver timer */
9D00C3A4  0F40301A   JAL DRV_TMR0_Initialize
9D00C3A8  AF8080E4   SW ZERO, -32540(GP)
180:                     DRV_OC0_Initialize ();
9D00C3AC  0F40316B   JAL DRV_OC0_Initialize
9D00C3B0  00000000   NOP
181:                     DRV_OC1_Initialize ();
9D00C3B4  0F403185   JAL DRV_OC1_Initialize
9D00C3B8  00000000   NOP
182:                     DRV_OC2_Initialize ();
9D00C3BC  0F40319F   JAL DRV_OC2_Initialize
9D00C3C0  00000000   NOP
183:                     DRV_OC3_Initialize ();
9D00C3C4  0F4031B9   JAL DRV_OC3_Initialize
9D00C3C8  00000000   NOP
184:                     Qinit(); /* Initialize the Queue */
9D00C3CC  0F40363E   JAL Qinit
9D00C3D0  00000000   NOP
185:                     OCenabled = 0;
186:                     DRV_TMR0_Start ();
9D00C3D4  0F40352C   JAL DRV_TMR0_Start
9D00C3D8  AF8080E8   SW ZERO, -32536(GP)
187:                     DRV_IC0_Start ();
9D00C3DC  0F4036B4   JAL DRV_IC0_Start
9D00C3E0  00000000   NOP
188:                     DRV_IC1_Start ();
9D00C3E4  0F4036BA   JAL DRV_IC1_Start
9D00C3E8  00000000   NOP
189:                     DRV_IC2_Start ();
9D00C3EC  0F4036C0   JAL DRV_IC2_Start
9D00C3F0  00000000   NOP
190:                     DRV_IC3_Start ();
9D00C3F4  0F4036C6   JAL DRV_IC3_Start
9D00C3F8  00000000   NOP
191:                     
192:                     
193:                     
194:                     bool center = false;
195:                     bool left = false;
196:                     bool right = false;
197:                 }
9D00C3FC  8FBF0014   LW RA, 20(SP)
9D00C400  03E00008   JR RA
9D00C404  27BD0018   ADDIU SP, SP, 24
198:                 
199:                 
200:                 /******************************************************************************
201:                   Function:
202:                     void PING_SENSORS_Tasks ( void )
203:                 
204:                   Remarks:
205:                     See prototype in ping_sensors.h.
206:                  */
207:                 int count = 0;
208:                 int leftAvg = 0;
209:                 int centerAvg = 0;
210:                 int rightAvg = 0;
211:                 int backAvg = 0;
212:                 int count;
213:                 void PING_SENSORS_Tasks ( void )
214:                 {
9D008C80  27BDFFD8   ADDIU SP, SP, -40
9D008C84  AFBF0024   SW RA, 36(SP)
215:                 
216:                     /* Check the application's current state. */
217:                     switch ( ping_sensorsData.state )
9D008C88  8F8280E4   LW V0, -32540(GP)
9D008C8C  10400005   BEQ V0, ZERO, 0x9D008CA4
9D008C90  24030001   ADDIU V1, ZERO, 1
9D008C94  10430006   BEQ V0, V1, 0x9D008CB0
9D008C98  8FBF0024   LW RA, 36(SP)
9D008C9C  0B40236D   J 0x9D008DB4
9D008CA0  00000000   NOP
218:                     {
219:                         /* Application's initial state. */
220:                         case PING_SENSORS_STATE_INIT:
221:                         {
222:                             bool appInitialized = true;
223:                        
224:                         
225:                             if (appInitialized)
226:                             {
227:                             
228:                                 ping_sensorsData.state = PING_SENSORS_STATE_SERVICE_TASKS;
9D008CA4  24020001   ADDIU V0, ZERO, 1
9D008CA8  0B40236C   J 0x9D008DB0
9D008CAC  AF8280E4   SW V0, -32540(GP)
229:                             }
230:                             break;
231:                         }
232:                 
233:                         case PING_SENSORS_STATE_SERVICE_TASKS:
234:                         {
235:                             VALUES_t vals;
236:                             dbgOutputLoc(0x61);
9D008CB0  0F402A43   JAL dbgOutputLoc
9D008CB4  24040061   ADDIU A0, ZERO, 97
237:                             vals = QReceive();
9D008CB8  0F4033C5   JAL QReceive
9D008CBC  27A40010   ADDIU A0, SP, 16
238:                             int diff = vals.val1 - vals.val2;
9D008CC0  97A30012   LHU V1, 18(SP)
9D008CC4  97A20014   LHU V0, 20(SP)
9D008CC8  00621023   SUBU V0, V1, V0
239:                             diff = abs(diff);
9D008CCC  00021FC3   SRA V1, V0, 31
9D008CD0  00621026   XOR V0, V1, V0
9D008CD4  00431023   SUBU V0, V0, V1
240:                             int step = diff * 8;
9D008CD8  000210C0   SLL V0, V0, 3
241:                             int cm = step / 58;
9D008CDC  3C038D3D   LUI V1, -29379
9D008CE0  3463CB09   ORI V1, V1, -13559
9D008CE4  00430018   MULT 0, V0, V1
9D008CE8  00001810   MFHI V1
9D008CEC  00621821   ADDU V1, V1, V0
9D008CF0  00031943   SRA V1, V1, 5
9D008CF4  000217C3   SRA V0, V0, 31
9D008CF8  00621023   SUBU V0, V1, V0
242:                             if (cm < 1000){
9D008CFC  284303E8   SLTI V1, V0, 1000
9D008D00  10600019   BEQ V1, ZERO, 0x9D008D68
9D008D04  93A40010   LBU A0, 16(SP)
243:                                 cm = (cm*3 - 17)/40;
9D008D08  00021840   SLL V1, V0, 1
9D008D0C  00621021   ADDU V0, V1, V0
9D008D10  2442FFEF   ADDIU V0, V0, -17
9D008D14  3C036666   LUI V1, 26214
9D008D18  24636667   ADDIU V1, V1, 26215
9D008D1C  00430018   MULT 0, V0, V1
9D008D20  00001810   MFHI V1
9D008D24  00031903   SRA V1, V1, 4
9D008D28  000217C3   SRA V0, V0, 31
244:                                 if (vals.sensor == 0x00) {
9D008D2C  14800003   BNE A0, ZERO, 0x9D008D3C
9D008D30  00621023   SUBU V0, V1, V0
9D008D34  0B40235A   J 0x9D008D68
9D008D38  AF82804C   SW V0, -32692(GP)
245:                                     leftAvg = cm;
246:                                 }
247:                                 else if (vals.sensor == 0x11) {
9D008D3C  24030011   ADDIU V1, ZERO, 17
9D008D40  14830003   BNE A0, V1, 0x9D008D50
9D008D44  24030022   ADDIU V1, ZERO, 34
9D008D48  0B40235A   J 0x9D008D68
9D008D4C  AF828044   SW V0, -32700(GP)
248:                                     rightAvg = cm;
249:                                 }
250:                                 else if (vals.sensor == 0x22) {
9D008D50  14830003   BNE A0, V1, 0x9D008D60
9D008D54  24030033   ADDIU V1, ZERO, 51
9D008D58  0B40235A   J 0x9D008D68
9D008D5C  AF828048   SW V0, -32696(GP)
251:                                     centerAvg = cm;
252:                                 }
253:                                 else if (vals.sensor == 0x33) {
9D008D60  50830001   BEQL A0, V1, 0x9D008D68
9D008D64  AF828040   SW V0, -32704(GP)
254:                                     backAvg = cm;
255:                                 }
256:                             }
257:                             
258:                             if (count > 3){
9D008D68  8F828050   LW V0, -32688(GP)
9D008D6C  28420004   SLTI V0, V0, 4
9D008D70  1440000D   BNE V0, ZERO, 0x9D008DA8
9D008D74  8F828050   LW V0, -32688(GP)
259:                                 PING_DATA_t new_data;
260:                                 new_data.left = leftAvg;
9D008D78  8F82804C   LW V0, -32692(GP)
9D008D7C  A3A20018   SB V0, 24(SP)
261:                                 new_data.right = rightAvg;
9D008D80  8F828044   LW V0, -32700(GP)
9D008D84  A3A20019   SB V0, 25(SP)
262:                                 new_data.center = centerAvg;
9D008D88  8F828048   LW V0, -32696(GP)
9D008D8C  A3A2001A   SB V0, 26(SP)
263:                                 new_data.back = backAvg;
9D008D90  8F828040   LW V0, -32704(GP)
9D008D94  A3A2001B   SB V0, 27(SP)
264:                                 GRID_QSend(new_data);
9D008D98  0F403612   JAL GRID_QSend
9D008D9C  8FA40018   LW A0, 24(SP)
265:                 //                messageItem_t debug;
266:                 //                debug.msgSize = sprintf(debug.payload, 
267:                 //                        "{\"DEBUG\" : 1 , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u }", 
268:                 //                        //"{\"DEBUG\" : 1 , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u }", 
269:                 //                        "LEFT", leftAvg, 
270:                 //                        "RIGHT", rightAvg, 
271:                 //                        "CENTER", centerAvg, 
272:                 //                        "BACK", backAvg);
273:                 //                SendMessageForTransmitQ(debug);
274:                                 
275:                                 
276:                                 count = 0;
9D008DA0  AF808050   SW ZERO, -32688(GP)
277:                             }
278:                             count++;
9D008DA4  8F828050   LW V0, -32688(GP)
9D008DA8  24420001   ADDIU V0, V0, 1
9D008DAC  AF828050   SW V0, -32688(GP)
279:                             break;
280:                         }
281:                 
282:                         /* TODO: implement your application state machine.*/
283:                         
284:                 
285:                         /* The default state should never be executed. */
286:                         default:
287:                         {
288:                             /* TODO: Handle error in application's state machine. */
289:                             break;
290:                         }
291:                     }
292:                 }
9D008DB0  8FBF0024   LW RA, 36(SP)
9D008DB4  03E00008   JR RA
9D008DB8  27BD0028   ADDIU SP, SP, 40
293:                 
294:                  
295:                 
296:                 /*******************************************************************************
297:                  End of File
298:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/pic_interface.c  ----------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       pic_interface.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "pic_interface.h"
57:                  #include "uart_public.h"
58:                  
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  // Section: Global Data Definitions
62:                  // *****************************************************************************
63:                  // *****************************************************************************
64:                  
65:                  // *****************************************************************************
66:                  /* Application Data
67:                  
68:                    Summary:
69:                      Holds application data
70:                  
71:                    Description:
72:                      This structure holds the application's data.
73:                  
74:                    Remarks:
75:                      This structure should be initialized by the APP_Initialize function.
76:                      
77:                      Application strings and buffers are be defined outside this structure.
78:                  */
79:                  
80:                  PIC_INTERFACE_DATA pic_interfaceData;
81:                  
82:                  DRV_HANDLE Pixy;
83:                  QueueHandle_t PixyByteHandle;//queue handle
84:                  static PIXY_DATA_t currentFrame[10];//current frame of data
85:                  static PROCESSED_PIXY_ITEM_t currentProcessedFrame[10];
86:                  static uint8_t currentProcessedCount;
87:                  static uint8_t currentBlockCount;//count of blocks in current frame
88:                  static uint8_t byteCount = 0;//byte count for current pixy message
89:                  static uint8_t dataArray[16];//current array of bytes for pixy data
90:                  
91:                  #include <math.h>
92:                  //robot status globals TODO MAKE NOT GLOBALS
93:                  uint8_t robot_x = 22;
94:                  uint8_t robot_y = 24;
95:                  int16_t robot_theta = 0;
96:                  
97:                  // *****************************************************************************
98:                  // *****************************************************************************
99:                  // Section: Application Callback Functions
100:                 // *****************************************************************************
101:                 // *****************************************************************************
102:                 
103:                 /* TODO:  Add any necessary callback functions.
104:                 */
105:                 void PixySendByteToQFromISR(PIXY_DATA_t byte);
106:                 void processPixyByte(uint8_t newByte);
107:                 /* TODO:  Add any necessary local functions.
108:                 */
109:                 
110:                 void Pixy_ByteReceive(const SYS_MODULE_INDEX index)
111:                 {
9D00BFEC  27BDFFE0   ADDIU SP, SP, -32
9D00BFF0  AFBF001C   SW RA, 28(SP)
9D00BFF4  AFB20018   SW S2, 24(SP)
9D00BFF8  AFB10014   SW S1, 20(SP)
9D00BFFC  AFB00010   SW S0, 16(SP)
112:                     dbgOutputLoc(DLOC_PIXY_ENTER_ISR);
9D00C000  0F402A43   JAL dbgOutputLoc
9D00C004  24040024   ADDIU A0, ZERO, 36
113:                     while(PLIB_USART_ReceiverDataIsAvailable(USART_ID_2)){
9D00C014  1040000C   BEQ V0, ZERO, 0x9D00C048
9D00C018  3C12BF80   LUI S2, -16512
9D00C040  1440FFF7   BNE V0, ZERO, PLIB_USART_ReceiverByteReceive
9D00C044  00000000   NOP
114:                         uint8_t temp = PLIB_USART_ReceiverByteReceive(USART_ID_2);
115:                         dbgOutputVal(temp);
9D00C028  0F402A13   JAL dbgOutputVal
9D00C02C  02002021   ADDU A0, S0, ZERO
116:                         processPixyByte(temp);
9D00C030  0F4024A0   JAL processPixyByte
9D00C034  02002021   ADDU A0, S0, ZERO
117:                         //PixySendByteToQFromISR(temp);
118:                     }
119:                 //    
120:                     dbgOutputLoc(DLOC_PIXY_EXIT_ISR);
9D00C048  0F402A43   JAL dbgOutputLoc
9D00C04C  24040025   ADDIU A0, ZERO, 37
121:                 }
9D00C050  8FBF001C   LW RA, 28(SP)
9D00C054  8FB20018   LW S2, 24(SP)
9D00C058  8FB10014   LW S1, 20(SP)
9D00C05C  8FB00010   LW S0, 16(SP)
9D00C060  03E00008   JR RA
9D00C064  27BD0020   ADDIU SP, SP, 32
122:                 // *****************************************************************************
123:                 // *****************************************************************************
124:                 // Section: Application Local Functions
125:                 // *****************************************************************************
126:                 // *****************************************************************************
127:                 
128:                 
129:                 /* TODO:  Add any necessary local functions.
130:                 */
131:                 
132:                 
133:                 int PixySendByteToQ(PIXY_DATA_t byte)
134:                 {
00000000  00000000   NOP
135:                     if (xQueueSend(PixyByteHandle, &byte, portMAX_DELAY) == pdTRUE)
00000014  00000000   NOP
136:                         return 1;
137:                     return 0;
138:                 }
0000002C  00000000   NOP
139:                 void PixySendByteToQFromISR(PIXY_DATA_t byte)
140:                 {
9D00CCD8  27BDFFE0   ADDIU SP, SP, -32
9D00CCDC  AFBF001C   SW RA, 28(SP)
9D00CCE0  AFA40020   SW A0, 32(SP)
9D00CCE4  AFA50024   SW A1, 36(SP)
9D00CCE8  AFA60028   SW A2, 40(SP)
141:                     BaseType_t xHigherPriorityTaskWoken, xResult;
142:                     xHigherPriorityTaskWoken = pdFALSE;
9D00CCEC  AFA00010   SW ZERO, 16(SP)
143:                     xResult = xQueueSendFromISR(PixyByteHandle, &byte, &xHigherPriorityTaskWoken);
9D00CCF0  8F8480D4   LW A0, -32556(GP)
9D00CCF4  27A50020   ADDIU A1, SP, 32
9D00CCF8  27A60010   ADDIU A2, SP, 16
9D00CCFC  0F40278B   JAL xQueueGenericSendFromISR
9D00CD00  00003821   ADDU A3, ZERO, ZERO
144:                     /* Actual macro used here is port specific. */
145:                     portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
9D00CD04  8FA20010   LW V0, 16(SP)
9D00CD08  10400006   BEQ V0, ZERO, 0x9D00CD24
9D00CD0C  8FBF001C   LW RA, 28(SP)
9D00CD10  40026800   MFC0 V0, Cause
9D00CD14  34420100   ORI V0, V0, 256
9D00CD18  40826800   MTC0 V0, Cause
9D00CD1C  000000C0   EHB
146:                 }
9D00CD20  8FBF001C   LW RA, 28(SP)
9D00CD24  03E00008   JR RA
9D00CD28  27BD0020   ADDIU SP, SP, 32
147:                 int PixyReceiveByteFromRXQ(PIXY_DATA_t *byte)
148:                 {
9D00D6FC  27BDFFE8   ADDIU SP, SP, -24
9D00D700  AFBF0014   SW RA, 20(SP)
9D00D704  00802821   ADDU A1, A0, ZERO
149:                     if (xQueueReceive(PixyByteHandle, byte, portMAX_DELAY) == pdTRUE)
9D00D708  8F8480D4   LW A0, -32556(GP)
9D00D70C  2406FFFF   ADDIU A2, ZERO, -1
9D00D710  0F40165D   JAL xQueueGenericReceive
9D00D714  00003821   ADDU A3, ZERO, ZERO
9D00D718  38420001   XORI V0, V0, 1
150:                        return 1;
151:                    return 0;
152:                 }
9D00D71C  2C420001   SLTIU V0, V0, 1
9D00D720  8FBF0014   LW RA, 20(SP)
9D00D724  03E00008   JR RA
9D00D728  27BD0018   ADDIU SP, SP, 24
153:                 
154:                 void processPixyMessage(uint8_t array[], uint8_t byteCount)
155:                 {
9D00D1A8  27BDFFD8   ADDIU SP, SP, -40
9D00D1AC  AFBF0024   SW RA, 36(SP)
156:                     PIXY_DATA_t ReceivedBlock;
157:                     ReceivedBlock.ID = *((uint16_t*)&array[4]);
9D00D1B0  94860004   LHU A2, 4(A0)
158:                     ReceivedBlock.x_center = *((uint16_t*)&array[6]);
9D00D1B4  94820006   LHU V0, 6(A0)
9D00D1B8  A7A20010   SH V0, 16(SP)
159:                     ReceivedBlock.y_center = *((uint16_t*)&array[8]);
9D00D1BC  94820008   LHU V0, 8(A0)
9D00D1C0  A7A20012   SH V0, 18(SP)
160:                     ReceivedBlock.width = *((uint16_t*)&array[10]);
9D00D1C4  9482000A   LHU V0, 10(A0)
9D00D1C8  A7A20014   SH V0, 20(SP)
161:                     ReceivedBlock.height = *((uint16_t*)&array[12]);
9D00D1CC  9482000C   LHU V0, 12(A0)
9D00D1D0  A7A20016   SH V0, 22(SP)
162:                     PixySendByteToQFromISR(ReceivedBlock);
9D00D1D4  8FA40010   LW A0, 16(SP)
9D00D1D8  0F403336   JAL PixySendByteToQFromISR
9D00D1DC  8FA50014   LW A1, 20(SP)
163:                     //send to queue
164:                 }
9D00D1E0  8FBF0024   LW RA, 36(SP)
9D00D1E4  03E00008   JR RA
9D00D1E8  27BD0028   ADDIU SP, SP, 40
165:                 
166:                 
167:                 void processPixyByte(uint8_t newByte)
168:                 {
9D009280  27BDFFD8   ADDIU SP, SP, -40
9D009284  AFBF0024   SW RA, 36(SP)
169:                     if(byteCount == 0 && !(newByte == 0x55 || newByte == 0x56)){// || newByte == 0x00)){
9D009288  9382803C   LBU V0, -32708(GP)
9D00928C  14400008   BNE V0, ZERO, 0x9D0092B0
9D009290  308400FF   ANDI A0, A0, 255
9D009294  2483FFAB   ADDIU V1, A0, -85
9D009298  306300FF   ANDI V1, V1, 255
9D00929C  2C630002   SLTIU V1, V1, 2
9D0092A0  1060003F   BEQ V1, ZERO, 0x9D0093A0
9D0092A4  8FBF0024   LW RA, 36(SP)
9D0092A8  0B4024E1   J 0x9D009384
9D0092AC  3C03A001   LUI V1, -24575
170:                         return;
171:                     }
172:                     if(byteCount == 1 && newByte == 0x00){
9D0092B0  24030001   ADDIU V1, ZERO, 1
9D0092B4  1443000D   BNE V0, V1, 0x9D0092EC
9D0092B8  3C03A001   LUI V1, -24575
9D0092BC  14800007   BNE A0, ZERO, 0x9D0092DC
9D0092C0  240200AA   ADDIU V0, ZERO, 170
173:                         PIXY_DATA_t ReceivedBlock;
174:                         ReceivedBlock.ID = 0;
175:                         PixySendByteToQFromISR(ReceivedBlock);
9D0092C4  8FA40010   LW A0, 16(SP)
9D0092C8  8FA50014   LW A1, 20(SP)
9D0092CC  0F403336   JAL PixySendByteToQFromISR
9D0092D0  00003021   ADDU A2, ZERO, ZERO
176:                         byteCount = 0;
9D0092D4  0B4024E7   J 0x9D00939C
9D0092D8  A380803C   SB ZERO, -32708(GP)
177:                         return;
178:                     }
179:                     if(byteCount == 1 && newByte != 0xAA){
9D0092DC  10820024   BEQ A0, V0, 0x9D009370
9D0092E0  2403FFAA   ADDIU V1, ZERO, -86
180:                         byteCount = 0;
181:                         return;
9D0092E4  0B4024E7   J 0x9D00939C
9D0092E8  A380803C   SB ZERO, -32708(GP)
182:                     }
183:                     dataArray[byteCount] = newByte;
9D0092EC  246354E8   ADDIU V1, V1, 21736
9D0092F0  00431821   ADDU V1, V0, V1
9D0092F4  A0640000   SB A0, 0(V1)
9D009370  3C02A001   LUI V0, -24575
9D009374  A04354E9   SB V1, 21737(V0)
9D009384  246354E8   ADDIU V1, V1, 21736
9D009388  00431821   ADDU V1, V0, V1
9D00938C  A0640000   SB A0, 0(V1)
184:                     byteCount++;
9D0092F8  24420001   ADDIU V0, V0, 1
9D0092FC  304200FF   ANDI V0, V0, 255
9D009378  24020002   ADDIU V0, ZERO, 2
9D00937C  0B4024E7   J 0x9D00939C
9D009380  A382803C   SB V0, -32708(GP)
9D009390  24420001   ADDIU V0, V0, 1
9D009394  0B4024D4   J 0x9D009350
9D009398  A382803C   SB V0, -32708(GP)
185:                     if(byteCount == 4 && (dataArray[2] == 0x55 || dataArray[2] == 0x56) && dataArray[3] == 0xAA){
9D009300  24030004   ADDIU V1, ZERO, 4
9D009304  14430012   BNE V0, V1, 0x9D009350
9D009308  A382803C   SB V0, -32708(GP)
9D00930C  3C02A001   LUI V0, -24575
9D009310  904254EA   LBU V0, 21738(V0)
9D009314  2442FFAB   ADDIU V0, V0, -85
9D009318  304200FF   ANDI V0, V0, 255
9D00931C  2C420002   SLTIU V0, V0, 2
9D009320  1040001F   BEQ V0, ZERO, 0x9D0093A0
9D009324  8FBF0024   LW RA, 36(SP)
9D009328  3C02A001   LUI V0, -24575
9D00932C  904354EB   LBU V1, 21739(V0)
9D009330  240200AA   ADDIU V0, ZERO, 170
9D009334  1462001A   BNE V1, V0, 0x9D0093A0
9D009338  8FA40010   LW A0, 16(SP)
186:                         PIXY_DATA_t ReceivedBlock;
187:                         ReceivedBlock.ID = 0;
188:                         PixySendByteToQFromISR(ReceivedBlock);
9D00933C  8FA50014   LW A1, 20(SP)
9D009340  0F403336   JAL PixySendByteToQFromISR
9D009344  00003021   ADDU A2, ZERO, ZERO
189:                         byteCount = 2;
9D009348  24020002   ADDIU V0, ZERO, 2
9D00934C  A382803C   SB V0, -32708(GP)
190:                     }
191:                     if(byteCount > 13){
9D009350  9385803C   LBU A1, -32708(GP)
9D009354  2CA2000E   SLTIU V0, A1, 14
9D009358  14400010   BNE V0, ZERO, 0x9D00939C
9D00935C  3C04A001   LUI A0, -24575
192:                         processPixyMessage(dataArray, byteCount);
9D009360  0F40346A   JAL processPixyMessage
9D009364  248454E8   ADDIU A0, A0, 21736
193:                         byteCount = 0;
9D009368  0B4024E7   J 0x9D00939C
9D00936C  A380803C   SB ZERO, -32708(GP)
194:                     }
195:                 }
9D00939C  8FBF0024   LW RA, 36(SP)
9D0093A0  03E00008   JR RA
9D0093A4  27BD0028   ADDIU SP, SP, 40
196:                 
197:                 #define X1 ((float)blockArray[i].x_center)
198:                 #define X2 ((float)blockArray[j].x_center)
199:                 #define Y1 ((float)blockArray[i].y_center)
200:                 #define Y2 ((float)blockArray[j].y_center)
201:                 #define THETA1 ((float)blockArray[i].theta)
202:                 #define THETA2 ((float)blockArray[j].theta)
203:                 #define RAD_TO_DEG(x) ((180.0/M_PI)*x)
204:                 #define DEG_TO_RAD(x) ((M_PI/180.0)*x)
205:                 bool stop = false;
206:                 void processBlocks(PROCESSED_PIXY_ITEM_t blockArray[], uint8_t numBlocks)
207:                 {
9D002F3C  27BDFB68   ADDIU SP, SP, -1176
9D002F40  AFBF0494   SW RA, 1172(SP)
9D002F44  AFBE0490   SW S8, 1168(SP)
9D002F48  AFB7048C   SW S7, 1164(SP)
9D002F4C  AFB60488   SW S6, 1160(SP)
9D002F50  AFB50484   SW S5, 1156(SP)
9D002F54  AFB40480   SW S4, 1152(SP)
9D002F58  AFB3047C   SW S3, 1148(SP)
9D002F5C  AFB20478   SW S2, 1144(SP)
9D002F60  AFB10474   SW S1, 1140(SP)
9D002F64  AFB00470   SW S0, 1136(SP)
9D002F68  30A500FF   ANDI A1, A1, 255
9D002F6C  AFA50454   SW A1, 1108(SP)
208:                   int i, j;
209:                   // if there's a target
210:                   float tan_1, tan_2, m, new_x, new_y;
211:                   float update_theta, update_x, update_y;
212:                   float theta_1, theta_2, theta_1_rad, theta_2_rad;
213:                   uint8_t theta_count, coord_count;
214:                   theta_count = 0;
215:                   coord_count = 0;
9D002FA4  AFA00404   SW ZERO, 1028(SP)
216:                   update_theta = 0;
9D002FB0  AFB60458   SW S6, 1112(SP)
217:                   update_x = 0;
9D002FAC  02C0B821   ADDU S7, S6, ZERO
218:                   update_y = 0;
9D002FA8  0000B021   ADDU S6, ZERO, ZERO
219:                   uint8_t debug_x1, debug_y1, debug_x2, debug_y2;
220:                   for(i = 0; i < numBlocks; i++){
9D002FB4  AFA00450   SW ZERO, 1104(SP)
9D002FDC  0B400CA1   J 0x9D003284
9D002FE0  AFA20438   SW V0, 1080(SP)
9D003284  8FA40454   LW A0, 1108(SP)
9D003288  8FA50450   LW A1, 1104(SP)
9D00328C  00A4102A   SLT V0, A1, A0
9D003290  1440FF54   BNE V0, ZERO, 0x9D002FE4
9D003294  8FA2044C   LW V0, 1100(SP)
221:                     float delt_y = (Y1 - robot_y);
9D002F70  93828010   LBU V0, -32752(GP)
9D002F74  AFA2045C   SW V0, 1116(SP)
9D002FE4  94530006   LHU S3, 6(V0)
9D002FE8  0F4033EB   JAL __floatunsisf
9D002FEC  02602021   ADDU A0, S3, ZERO
9D002FF0  0040A821   ADDU S5, V0, ZERO
9D003008  0F403283   JAL __floatsisf
9D00300C  8FA4045C   LW A0, 1116(SP)
9D003010  02A02021   ADDU A0, S5, ZERO
9D003014  0F401523   JAL fpsub
9D003018  00402821   ADDU A1, V0, ZERO
9D00301C  00408021   ADDU S0, V0, ZERO
222:                     float delt_x = (X1 - robot_x);
9D002F78  93838011   LBU V1, -32751(GP)
9D002F7C  AFA30460   SW V1, 1120(SP)
9D002FF4  8FA3044C   LW V1, 1100(SP)
9D002FF8  94720004   LHU S2, 4(V1)
9D002FFC  0F4033EB   JAL __floatunsisf
9D003000  02402021   ADDU A0, S2, ZERO
9D003004  AFA20400   SW V0, 1024(SP)
9D003020  0F403283   JAL __floatsisf
9D003024  8FA40460   LW A0, 1120(SP)
9D003028  8FA40400   LW A0, 1024(SP)
9D00302C  0F401523   JAL fpsub
9D003030  00402821   ADDU A1, V0, ZERO
223:                     float theta_robot = RAD_TO_DEG(atan(delt_y/delt_x)) - THETA1;
9D002FB8  3C029D00   LUI V0, -25344
9D002FBC  8C426A54   LW V0, 27220(V0)
9D002FC0  AFA20464   SW V0, 1124(SP)
9D003034  02002021   ADDU A0, S0, ZERO
9D003038  0F401780   JAL __divsf3
9D00303C  00402821   ADDU A1, V0, ZERO
9D003040  0F402C81   JAL 0x9D00B204
9D003044  00402021   ADDU A0, V0, ZERO
9D003048  00408021   ADDU S0, V0, ZERO
9D00304C  8FA5044C   LW A1, 1100(SP)
9D003050  0F403283   JAL __floatsisf
9D003054  84A40008   LH A0, 8(A1)
9D003058  AFA20420   SW V0, 1056(SP)
9D00305C  02002021   ADDU A0, S0, ZERO
9D003060  0F401B08   JAL fpmul
9D003064  8FA50464   LW A1, 1124(SP)
9D003068  00402021   ADDU A0, V0, ZERO
9D00306C  0F401523   JAL fpsub
9D003070  8FA50420   LW A1, 1056(SP)
224:                     update_theta += theta_robot;
9D003074  8FA40458   LW A0, 1112(SP)
9D003078  0F401525   JAL fpadd
9D00307C  00402821   ADDU A1, V0, ZERO
9D003080  AFA20458   SW V0, 1112(SP)
225:                     theta_count++;
226:                     for(j = i+1; j < numBlocks; j++){
9D003084  8FA20450   LW V0, 1104(SP)
9D003088  24420001   ADDIU V0, V0, 1
9D00308C  AFA20450   SW V0, 1104(SP)
9D003090  8FA30454   LW V1, 1108(SP)
9D003094  0043102A   SLT V0, V0, V1
9D003098  10400074   BEQ V0, ZERO, 0x9D00326C
9D00309C  8FA4044C   LW A0, 1100(SP)
9D00325C  8FA50418   LW A1, 1048(SP)
9D003260  14B1FF98   BNE A1, S1, 0x9D0030C4
9D003264  2610000C   ADDIU S0, S0, 12
9D003268  0040B021   ADDU S6, V0, ZERO
9D00326C  8FA2044C   LW V0, 1100(SP)
9D003270  2442000C   ADDIU V0, V0, 12
9D003274  AFA2044C   SW V0, 1100(SP)
9D003278  8FA30418   LW V1, 1048(SP)
9D00327C  2463FFF4   ADDIU V1, V1, -12
9D003280  AFA30418   SW V1, 1048(SP)
227:                         if(blockArray[i].ID == blockArray[j].ID){
9D0030A0  8C840000   LW A0, 0(A0)
9D0030A4  AFA4041C   SW A0, 1052(SP)
9D0030A8  8FB0044C   LW S0, 1100(SP)
9D0030AC  00008821   ADDU S1, ZERO, ZERO
9D0030C4  8E03000C   LW V1, 12(S0)
9D0030C8  8FA5041C   LW A1, 1052(SP)
9D0030CC  50A30063   BEQL A1, V1, 0x9D00325C
9D0030D0  2631000C   ADDIU S1, S1, 12
228:                             continue;
229:                         }
230:                         theta_1 = THETA1 + robot_theta;
9D002F80  8785803A   LH A1, -32710(GP)
9D002F84  AFA5042C   SW A1, 1068(SP)
9D002F88  AFA4044C   SW A0, 1100(SP)
9D002F8C  8FA30454   LW V1, 1108(SP)
9D002F90  00031080   SLL V0, V1, 2
9D002F94  00031900   SLL V1, V1, 4
9D002F98  00621023   SUBU V0, V1, V0
9D002F9C  2442FFF4   ADDIU V0, V0, -12
9D002FA0  AFA20418   SW V0, 1048(SP)
9D0030D4  0F403283   JAL __floatsisf
9D0030D8  8FA4042C   LW A0, 1068(SP)
9D0030DC  00409021   ADDU S2, V0, ZERO
9D0030E0  8FA40420   LW A0, 1056(SP)
9D0030E4  0F401525   JAL fpadd
9D0030E8  00402821   ADDU A1, V0, ZERO
9D0030EC  AFA20408   SW V0, 1032(SP)
231:                         theta_1_rad = DEG_TO_RAD(theta_1);
9D002FC4  3C029D00   LUI V0, -25344
9D002FC8  8C456A58   LW A1, 27224(V0)
9D002FCC  AFA50430   SW A1, 1072(SP)
9D0030F0  00402021   ADDU A0, V0, ZERO
9D0030F4  0F401B08   JAL fpmul
9D0030F8  8FA50430   LW A1, 1072(SP)
9D0030FC  AFA20410   SW V0, 1040(SP)
232:                         theta_2 = THETA2 + robot_theta;
9D003100  0F403283   JAL __floatsisf
9D003104  86040014   LH A0, 20(S0)
9D003108  02402021   ADDU A0, S2, ZERO
9D00310C  0F401525   JAL fpadd
9D003110  00402821   ADDU A1, V0, ZERO
9D003114  AFA2040C   SW V0, 1036(SP)
233:                         theta_2_rad = DEG_TO_RAD(theta_2);
9D002FD0  AFA50434   SW A1, 1076(SP)
9D003118  00402021   ADDU A0, V0, ZERO
9D00311C  0F401B08   JAL fpmul
9D003120  8FA50434   LW A1, 1076(SP)
9D003124  AFA20414   SW V0, 1044(SP)
234:                         debug_x1 = X1;
9D0030B0  325200FF   ANDI S2, S2, 255
9D0030B4  AFB20424   SW S2, 1060(SP)
9D003128  8FA20424   LW V0, 1060(SP)
9D00312C  AFA2043C   SW V0, 1084(SP)
235:                         debug_y1 = Y1;
9D0030B8  327300FF   ANDI S3, S3, 255
9D0030BC  AFB30428   SW S3, 1064(SP)
9D0030C0  02C01021   ADDU V0, S6, ZERO
9D003130  8FA30428   LW V1, 1064(SP)
9D003134  AFA30440   SW V1, 1088(SP)
236:                         debug_x2 = X2;
9D003138  96130010   LHU S3, 16(S0)
9D00313C  326400FF   ANDI A0, S3, 255
9D003140  AFA40444   SW A0, 1092(SP)
237:                         debug_y2 = Y2;
9D003144  96120012   LHU S2, 18(S0)
9D003148  324500FF   ANDI A1, S2, 255
9D00314C  AFA50448   SW A1, 1096(SP)
238:                       tan_1 = tan(theta_1_rad);
9D003150  0F401E72   JAL 0x9D0079C8
9D003154  8FA40410   LW A0, 1040(SP)
9D003158  0040A021   ADDU S4, V0, ZERO
239:                       tan_2 = tan(theta_2_rad);
9D00315C  0F401E72   JAL 0x9D0079C8
9D003160  8FA40414   LW A0, 1044(SP)
9D003164  0040F021   ADDU S8, V0, ZERO
240:                       float x_r = ((Y1 - Y2) - (X1*tan_1 - X2*tan_2))/(tan_2 - tan_1);
9D003168  0F4033EB   JAL __floatunsisf
9D00316C  02402021   ADDU A0, S2, ZERO
9D003170  00409021   ADDU S2, V0, ZERO
9D003174  0F4033EB   JAL __floatunsisf
9D003178  02602021   ADDU A0, S3, ZERO
9D00317C  00409821   ADDU S3, V0, ZERO
9D003180  02A02021   ADDU A0, S5, ZERO
9D003184  0F401523   JAL fpsub
9D003188  02402821   ADDU A1, S2, ZERO
9D00318C  0040B021   ADDU S6, V0, ZERO
9D003190  8FA40400   LW A0, 1024(SP)
9D003194  0F401B08   JAL fpmul
9D003198  02802821   ADDU A1, S4, ZERO
9D00319C  0040B821   ADDU S7, V0, ZERO
9D0031A0  02602021   ADDU A0, S3, ZERO
9D0031A4  0F401B08   JAL fpmul
9D0031A8  03C02821   ADDU A1, S8, ZERO
9D0031AC  02E02021   ADDU A0, S7, ZERO
9D0031B0  0F401523   JAL fpsub
9D0031B4  00402821   ADDU A1, V0, ZERO
9D0031B8  02C02021   ADDU A0, S6, ZERO
9D0031BC  0F401523   JAL fpsub
9D0031C0  00402821   ADDU A1, V0, ZERO
9D0031C4  0040B021   ADDU S6, V0, ZERO
9D0031C8  03C02021   ADDU A0, S8, ZERO
9D0031CC  0F401523   JAL fpsub
9D0031D0  02802821   ADDU A1, S4, ZERO
9D0031D4  02C02021   ADDU A0, S6, ZERO
9D0031D8  0F401780   JAL __divsf3
9D0031DC  00402821   ADDU A1, V0, ZERO
9D0031E0  0040B821   ADDU S7, V0, ZERO
241:                       float y_r1 = Y1 - (X1 - x_r)*tan_1;
9D0031E4  8FA40400   LW A0, 1024(SP)
9D0031E8  0F401523   JAL fpsub
9D0031EC  00402821   ADDU A1, V0, ZERO
9D0031F0  00402021   ADDU A0, V0, ZERO
9D0031F4  0F401B08   JAL fpmul
9D0031F8  02802821   ADDU A1, S4, ZERO
9D0031FC  02A02021   ADDU A0, S5, ZERO
9D003200  0F401523   JAL fpsub
9D003204  00402821   ADDU A1, V0, ZERO
9D003208  0040B021   ADDU S6, V0, ZERO
242:                       float y_r2 = Y2 - (X2 - x_r)*tan_2;
9D00320C  02602021   ADDU A0, S3, ZERO
9D003210  0F401523   JAL fpsub
9D003214  02E02821   ADDU A1, S7, ZERO
9D003218  00402021   ADDU A0, V0, ZERO
9D00321C  0F401B08   JAL fpmul
9D003220  03C02821   ADDU A1, S8, ZERO
9D003224  02402021   ADDU A0, S2, ZERO
9D003228  0F401523   JAL fpsub
9D00322C  00402821   ADDU A1, V0, ZERO
243:                 //      update_x += x_r;
244:                 //      update_y += (y_r1 + y_r2)/2;
245:                       update_x = x_r;
246:                       update_y = (y_r1 + y_r2)/2;
9D002FD4  3C029D00   LUI V0, -25344
9D002FD8  8C426A5C   LW V0, 27228(V0)
9D003230  02C02021   ADDU A0, S6, ZERO
9D003234  0F401525   JAL fpadd
9D003238  00402821   ADDU A1, V0, ZERO
9D00323C  00402021   ADDU A0, V0, ZERO
9D003240  0F401B08   JAL fpmul
9D003244  8FA50438   LW A1, 1080(SP)
247:                       coord_count++;
9D003248  8FA40404   LW A0, 1028(SP)
9D00324C  24830001   ADDIU V1, A0, 1
9D003250  306300FF   ANDI V1, V1, 255
9D003254  AFA30404   SW V1, 1028(SP)
9D003258  2631000C   ADDIU S1, S1, 12
248:                     }
249:                   }
250:                   uint8_t temp_robot_x, temp_robot_y;
251:                   int16_t temp_robot_theta;
252:                   if(theta_count > 0){
9D003298  50800021   BEQL A0, ZERO, 0x9D003320
9D00329C  8FA40404   LW A0, 1028(SP)
253:                     update_theta /= theta_count;
9D0032A0  0F403283   JAL __floatsisf
9D0032A4  00000000   NOP
9D0032A8  8FA40458   LW A0, 1112(SP)
9D0032AC  0F401780   JAL __divsf3
9D0032B0  00402821   ADDU A1, V0, ZERO
9D0032B4  00408021   ADDU S0, V0, ZERO
254:                     temp_robot_theta = ROUND(update_theta);
9D0032B8  0F402B2E   JAL fpfloor
9D0032BC  00402021   ADDU A0, V0, ZERO
9D0032C0  00408821   ADDU S1, V0, ZERO
9D0032C4  00402021   ADDU A0, V0, ZERO
9D0032C8  3C029D00   LUI V0, -25344
9D0032CC  0F401525   JAL fpadd
9D0032D0  8C456A5C   LW A1, 27228(V0)
9D0032D4  00402021   ADDU A0, V0, ZERO
9D0032D8  0F402CA9   JAL __ltsf2
9D0032DC  02002821   ADDU A1, S0, ZERO
9D0032E0  04410008   BGEZ V0, 0x9D003304
9D0032E4  00000000   NOP
9D0032E8  0F402B5B   JAL fpceil
9D0032EC  02002021   ADDU A0, S0, ZERO
9D0032F0  0F402F9D   JAL __fixsfsi
9D0032F4  00402021   ADDU A0, V0, ZERO
9D0032F8  7C021620   SEH V0, V0
9D0032FC  0B400CC5   J 0x9D003314
9D003300  AFA20468   SW V0, 1128(SP)
9D003304  0F402F9D   JAL __fixsfsi
9D003308  02202021   ADDU A0, S1, ZERO
9D00330C  7C021620   SEH V0, V0
9D003310  AFA20468   SW V0, 1128(SP)
255:                     robot_theta = temp_robot_theta;
9D003314  8FA30468   LW V1, 1128(SP)
9D003318  A783803A   SH V1, -32710(GP)
256:                     //TODO SEND LOCATION UPDATE
257:                   }
258:                   if(coord_count > 0){
9D00331C  8FA40404   LW A0, 1028(SP)
9D003320  1080008C   BEQ A0, ZERO, 0x9D003554
9D003324  8FBF0494   LW RA, 1172(SP)
259:                     messageItem_t debug;
260:                     //update_x /= coord_count;
261:                     //update_y /= coord_count;
262:                     temp_robot_x = ROUND(update_x);
9D003328  0F402B2E   JAL fpfloor
9D00332C  02E02021   ADDU A0, S7, ZERO
9D003330  00408021   ADDU S0, V0, ZERO
9D003334  00402021   ADDU A0, V0, ZERO
9D003338  3C029D00   LUI V0, -25344
9D00333C  0F401525   JAL fpadd
9D003340  8C456A5C   LW A1, 27228(V0)
9D003344  00402021   ADDU A0, V0, ZERO
9D003348  0F402CA9   JAL __ltsf2
9D00334C  02E02821   ADDU A1, S7, ZERO
9D003350  04410007   BGEZ V0, 0x9D003370
9D003354  00000000   NOP
9D003358  0F402B5B   JAL fpceil
9D00335C  02E02021   ADDU A0, S7, ZERO
9D003360  0F403039   JAL __fixunssfsi
9D003364  00402021   ADDU A0, V0, ZERO
9D003368  0B400CDF   J 0x9D00337C
9D00336C  305100FF   ANDI S1, V0, 255
9D003370  0F403039   JAL __fixunssfsi
9D003374  02002021   ADDU A0, S0, ZERO
9D003378  305100FF   ANDI S1, V0, 255
263:                     temp_robot_y = ROUND(update_y);
9D00337C  0F402B2E   JAL fpfloor
9D003380  02C02021   ADDU A0, S6, ZERO
9D003384  00408021   ADDU S0, V0, ZERO
9D003388  00402021   ADDU A0, V0, ZERO
9D00338C  3C029D00   LUI V0, -25344
9D003390  0F401525   JAL fpadd
9D003394  8C456A5C   LW A1, 27228(V0)
9D003398  00402021   ADDU A0, V0, ZERO
9D00339C  0F402CA9   JAL __ltsf2
9D0033A0  02C02821   ADDU A1, S6, ZERO
9D0033A4  04410007   BGEZ V0, 0x9D0033C4
9D0033A8  00000000   NOP
9D0033AC  0F402B5B   JAL fpceil
9D0033B0  02C02021   ADDU A0, S6, ZERO
9D0033B4  0F403039   JAL __fixunssfsi
9D0033B8  00402021   ADDU A0, V0, ZERO
9D0033BC  0B400CF4   J 0x9D0033D0
9D0033C0  305000FF   ANDI S0, V0, 255
9D0033C4  0F403039   JAL __fixunssfsi
9D0033C8  02002021   ADDU A0, S0, ZERO
9D0033CC  305000FF   ANDI S0, V0, 255
264:                     debug.msgSize = sprintf(debug.payload, 
9D0033D0  3C029D00   LUI V0, -25344
9D0033D4  24426930   ADDIU V0, V0, 26928
9D0033D8  AFA20010   SW V0, 16(SP)
9D0033DC  AFB00014   SW S0, 20(SP)
9D0033E0  3C029D00   LUI V0, -25344
9D0033E4  2442693C   ADDIU V0, V0, 26940
9D0033E8  AFA20018   SW V0, 24(SP)
9D0033EC  8FA50468   LW A1, 1128(SP)
9D0033F0  AFA5001C   SW A1, 28(SP)
9D0033F4  3C029D00   LUI V0, -25344
9D0033F8  24426944   ADDIU V0, V0, 26948
9D0033FC  AFA20020   SW V0, 32(SP)
9D003400  8FA20408   LW V0, 1032(SP)
9D003404  AFA20024   SW V0, 36(SP)
9D003408  3C029D00   LUI V0, -25344
9D00340C  2442694C   ADDIU V0, V0, 26956
9D003410  AFA20028   SW V0, 40(SP)
9D003414  8FA30410   LW V1, 1040(SP)
9D003418  AFA3002C   SW V1, 44(SP)
9D00341C  3C029D00   LUI V0, -25344
9D003420  24426958   ADDIU V0, V0, 26968
9D003424  AFA20030   SW V0, 48(SP)
9D003428  AFB40034   SW S4, 52(SP)
9D00342C  3C029D00   LUI V0, -25344
9D003430  24426960   ADDIU V0, V0, 26976
9D003434  AFA20038   SW V0, 56(SP)
9D003438  8FA4043C   LW A0, 1084(SP)
9D00343C  AFA4003C   SW A0, 60(SP)
9D003440  3C029D00   LUI V0, -25344
9D003444  24426964   ADDIU V0, V0, 26980
9D003448  AFA20040   SW V0, 64(SP)
9D00344C  8FA50440   LW A1, 1088(SP)
9D003450  AFA50044   SW A1, 68(SP)
9D003454  3C029D00   LUI V0, -25344
9D003458  24426968   ADDIU V0, V0, 26984
9D00345C  AFA20048   SW V0, 72(SP)
9D003460  8FA2040C   LW V0, 1036(SP)
9D003464  AFA2004C   SW V0, 76(SP)
9D003468  3C029D00   LUI V0, -25344
9D00346C  24426970   ADDIU V0, V0, 26992
9D003470  AFA20050   SW V0, 80(SP)
9D003474  8FA30414   LW V1, 1044(SP)
9D003478  AFA30054   SW V1, 84(SP)
9D00347C  3C029D00   LUI V0, -25344
9D003480  2442697C   ADDIU V0, V0, 27004
9D003484  AFA20058   SW V0, 88(SP)
9D003488  AFBE005C   SW S8, 92(SP)
9D00348C  3C029D00   LUI V0, -25344
9D003490  24426984   ADDIU V0, V0, 27012
9D003494  AFA20060   SW V0, 96(SP)
9D003498  8FA40444   LW A0, 1092(SP)
9D00349C  AFA40064   SW A0, 100(SP)
9D0034A0  3C029D00   LUI V0, -25344
9D0034A4  24426988   ADDIU V0, V0, 27016
9D0034A8  AFA20068   SW V0, 104(SP)
9D0034AC  8FA50448   LW A1, 1096(SP)
9D0034B0  AFA5006C   SW A1, 108(SP)
9D0034B4  27A40200   ADDIU A0, SP, 512
9D0034B8  3C059D00   LUI A1, -25344
9D0034BC  24A56870   ADDIU A1, A1, 26736
9D0034C0  3C069D00   LUI A2, -25344
9D0034C4  24C66924   ADDIU A2, A2, 26916
9D0034C8  0F4031ED   JAL _sprintf_cdfFnopsuxX
9D0034CC  02203821   ADDU A3, S1, ZERO
9D0034D0  AFA203F4   SW V0, 1012(SP)
265:                             "{\"DEBUG\" : 1 , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %i , \"%s\" : %f , \"%s\" : %f , \"%s\" : %f  , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %f , \"%s\" : %f , \"%s\" : %f  , \"%s\" : %u, \"%s\" : %u  }",
266:                             "X_LOCATION", temp_robot_x,
267:                             "Y_LOCATION", temp_robot_y,
268:                             "ANGLE", temp_robot_theta,
269:                             "THETA_1", theta_1,
270:                             "THETA_1_RAD", theta_1_rad,
271:                             "TAN_1", tan_1,
272:                             "X_1", debug_x1,
273:                             "Y_1", debug_y1,
274:                             "THETA_2", theta_2,
275:                             "THETA_2_RAD", theta_2_rad,
276:                             "TAN_2", tan_2,
277:                             "X_2", debug_x2,
278:                             "Y_2", debug_y2
279:                             );
280:                     if(!stop)
9D0034D4  93828038   LBU V0, -32712(GP)
9D0034D8  14400019   BNE V0, ZERO, 0x9D003540
9D0034DC  27A20210   ADDIU V0, SP, 528
281:                         SendMessageForTransmitQ(debug);
9D0034E0  27A30010   ADDIU V1, SP, 16
9D0034E4  27A403F0   ADDIU A0, SP, 1008
9D0034E8  8C480000   LW T0, 0(V0)
9D0034EC  8C470004   LW A3, 4(V0)
9D0034F0  8C460008   LW A2, 8(V0)
9D0034F4  8C45000C   LW A1, 12(V0)
9D0034F8  AC680000   SW T0, 0(V1)
9D0034FC  AC670004   SW A3, 4(V1)
9D003500  AC660008   SW A2, 8(V1)
9D003504  AC65000C   SW A1, 12(V1)
9D003508  24420010   ADDIU V0, V0, 16
9D00350C  1444FFF6   BNE V0, A0, 0x9D0034E8
9D003510  24630010   ADDIU V1, V1, 16
9D003514  8C450000   LW A1, 0(V0)
9D003518  8C440004   LW A0, 4(V0)
9D00351C  8C420008   LW V0, 8(V0)
9D003520  AC650000   SW A1, 0(V1)
9D003524  AC640004   SW A0, 4(V1)
9D003528  AC620008   SW V0, 8(V1)
9D00352C  8FA40200   LW A0, 512(SP)
9D003530  8FA50204   LW A1, 516(SP)
9D003534  8FA60208   LW A2, 520(SP)
9D003538  0F4034BF   JAL SendMessageForTransmitQ
9D00353C  8FA7020C   LW A3, 524(SP)
282:                     if(temp_robot_y == 0){
9D003540  16000004   BNE S0, ZERO, 0x9D003554
9D003544  8FBF0494   LW RA, 1172(SP)
283:                         stop = true;
9D003548  24020001   ADDIU V0, ZERO, 1
9D00354C  A3828038   SB V0, -32712(GP)
284:                     }
285:                   }
286:                   
287:                 }
9D003550  8FBF0494   LW RA, 1172(SP)
9D003554  8FBE0490   LW S8, 1168(SP)
9D003558  8FB7048C   LW S7, 1164(SP)
9D00355C  8FB60488   LW S6, 1160(SP)
9D003560  8FB50484   LW S5, 1156(SP)
9D003564  8FB40480   LW S4, 1152(SP)
9D003568  8FB3047C   LW S3, 1148(SP)
9D00356C  8FB20478   LW S2, 1144(SP)
9D003570  8FB10474   LW S1, 1140(SP)
9D003574  8FB00470   LW S0, 1136(SP)
9D003578  03E00008   JR RA
9D00357C  27BD0498   ADDIU SP, SP, 1176
288:                 
289:                 void processFrame()
290:                 {
9D00D9C0  27BDFFE8   ADDIU SP, SP, -24
9D00D9C4  AFBF0014   SW RA, 20(SP)
291:                     processBlocks(currentProcessedFrame, currentProcessedCount);
9D00D9C8  3C04A001   LUI A0, -24575
9D00D9CC  248454F8   ADDIU A0, A0, 21752
9D00D9D0  0F400BCF   JAL processBlocks
9D00D9D4  9385803E   LBU A1, -32706(GP)
292:                 //    messageItem_t debug;
293:                 //    debug.msgSize = sprintf(debug.payload,
294:                 //            "END OF PIXY FRAME\r\n\r\n\r\n\r\n"
295:                 //            );
296:                 //    SendMessageForTransmitQ(debug);
297:                 }
9D00D9D8  8FBF0014   LW RA, 20(SP)
9D00D9DC  03E00008   JR RA
9D00D9E0  27BD0018   ADDIU SP, SP, 24
298:                 
299:                 void processPixyItem(PIXY_DATA_t *data, PROCESSED_PIXY_ITEM_t *processed)
300:                 {
301:                     processed->ID = PIXY_INVALID;
9D00A370  ACA00000   SW ZERO, 0(A1)
302:                     processed->theta = 0;
9D00A374  A4A00008   SH ZERO, 8(A1)
303:                     processed->x_center = 0;
9D00A378  A4A00004   SH ZERO, 4(A1)
304:                     processed->y_center = 0;
9D00A37C  A4A00006   SH ZERO, 6(A1)
305:                     if(data->width < MIN_WIDTH){
9D00A380  94820004   LHU V0, 4(A0)
9D00A384  2C42000A   SLTIU V0, V0, 10
9D00A388  50400004   BEQL V0, ZERO, 0x9D00A39C
9D00A38C  94820006   LHU V0, 6(A0)
306:                         data->ID = PIXY_INVALID;
9D00A390  AC800008   SW ZERO, 8(A0)
307:                         processed->ID = PIXY_INVALID;
308:                         return;
9D00A394  03E00008   JR RA
9D00A398  ACA00000   SW ZERO, 0(A1)
309:                     }
310:                     if(data->height < MIN_HEIGHT){
9D00A39C  2C42000A   SLTIU V0, V0, 10
9D00A3A0  50400004   BEQL V0, ZERO, 0x9D00A3B4
9D00A3A4  8C820008   LW V0, 8(A0)
311:                         data->ID = PIXY_INVALID;
9D00A3A8  AC800008   SW ZERO, 8(A0)
312:                         processed->ID = PIXY_INVALID;
313:                         return;
9D00A3AC  03E00008   JR RA
9D00A3B0  ACA00000   SW ZERO, 0(A1)
314:                     }
315:                     if(data->ID == TARGET_CODE){
9D00A3B4  2403000A   ADDIU V1, ZERO, 10
9D00A3B8  14430005   BNE V0, V1, 0x9D00A3D0
9D00A3BC  2403000B   ADDIU V1, ZERO, 11
316:                         data->ID = PIXY_TARGET;
9D00A3C0  24020001   ADDIU V0, ZERO, 1
9D00A3C4  AC820008   SW V0, 8(A0)
9D00A3C8  0B402908   J 0x9D00A420
9D00A3CC  ACA20000   SW V0, 0(A1)
317:                         processed->ID = PIXY_TARGET;
318:                     }
319:                     else if (data->ID == VERTEX_1_CODE){
9D00A3D0  14430009   BNE V0, V1, 0x9D00A3F8
9D00A3D4  24030013   ADDIU V1, ZERO, 19
320:                         data->ID = PIXY_VERTEX_1;
9D00A3D8  24020002   ADDIU V0, ZERO, 2
9D00A3DC  AC820008   SW V0, 8(A0)
321:                         processed->ID = PIXY_VERTEX_1;
9D00A3E0  ACA20000   SW V0, 0(A1)
322:                         processed->x_center = 70;
9D00A3E4  24020046   ADDIU V0, ZERO, 70
9D00A3E8  A4A20004   SH V0, 4(A1)
323:                         processed->y_center = 24;
9D00A3EC  24020018   ADDIU V0, ZERO, 24
9D00A3F0  0B402908   J 0x9D00A420
9D00A3F4  A4A20006   SH V0, 6(A1)
324:                     }
325:                     else if (data->ID == VERTEX_2_CODE){
9D00A3F8  54430008   BNEL V0, V1, 0x9D00A41C
9D00A3FC  AC800008   SW ZERO, 8(A0)
326:                         data->ID = PIXY_VERTEX_2;
9D00A400  24020003   ADDIU V0, ZERO, 3
9D00A404  AC820008   SW V0, 8(A0)
327:                         processed->ID = PIXY_VERTEX_2;
9D00A408  ACA20000   SW V0, 0(A1)
328:                         processed->x_center = 118;
9D00A40C  24020076   ADDIU V0, ZERO, 118
9D00A410  A4A20004   SH V0, 4(A1)
9D00A414  0B402908   J 0x9D00A420
9D00A418  A4A00006   SH ZERO, 6(A1)
329:                         processed->y_center = 0;
330:                     }
331:                     else{
332:                         data->ID = PIXY_INVALID;
333:                         processed->ID = PIXY_INVALID;
9D00A41C  ACA00000   SW ZERO, 0(A1)
334:                     }
335:                     processed->theta = ((int16_t)160 - data->x_center - 2)/4 + 1;
9D00A420  94820000   LHU V0, 0(A0)
9D00A424  2403009E   ADDIU V1, ZERO, 158
9D00A428  00621023   SUBU V0, V1, V0
9D00A42C  24430003   ADDIU V1, V0, 3
9D00A430  28440000   SLTI A0, V0, 0
9D00A434  0064100B   MOVN V0, V1, A0
9D00A438  00021083   SRA V0, V0, 2
9D00A43C  24420001   ADDIU V0, V0, 1
9D00A440  03E00008   JR RA
9D00A444  A4A20008   SH V0, 8(A1)
336:                     
337:                 }
338:                 
339:                 
340:                 
341:                 
342:                 
343:                 void debugPIXY_MESSAGE(PIXY_DATA_t data)
344:                 {
00000000  00000000   NOP
345:                     messageItem_t pixy_debug;
346:                     pixy_debug.msgSize = sprintf(pixy_debug.payload, 
00000014  00000000   NOP
347:                             //"{\"DEBUG\" : 1 , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u }\r\n", 
348:                             "{\"DEBUG\" : 1 , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u  , \"%s\" : %u }", 
349:                             "ID", data.ID, 
350:                             "xCoord", data.x_center, 
351:                             "yCoord", data.y_center, 
352:                             "Width", data.width,
353:                             "Height", data.height);
354:                     SendMessageForTransmitQ(pixy_debug);
00000084  00000000   NOP
355:                 }
000000E8  00000000   NOP
356:                 
357:                 void debugPIXY_PROCESSED(PROCESSED_PIXY_ITEM_t data)
358:                 {
9D009F14  27BDFBF8   ADDIU SP, SP, -1032
9D009F18  AFBF0404   SW RA, 1028(SP)
9D009F1C  AFA40408   SW A0, 1032(SP)
9D009F20  AFA5040C   SW A1, 1036(SP)
9D009F24  AFA60410   SW A2, 1040(SP)
359:                     messageItem_t debug;
360:                     debug.msgSize = sprintf(debug.payload,
9D009F28  00803821   ADDU A3, A0, ZERO
9D009F2C  3C029D00   LUI V0, -25344
9D009F30  2442693C   ADDIU V0, V0, 26940
9D009F34  AFA20010   SW V0, 16(SP)
9D009F38  7C063620   SEH A2, A2
9D009F3C  AFA60014   SW A2, 20(SP)
9D009F40  3C029D00   LUI V0, -25344
9D009F44  24426A44   ADDIU V0, V0, 27204
9D009F48  AFA20018   SW V0, 24(SP)
9D009F4C  30A2FFFF   ANDI V0, A1, -1
9D009F50  AFA2001C   SW V0, 28(SP)
9D009F54  3C029D00   LUI V0, -25344
9D009F58  24426A4C   ADDIU V0, V0, 27212
9D009F5C  AFA20020   SW V0, 32(SP)
9D009F60  00052C02   SRL A1, A1, 16
9D009F64  AFA50024   SW A1, 36(SP)
9D009F68  27A40200   ADDIU A0, SP, 512
9D009F6C  3C059D00   LUI A1, -25344
9D009F70  24A56A00   ADDIU A1, A1, 27136
9D009F74  3C069D00   LUI A2, -25344
9D009F78  0F4031ED   JAL _sprintf_cdfFnopsuxX
9D009F7C  24C669DC   ADDIU A2, A2, 27100
9D009F80  AFA203F4   SW V0, 1012(SP)
361:                             "{\"DEBUG\" : 1 , \"%s\" : %u  , \"%s\" : %i  , \"%s\" : %u  , \"%s\" : %u  }",
362:                             "ID", data.ID,
363:                             "ANGLE", data.theta,
364:                             "XCoord", data.x_center,
365:                             "YCoord", data.y_center
366:                             );
367:                     SendMessageForTransmitQ(debug);
9D009F84  27A20210   ADDIU V0, SP, 528
9D009F88  27A30010   ADDIU V1, SP, 16
9D009F8C  27A403F0   ADDIU A0, SP, 1008
9D009F90  8C480000   LW T0, 0(V0)
9D009F94  8C470004   LW A3, 4(V0)
9D009F98  8C460008   LW A2, 8(V0)
9D009F9C  8C45000C   LW A1, 12(V0)
9D009FA0  AC680000   SW T0, 0(V1)
9D009FA4  AC670004   SW A3, 4(V1)
9D009FA8  AC660008   SW A2, 8(V1)
9D009FAC  AC65000C   SW A1, 12(V1)
9D009FB0  24420010   ADDIU V0, V0, 16
9D009FB4  1444FFF6   BNE V0, A0, 0x9D009F90
9D009FB8  24630010   ADDIU V1, V1, 16
9D009FBC  8C450000   LW A1, 0(V0)
9D009FC0  8C440004   LW A0, 4(V0)
9D009FC4  8C420008   LW V0, 8(V0)
9D009FC8  AC650000   SW A1, 0(V1)
9D009FCC  AC640004   SW A0, 4(V1)
9D009FD0  AC620008   SW V0, 8(V1)
9D009FD4  8FA40200   LW A0, 512(SP)
9D009FD8  8FA50204   LW A1, 516(SP)
9D009FDC  8FA60208   LW A2, 520(SP)
9D009FE0  0F4034BF   JAL SendMessageForTransmitQ
9D009FE4  8FA7020C   LW A3, 524(SP)
368:                 }
9D009FE8  8FBF0404   LW RA, 1028(SP)
9D009FEC  03E00008   JR RA
9D009FF0  27BD0408   ADDIU SP, SP, 1032
369:                 
370:                 // *****************************************************************************
371:                 // *****************************************************************************
372:                 // Section: Application Initialization and State Machine Functions
373:                 // *****************************************************************************
374:                 // *****************************************************************************
375:                 
376:                 /*******************************************************************************
377:                   Function:
378:                     void PIC_INTERFACE_Initialize ( void )
379:                 
380:                   Remarks:
381:                     See prototype in pic_interface.h.
382:                  */
383:                 
384:                 void PIC_INTERFACE_Initialize ( void )
385:                 {
9D00C8E8  27BDFFE8   ADDIU SP, SP, -24
9D00C8EC  AFBF0014   SW RA, 20(SP)
386:                     /* Place the App state machine in its initial state. */
387:                     pic_interfaceData.state = PIC_INTERFACE_STATE_INIT;
9D00C8F0  AF8080DC   SW ZERO, -32548(GP)
388:                 
389:                     
390:                     /* TODO: Initialize your application's state machine and other
391:                      * parameters.
392:                      */
393:                     Pixy = DRV_USART_Open(DRV_USART_INDEX_1, DRV_IO_INTENT_READ);
9D00C8F4  24040001   ADDIU A0, ZERO, 1
9D00C8F8  0F401F48   JAL DRV_USART_Open
9D00C8FC  24050001   ADDIU A1, ZERO, 1
394:                     if (Pixy == DRV_HANDLE_INVALID){
9D00C900  2403FFFF   ADDIU V1, ZERO, -1
9D00C904  14430003   BNE V0, V1, 0x9D00C914
9D00C908  AF8280D8   SW V0, -32552(GP)
395:                         errorHandler(0xFF);
9D00C90C  0F403681   JAL errorHandler
9D00C910  240400FF   ADDIU A0, ZERO, 255
396:                     }
397:                     //DRV_USART_ByteTransmitCallbackSet(DRV_USART_INDEX_0, APP_USARTTransmitEventHandler);
398:                     DRV_USART_ByteReceiveCallbackSet(DRV_USART_INDEX_1, Pixy_ByteReceive);
9D00C914  24040001   ADDIU A0, ZERO, 1
9D00C918  3C059D01   LUI A1, -25343
9D00C91C  0F4035D7   JAL DRV_USART_ByteReceiveCallbackSet
9D00C920  24A5BFEC   ADDIU A1, A1, -16404
399:                     
400:                     PixyByteHandle = xQueueCreate(16, sizeof(PIXY_DATA_t));
9D00C924  24040010   ADDIU A0, ZERO, 16
9D00C928  2405000C   ADDIU A1, ZERO, 12
9D00C92C  0F402DB4   JAL xQueueGenericCreate
9D00C930  00003021   ADDU A2, ZERO, ZERO
9D00C934  AF8280D4   SW V0, -32556(GP)
401:                     //enableDbgVal();
402:                     dbgOutputVal(0xAA);
9D00C938  0F402A13   JAL dbgOutputVal
9D00C93C  240400AA   ADDIU A0, ZERO, 170
403:                 }
9D00C940  8FBF0014   LW RA, 20(SP)
9D00C944  03E00008   JR RA
9D00C948  27BD0018   ADDIU SP, SP, 24
404:                 
405:                 
406:                 /******************************************************************************
407:                   Function:
408:                     void PIC_INTERFACE_Tasks ( void )
409:                 
410:                   Remarks:
411:                     See prototype in pic_interface.h.
412:                  */
413:                 
414:                 void PIC_INTERFACE_Tasks ( void )
415:                 {
9D0094D0  27BDFFD0   ADDIU SP, SP, -48
9D0094D4  AFBF002C   SW RA, 44(SP)
416:                 
417:                     /* Check the application's current state. */
418:                     switch ( pic_interfaceData.state )
9D0094D8  8F8280DC   LW V0, -32548(GP)
9D0094DC  10400005   BEQ V0, ZERO, 0x9D0094F4
9D0094E0  24030001   ADDIU V1, ZERO, 1
9D0094E4  10430006   BEQ V0, V1, 0x9D009500
9D0094E8  8FBF002C   LW RA, 44(SP)
9D0094EC  0B40257B   J 0x9D0095EC
9D0094F0  00000000   NOP
419:                     {
420:                         /* Application's initial state. */
421:                         case PIC_INTERFACE_STATE_INIT:
422:                         {
423:                             bool appInitialized = true;
424:                        
425:                         
426:                             if (appInitialized)
427:                             {
428:                             
429:                                 pic_interfaceData.state = PIC_INTERFACE_STATE_SERVICE_TASKS;
9D0094F4  24020001   ADDIU V0, ZERO, 1
9D0094F8  0B40257A   J 0x9D0095E8
9D0094FC  AF8280DC   SW V0, -32548(GP)
430:                             }
431:                             break;
432:                         }
433:                 
434:                         case PIC_INTERFACE_STATE_SERVICE_TASKS:
435:                         {
436:                             PIXY_DATA_t data;
437:                             dbgOutputLoc(DLOC_PIXY_WAIT_FOR_QUEUE);
9D009500  0F402A43   JAL dbgOutputLoc
9D009504  24040026   ADDIU A0, ZERO, 38
438:                             PixyReceiveByteFromRXQ(&data);
9D009508  0F4035BF   JAL PixyReceiveByteFromRXQ
9D00950C  27A4001C   ADDIU A0, SP, 28
439:                             PROCESSED_PIXY_ITEM_t processed_item;
440:                             processPixyItem(&data, &processed_item);
9D009510  27A4001C   ADDIU A0, SP, 28
9D009514  0F4028DC   JAL processPixyItem
9D009518  27A50010   ADDIU A1, SP, 16
441:                             dbgOutputLoc(DLOC_PIXY_GOT_FROM_QUEUE);
9D00951C  0F402A43   JAL dbgOutputLoc
9D009520  24040027   ADDIU A0, ZERO, 39
442:                             
443:                             if (data.ID == 0){
9D009524  8FA20024   LW V0, 36(SP)
9D009528  14400006   BNE V0, ZERO, 0x9D009544
9D00952C  8FA40010   LW A0, 16(SP)
444:                                 //new Frame
445:                                 processFrame();
9D009530  0F403670   JAL processFrame
9D009534  00000000   NOP
446:                                 currentBlockCount = 0;
9D009538  A380803D   SB ZERO, -32707(GP)
447:                                 currentProcessedCount = 0;
448:                                 //debugPIXY_PROCESSED(processed_item);
449:                                 break;
9D00953C  0B40257A   J 0x9D0095E8
9D009540  A380803E   SB ZERO, -32706(GP)
450:                             }
451:                             else{
452:                 //                debugPIXY_MESSAGE(data);
453:                                 debugPIXY_PROCESSED(processed_item);
9D009544  8FA50014   LW A1, 20(SP)
9D009548  0F4027C5   JAL debugPIXY_PROCESSED
9D00954C  8FA60018   LW A2, 24(SP)
454:                                 if(data.ID != PIXY_TARGET){
9D009550  8FA40024   LW A0, 36(SP)
9D009554  24020001   ADDIU V0, ZERO, 1
9D009558  10820011   BEQ A0, V0, 0x9D0095A0
9D00955C  9383803E   LBU V1, -32706(GP)
455:                                     currentProcessedFrame[currentProcessedCount].ID = processed_item.ID;
9D009560  00031080   SLL V0, V1, 2
9D009564  00032900   SLL A1, V1, 4
9D009568  00A21023   SUBU V0, A1, V0
9D00956C  3C05A001   LUI A1, -24575
9D009570  24A554F8   ADDIU A1, A1, 21752
9D009574  00451021   ADDU V0, V0, A1
9D009578  8FA50010   LW A1, 16(SP)
9D00957C  AC450000   SW A1, 0(V0)
456:                                     currentProcessedFrame[currentProcessedCount].x_center = processed_item.x_center;
9D009580  97A50014   LHU A1, 20(SP)
9D009584  A4450004   SH A1, 4(V0)
457:                                     currentProcessedFrame[currentProcessedCount].y_center = processed_item.y_center;
9D009588  97A50016   LHU A1, 22(SP)
9D00958C  A4450006   SH A1, 6(V0)
458:                                     currentProcessedFrame[currentProcessedCount].theta = processed_item.theta;
9D009590  97A50018   LHU A1, 24(SP)
9D009594  A4450008   SH A1, 8(V0)
459:                                     currentProcessedCount++;
9D009598  24630001   ADDIU V1, V1, 1
9D00959C  A383803E   SB V1, -32706(GP)
460:                                 }
461:                             }
462:                             currentFrame[currentBlockCount].ID = data.ID;
9D0095A0  9383803D   LBU V1, -32707(GP)
9D0095A4  00031080   SLL V0, V1, 2
9D0095A8  00032900   SLL A1, V1, 4
9D0095AC  00A21023   SUBU V0, A1, V0
9D0095B0  3C05A001   LUI A1, -24575
9D0095B4  24A55570   ADDIU A1, A1, 21872
9D0095B8  00451021   ADDU V0, V0, A1
9D0095BC  AC440008   SW A0, 8(V0)
463:                             currentFrame[currentBlockCount].x_center = data.x_center;
9D0095C0  97A4001C   LHU A0, 28(SP)
9D0095C4  A4440000   SH A0, 0(V0)
464:                             currentFrame[currentBlockCount].y_center = data.y_center;
9D0095C8  97A4001E   LHU A0, 30(SP)
9D0095CC  A4440002   SH A0, 2(V0)
465:                             currentFrame[currentBlockCount].width = data.width;
9D0095D0  97A40020   LHU A0, 32(SP)
9D0095D4  A4440004   SH A0, 4(V0)
466:                             currentFrame[currentBlockCount].height = data.height;
9D0095D8  97A40022   LHU A0, 34(SP)
9D0095DC  A4440006   SH A0, 6(V0)
467:                             currentBlockCount++;
9D0095E0  24630001   ADDIU V1, V1, 1
9D0095E4  A383803D   SB V1, -32707(GP)
468:                             break;
469:                         }
470:                 
471:                         /* TODO: implement your application state machine.*/
472:                         
473:                 
474:                         /* The default state should never be executed. */
475:                         default:
476:                         {
477:                             /* TODO: Handle error in application's state machine. */
478:                             break;
479:                         }
480:                     }
481:                 }
9D0095E8  8FBF002C   LW RA, 44(SP)
9D0095EC  03E00008   JR RA
9D0095F0  27BD0030   ADDIU SP, SP, 48
482:                 
483:                  
484:                 
485:                 /*******************************************************************************
486:                  End of File
487:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/main.c  -------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for an MPLAB Harmony project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include <stddef.h>                     // Defines NULL
59:                  #include <stdbool.h>                    // Defines true
60:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
61:                  #include "system/common/sys_module.h"   // SYS function prototypes
62:                  
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Main Entry Point
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  int main ( void )
71:                  {
9D00D9E4  27BDFFE8   ADDIU SP, SP, -24
9D00D9E8  AFBF0014   SW RA, 20(SP)
72:                      /* Initialize all MPLAB Harmony modules, including application(s). */
73:                      SYS_Initialize ( NULL );
9D00D9EC  0F4021D9   JAL SYS_Initialize
9D00D9F0  00002021   ADDU A0, ZERO, ZERO
74:                  
75:                  
76:                      while ( true )
77:                      {
78:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
79:                          SYS_Tasks ( );
9D00D9F4  0F402019   JAL SYS_Tasks
9D00D9F8  00000000   NOP
9D00D9FC  0B40367D   J 0x9D00D9F4
9D00DA00  00000000   NOP
80:                  
81:                      }
82:                  
83:                      /* Execution should not come here during normal operation */
84:                  
85:                      return ( EXIT_FAILURE );
86:                  }
87:                  
88:                  
89:                  /*******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/json_parser.c  ------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       json_parser.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "json_parser.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  JSON_PARSER_DATA json_parserData;
80:                  static QueueHandle_t JSON_PARSER_QUEUE;
81:                  static jsmn_parser Parser;
82:                  
83:                  // *****************************************************************************
84:                  // *****************************************************************************
85:                  // Section: Application Callback Functions
86:                  // *****************************************************************************
87:                  // *****************************************************************************
88:                  
89:                  /* TODO:  Add any necessary callback functions.
90:                  */
91:                  
92:                  // *****************************************************************************
93:                  // *****************************************************************************
94:                  // Section: Application Local Functions
95:                  // *****************************************************************************
96:                  // *****************************************************************************
97:                  
98:                  
99:                  /* TODO:  Add any necessary local functions.
100:                 */
101:                 int JSONParserNewPacket(messageItem_t data)
102:                 {
9D00D33C  27BDFFE8   ADDIU SP, SP, -24
9D00D340  AFBF0014   SW RA, 20(SP)
9D00D344  AFA40018   SW A0, 24(SP)
9D00D348  AFA5001C   SW A1, 28(SP)
9D00D34C  AFA60020   SW A2, 32(SP)
9D00D350  AFA70024   SW A3, 36(SP)
103:                     if (xQueueSend(JSON_PARSER_QUEUE, &data, portMAX_DELAY) == pdTRUE)
9D00D354  8F848058   LW A0, -32680(GP)
9D00D358  27A50018   ADDIU A1, SP, 24
9D00D35C  2406FFFF   ADDIU A2, ZERO, -1
9D00D360  0F40199A   JAL xQueueGenericSend
9D00D364  00003821   ADDU A3, ZERO, ZERO
9D00D368  38420001   XORI V0, V0, 1
104:                         return 1;
105:                     return 0;
106:                 }
9D00D36C  2C420001   SLTIU V0, V0, 1
9D00D370  8FBF0014   LW RA, 20(SP)
9D00D374  03E00008   JR RA
9D00D378  27BD0018   ADDIU SP, SP, 24
107:                 void JSONParserNewPacketFromISR(messageItem_t data)
108:                 {
00000000  00000000   NOP
109:                     BaseType_t xHigherPriorityTaskWoken, xResult;
110:                     xHigherPriorityTaskWoken = pdFALSE;
00000018  00000000   NOP
111:                     xResult = xQueueSendFromISR(JSON_PARSER_QUEUE, &data, &xHigherPriorityTaskWoken);
0000001C  00000000   NOP
112:                     /* Actual macro used here is port specific. */
113:                     portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
00000030  00000000   NOP
114:                 }
0000004C  00000000   NOP
115:                 int JSONParserReceivePacket(messageItem_t *data)
116:                 {
9D00D72C  27BDFFE8   ADDIU SP, SP, -24
9D00D730  AFBF0014   SW RA, 20(SP)
9D00D734  00802821   ADDU A1, A0, ZERO
117:                     if (xQueueReceive(JSON_PARSER_QUEUE, data, portMAX_DELAY) == pdTRUE)
9D00D738  8F848058   LW A0, -32680(GP)
9D00D73C  2406FFFF   ADDIU A2, ZERO, -1
9D00D740  0F40165D   JAL xQueueGenericReceive
9D00D744  00003821   ADDU A3, ZERO, ZERO
9D00D748  38420001   XORI V0, V0, 1
118:                        return 1;
119:                    return 0;
120:                 }
9D00D74C  2C420001   SLTIU V0, V0, 1
9D00D750  8FBF0014   LW RA, 20(SP)
9D00D754  03E00008   JR RA
9D00D758  27BD0018   ADDIU SP, SP, 24
121:                 
122:                 //compare string to the token string
123:                 bool json_token_streq(char *js, jsmntok_t *t, char *s) 
124:                 {
9D00C9AC  27BDFFE0   ADDIU SP, SP, -32
9D00C9B0  AFBF001C   SW RA, 28(SP)
9D00C9B4  AFB10018   SW S1, 24(SP)
9D00C9B8  AFB00014   SW S0, 20(SP)
9D00C9BC  00C08821   ADDU S1, A2, ZERO
125:                     return (strncmp(js + t->start, s, t->end - t->start) == 0 
9D00C9C0  8CA30004   LW V1, 4(A1)
9D00C9C4  8CB00008   LW S0, 8(A1)
9D00C9C8  02038023   SUBU S0, S0, V1
9D00C9CC  00832021   ADDU A0, A0, V1
9D00C9D0  00C02821   ADDU A1, A2, ZERO
9D00C9D4  0F4030CB   JAL strncmp
9D00C9D8  02003021   ADDU A2, S0, ZERO
126:                             && strlen(s) == (size_t) (t->end - t->start)); 
9D00C9DC  14400005   BNE V0, ZERO, 0x9D00C9F4
9D00C9E0  00001821   ADDU V1, ZERO, ZERO
9D00C9E4  0F4020D5   JAL 0x9D008354
9D00C9E8  02202021   ADDU A0, S1, ZERO
9D00C9EC  02021026   XOR V0, S0, V0
9D00C9F0  2C430001   SLTIU V1, V0, 1
127:                 } 
9D00C9F4  00601021   ADDU V0, V1, ZERO
9D00C9F8  8FBF001C   LW RA, 28(SP)
9D00C9FC  8FB10018   LW S1, 24(SP)
9D00CA00  8FB00014   LW S0, 20(SP)
9D00CA04  03E00008   JR RA
9D00CA08  27BD0020   ADDIU SP, SP, 32
128:                 
129:                 // *****************************************************************************
130:                 // *****************************************************************************
131:                 // Section: Application Initialization and State Machine Functions
132:                 // *****************************************************************************
133:                 // *****************************************************************************
134:                 
135:                 /*******************************************************************************
136:                   Function:
137:                     void JSON_PARSER_Initialize ( void )
138:                 
139:                   Remarks:
140:                     See prototype in json_parser.h.
141:                  */
142:                 
143:                 void JSON_PARSER_Initialize ( void )
144:                 {
9D00D564  27BDFFE8   ADDIU SP, SP, -24
9D00D568  AFBF0014   SW RA, 20(SP)
145:                     /* Place the App state machine in its initial state. */
146:                     json_parserData.state = JSON_PARSER_STATE_INIT;
9D00D56C  AF8080FC   SW ZERO, -32516(GP)
147:                 
148:                     
149:                     /* TODO: Initialize your application's state machine and other
150:                      * parameters.
151:                      */
152:                     JSON_PARSER_QUEUE = xQueueCreate(5, sizeof(messageItem_t));
9D00D570  24040005   ADDIU A0, ZERO, 5
9D00D574  240501FC   ADDIU A1, ZERO, 508
9D00D578  0F402DB4   JAL xQueueGenericCreate
9D00D57C  00003021   ADDU A2, ZERO, ZERO
9D00D580  AF828058   SW V0, -32680(GP)
153:                     jsmn_init(&Parser);
9D00D584  3C04A001   LUI A0, -24575
9D00D588  0F40372C   JAL jsmn_init
9D00D58C  24844F58   ADDIU A0, A0, 20312
154:                 }
9D00D590  8FBF0014   LW RA, 20(SP)
9D00D594  03E00008   JR RA
9D00D598  27BD0018   ADDIU SP, SP, 24
155:                 //void handleJSON(JSON_OBJECT object)
156:                 //{
157:                 //    
158:                 //}
159:                 
160:                 void parseTokens(char data[], jsmntok_t tokenList[], int tokenCount);
161:                 void parseJSONMessage(char data[], int dataSize, jsmntok_t tokenList[], int maxTokenCount)
162:                 {
9D00B9B0  27BDFFD0   ADDIU SP, SP, -48
9D00B9B4  AFBF002C   SW RA, 44(SP)
9D00B9B8  AFB40028   SW S4, 40(SP)
9D00B9BC  AFB30024   SW S3, 36(SP)
9D00B9C0  AFB20020   SW S2, 32(SP)
9D00B9C4  AFB1001C   SW S1, 28(SP)
9D00B9C8  AFB00018   SW S0, 24(SP)
9D00B9CC  00809021   ADDU S2, A0, ZERO
9D00B9D0  00A09821   ADDU S3, A1, ZERO
9D00B9D4  00C08821   ADDU S1, A2, ZERO
9D00B9D8  00E0A021   ADDU S4, A3, ZERO
163:                     jsmn_init(&Parser);
9D00B9DC  3C10A001   LUI S0, -24575
9D00B9E0  0F40372C   JAL jsmn_init
9D00B9E4  26044F58   ADDIU A0, S0, 20312
164:                     int tokenCount =  jsmn_parse(&Parser, data, dataSize, tokenList, maxTokenCount);
9D00B9E8  AFB40010   SW S4, 16(SP)
9D00B9EC  26044F58   ADDIU A0, S0, 20312
9D00B9F0  02402821   ADDU A1, S2, ZERO
9D00B9F4  02603021   ADDU A2, S3, ZERO
9D00B9F8  0F400957   JAL jsmn_parse
9D00B9FC  02203821   ADDU A3, S1, ZERO
165:                     if (tokenCount < 0){
9D00BA00  04410003   BGEZ V0, 0x9D00BA10
9D00BA04  00408021   ADDU S0, V0, ZERO
166:                         errorHandler(tokenCount);
9D00BA08  0F403681   JAL errorHandler
9D00BA0C  304400FF   ANDI A0, V0, 255
167:                     }
168:                     parseTokens(data, tokenList, tokenCount);
9D00BA10  02402021   ADDU A0, S2, ZERO
9D00BA14  02202821   ADDU A1, S1, ZERO
9D00BA18  0F4022D0   JAL parseTokens
9D00BA1C  02003021   ADDU A2, S0, ZERO
169:                 }
9D00BA20  8FBF002C   LW RA, 44(SP)
9D00BA24  8FB40028   LW S4, 40(SP)
9D00BA28  8FB30024   LW S3, 36(SP)
9D00BA2C  8FB20020   LW S2, 32(SP)
9D00BA30  8FB1001C   LW S1, 28(SP)
9D00BA34  8FB00018   LW S0, 24(SP)
9D00BA38  03E00008   JR RA
9D00BA3C  27BD0030   ADDIU SP, SP, 48
170:                 
171:                 //Parse the list of tokens generated by jsmn
172:                 void parseTokens(char data[], jsmntok_t tokenList[], int tokenCount)
173:                 {
9D008B40  27BDFBE8   ADDIU SP, SP, -1048
9D008B44  AFBF0414   SW RA, 1044(SP)
9D008B48  AFB30410   SW S3, 1040(SP)
9D008B4C  AFB2040C   SW S2, 1036(SP)
9D008B50  AFB10408   SW S1, 1032(SP)
9D008B54  AFB00404   SW S0, 1028(SP)
9D008B58  00809821   ADDU S3, A0, ZERO
9D008B5C  00A08821   ADDU S1, A1, ZERO
9D008B60  00C08021   ADDU S0, A2, ZERO
174:                     messageItem_t debug;
175:                 //    debug.msgSize = sprintf(debug.payload, 
176:                 //                "{\"DEBUG\" : 1 , \"VERTEX\" : 1 }"
177:                 //                );
178:                 //    SendMessageForTransmitQ(debug);
179:                     if(json_token_streq(data, &tokenList[1], "REQUEST")){
9D008B64  24B20010   ADDIU S2, A1, 16
9D008B68  02402821   ADDU A1, S2, ZERO
9D008B6C  3C069D01   LUI A2, -25343
9D008B70  0F40326B   JAL json_token_streq
9D008B74  24C6D3FC   ADDIU A2, A2, -11268
9D008B78  1440002F   BNE V0, ZERO, 0x9D008C38
9D008B7C  02602021   ADDU A0, S3, ZERO
180:                         if(json_token_streq(data, &tokenList[10], "OBSTACLES")){
181:                             //classifyObjects
182:                         }
183:                         else if(json_token_streq(data, &tokenList[10], "LOCATION")){
184:                             
185:                         }
186:                     }
187:                     else if(json_token_streq(data, &tokenList[1], "RESPONSE")){
9D008B80  02402821   ADDU A1, S2, ZERO
9D008B84  3C069D01   LUI A2, -25343
9D008B88  0F40326B   JAL json_token_streq
9D008B8C  24C6D404   ADDIU A2, A2, -11260
9D008B90  10400029   BEQ V0, ZERO, 0x9D008C38
9D008B94  02602021   ADDU A0, S3, ZERO
188:                         if(json_token_streq(data, &tokenList[10], "VERTEX")){
9D008B98  262500A0   ADDIU A1, S1, 160
9D008B9C  3C069D01   LUI A2, -25343
9D008BA0  0F40326B   JAL json_token_streq
9D008BA4  24C6D410   ADDIU A2, A2, -11248
9D008BA8  10400023   BEQ V0, ZERO, 0x9D008C38
9D008BAC  00000000   NOP
189:                             //messageItem_t debug;
190:                             debug.msgSize = sprintf(debug.payload, 
9D008BB0  8E2400D4   LW A0, 212(S1)
9D008BB4  0F402C07   JAL atoi
9D008BB8  02642021   ADDU A0, S3, A0
9D008BBC  27A40200   ADDIU A0, SP, 512
9D008BC0  3C059D01   LUI A1, -25343
9D008BC4  24A5D418   ADDIU A1, A1, -11240
9D008BC8  0F4031ED   JAL _sprintf_cdfFnopsuxX
9D008BCC  00403021   ADDU A2, V0, ZERO
9D008BD0  AFA203F4   SW V0, 1012(SP)
191:                                         "{\"DEBUG\" : 1 , \"VERTEX\" : %i }", atoi(data + tokenList[13].start)
192:                                         );
193:                             SendMessageForTransmitQ(debug);
9D008BD4  27A20210   ADDIU V0, SP, 528
9D008BD8  27A30010   ADDIU V1, SP, 16
9D008BDC  27A403F0   ADDIU A0, SP, 1008
9D008BE0  8C480000   LW T0, 0(V0)
9D008BE4  8C470004   LW A3, 4(V0)
9D008BE8  8C460008   LW A2, 8(V0)
9D008BEC  8C45000C   LW A1, 12(V0)
9D008BF0  AC680000   SW T0, 0(V1)
9D008BF4  AC670004   SW A3, 4(V1)
9D008BF8  AC660008   SW A2, 8(V1)
9D008BFC  AC65000C   SW A1, 12(V1)
9D008C00  24420010   ADDIU V0, V0, 16
9D008C04  1444FFF6   BNE V0, A0, 0x9D008BE0
9D008C08  24630010   ADDIU V1, V1, 16
9D008C0C  8C450000   LW A1, 0(V0)
9D008C10  8C440004   LW A0, 4(V0)
9D008C14  8C420008   LW V0, 8(V0)
9D008C18  AC650000   SW A1, 0(V1)
9D008C1C  AC640004   SW A0, 4(V1)
9D008C20  AC620008   SW V0, 8(V1)
9D008C24  8FA40200   LW A0, 512(SP)
9D008C28  8FA50204   LW A1, 516(SP)
9D008C2C  8FA60208   LW A2, 520(SP)
9D008C30  0F4034BF   JAL SendMessageForTransmitQ
9D008C34  8FA7020C   LW A3, 524(SP)
194:                         }
195:                         else if(json_token_streq(data, &tokenList[10], "LOCATION")){
196:                             
197:                         }
198:                         
199:                     }
200:                     
201:                     
202:                     //Erase Tokens
203:                     int i;
204:                     for(i = 0; i < tokenCount; i++){
9D008C38  1A00000B   BLEZ S0, 0x9D008C68
9D008C3C  8FBF0414   LW RA, 1044(SP)
9D008C40  02202821   ADDU A1, S1, ZERO
9D008C44  00001021   ADDU V0, ZERO, ZERO
9D008C58  24420001   ADDIU V0, V0, 1
9D008C5C  1450FFFA   BNE V0, S0, 0x9D008C48
9D008C60  24A50010   ADDIU A1, A1, 16
205:                         tokenList[i].type = JSMN_UNDEFINED;
9D008C48  ACA00000   SW ZERO, 0(A1)
206:                         tokenList[i].start = 0;
9D008C4C  ACA00004   SW ZERO, 4(A1)
207:                         tokenList[i].end = 0;
9D008C50  ACA00008   SW ZERO, 8(A1)
208:                         tokenList[i].size = 0;
9D008C54  ACA0000C   SW ZERO, 12(A1)
209:                     }
210:                 }
9D008C64  8FBF0414   LW RA, 1044(SP)
9D008C68  8FB30410   LW S3, 1040(SP)
9D008C6C  8FB2040C   LW S2, 1036(SP)
9D008C70  8FB10408   LW S1, 1032(SP)
9D008C74  8FB00404   LW S0, 1028(SP)
9D008C78  03E00008   JR RA
9D008C7C  27BD0418   ADDIU SP, SP, 1048
211:                 /******************************************************************************
212:                   Function:
213:                     void JSON_PARSER_Tasks ( void )
214:                 
215:                   Remarks:
216:                     See prototype in json_parser.h.
217:                  */
218:                 
219:                 //array of tokens to store information in
220:                 static jsmntok_t tokens[MAX_TOKENS];
221:                 
222:                 
223:                 int numTokens;
224:                 static char data2[MAX_PAYLOAD_SIZE];
225:                 static int numValidMsg = 0;
226:                 void JSON_PARSER_Tasks ( void )
227:                 {
9D00A448  27BDFDE0   ADDIU SP, SP, -544
9D00A44C  AFBF021C   SW RA, 540(SP)
9D00A450  AFBE0218   SW S8, 536(SP)
9D00A454  AFB00214   SW S0, 532(SP)
228:                 
229:                     /* Check the application's current state. */
230:                     switch ( json_parserData.state )
9D00A458  8F8280FC   LW V0, -32516(GP)
9D00A45C  10400006   BEQ V0, ZERO, 0x9D00A478
9D00A460  03A0F021   ADDU S8, SP, ZERO
9D00A464  24030001   ADDIU V1, ZERO, 1
9D00A468  10430006   BEQ V0, V1, 0x9D00A484
9D00A46C  03A08021   ADDU S0, SP, ZERO
231:                     {
232:                         /* Application's initial state. */
233:                         case JSON_PARSER_STATE_INIT:
234:                         {
235:                             bool appInitialized = true;
236:                        
237:                         
238:                             if (appInitialized)
239:                             {
240:                             
241:                                 json_parserData.state = JSON_PARSER_STATE_SERVICE_TASKS;
9D00A478  24020001   ADDIU V0, ZERO, 1
9D00A47C  0B402941   J 0x9D00A504
9D00A480  AF8280FC   SW V0, -32516(GP)
242:                             }
243:                             break;
244:                         }
245:                 
246:                         case JSON_PARSER_STATE_SERVICE_TASKS:
247:                         {
248:                             messageItem_t receivedMessage;
249:                             dbgOutputLoc(DLOC_JSON_PARSE_WAIT_FOR_QUEUE);
9D00A484  0F402A43   JAL dbgOutputLoc
9D00A488  2404001C   ADDIU A0, ZERO, 28
250:                             JSONParserReceivePacket(&receivedMessage);
9D00A48C  0F4035CB   JAL JSONParserReceivePacket
9D00A490  27C40010   ADDIU A0, S8, 16
251:                             dbgOutputLoc(DLOC_JSON_PARSE_GOT_FROM_QUEUE);
9D00A494  0F402A43   JAL dbgOutputLoc
9D00A498  2404001D   ADDIU A0, ZERO, 29
252:                             int count = receivedMessage.msgSize;
9D00A49C  8FC50204   LW A1, 516(S8)
253:                             char data[count+1];
9D00A4A0  24A20008   ADDIU V0, A1, 8
9D00A4A4  000210C2   SRL V0, V0, 3
9D00A4A8  000210C0   SLL V0, V0, 3
9D00A4AC  03A2E823   SUBU SP, SP, V0
9D00A4B0  27A40010   ADDIU A0, SP, 16
254:                             int i;
255:                             for (i=0; i < count; i++){
9D00A4B4  18A00009   BLEZ A1, 0x9D00A4DC
9D00A4B8  00803821   ADDU A3, A0, ZERO
9D00A4BC  00001021   ADDU V0, ZERO, ZERO
9D00A4C0  00E21821   ADDU V1, A3, V0
9D00A4C4  27C80010   ADDIU T0, S8, 16
9D00A4C8  01023021   ADDU A2, T0, V0
9D00A4D0  24420001   ADDIU V0, V0, 1
9D00A4D4  1445FFFA   BNE V0, A1, 0x9D00A4C0
9D00A4D8  A0660000   SB A2, 0(V1)
256:                                 data[i] = receivedMessage.payload[i];
9D00A4CC  90C60000   LBU A2, 0(A2)
257:                             }
258:                             data[count] = '\0';
9D00A4DC  00851021   ADDU V0, A0, A1
9D00A4E0  A0400000   SB ZERO, 0(V0)
259:                             //JSON_OBJECT parsedMessage;
260:                             //parseJSON(data, count, &parsedMessage);
261:                             //handleJSON(parsedMessage);
262:                             
263:                             //initialize parser and then parse json
264:                             parseJSONMessage(data, count, tokens, MAX_TOKENS);
9D00A4E4  3C06A001   LUI A2, -24575
9D00A4E8  24C64B58   ADDIU A2, A2, 19288
9D00A4EC  0F402E6C   JAL parseJSONMessage
9D00A4F0  24070040   ADDIU A3, ZERO, 64
265:                             numValidMsg++;
9D00A4F4  8F828054   LW V0, -32684(GP)
9D00A4F8  24420001   ADDIU V0, V0, 1
9D00A4FC  AF828054   SW V0, -32684(GP)
9D00A500  0200E821   ADDU SP, S0, ZERO
266:                             break;
267:                         }
268:                 
269:                         /* TODO: implement your application state machine.*/
270:                         
271:                 
272:                         /* The default state should never be executed. */
273:                         default:
274:                         {
275:                             /* TODO: Handle error in application's state machine. */
276:                             break;
277:                         }
278:                     }
279:                 }
9D00A470  0B402942   J 0x9D00A508
9D00A474  03C0E821   ADDU SP, S8, ZERO
9D00A504  03C0E821   ADDU SP, S8, ZERO
9D00A508  8FBF021C   LW RA, 540(SP)
9D00A50C  8FBE0218   LW S8, 536(SP)
9D00A510  8FB00214   LW S0, 532(SP)
9D00A514  03E00008   JR RA
9D00A518  27BD0220   ADDIU SP, SP, 544
280:                 
281:                  
282:                 
283:                 /*******************************************************************************
284:                  End of File
285:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/jsmn.c  -------------------
1:                   #include "jsmn.h"
2:                   
3:                   /**
4:                    * Allocates a fresh unused token from the token pull.
5:                    */
6:                   static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser,
7:                   		jsmntok_t *tokens, size_t num_tokens) {
8:                   	jsmntok_t *tok;
9:                   	if (parser->toknext >= num_tokens) {
9D0027E8  8C830004   LW V1, 4(A0)
9D002958  8C830004   LW V1, 4(A0)
9D002DD8  8FAB0038   LW T3, 56(SP)
9D002DDC  006B482B   SLTU T1, V1, T3
9D002DE0  11200008   BEQ T1, ZERO, 0x9D002E04
9D002DE4  24690001   ADDIU T1, V1, 1
10:                  		return NULL;
11:                  	}
12:                  	tok = &tokens[parser->toknext++];
9D0027FC  AC890004   SW T1, 4(A0)
9D002968  AC890004   SW T1, 4(A0)
9D002DE8  AC890004   SW T1, 4(A0)
9D002DEC  00031900   SLL V1, V1, 4
9D002DF0  00E31821   ADDU V1, A3, V1
13:                  	tok->start = tok->end = -1;
9D0025C0  2408FFFF   ADDIU T0, ZERO, -1
9D002808  AC680008   SW T0, 8(V1)
9D002974  AC680008   SW T0, 8(V1)
9D002DF4  AC680008   SW T0, 8(V1)
9D002DF8  AC680004   SW T0, 4(V1)
14:                  	tok->size = 0;
15:                  #ifdef JSMN_PARENT_LINKS
16:                  	tok->parent = -1;
17:                  #endif
18:                  	return tok;
19:                  }
20:                  
21:                  /**
22:                   * Fills token type and boundaries.
23:                   */
24:                  static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type,
25:                                              int start, int end) {
26:                  	token->type = type;
9D002994  AC770000   SW S7, 0(V1)
9D002E14  240D0004   ADDIU T5, ZERO, 4
27:                  	token->start = start;
9D00299C  AC6A0004   SW T2, 4(V1)
9D002E1C  AC6A0004   SW T2, 4(V1)
28:                  	token->end = end;
9D0029A0  AC690008   SW T1, 8(V1)
9D002E20  AC690008   SW T1, 8(V1)
29:                  	token->size = 0;
9D0029A4  AC60000C   SW ZERO, 12(V1)
9D002E24  AC60000C   SW ZERO, 12(V1)
30:                  }
31:                  
32:                  /**
33:                   * Fills next available token with JSON primitive.
34:                   */
35:                  static int jsmn_parse_primitive(jsmn_parser *parser, const char *js,
36:                  		size_t len, jsmntok_t *tokens, size_t num_tokens) {
37:                  	jsmntok_t *token;
38:                  	int start;
39:                  
40:                  	start = parser->pos;
41:                  
42:                  	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
9D002D10  8C890000   LW T1, 0(A0)
9D002D14  0126182B   SLTU V1, T1, A2
9D002D18  50600027   BEQL V1, ZERO, 0x9D002DB8
9D002D1C  AC8A0000   SW T2, 0(A0)
9D002D20  00A91821   ADDU V1, A1, T1
9D002D24  80630000   LB V1, 0(V1)
9D002D28  50600023   BEQL V1, ZERO, 0x9D002DB8
9D002D2C  AC8A0000   SW T2, 0(A0)
9D002D98  0126182B   SLTU V1, T1, A2
9D002D9C  10600005   BEQ V1, ZERO, 0x9D002DB4
9D002DA0  AC890000   SW T1, 0(A0)
9D002DA4  00A91821   ADDU V1, A1, T1
9D002DA8  80630000   LB V1, 0(V1)
9D002DAC  1460FFE0   BNE V1, ZERO, 0x9D002D30
9D002DB0  00000000   NOP
43:                  		switch (js[parser->pos]) {
9D0025AC  240C0020   ADDIU T4, ZERO, 32
9D0025B0  2410005D   ADDIU S0, ZERO, 93
9D0025B4  2419007D   ADDIU T9, ZERO, 125
9D0025B8  2411002C   ADDIU S1, ZERO, 44
9D0025BC  2412000D   ADDIU S2, ZERO, 13
9D002D30  106C0023   BEQ V1, T4, jsmn_parse_primitive
9D002D34  286B0021   SLTI T3, V1, 33
9D002D38  11600009   BEQ T3, ZERO, 0x9D002D60
9D002D3C  286B0009   SLTI T3, V1, 9
9D002D40  1560000D   BNE T3, ZERO, 0x9D002D78
9D002D44  286B000B   SLTI T3, V1, 11
9D002D48  1560001D   BNE T3, ZERO, jsmn_parse_primitive
9D002D4C  00000000   NOP
9D002D50  1472000A   BNE V1, S2, 0x9D002D7C
9D002D54  2463FFE0   ADDIU V1, V1, -32
9D002D58  0B400B70   J jsmn_parse_primitive
9D002D5C  00000000   NOP
9D002D60  10700017   BEQ V1, S0, jsmn_parse_primitive
9D002D64  00000000   NOP
9D002D68  10790015   BEQ V1, T9, jsmn_parse_primitive
9D002D6C  00000000   NOP
9D002D70  10710013   BEQ V1, S1, jsmn_parse_primitive
9D002D74  00000000   NOP
44:                  #ifndef JSMN_STRICT
45:                  			/* In strict mode primitive must be followed by "," or "}" or "]" */
46:                  			case ':':
47:                  #endif
48:                  			case '\t' : case '\r' : case '\n' : case ' ' :
49:                  			case ','  : case ']'  : case '}' :
50:                  				goto found;
51:                  		}
52:                  		if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
9D002D78  2463FFE0   ADDIU V1, V1, -32
9D002D7C  306300FF   ANDI V1, V1, 255
9D002D80  2C63005F   SLTIU V1, V1, 95
9D002D84  54600004   BNEL V1, ZERO, jsmn_parse_primitive
9D002D88  25290001   ADDIU T1, T1, 1
53:                  			parser->pos = start;
9D002D8C  AC8A0000   SW T2, 0(A0)
54:                  			return JSMN_ERROR_INVAL;
9D002D90  0B400BC4   J 0x9D002F10
9D002D94  2402FFFE   ADDIU V0, ZERO, -2
55:                  		}
56:                  	}
57:                  #ifdef JSMN_STRICT
58:                  	/* In strict mode primitive must be followed by a comma/object/array */
59:                  	parser->pos = start;
9D002DB4  AC8A0000   SW T2, 0(A0)
60:                  	return JSMN_ERROR_PART;
9D002DB8  0B400BC4   J 0x9D002F10
9D002DBC  2402FFFD   ADDIU V0, ZERO, -3
61:                  #endif
62:                  
63:                  found:
64:                  	if (tokens == NULL) {
9D002DC0  54E00005   BNEL A3, ZERO, jsmn_parse_primitive
9D002DC4  8C830004   LW V1, 4(A0)
65:                  		parser->pos--;
9D002DC8  2529FFFF   ADDIU T1, T1, -1
9D002DCC  AC890000   SW T1, 0(A0)
66:                  		return 0;
67:                  	}
68:                  	token = jsmn_alloc_token(parser, tokens, num_tokens);
69:                  	if (token == NULL) {
9D002DFC  14600004   BNE V1, ZERO, jsmn_parse_primitive
9D002E00  AC60000C   SW ZERO, 12(V1)
70:                  		parser->pos = start;
9D002E04  AC8A0000   SW T2, 0(A0)
71:                  		return JSMN_ERROR_NOMEM;
9D002E08  0B400BC4   J 0x9D002F10
9D002E0C  2402FFFF   ADDIU V0, ZERO, -1
72:                  	}
73:                  	jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
9D002E10  8C890000   LW T1, 0(A0)
74:                  #ifdef JSMN_PARENT_LINKS
75:                  	token->parent = parser->toksuper;
76:                  #endif
77:                  	parser->pos--;
9D002E28  8C830000   LW V1, 0(A0)
9D002E2C  2463FFFF   ADDIU V1, V1, -1
9D002E30  AC830000   SW V1, 0(A0)
78:                  	return 0;
79:                  }
80:                  
81:                  /**
82:                   * Fills next token with JSON string.
83:                   */
84:                  static int jsmn_parse_string(jsmn_parser *parser, const char *js,
85:                  		size_t len, jsmntok_t *tokens, size_t num_tokens) {
86:                  	jsmntok_t *token;
87:                  
88:                  	int start = parser->pos;
89:                  
90:                  	parser->pos++;
9D002918  25430001   ADDIU V1, T2, 1
91:                  
92:                  	/* Skip starting quote */
93:                  	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
9D00291C  0066482B   SLTU T1, V1, A2
9D002920  112000BE   BEQ T1, ZERO, 0x9D002C1C
9D002924  AC830000   SW V1, 0(A0)
9D002928  00A34821   ADDU T1, A1, V1
9D00292C  81290000   LB T1, 0(T1)
9D002930  512000BB   BEQL T1, ZERO, 0x9D002C20
9D002934  AC8A0000   SW T2, 0(A0)
9D002BF8  8C830000   LW V1, 0(A0)
9D002BFC  24630001   ADDIU V1, V1, 1
9D002C00  0066482B   SLTU T1, V1, A2
9D002C04  11200005   BEQ T1, ZERO, 0x9D002C1C
9D002C08  AC830000   SW V1, 0(A0)
9D002C0C  00A34821   ADDU T1, A1, V1
9D002C10  81290000   LB T1, 0(T1)
9D002C14  1520FF4C   BNE T1, ZERO, 0x9D002948
9D002C18  00000000   NOP
94:                  		char c = js[parser->pos];
95:                  
96:                  		/* Quote: end of string */
97:                  		if (c == '\"') {
9D0025D4  240E0022   ADDIU T6, ZERO, 34
9D002938  152E0020   BNE T1, T6, jsmn_parse_string
9D00293C  00000000   NOP
9D002940  0B400A54   J 0x9D002950
9D002944  00000000   NOP
9D002948  152E001C   BNE T1, T6, jsmn_parse_string
9D00294C  00000000   NOP
98:                  			if (tokens == NULL) {
9D002950  10E0016D   BEQ A3, ZERO, 0x9D002F08
9D002954  8FAB0038   LW T3, 56(SP)
99:                  				return 0;
100:                 			}
101:                 			token = jsmn_alloc_token(parser, tokens, num_tokens);
102:                 			if (token == NULL) {
9D00297C  14600004   BNE V1, ZERO, jsmn_parse_string
9D002980  AC60000C   SW ZERO, 12(V1)
103:                 				parser->pos = start;
9D002984  AC8A0000   SW T2, 0(A0)
104:                 				return JSMN_ERROR_NOMEM;
9D002988  0B400BC4   J 0x9D002F10
9D00298C  2402FFFF   ADDIU V0, ZERO, -1
105:                 			}
106:                 			jsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);
9D002990  8C890000   LW T1, 0(A0)
9D002998  254A0001   ADDIU T2, T2, 1
107:                 #ifdef JSMN_PARENT_LINKS
108:                 			token->parent = parser->toksuper;
109:                 #endif
110:                 			return 0;
111:                 		}
112:                 
113:                 		/* Backslash: Quoted symbol expected */
114:                 		if (c == '\\' && parser->pos + 1 < len) {
9D0025D8  240F005C   ADDIU T7, ZERO, 92
9D0029BC  552F008F   BNEL T1, T7, 0x9D002BFC
9D0029C0  8C830000   LW V1, 0(A0)
9D0029C4  24690001   ADDIU T1, V1, 1
9D0029C8  0126582B   SLTU T3, T1, A2
9D0029CC  5160008B   BEQL T3, ZERO, 0x9D002BFC
9D0029D0  8C830000   LW V1, 0(A0)
115:                 			int i;
116:                 			parser->pos++;
9D0029D4  AC890000   SW T1, 0(A0)
117:                 			switch (js[parser->pos]) {
9D0025DC  3C169D00   LUI S6, -25344
9D0025E0  26D62A08   ADDIU S6, S6, 10760
9D0029D8  00A94821   ADDU T1, A1, T1
9D0029DC  91290000   LBU T1, 0(T1)
9D0029E0  2529FFDE   ADDIU T1, T1, -34
9D0029E4  312B00FF   ANDI T3, T1, 255
9D0029E8  2D6B0054   SLTIU T3, T3, 84
9D0029EC  1160007F   BEQ T3, ZERO, jsmn_parse_string
9D0029F0  312900FF   ANDI T1, T1, 255
9D0029F4  00094880   SLL T1, T1, 2
9D0029F8  02C94821   ADDU T1, S6, T1
9D0029FC  8D290000   LW T1, 0(T1)
9D002A00  01200008   JR T1
9D002A04  00000000   NOP
118:                 				/* Allowed escaped symbols */
119:                 				case '\"': case '/' : case '\\' : case 'b' :
120:                 				case 'f' : case 'r' : case 'n'  : case 't' :
121:                 					break;
122:                 				/* Allows escaped symbol \uXXXX */
123:                 				case 'u':
124:                 					parser->pos++;
9D002B58  24690002   ADDIU T1, V1, 2
125:                 					for(i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0'; i++) {
9D002B5C  0126582B   SLTU T3, T1, A2
9D002B60  1160001E   BEQ T3, ZERO, 0x9D002BDC
9D002B64  AC890000   SW T1, 0(A0)
9D002B68  00A95821   ADDU T3, A1, T1
9D002B6C  816B0000   LB T3, 0(T3)
9D002B70  1160001A   BEQ T3, ZERO, 0x9D002BDC
9D002B74  24630006   ADDIU V1, V1, 6
9D002BB8  11230008   BEQ T1, V1, 0x9D002BDC
9D002BBC  AC890000   SW T1, 0(A0)
9D002BC0  0126582B   SLTU T3, T1, A2
9D002BC4  51600006   BEQL T3, ZERO, 0x9D002BE0
9D002BC8  8C830000   LW V1, 0(A0)
9D002BCC  00A95821   ADDU T3, A1, T1
9D002BD0  816B0000   LB T3, 0(T3)
9D002BD4  5560FFE9   BNEL T3, ZERO, 0x9D002B7C
9D002BD8  316B00FF   ANDI T3, T3, 255
126:                 						/* If it isn't a hex character we have an error */
127:                 						if(!((js[parser->pos] >= 48 && js[parser->pos] <= 57) || /* 0-9 */
9D002B78  316B00FF   ANDI T3, T3, 255
9D002B7C  256DFFD0   ADDIU T5, T3, -48
9D002B80  31AD00FF   ANDI T5, T5, 255
9D002B84  2DAD000A   SLTIU T5, T5, 10
9D002B88  55A0000B   BNEL T5, ZERO, jsmn_parse_string
9D002B8C  25290001   ADDIU T1, T1, 1
9D002B90  240DFFDF   ADDIU T5, ZERO, -33
9D002B94  016D5824   AND T3, T3, T5
9D002B98  256BFFBF   ADDIU T3, T3, -65
9D002B9C  316B00FF   ANDI T3, T3, 255
9D002BA0  2D6B0006   SLTIU T3, T3, 6
9D002BA4  55600004   BNEL T3, ZERO, jsmn_parse_string
9D002BA8  25290001   ADDIU T1, T1, 1
128:                 									(js[parser->pos] >= 65 && js[parser->pos] <= 70) || /* A-F */
129:                 									(js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
130:                 							parser->pos = start;
9D002BAC  AC8A0000   SW T2, 0(A0)
131:                 							return JSMN_ERROR_INVAL;
9D002BB0  0B400BC4   J 0x9D002F10
9D002BB4  2402FFFE   ADDIU V0, ZERO, -2
132:                 						}
133:                 						parser->pos++;
134:                 					}
135:                 					parser->pos--;
9D002BDC  8C830000   LW V1, 0(A0)
9D002BE0  2463FFFF   ADDIU V1, V1, -1
9D002BE4  0B400AFE   J jsmn_parse_string
9D002BE8  AC830000   SW V1, 0(A0)
136:                 					break;
137:                 				/* Unexpected symbol */
138:                 				default:
139:                 					parser->pos = start;
9D002BEC  AC8A0000   SW T2, 0(A0)
140:                 					return JSMN_ERROR_INVAL;
9D002BF0  0B400BC4   J 0x9D002F10
9D002BF4  2402FFFE   ADDIU V0, ZERO, -2
141:                 			}
142:                 		}
143:                 	}
144:                 	parser->pos = start;
9D002C1C  AC8A0000   SW T2, 0(A0)
145:                 	return JSMN_ERROR_PART;
9D002C20  0B400BC4   J 0x9D002F10
9D002C24  2402FFFD   ADDIU V0, ZERO, -3
146:                 }
147:                 
148:                 /**
149:                  * Parse JSON string and fill tokens.
150:                  */
151:                 int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
152:                 		jsmntok_t *tokens, unsigned int num_tokens) {
9D00255C  27BDFFD8   ADDIU SP, SP, -40
9D002560  AFBE0024   SW S8, 36(SP)
9D002564  AFB70020   SW S7, 32(SP)
9D002568  AFB6001C   SW S6, 28(SP)
9D00256C  AFB50018   SW S5, 24(SP)
9D002570  AFB40014   SW S4, 20(SP)
9D002574  AFB30010   SW S3, 16(SP)
9D002578  AFB2000C   SW S2, 12(SP)
9D00257C  AFB10008   SW S1, 8(SP)
9D002580  AFB00004   SW S0, 4(SP)
153:                 	int r;
154:                 	int i;
155:                 	jsmntok_t *token;
156:                 	int count = parser->toknext;
157:                 
158:                 	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
9D002584  8C8A0000   LW T2, 0(A0)
9D002588  0146182B   SLTU V1, T2, A2
9D00258C  1060023A   BEQ V1, ZERO, 0x9D002E78
9D002590  8C820004   LW V0, 4(A0)
9D002594  00AA1821   ADDU V1, A1, T2
9D002598  807E0000   LB S8, 0(V1)
9D00259C  13C00236   BEQ S8, ZERO, 0x9D002E78
9D0025A0  27C3FFF7   ADDIU V1, S8, -9
9D0029B4  0B400B96   J 0x9D002E58
9D0029B8  8C8A0000   LW T2, 0(A0)
9D002E54  8C8A0000   LW T2, 0(A0)
9D002E58  254A0001   ADDIU T2, T2, 1
9D002E5C  0146182B   SLTU V1, T2, A2
9D002E60  10600005   BEQ V1, ZERO, 0x9D002E78
9D002E64  AC8A0000   SW T2, 0(A0)
9D002E68  00AA1821   ADDU V1, A1, T2
9D002E6C  807E0000   LB S8, 0(V1)
9D002E70  17C0FDDD   BNE S8, ZERO, 0x9D0025E8
9D002E74  27C3FFF7   ADDIU V1, S8, -9
159:                 		char c;
160:                 		jsmntype_t type;
161:                 
162:                 		c = js[parser->pos];
163:                 		switch (c) {
9D0025A4  3C189D00   LUI T8, -25344
9D0025A8  2718260C   ADDIU T8, T8, 9740
9D0025E8  306900FF   ANDI T1, V1, 255
9D0025EC  2D290075   SLTIU T1, T1, 117
9D0025F0  11200237   BEQ T1, ZERO, 0x9D002ED0
9D0025F4  306300FF   ANDI V1, V1, 255
9D0025F8  00031880   SLL V1, V1, 2
9D0025FC  03031821   ADDU V1, T8, V1
9D002600  8C630000   LW V1, 0(V1)
9D002604  00600008   JR V1
9D002608  00000000   NOP
164:                 			case '{': case '[':
165:                 				count++;
166:                 				if (tokens == NULL) {
9D0027E0  10E0019C   BEQ A3, ZERO, 0x9D002E54
9D0027E4  24420001   ADDIU V0, V0, 1
167:                 					break;
168:                 				}
169:                 				token = jsmn_alloc_token(parser, tokens, num_tokens);
170:                 				if (token == NULL)
9D002810  106001B3   BEQ V1, ZERO, 0x9D002EE0
9D002814  AC60000C   SW ZERO, 12(V1)
171:                 					return JSMN_ERROR_NOMEM;
9D002ED8  0B400BC4   J 0x9D002F10
9D002EDC  2402FFFF   ADDIU V0, ZERO, -1
9D002EE0  0B400BC4   J 0x9D002F10
9D002EE4  2402FFFF   ADDIU V0, ZERO, -1
172:                 				if (parser->toksuper != -1) {
9D002818  8C890008   LW T1, 8(A0)
9D00281C  11280005   BEQ T1, T0, 0x9D002834
9D002820  00094900   SLL T1, T1, 4
173:                 					tokens[parser->toksuper].size++;
9D002824  00E94821   ADDU T1, A3, T1
9D002828  8D2A000C   LW T2, 12(T1)
9D00282C  254A0001   ADDIU T2, T2, 1
9D002830  AD2A000C   SW T2, 12(T1)
174:                 #ifdef JSMN_PARENT_LINKS
175:                 					token->parent = parser->toksuper;
176:                 #endif
177:                 				}
178:                 				token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
9D002834  3BDE007B   XORI S8, S8, 123
9D002838  02605821   ADDU T3, S3, ZERO
9D00283C  029E580B   MOVN T3, S4, S8
9D002840  AC6B0000   SW T3, 0(V1)
179:                 				token->start = parser->pos;
9D002844  8C890000   LW T1, 0(A0)
9D002848  AC690004   SW T1, 4(V1)
180:                 				parser->toksuper = parser->toknext - 1;
9D00284C  8C830004   LW V1, 4(A0)
9D002850  2463FFFF   ADDIU V1, V1, -1
181:                 				break;
9D002854  0B400B95   J 0x9D002E54
9D002858  AC830008   SW V1, 8(A0)
182:                 			case '}': case ']':
183:                 				if (tokens == NULL)
9D00285C  10E0017D   BEQ A3, ZERO, 0x9D002E54
9D002860  03D9F026   XOR S8, S8, T9
184:                 					break;
185:                 				type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
9D0025E4  24140002   ADDIU S4, ZERO, 2
9D002864  02606821   ADDU T5, S3, ZERO
9D002868  029E680B   MOVN T5, S4, S8
186:                 #ifdef JSMN_PARENT_LINKS
187:                 				if (parser->toknext < 1) {
188:                 					return JSMN_ERROR_INVAL;
189:                 				}
190:                 				token = &tokens[parser->toknext - 1];
191:                 				for (;;) {
192:                 					if (token->start != -1 && token->end == -1) {
193:                 						if (token->type != type) {
194:                 							return JSMN_ERROR_INVAL;
195:                 						}
196:                 						token->end = parser->pos + 1;
197:                 						parser->toksuper = token->parent;
198:                 						break;
199:                 					}
200:                 					if (token->parent == -1) {
201:                 						break;
202:                 					}
203:                 					token = &tokens[token->parent];
204:                 				}
205:                 #else
206:                 				for (i = parser->toknext - 1; i >= 0; i--) {
9D00286C  8C890004   LW T1, 4(A0)
9D002870  2523FFFF   ADDIU V1, T1, -1
9D002874  046001A0   BLTZ V1, 0x9D002EF8
9D002878  01A0F021   ADDU S8, T5, ZERO
9D0028C4  2463FFFF   ADDIU V1, V1, -1
9D0028C8  0461FFF0   BGEZ V1, 0x9D00288C
9D0028CC  2529FFF0   ADDIU T1, T1, -16
9D0028D0  0B400BBE   J 0x9D002EF8
9D0028D4  00000000   NOP
207:                 					token = &tokens[i];
208:                 					if (token->start != -1 && token->end == -1) {
9D00287C  01354821   ADDU T1, T1, S5
9D002880  00094900   SLL T1, T1, 4
9D002884  00E94821   ADDU T1, A3, T1
9D002888  25290004   ADDIU T1, T1, 4
9D00288C  8D2B0000   LW T3, 0(T1)
9D002890  1168000C   BEQ T3, T0, 0x9D0028C4
9D002894  252DFFFC   ADDIU T5, T1, -4
9D002898  8D2B0004   LW T3, 4(T1)
9D00289C  5568000A   BNEL T3, T0, 0x9D0028C8
9D0028A0  2463FFFF   ADDIU V1, V1, -1
209:                 						if (token->type != type) {
9D0028A4  8D29FFFC   LW T1, -4(T1)
9D0028A8  17C9018F   BNE S8, T1, 0x9D002EE8
9D0028AC  254A0001   ADDIU T2, T2, 1
210:                 							return JSMN_ERROR_INVAL;
9D002EE8  0B400BC4   J 0x9D002F10
9D002EEC  2402FFFE   ADDIU V0, ZERO, -2
211:                 						}
212:                 						parser->toksuper = -1;
9D0028B0  AC880008   SW T0, 8(A0)
213:                 						token->end = parser->pos + 1;
214:                 						break;
215:                 					}
216:                 				}
217:                 				/* Error if unmatched closing bracket */
218:                 				if (i == -1) 
9D0028B4  14680008   BNE V1, T0, 0x9D0028D8
9D0028B8  ADAA0008   SW T2, 8(T5)
9D0028BC  0B400BBC   J 0x9D002EF0
9D0028C0  2402FFFE   ADDIU V0, ZERO, -2
9D002EF8  5468FFD7   BNEL V1, T0, 0x9D002E58
9D002EFC  8C8A0000   LW T2, 0(A0)
9D002F00  0B400BC4   J 0x9D002F10
9D002F04  2402FFFE   ADDIU V0, ZERO, -2
219:                                     return JSMN_ERROR_INVAL;
220:                 				for (; i >= 0; i--) {
9D0028D8  0460015E   BLTZ V1, 0x9D002E54
9D0028DC  00034900   SLL T1, V1, 4
9D002908  1468FFF7   BNE V1, T0, 0x9D0028E8
9D00290C  2529FFF0   ADDIU T1, T1, -16
9D002910  0B400B96   J 0x9D002E58
9D002914  8C8A0000   LW T2, 0(A0)
221:                 					token = &tokens[i];
222:                 					if (token->start != -1 && token->end == -1) {
9D0028E0  00E94821   ADDU T1, A3, T1
9D0028E4  25290004   ADDIU T1, T1, 4
9D0028E8  8D2A0000   LW T2, 0(T1)
9D0028EC  51480006   BEQL T2, T0, 0x9D002908
9D0028F0  2463FFFF   ADDIU V1, V1, -1
9D0028F4  8D2A0004   LW T2, 4(T1)
9D0028F8  55480003   BNEL T2, T0, 0x9D002908
9D0028FC  2463FFFF   ADDIU V1, V1, -1
223:                 						parser->toksuper = i;
224:                 						break;
9D002900  0B400B95   J 0x9D002E54
9D002904  AC830008   SW V1, 8(A0)
225:                 					}
226:                 				}
227:                 #endif
228:                 				break;
229:                 			case '\"':
230:                 				r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
231:                 				if (r < 0) return r;
232:                 				count++;
9D002F08  0B400B95   J 0x9D002E54
9D002F0C  24420001   ADDIU V0, V0, 1
233:                 				if (parser->toksuper != -1 && tokens != NULL)
9D0029A8  8C830008   LW V1, 8(A0)
9D0029AC  1468009E   BNE V1, T0, 0x9D002C28
9D0029B0  24420001   ADDIU V0, V0, 1
234:                 					tokens[parser->toksuper].size++;
9D002C28  00031900   SLL V1, V1, 4
9D002C2C  00E31821   ADDU V1, A3, V1
9D002C30  8C69000C   LW T1, 12(V1)
9D002C34  25290001   ADDIU T1, T1, 1
9D002C38  0B400B95   J 0x9D002E54
9D002C3C  AC69000C   SW T1, 12(V1)
235:                 				break;
236:                 			case '\t' : case '\r' : case '\n' : case ' ':
237:                 				break;
238:                 			case ':':
239:                 				parser->toksuper = parser->toknext - 1;
9D002C40  8C830004   LW V1, 4(A0)
9D002C44  2463FFFF   ADDIU V1, V1, -1
240:                 				break;
9D002C48  0B400B95   J 0x9D002E54
9D002C4C  AC830008   SW V1, 8(A0)
241:                 			case ',':
242:                 				if (tokens != NULL && parser->toksuper != -1 &&
9D002C50  50E00081   BEQL A3, ZERO, 0x9D002E58
9D002C54  8C8A0000   LW T2, 0(A0)
9D002C58  8C830008   LW V1, 8(A0)
9D002C5C  1068007D   BEQ V1, T0, 0x9D002E54
9D002C60  00031900   SLL V1, V1, 4
243:                 						tokens[parser->toksuper].type != JSMN_ARRAY &&
9D002C64  00E31821   ADDU V1, A3, V1
9D002C68  8C630000   LW V1, 0(V1)
9D002C6C  2463FFFF   ADDIU V1, V1, -1
9D002C70  2C630002   SLTIU V1, V1, 2
9D002C74  54600078   BNEL V1, ZERO, 0x9D002E58
9D002C78  8C8A0000   LW T2, 0(A0)
244:                 						tokens[parser->toksuper].type != JSMN_OBJECT) {
245:                 #ifdef JSMN_PARENT_LINKS
246:                 					parser->toksuper = tokens[parser->toksuper].parent;
247:                 #else
248:                 					for (i = parser->toknext - 1; i >= 0; i--) {
9D002C7C  8C830004   LW V1, 4(A0)
9D002C80  2469FFFF   ADDIU T1, V1, -1
9D002C84  05200073   BLTZ T1, 0x9D002E54
9D002C88  00751821   ADDU V1, V1, S5
9D002CC8  0521FFF2   BGEZ T1, 0x9D002C94
9D002CCC  2463FFF0   ADDIU V1, V1, -16
9D002CD0  0B400B96   J 0x9D002E58
9D002CD4  8C8A0000   LW T2, 0(A0)
249:                 						if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
9D0025CC  3C150FFF   LUI S5, 4095
9D0025D0  36B5FFFF   ORI S5, S5, -1
9D002C8C  00031900   SLL V1, V1, 4
9D002C90  00E31821   ADDU V1, A3, V1
9D002C94  8C6A0000   LW T2, 0(V1)
9D002C98  254AFFFF   ADDIU T2, T2, -1
9D002C9C  2D4A0002   SLTIU T2, T2, 2
9D002CA0  51400009   BEQL T2, ZERO, 0x9D002CC8
9D002CA4  2529FFFF   ADDIU T1, T1, -1
250:                 							if (tokens[i].start != -1 && tokens[i].end == -1) {
9D002CA8  8C6A0004   LW T2, 4(V1)
9D002CAC  51480006   BEQL T2, T0, 0x9D002CC8
9D002CB0  2529FFFF   ADDIU T1, T1, -1
9D002CB4  8C6A0008   LW T2, 8(V1)
9D002CB8  55480003   BNEL T2, T0, 0x9D002CC8
9D002CBC  2529FFFF   ADDIU T1, T1, -1
251:                 								parser->toksuper = i;
252:                 								break;
9D002CC0  0B400B95   J 0x9D002E54
9D002CC4  AC890008   SW T1, 8(A0)
253:                 							}
254:                 						}
255:                 					}
256:                 #endif
257:                 				}
258:                 				break;
259:                 #ifdef JSMN_STRICT
260:                 			/* In strict mode primitives are: numbers and booleans */
261:                 			case '-': case '0': case '1' : case '2': case '3' : case '4':
262:                 			case '5': case '6': case '7' : case '8': case '9':
263:                 			case 't': case 'f': case 'n' :
264:                 				/* And they must not be keys of the object */
265:                 				if (tokens != NULL && parser->toksuper != -1) {
9D002CD8  50E0000E   BEQL A3, ZERO, 0x9D002D14
9D002CDC  8C890000   LW T1, 0(A0)
9D002CE0  8C830008   LW V1, 8(A0)
9D002CE4  1068000A   BEQ V1, T0, jsmn_parse_primitive
9D002CE8  00031900   SLL V1, V1, 4
266:                 					jsmntok_t *t = &tokens[parser->toksuper];
9D002CEC  00E31821   ADDU V1, A3, V1
267:                 					if (t->type == JSMN_OBJECT ||
9D0025C4  24130001   ADDIU S3, ZERO, 1
9D0025C8  24170003   ADDIU S7, ZERO, 3
9D002CF0  8C690000   LW T1, 0(V1)
9D002CF4  51330086   BEQL T1, S3, 0x9D002F10
9D002CF8  2402FFFE   ADDIU V0, ZERO, -2
9D002CFC  55370005   BNEL T1, S7, 0x9D002D14
9D002D00  8C890000   LW T1, 0(A0)
268:                 							(t->type == JSMN_STRING && t->size != 0)) {
9D002D04  8C63000C   LW V1, 12(V1)
9D002D08  54600081   BNEL V1, ZERO, 0x9D002F10
9D002D0C  2402FFFE   ADDIU V0, ZERO, -2
269:                 						return JSMN_ERROR_INVAL;
270:                 					}
271:                 				}
272:                 #else
273:                 			/* In non-strict mode every unquoted value is a primitive */
274:                 			default:
275:                 #endif
276:                 				r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
277:                 				if (r < 0) return r;
278:                 				count++;
9D002DD0  0B400B95   J 0x9D002E54
9D002DD4  24420001   ADDIU V0, V0, 1
279:                 				if (parser->toksuper != -1 && tokens != NULL)
9D002E34  8C830008   LW V1, 8(A0)
9D002E38  10680006   BEQ V1, T0, 0x9D002E54
9D002E3C  24420001   ADDIU V0, V0, 1
280:                 					tokens[parser->toksuper].size++;
9D002E40  00031900   SLL V1, V1, 4
9D002E44  00E31821   ADDU V1, A3, V1
9D002E48  8C69000C   LW T1, 12(V1)
9D002E4C  25290001   ADDIU T1, T1, 1
9D002E50  AC69000C   SW T1, 12(V1)
281:                 				break;
282:                 
283:                 #ifdef JSMN_STRICT
284:                 			/* Unexpected char in strict mode */
285:                 			default:
286:                 				return JSMN_ERROR_INVAL;
9D002ED0  0B400BC4   J 0x9D002F10
9D002ED4  2402FFFE   ADDIU V0, ZERO, -2
287:                 #endif
288:                 		}
289:                 	}
290:                 
291:                 	if (tokens != NULL) {
9D002E78  50E00026   BEQL A3, ZERO, 0x9D002F14
9D002E7C  8FBE0024   LW S8, 36(SP)
292:                 		for (i = parser->toknext - 1; i >= 0; i--) {
9D002E80  8C840004   LW A0, 4(A0)
9D002E84  2483FFFF   ADDIU V1, A0, -1
9D002E88  04600021   BLTZ V1, 0x9D002F10
9D002E8C  3C050FFF   LUI A1, 4095
9D002EC0  0461FFF9   BGEZ V1, 0x9D002EA8
9D002EC4  24E7FFF0   ADDIU A3, A3, -16
9D002EC8  0B400BC5   J 0x9D002F14
9D002ECC  8FBE0024   LW S8, 36(SP)
293:                 			/* Unmatched opened object or array */
294:                 			if (tokens[i].start != -1 && tokens[i].end == -1) {
9D002E90  34A5FFFF   ORI A1, A1, -1
9D002E94  00852021   ADDU A0, A0, A1
9D002E98  00042100   SLL A0, A0, 4
9D002E9C  00E43821   ADDU A3, A3, A0
9D002EA0  24E70004   ADDIU A3, A3, 4
9D002EA4  2405FFFF   ADDIU A1, ZERO, -1
9D002EA8  8CE40000   LW A0, 0(A3)
9D002EAC  10850004   BEQ A0, A1, 0x9D002EC0
9D002EB0  2463FFFF   ADDIU V1, V1, -1
9D002EB4  8CE40004   LW A0, 4(A3)
9D002EB8  50850015   BEQL A0, A1, 0x9D002F10
9D002EBC  2402FFFD   ADDIU V0, ZERO, -3
295:                 				return JSMN_ERROR_PART;
296:                 			}
297:                 		}
298:                 	}
299:                 
300:                 	return count;
301:                 }
9D002EF0  0B400BC5   J 0x9D002F14
9D002EF4  8FBE0024   LW S8, 36(SP)
9D002F10  8FBE0024   LW S8, 36(SP)
9D002F14  8FB70020   LW S7, 32(SP)
9D002F18  8FB6001C   LW S6, 28(SP)
9D002F1C  8FB50018   LW S5, 24(SP)
9D002F20  8FB40014   LW S4, 20(SP)
9D002F24  8FB30010   LW S3, 16(SP)
9D002F28  8FB2000C   LW S2, 12(SP)
9D002F2C  8FB10008   LW S1, 8(SP)
9D002F30  8FB00004   LW S0, 4(SP)
9D002F34  03E00008   JR RA
9D002F38  27BD0028   ADDIU SP, SP, 40
302:                 
303:                 /**
304:                  * Creates a new parser based over a given  buffer with an array of tokens
305:                  * available.
306:                  */
307:                 void jsmn_init(jsmn_parser *parser) {
308:                 	parser->pos = 0;
9D00DCB0  AC800000   SW ZERO, 0(A0)
309:                 	parser->toknext = 0;
9D00DCB4  AC800004   SW ZERO, 4(A0)
310:                 	parser->toksuper = -1;
9D00DCB8  2402FFFF   ADDIU V0, ZERO, -1
9D00DCBC  03E00008   JR RA
9D00DCC0  AC820008   SW V0, 8(A0)
311:                 }
312:                 
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/grid_handler.c  -----------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       grid_handler.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "grid_handler.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  GRID_HANDLER_DATA grid_handlerData;
80:                  static uint8_t world[MAPDIM][MAPDIM];
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  // Section: Application Callback Functions
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  
87:                  /* TODO:  Add any necessary callback functions.
88:                  */
89:                  
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Application Local Functions
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  
96:                  
97:                  /* TODO:  Add any necessary local functions.
98:                  */
99:                  QueueHandle_t GRID_Q;
100:                 
101:                 
102:                 void GRID_Qinit ()
103:                 {
9D00D920  27BDFFE8   ADDIU SP, SP, -24
9D00D924  AFBF0014   SW RA, 20(SP)
104:                     GRID_Q = xQueueCreate (5, sizeof (PING_DATA_t));
9D00D928  24040005   ADDIU A0, ZERO, 5
9D00D92C  24050004   ADDIU A1, ZERO, 4
9D00D930  0F402DB4   JAL xQueueGenericCreate
9D00D934  00003021   ADDU A2, ZERO, ZERO
9D00D938  AF8280F0   SW V0, -32528(GP)
105:                 }
9D00D93C  8FBF0014   LW RA, 20(SP)
9D00D940  03E00008   JR RA
9D00D944  27BD0018   ADDIU SP, SP, 24
106:                 
107:                 void GRID_QSend(PING_DATA_t byte)
108:                 {
9D00D848  27BDFFE8   ADDIU SP, SP, -24
9D00D84C  AFBF0014   SW RA, 20(SP)
9D00D850  AFA40018   SW A0, 24(SP)
109:                     xQueueSend(GRID_Q, &byte, portMAX_DELAY);
9D00D854  8F8480F0   LW A0, -32528(GP)
9D00D858  27A50018   ADDIU A1, SP, 24
9D00D85C  2406FFFF   ADDIU A2, ZERO, -1
9D00D860  0F40199A   JAL xQueueGenericSend
9D00D864  00003821   ADDU A3, ZERO, ZERO
110:                 }
9D00D868  8FBF0014   LW RA, 20(SP)
9D00D86C  03E00008   JR RA
9D00D870  27BD0018   ADDIU SP, SP, 24
111:                 
112:                 void GRID_QSendFromISR (PING_DATA_t tmrvals)
113:                 {
00000000  00000000   NOP
114:                     /* Check for whether the task needs to do a context switch */
115:                     BaseType_t conSwitch;
116:                     conSwitch = pdFALSE;
0000000C  00000000   NOP
117:                     
118:                     /* Send to the Queue from an ISR */
119:                     if ((xQueueOverwriteFromISR (GRID_Q, &tmrvals, &conSwitch)) == errQUEUE_FULL) {
00000010  00000000   NOP
120:                         PLIB_PORTS_Write (PORTS_ID_0, PORT_CHANNEL_E, 0x00FA);
121:                 //        xQueueReset(Q);
122:                     }
123:                     
124:                     /* Switch if needed */
125:                     portEND_SWITCHING_ISR(conSwitch);
0000003C  00000000   NOP
126:                 }
00000058  00000000   NOP
127:                 
128:                 void GRID_QReceive (PING_DATA_t *ret)
129:                 {
9D00D948  27BDFFE8   ADDIU SP, SP, -24
9D00D94C  AFBF0014   SW RA, 20(SP)
9D00D950  00802821   ADDU A1, A0, ZERO
130:                     
131:                     xQueueReceive (GRID_Q, ret, portMAX_DELAY);
9D00D954  8F8480F0   LW A0, -32528(GP)
9D00D958  2406FFFF   ADDIU A2, ZERO, -1
9D00D95C  0F40165D   JAL xQueueGenericReceive
9D00D960  00003821   ADDU A3, ZERO, ZERO
132:                     
133:                 }
9D00D964  8FBF0014   LW RA, 20(SP)
9D00D968  03E00008   JR RA
9D00D96C  27BD0018   ADDIU SP, SP, 24
134:                 
135:                 
136:                 // *****************************************************************************
137:                 // *****************************************************************************
138:                 // Section: Application Initialization and State Machine Functions
139:                 // *****************************************************************************
140:                 // *****************************************************************************
141:                 
142:                 /*******************************************************************************
143:                   Function:
144:                     void GRID_HANDLER_Initialize ( void )
145:                 
146:                   Remarks:
147:                     See prototype in grid_handler.h.
148:                  */
149:                 
150:                 void GRID_HANDLER_Initialize ( void )
151:                 {
9D00DA64  27BDFFE8   ADDIU SP, SP, -24
9D00DA68  AFBF0014   SW RA, 20(SP)
152:                     /* Place the App state machine in its initial state. */
153:                     grid_handlerData.state = GRID_HANDLER_STATE_INIT;
154:                 
155:                     
156:                     /* TODO: Initialize your application's state machine and other
157:                      * parameters.
158:                      */
159:                     GRID_Qinit();
9D00DA6C  0F403648   JAL GRID_Qinit
9D00DA70  AF8080F4   SW ZERO, -32524(GP)
160:                 }
9D00DA74  8FBF0014   LW RA, 20(SP)
9D00DA78  03E00008   JR RA
9D00DA7C  27BD0018   ADDIU SP, SP, 24
161:                 
162:                 
163:                 /******************************************************************************
164:                   Function:
165:                     void GRID_HANDLER_Tasks ( void )
166:                 
167:                   Remarks:
168:                     See prototype in grid_handler.h.
169:                  */
170:                 uint8_t msgCount;
171:                 
172:                 void GRID_HANDLER_Tasks ( void )
173:                 {
9D005208  27BDE818   ADDIU SP, SP, -6120
9D00520C  AFBF17E4   SW RA, 6116(SP)
9D005210  AFB217E0   SW S2, 6112(SP)
9D005214  AFB117DC   SW S1, 6108(SP)
9D005218  AFB017D8   SW S0, 6104(SP)
174:                 
175:                     /* Check the application's current state. */
176:                     switch ( grid_handlerData.state )
9D00521C  8F8280F4   LW V0, -32524(GP)
9D005220  10400005   BEQ V0, ZERO, 0x9D005238
9D005224  24030001   ADDIU V1, ZERO, 1
9D005228  10430006   BEQ V0, V1, 0x9D005244
9D00522C  8FBF17E4   LW RA, 6116(SP)
177:                     {
178:                         /* Application's initial state. */
179:                         case GRID_HANDLER_STATE_INIT:
180:                         {
181:                             bool appInitialized = true;
182:                        
183:                         
184:                             if (appInitialized)
185:                             {
186:                             
187:                                 grid_handlerData.state = GRID_HANDLER_STATE_SERVICE_TASKS;
9D005238  24020001   ADDIU V0, ZERO, 1
9D00523C  0B40151D   J 0x9D005474
9D005240  AF8280F4   SW V0, -32524(GP)
188:                             }
189:                             break;
190:                         }
191:                 
192:                         case GRID_HANDLER_STATE_SERVICE_TASKS:
193:                         {
194:                             PING_DATA_t data;
195:                             GRID_QReceive(&data);
9D005244  0F403652   JAL GRID_QReceive
9D005248  27A417D0   ADDIU A0, SP, 6096
196:                             uint8_t grid[18][18];
197:                             int x, y;
198:                             for(x = 0; x < 18; x++){
9D00526C  0B4014BA   J 0x9D0052E8
9D005270  240FFFF4   ADDIU T7, ZERO, -12
9D005274  00401821   ADDU V1, V0, ZERO
9D0052D0  156F0005   BNE T3, T7, 0x9D0052E8
9D0052D4  25CE0012   ADDIU T6, T6, 18
9D0052D8  27A50F80   ADDIU A1, SP, 3968
9D0052DC  27A71490   ADDIU A3, SP, 5264
199:                                 for(y = 0; y < 18; y++){
9D005268  24080012   ADDIU T0, ZERO, 18
9D0052C0  24840001   ADDIU A0, A0, 1
9D0052C4  1488FFEB   BNE A0, T0, 0x9D005274
9D0052C8  24420001   ADDIU V0, V0, 1
9D0052CC  256BFFFF   ADDIU T3, T3, -1
200:                                     grid[x][y] = 0;
201:                                     if(y > 2*(abs(6-x))){//left sensor
9D005278  00E4282A   SLT A1, A3, A0
9D00527C  10A00005   BEQ A1, ZERO, 0x9D005294
9D005280  A0400000   SB ZERO, 0(V0)
9D0052E8  000B17C3   SRA V0, T3, 31
9D0052EC  004B1826   XOR V1, V0, T3
9D0052F0  00621023   SUBU V0, V1, V0
9D0052F4  00023840   SLL A3, V0, 1
9D0052F8  25630006   ADDIU V1, T3, 6
202:                                         if(y > data.left){
9D00524C  93AA17D0   LBU T2, 6096(SP)
9D005284  0144282A   SLT A1, T2, A0
9D005288  50A00002   BEQL A1, ZERO, 0x9D005294
9D00528C  A04D0000   SB T5, 0(V0)
9D005290  A04C0000   SB T4, 0(V0)
203:                                             grid[x][y] += THING;
9D005264  240C0003   ADDIU T4, ZERO, 3
204:                                         }
205:                                         else{
206:                                             grid[x][y] += EMPTY;
9D005260  240DFFFE   ADDIU T5, ZERO, -2
207:                                         }
208:                                     }
209:                                     if(y > 2*(abs(12-x))){//right sensor
9D005294  00C4282A   SLT A1, A2, A0
9D005298  50A0000A   BEQL A1, ZERO, 0x9D0052C4
9D00529C  24840001   ADDIU A0, A0, 1
9D0052FC  000317C3   SRA V0, V1, 31
9D005300  00431826   XOR V1, V0, V1
9D005304  00621023   SUBU V0, V1, V0
9D005308  00023040   SLL A2, V0, 1
9D00530C  01C01021   ADDU V0, T6, ZERO
9D005310  0B40149D   J 0x9D005274
9D005314  00002021   ADDU A0, ZERO, ZERO
9D005318  00A21821   ADDU V1, A1, V0
210:                                         if(y > data.right){
9D005250  93A917D1   LBU T1, 6097(SP)
9D005254  27B0168C   ADDIU S0, SP, 5772
9D005258  02007021   ADDU T6, S0, ZERO
9D00525C  240B0006   ADDIU T3, ZERO, 6
9D0052A0  0124282A   SLT A1, T1, A0
9D0052A4  10A00004   BEQ A1, ZERO, 0x9D0052B8
9D0052A8  90650000   LBU A1, 0(V1)
9D005348  0B4014C6   J 0x9D005318
9D00534C  00001021   ADDU V0, ZERO, ZERO
9D005350  00E21821   ADDU V1, A3, V0
9D005354  00C22821   ADDU A1, A2, V0
9D005374  0B4014D4   J 0x9D005350
9D005378  00801021   ADDU V0, A0, ZERO
211:                                             grid[x][y] += THING;
9D0052AC  24A50003   ADDIU A1, A1, 3
9D0052B0  0B4014B0   J 0x9D0052C0
9D0052B4  A0650000   SB A1, 0(V1)
212:                                         }
213:                                         else{
214:                                             grid[x][y] += EMPTY;
9D0052B8  24A5FFFE   ADDIU A1, A1, -2
9D0052BC  A0650000   SB A1, 0(V1)
215:                                         }
216:                                     }
217:                                 }
218:                             }
219:                             uint8_t relGrid[GRID_SIZE][GRID_SIZE];
220:                             for (x = 0; x < GRID_SIZE; x++){
9D00532C  54A7FFFA   BNEL A1, A3, 0x9D005318
9D005330  00001021   ADDU V0, ZERO, ZERO
9D005334  27A6172E   ADDIU A2, SP, 5934
9D005338  27A710C4   ADDIU A3, SP, 4292
9D00533C  260901E6   ADDIU T1, S0, 486
221:                                 for (y = 0; y < GRID_SIZE; y++){
9D0052E0  0B4014D2   J 0x9D005348
9D0052E4  24060024   ADDIU A2, ZERO, 36
9D00531C  24420001   ADDIU V0, V0, 1
9D005320  1446FFFD   BNE V0, A2, 0x9D005318
9D005324  A0600000   SB ZERO, 0(V1)
9D005328  24A50024   ADDIU A1, A1, 36
222:                                     relGrid[x][y] = 0;
223:                                 }
224:                             }
225:                             uint8_t half_offset = (GRID_SIZE - 18)/2;
226:                             for(x = half_offset; x < (GRID_SIZE - half_offset); x++){
9D00536C  10C90003   BEQ A2, T1, 0x9D00537C
9D005370  24E70024   ADDIU A3, A3, 36
227:                                 for(y = GRID_SIZE - 18; y < GRID_SIZE; y++){
9D005340  0B4014DD   J 0x9D005374
9D005344  24080024   ADDIU T0, ZERO, 36
9D00535C  24420001   ADDIU V0, V0, 1
9D005360  1448FFFB   BNE V0, T0, 0x9D005350
9D005364  A0650000   SB A1, 0(V1)
9D005368  24C60012   ADDIU A2, A2, 18
228:                                     relGrid[x][y] = grid[x - half_offset][y - (GRID_SIZE - 18)];
9D005358  90A5FF4C   LBU A1, -180(A1)
229:                                 }
230:                             }
231:                             GRID_ITEM_t absGridData[GRID_SIZE][GRID_SIZE];
232:                             transposeRelativeToAbsolute(relGrid, GRID_SIZE, robot_x, robot_y, robot_theta, absGridData);
9D00537C  93868011   LBU A2, -32751(GP)
9D005380  93878010   LBU A3, -32752(GP)
9D005384  8782803A   LH V0, -32710(GP)
9D005388  AFA20010   SW V0, 16(SP)
9D00538C  27B10050   ADDIU S1, SP, 80
9D005390  AFB10014   SW S1, 20(SP)
9D005394  27A40F80   ADDIU A0, SP, 3968
9D005398  0F4015C1   JAL transposeRelativeToAbsolute
9D00539C  24050024   ADDIU A1, ZERO, 36
233:                             updateMyWorld(absGridData, world);
9D0053A0  02202021   ADDU A0, S1, ZERO
9D0053A4  3C11A001   LUI S1, -24575
9D0053A8  0F40236F   JAL updateMyWorld
9D0053AC  26254F64   ADDIU A1, S1, 20324
234:                             classifyObjects(world, msgCount);
9D0053B0  26244F64   ADDIU A0, S1, 20324
9D0053B4  0F400D60   JAL classifyObjects
9D0053B8  938580EC   LBU A1, -32532(GP)
235:                             msgCount++;
9D0053BC  938280EC   LBU V0, -32532(GP)
9D0053C0  24420001   ADDIU V0, V0, 1
9D0053C4  A38280EC   SB V0, -32532(GP)
9D0053C8  27B1169D   ADDIU S1, SP, 5789
236:                             messageItem_t debug;
237:                             for(y = 17; y > 0; y--){
9D00546C  1630FFD9   BNE S1, S0, 0x9D0053D4
9D005470  AFA21684   SW V0, 5764(SP)
238:                                 debug.msgSize = sprintf(debug.payload, "%3i %3i %3i %3i %3i %3i %3i %3i %3i %3i %3i %3i %3i %3i %3i %3i %3i %3i \r\n", 
9D0053CC  3C129D01   LUI S2, -25343
9D0053D0  2652CF60   ADDIU S2, S2, -12448
9D0053D4  92260000   LBU A2, 0(S1)
9D0053D8  92270012   LBU A3, 18(S1)
9D0053DC  92220024   LBU V0, 36(S1)
9D0053E0  AFA20010   SW V0, 16(SP)
9D0053E4  92220036   LBU V0, 54(S1)
9D0053E8  AFA20014   SW V0, 20(SP)
9D0053EC  92220048   LBU V0, 72(S1)
9D0053F0  AFA20018   SW V0, 24(SP)
9D0053F4  9222005A   LBU V0, 90(S1)
9D0053F8  AFA2001C   SW V0, 28(SP)
9D0053FC  9222006C   LBU V0, 108(S1)
9D005400  AFA20020   SW V0, 32(SP)
9D005404  9222007E   LBU V0, 126(S1)
9D005408  AFA20024   SW V0, 36(SP)
9D00540C  92220090   LBU V0, 144(S1)
9D005410  AFA20028   SW V0, 40(SP)
9D005414  922200A2   LBU V0, 162(S1)
9D005418  AFA2002C   SW V0, 44(SP)
9D00541C  922200B4   LBU V0, 180(S1)
9D005420  AFA20030   SW V0, 48(SP)
9D005424  922200C6   LBU V0, 198(S1)
9D005428  AFA20034   SW V0, 52(SP)
9D00542C  922200D8   LBU V0, 216(S1)
9D005430  AFA20038   SW V0, 56(SP)
9D005434  922200EA   LBU V0, 234(S1)
9D005438  AFA2003C   SW V0, 60(SP)
9D00543C  922200FC   LBU V0, 252(S1)
9D005440  AFA20040   SW V0, 64(SP)
9D005444  9222010E   LBU V0, 270(S1)
9D005448  AFA20044   SW V0, 68(SP)
9D00544C  92220120   LBU V0, 288(S1)
9D005450  AFA20048   SW V0, 72(SP)
9D005454  92220132   LBU V0, 306(S1)
9D005458  AFA2004C   SW V0, 76(SP)
9D00545C  27A41490   ADDIU A0, SP, 5264
9D005460  0F4031ED   JAL _sprintf_cdfFnopsuxX
9D005464  02402821   ADDU A1, S2, ZERO
9D005468  2631FFFF   ADDIU S1, S1, -1
239:                                         grid[0][y], grid[1][y], grid[2][y],
240:                                         grid[3][y], grid[4][y], grid[5][y],
241:                                         grid[6][y], grid[7][y], grid[8][y],
242:                                         grid[9][y], grid[10][y], grid[11][y],
243:                                         grid[12][y], grid[13][y], grid[14][y],
244:                                         grid[15][y], grid[16][y], grid[17][y]
245:                                         );
246:                                 //SendMessageForTransmitQ(debug);
247:                             }
248:                             break;
249:                         }
250:                 
251:                         /* TODO: implement your application state machine.*/
252:                         
253:                 
254:                         /* The default state should never be executed. */
255:                         default:
256:                         {
257:                             /* TODO: Handle error in application's state machine. */
258:                             break;
259:                         }
260:                     }
261:                 }
9D005230  0B40151F   J 0x9D00547C
9D005234  8FB217E0   LW S2, 6112(SP)
9D005474  8FBF17E4   LW RA, 6116(SP)
9D005478  8FB217E0   LW S2, 6112(SP)
9D00547C  8FB117DC   LW S1, 6108(SP)
9D005480  8FB017D8   LW S0, 6104(SP)
9D005484  03E00008   JR RA
9D005488  27BD17E8   ADDIU SP, SP, 6120
262:                 
263:                  
264:                 
265:                 /*******************************************************************************
266:                  End of File
267:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/grid_algortihms.c  --------
1:                   
2:                   #include "grid_algorithms.h"
3:                   
4:                   
5:                   ////////////////////////////////////////////////////////////////////////////////
6:                   ///
7:                   ///
8:                   ///
9:                   void printMap(uint8_t worldMap[][MAPDIM])
10:                  {
00000000  00000000   NOP
00000020  00000000   NOP
11:                    int i, j;
12:                    for(j = 0; j < MAPDIM; j++){
00000018  00000000   NOP
13:                      for(i = 0; i < MAPDIM; i++){
0000000C  00000000   NOP
14:                        //world[i][j] = 40;
15:                        //// fprintf(stdout, "%2i,%2i,%2i ", i, j, world[i][j]);
16:                        // fprintf(stdout, "%3i ", worldMap[i][MAPDIM - j - 1]);
17:                      }
18:                      // fprintf(stdout, "\n");
19:                    }
20:                  }
21:                  
22:                  ////////////////////////////////////////////////////////////////////////////////
23:                  ///
24:                  ///
25:                  ///
26:                  void printRel(uint8_t relGrid[][GRID_SIZE])
27:                  {
00000000  00000000   NOP
00000020  00000000   NOP
28:                    int i, j;
29:                    for(i = 0; i < GRID_SIZE; i++){
00000018  00000000   NOP
30:                      for(j = 0; j < GRID_SIZE; j++){
0000000C  00000000   NOP
31:                        // fprintf(stdout, "%3i, ", relGrid[i][j]);
32:                      }
33:                      // fprintf(stdout, "\n");
34:                      //// fprintf(stdout, "%i, %i, %i, %i\n", test_grid[i][0], test_grid[i][1], test_grid[i][2], test_grid[i][3]);
35:                    }
36:                  }
37:                  
38:                  uint8_t buf[512];
39:                  ////////////////////////////////////////////////////////////////////////////////
40:                  ///
41:                  ///
42:                  ///
43:                  void transmitObstacle(OBSTACLE_t object, uint8_t msgID)
44:                  {
9D00A6C0  27BDFBF8   ADDIU SP, SP, -1032
9D00A6C4  AFBF0404   SW RA, 1028(SP)
9D00A6C8  AFA40408   SW A0, 1032(SP)
9D00A6CC  AFA5040C   SW A1, 1036(SP)
9D00A6D0  30C700FF   ANDI A3, A2, 255
45:                    // fprintf(stdout, "TRANSMITTING OBSTACLE\n\n");
46:                    //uint8_t buf[512];
47:                    messageItem_t debug;
48:                    debug.msgSize = sprintf(debug.payload,"{response: { source: TargetLocator, Dest: %s, ID: %i, Type: Obstacle, {x: %i, y: %i, length: %i, width: %i, theta: %i}}}", "PATH", msgID, object.x_center, object.y_center, object.length, object.width, object.theta);
9D00A6D4  308200FF   ANDI V0, A0, 255
9D00A6D8  AFA20010   SW V0, 16(SP)
9D00A6DC  7C823A00   EXT V0, A0, 8, 8
9D00A6E0  AFA20014   SW V0, 20(SP)
9D00A6E4  30A200FF   ANDI V0, A1, 255
9D00A6E8  AFA20018   SW V0, 24(SP)
9D00A6EC  7CA53A00   EXT A1, A1, 8, 8
9D00A6F0  AFA5001C   SW A1, 28(SP)
9D00A6F4  00042403   SRA A0, A0, 16
9D00A6F8  AFA40020   SW A0, 32(SP)
9D00A6FC  27A40200   ADDIU A0, SP, 512
9D00A700  3C059D01   LUI A1, -25343
9D00A704  24A584BC   ADDIU A1, A1, -31556
9D00A708  3C069D01   LUI A2, -25343
9D00A70C  0F4031ED   JAL _sprintf_cdfFnopsuxX
9D00A710  24C68538   ADDIU A2, A2, -31432
9D00A714  AFA203F4   SW V0, 1012(SP)
49:                    SendMessageForTransmitQ(debug);
9D00A718  27A20210   ADDIU V0, SP, 528
9D00A71C  27A30010   ADDIU V1, SP, 16
9D00A720  27A403F0   ADDIU A0, SP, 1008
9D00A724  8C480000   LW T0, 0(V0)
9D00A728  8C470004   LW A3, 4(V0)
9D00A72C  8C460008   LW A2, 8(V0)
9D00A730  8C45000C   LW A1, 12(V0)
9D00A734  AC680000   SW T0, 0(V1)
9D00A738  AC670004   SW A3, 4(V1)
9D00A73C  AC660008   SW A2, 8(V1)
9D00A740  AC65000C   SW A1, 12(V1)
9D00A744  24420010   ADDIU V0, V0, 16
9D00A748  1444FFF6   BNE V0, A0, 0x9D00A724
9D00A74C  24630010   ADDIU V1, V1, 16
9D00A750  8C450000   LW A1, 0(V0)
9D00A754  8C440004   LW A0, 4(V0)
9D00A758  8C420008   LW V0, 8(V0)
9D00A75C  AC650000   SW A1, 0(V1)
9D00A760  AC640004   SW A0, 4(V1)
9D00A764  AC620008   SW V0, 8(V1)
9D00A768  8FA40200   LW A0, 512(SP)
9D00A76C  8FA50204   LW A1, 516(SP)
9D00A770  8FA60208   LW A2, 520(SP)
9D00A774  0F4034BF   JAL SendMessageForTransmitQ
9D00A778  8FA7020C   LW A3, 524(SP)
50:                    //send to queue
51:                    // fprintf(stdout, buf);
52:                    // fprintf(stdout, "FINISHED TRANSMIT\n\n");
53:                  }
9D00A77C  8FBF0404   LW RA, 1028(SP)
9D00A780  03E00008   JR RA
9D00A784  27BD0408   ADDIU SP, SP, 1032
54:                  
55:                  ////////////////////////////////////////////////////////////////////////////////
56:                  ///
57:                  ///
58:                  ///
59:                  void transmitTarget(TARGET_t target, uint8_t msgID)
60:                  {
9D00CFF8  27BDFFE0   ADDIU SP, SP, -32
9D00CFFC  AFBF001C   SW RA, 28(SP)
9D00D000  A7A40020   SH A0, 32(SP)
9D00D004  30A700FF   ANDI A3, A1, 255
61:                    //uint8_t buf[512];
62:                    uint16_t length = sprintf(buf, "{response: { source: TargetLocator, Dest: %s, ID: %i, Type: Target, {x: %i, y: %i}}}", "PATH", msgID, target.x_center, target.y_center);
9D00D008  308200FF   ANDI V0, A0, 255
9D00D00C  AFA20010   SW V0, 16(SP)
9D00D010  7C843A00   EXT A0, A0, 8, 8
9D00D014  AFA40014   SW A0, 20(SP)
9D00D018  3C04A000   LUI A0, -24576
9D00D01C  24840810   ADDIU A0, A0, 2064
9D00D020  3C059D01   LUI A1, -25343
9D00D024  24A58540   ADDIU A1, A1, -31424
9D00D028  3C069D01   LUI A2, -25343
9D00D02C  0F4031ED   JAL _sprintf_cdfFnopsuxX
9D00D030  24C68538   ADDIU A2, A2, -31432
63:                    // fprintf(stdout, buf);
64:                  }
9D00D034  8FBF001C   LW RA, 28(SP)
9D00D038  03E00008   JR RA
9D00D03C  27BD0020   ADDIU SP, SP, 32
65:                  
66:                  ////////////////////////////////////////////////////////////////////////////////
67:                  ///
68:                  ///
69:                  ///
70:                  void transmitRelative(uint8_t relGrid[][GRID_SIZE], uint8_t msgID)
71:                  {
00000000  00000000   NOP
00000048  00000000   NOP
72:                    // fprintf(stdout, "TRANSMITTING RELATIVE DATA\n\n");
73:                    //uint8_t buf[512];
74:                    uint16_t length = sprintf(buf, "{response: { source: TargetLocator, Dest: %s, ID: %i, Type: ObstacleData, {[", "SEARCHER", msgID);
0000000C  00000000   NOP
75:                    //// fprintf(stdout, buf);
76:                    int i, j;
77:                    for(i = 0; i < GRID_SIZE; i++){
00000040  00000000   NOP
78:                      for(j = 0; j < GRID_SIZE; j++){
00000034  00000000   NOP
79:                        //// fprintf(stdout, "CURRENT LENGTH: %i\n", length);
80:                        //length += sprintf(&buf[length], "%i,", relGrid[i][j]>DETECT_THRESH);
81:                      }
82:                    }
83:                    length += sprintf(&buf[length-1], "]}}}");
00000050  00000000   NOP
84:                    // fprintf(stdout, "TOTAL MSG LENGTH: %i\n", length);
85:                    // fprintf(stdout, buf);
86:                    // fprintf(stdout, "\n\n");
87:                  }
0000007C  00000000   NOP
88:                  
89:                  uint8_t test_grid[GRID_SIZE][GRID_SIZE] ;//= { //{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};
90:                                                              // {THING, THING, THING, THING}, 
91:                                                              // {THING, THING, THING, THING}, 
92:                                                              // {THING, THING, THING, THING}, 
93:                                                              // {THING, THING, THING, THING}};
94:                  
95:                  
96:                  
97:                  ////////////////////////////////////////////////////////////////////////////////
98:                  ///
99:                  ///
100:                 ///takes a relative grid and the rover location, and generates an absolute space, that can be overlayed onto the current world
101:                 void transposeRelativeToAbsolute(uint8_t relGrid[GRID_SIZE][GRID_SIZE], 
102:                         uint8_t sizeofRel,
103:                         uint8_t x_loc, 
104:                         uint8_t y_loc,
105:                         int16_t theta, 
106:                         GRID_ITEM_t abs_select[][GRID_SIZE])
107:                 {
9D005704  27BDFFA8   ADDIU SP, SP, -88
9D005708  AFBF0054   SW RA, 84(SP)
9D00570C  AFBE0050   SW S8, 80(SP)
9D005710  AFB7004C   SW S7, 76(SP)
9D005714  AFB60048   SW S6, 72(SP)
9D005718  AFB50044   SW S5, 68(SP)
9D00571C  AFB40040   SW S4, 64(SP)
9D005720  AFB3003C   SW S3, 60(SP)
9D005724  AFB20038   SW S2, 56(SP)
9D005728  AFB10034   SW S1, 52(SP)
9D00572C  AFB00030   SW S0, 48(SP)
9D005730  00809821   ADDU S3, A0, ZERO
9D005734  30B400FF   ANDI S4, A1, 255
9D005738  30D000FF   ANDI S0, A2, 255
9D00573C  30F100FF   ANDI S1, A3, 255
9D005740  87A40068   LH A0, 104(SP)
108:                   int i, j;
109:                   float angle = theta*2*M_PI/360;
9D005744  0F403283   JAL __floatsisf
9D005748  00042040   SLL A0, A0, 1
9D00574C  00402021   ADDU A0, V0, ZERO
9D005750  3C029D01   LUI V0, -25343
9D005754  0F401B08   JAL fpmul
9D005758  8C4585FC   LW A1, -31236(V0)
9D00575C  00402021   ADDU A0, V0, ZERO
9D005760  3C029D01   LUI V0, -25343
9D005764  0F401780   JAL __divsf3
9D005768  8C458600   LW A1, -31232(V0)
9D00576C  00409021   ADDU S2, V0, ZERO
110:                   float sin_i = sin(angle);
9D005770  0F40257D   JAL 0x9D0095F4
9D005774  00402021   ADDU A0, V0, ZERO
9D005778  0040B021   ADDU S6, V0, ZERO
111:                   float cos_i = cos(angle);
9D00577C  0F4025C4   JAL 0x9D009710
9D005780  02402021   ADDU A0, S2, ZERO
112:                   float new_x, new_y;
113:                   for(i = 0; i< sizeofRel;i++){
9D005784  1A80006F   BLEZ S4, 0x9D005944
9D005788  0040A821   ADDU S5, V0, ZERO
9D00578C  AFB30024   SW S3, 36(SP)
9D005790  8FA2006C   LW V0, 108(SP)
9D005794  AFA20028   SW V0, 40(SP)
9D005798  AFA00020   SW ZERO, 32(SP)
9D0058D8  8FA40020   LW A0, 32(SP)
9D0058DC  24840001   ADDIU A0, A0, 1
9D0058E0  AFA40020   SW A0, 32(SP)
9D0058E4  8FA20024   LW V0, 36(SP)
9D0058E8  24420024   ADDIU V0, V0, 36
9D0058EC  AFA20024   SW V0, 36(SP)
9D0058F0  8FA30028   LW V1, 40(SP)
9D0058F4  2463006C   ADDIU V1, V1, 108
9D0058F8  0094102A   SLT V0, A0, S4
9D0058FC  10400011   BEQ V0, ZERO, 0x9D005944
9D005900  AFA30028   SW V1, 40(SP)
114:                     for(j = 0; j<sizeofRel; j++){
9D0058CC  26100001   ADDIU S0, S0, 1
9D0058D0  1614FFB7   BNE S0, S4, 0x9D0057B0
9D0058D4  26310003   ADDIU S1, S1, 3
115:                       //new_x = i*sin_i + j*cos_i;
116:                       //new_y = i*cos_i - j*sin_i;
117:                       new_x = i*cos_i - j*sin_i;
9D0057B0  0F403283   JAL __floatsisf
9D0057B4  02002021   ADDU A0, S0, ZERO
9D0057B8  00409021   ADDU S2, V0, ZERO
9D0057BC  00402021   ADDU A0, V0, ZERO
9D0057C0  0F401B08   JAL fpmul
9D0057C4  02C02821   ADDU A1, S6, ZERO
9D0057C8  02E02021   ADDU A0, S7, ZERO
9D0057CC  0F401523   JAL fpsub
9D0057D0  00402821   ADDU A1, V0, ZERO
9D0057D4  00409821   ADDU S3, V0, ZERO
9D005904  0F403283   JAL __floatsisf
9D005908  8FA40020   LW A0, 32(SP)
9D00590C  00408021   ADDU S0, V0, ZERO
9D005910  00402021   ADDU A0, V0, ZERO
9D005914  0F401B08   JAL fpmul
9D005918  02A02821   ADDU A1, S5, ZERO
9D00591C  0040B821   ADDU S7, V0, ZERO
118:                       new_y = i*sin_i + j*cos_i;
9D0057D8  02A02021   ADDU A0, S5, ZERO
9D0057DC  0F401B08   JAL fpmul
9D0057E0  02402821   ADDU A1, S2, ZERO
9D0057E4  8FA40010   LW A0, 16(SP)
9D0057E8  0F401525   JAL fpadd
9D0057EC  00402821   ADDU A1, V0, ZERO
9D0057F0  00409021   ADDU S2, V0, ZERO
9D005920  02C02021   ADDU A0, S6, ZERO
9D005924  0F401B08   JAL fpmul
9D005928  02002821   ADDU A1, S0, ZERO
9D00592C  AFA20010   SW V0, 16(SP)
119:                       int8_t x_val, y_val;
120:                       x_val = ROUND(new_x);
9D0057F4  0F402B2E   JAL fpfloor
9D0057F8  02602021   ADDU A0, S3, ZERO
9D0057FC  0040F021   ADDU S8, V0, ZERO
9D005800  00402021   ADDU A0, V0, ZERO
9D005804  3C039D01   LUI V1, -25343
9D005808  24638604   ADDIU V1, V1, -31228
9D00580C  0F401525   JAL fpadd
9D005810  8C650000   LW A1, 0(V1)
9D005814  00402021   ADDU A0, V0, ZERO
9D005818  0F402CA9   JAL __ltsf2
9D00581C  02602821   ADDU A1, S3, ZERO
9D005820  04410007   BGEZ V0, 0x9D005840
9D005824  00000000   NOP
9D005828  0F402B5B   JAL fpceil
9D00582C  02602021   ADDU A0, S3, ZERO
9D005830  0F402F9D   JAL __fixsfsi
9D005834  00402021   ADDU A0, V0, ZERO
9D005838  0B401613   J 0x9D00584C
9D00583C  7C02F420   SEB S8, V0
9D005840  0F402F9D   JAL __fixsfsi
9D005844  03C02021   ADDU A0, S8, ZERO
9D005848  7C02F420   SEB S8, V0
121:                       y_val = ROUND(new_y);
9D00584C  0F402B2E   JAL fpfloor
9D005850  02402021   ADDU A0, S2, ZERO
9D005854  00409821   ADDU S3, V0, ZERO
9D005858  00402021   ADDU A0, V0, ZERO
9D00585C  3C029D01   LUI V0, -25343
9D005860  24428604   ADDIU V0, V0, -31228
9D005864  0F401525   JAL fpadd
9D005868  8C450000   LW A1, 0(V0)
9D00586C  00402021   ADDU A0, V0, ZERO
9D005870  0F402CA9   JAL __ltsf2
9D005874  02402821   ADDU A1, S2, ZERO
9D005878  04410007   BGEZ V0, 0x9D005898
9D00587C  00000000   NOP
9D005880  0F402B5B   JAL fpceil
9D005884  02402021   ADDU A0, S2, ZERO
9D005888  0F402F9D   JAL __fixsfsi
9D00588C  00402021   ADDU A0, V0, ZERO
9D005890  0B401629   J 0x9D0058A4
9D005894  7C021420   SEB V0, V0
9D005898  0F402F9D   JAL __fixsfsi
9D00589C  02602021   ADDU A0, S3, ZERO
9D0058A0  7C021420   SEB V0, V0
122:                       //// fprintf(stdout, "rel: %i %i\nx_output: %f vs. %i\ny_output: %f vs. %i\n\n", i, j, new_x, x_val, new_y, y_val);
123:                       abs_select[i][j].x = x_val + x_loc - GRID_SIZE/2;
9D00579C  2610FFEE   ADDIU S0, S0, -18
9D0057A0  AFB00018   SW S0, 24(SP)
9D0058A4  8FA30018   LW V1, 24(SP)
9D0058A8  007EF021   ADDU S8, V1, S8
9D0058AC  A23E0000   SB S8, 0(S1)
124:                       abs_select[i][j].y = y_val + y_loc - GRID_SIZE/2;
9D0057A4  2631FFEE   ADDIU S1, S1, -18
9D0057A8  0B401641   J 0x9D005904
9D0057AC  AFB1001C   SW S1, 28(SP)
9D0058B0  8FA4001C   LW A0, 28(SP)
9D0058B4  00821021   ADDU V0, A0, V0
9D0058B8  A2220001   SB V0, 1(S1)
9D0058BC  8FA30014   LW V1, 20(SP)
9D0058C0  00701021   ADDU V0, V1, S0
125:                       abs_select[i][j].value = relGrid[i][j];
9D0058C4  90420000   LBU V0, 0(V0)
9D0058C8  A2220002   SB V0, 2(S1)
9D005930  8FA40024   LW A0, 36(SP)
9D005934  AFA40014   SW A0, 20(SP)
9D005938  8FB10028   LW S1, 40(SP)
9D00593C  0B4015EC   J 0x9D0057B0
9D005940  00008021   ADDU S0, ZERO, ZERO
126:                     }
127:                   }
128:                 }
9D005944  8FBF0054   LW RA, 84(SP)
9D005948  8FBE0050   LW S8, 80(SP)
9D00594C  8FB7004C   LW S7, 76(SP)
9D005950  8FB60048   LW S6, 72(SP)
9D005954  8FB50044   LW S5, 68(SP)
9D005958  8FB40040   LW S4, 64(SP)
9D00595C  8FB3003C   LW S3, 60(SP)
9D005960  8FB20038   LW S2, 56(SP)
9D005964  8FB10034   LW S1, 52(SP)
9D005968  8FB00030   LW S0, 48(SP)
9D00596C  03E00008   JR RA
9D005970  27BD0058   ADDIU SP, SP, 88
129:                 
130:                 ////////////////////////////////////////////////////////////////////////////////
131:                 ///
132:                 ///
133:                 ///take an absolute map of some portion of the world, and add it onto the existing world
134:                 void updateMyWorld(GRID_ITEM_t newGrid[][GRID_SIZE],
135:                         uint8_t worldGrid[][MAPDIM])
136:                 {
9D008E5C  00801021   ADDU V0, A0, ZERO
9D008E60  0B402373   J 0x9D008DCC
9D008E64  00001821   ADDU V1, ZERO, ZERO
137:                   // fprintf(stdout, "UPDATING WORLD\n\n");
138:                   int i_count, i, j_count, j;
139:                   for (i_count = 0; i_count < GRID_SIZE; i_count++){
9D008DBC  00007021   ADDU T6, ZERO, ZERO
9D008E3C  25CE0001   ADDIU T6, T6, 1
9D008E40  15CA0006   BNE T6, T2, 0x9D008E5C
9D008E44  2484006C   ADDIU A0, A0, 108
9D008E48  00A01021   ADDU V0, A1, ZERO
9D008E4C  00004821   ADDU T1, ZERO, ZERO
9D008EE4  0B40239A   J 0x9D008E68
140:                     for (j_count = 0; j_count < GRID_SIZE; j_count++){
9D008DC4  0B402397   J 0x9D008E5C
9D008DC8  240A0024   ADDIU T2, ZERO, 36
9D008E30  24630001   ADDIU V1, V1, 1
9D008E34  146AFFE5   BNE V1, T2, 0x9D008DCC
9D008E38  24420003   ADDIU V0, V0, 3
141:                       i = newGrid[i_count][j_count].x;
9D008DCC  90460000   LBU A2, 0(V0)
142:                       j = newGrid[i_count][j_count].y;
143:                       if (i > MAPDIM || j > MAPDIM){
9D008DD0  28C7001F   SLTI A3, A2, 31
9D008DD4  10E00016   BEQ A3, ZERO, 0x9D008E30
9D008DD8  90480001   LBU T0, 1(V0)
9D008DDC  2907001F   SLTI A3, T0, 31
9D008DE0  50E00014   BEQL A3, ZERO, 0x9D008E34
9D008DE4  24630001   ADDIU V1, V1, 1
144:                         //TODO throw error, out of bounds
145:                         continue;
146:                       }
147:                       worldGrid[i][j] += newGrid[i_count][j_count].value;//TODO decide how to update
9D008DE8  00063840   SLL A3, A2, 1
9D008DEC  00063140   SLL A2, A2, 5
9D008DF0  00C73023   SUBU A2, A2, A3
9D008DF4  00A63021   ADDU A2, A1, A2
9D008DF8  00C85821   ADDU T3, A2, T0
9D008DFC  916C0000   LBU T4, 0(T3)
9D008E00  90470002   LBU A3, 2(V0)
9D008E04  01873821   ADDU A3, T4, A3
9D008E08  30E700FF   ANDI A3, A3, 255
148:                       if(worldGrid[i][j] > MIN_OVERFLOW){//overflow sub
9D008E0C  2CE900F1   SLTIU T1, A3, 241
9D008E10  15200003   BNE T1, ZERO, 0x9D008E20
9D008E14  A1670000   SB A3, 0(T3)
149:                         worldGrid[i][j] = 0;
9D008E18  0B40238C   J 0x9D008E30
9D008E1C  A1600000   SB ZERO, 0(T3)
150:                       }
151:                       if(worldGrid[i][j] > MAX_VAL){//overflow sub
9D008E20  2CE700E7   SLTIU A3, A3, 231
9D008E24  14E00002   BNE A3, ZERO, 0x9D008E30
9D008E28  00C84021   ADDU T0, A2, T0
152:                         worldGrid[i][j] = MAX_VAL - 10;
9D008DC0  240DFFDC   ADDIU T5, ZERO, -36
9D008E2C  A10D0000   SB T5, 0(T0)
153:                       }
154:                     }
155:                   }
156:                   for(i = 0; i < MAPDIM; i++){
9D008ECC  25290001   ADDIU T1, T1, 1
9D008ED0  11260006   BEQ T1, A2, 0x9D008EEC
9D008ED4  01401021   ADDU V0, T2, ZERO
9D008ED8  244A001E   ADDIU T2, V0, 30
9D008EDC  01403821   ADDU A3, T2, ZERO
9D008EE0  2448FFE2   ADDIU T0, V0, -30
157:                     for(j = 0; j < MAPDIM; j++){
9D008E54  0B4023B6   J 0x9D008ED8
9D008E58  2406001E   ADDIU A2, ZERO, 30
9D008EC0  24630001   ADDIU V1, V1, 1
9D008EC4  1466FFE8   BNE V1, A2, 0x9D008E68
9D008EC8  24420001   ADDIU V0, V0, 1
158:                       if(worldGrid[i][j] < DETECT_THRESH){
9D008E68  90440000   LBU A0, 0(V0)
9D008E6C  2C840064   SLTIU A0, A0, 100
9D008E70  50800014   BEQL A0, ZERO, 0x9D008EC4
9D008E74  24630001   ADDIU V1, V1, 1
9D008E78  00E32021   ADDU A0, A3, V1
159:                         if((worldGrid[i+1][j] > DETECT_THRESH) &&
9D008E7C  90840000   LBU A0, 0(A0)
9D008E80  2C840065   SLTIU A0, A0, 101
9D008E84  5480000F   BNEL A0, ZERO, 0x9D008EC4
9D008E88  24630001   ADDIU V1, V1, 1
9D008E8C  01032021   ADDU A0, T0, V1
9D008E90  90840000   LBU A0, 0(A0)
9D008E94  2C840065   SLTIU A0, A0, 101
9D008E98  5480000A   BNEL A0, ZERO, 0x9D008EC4
9D008E9C  24630001   ADDIU V1, V1, 1
160:                             (worldGrid[i-1][j] > DETECT_THRESH) &&
9D008EA0  90440001   LBU A0, 1(V0)
9D008EA4  2C840065   SLTIU A0, A0, 101
9D008EA8  54800006   BNEL A0, ZERO, 0x9D008EC4
9D008EAC  24630001   ADDIU V1, V1, 1
161:                             (worldGrid[i][j+1] > DETECT_THRESH) &&
9D008EB0  9044FFFF   LBU A0, -1(V0)
9D008EB4  2C840065   SLTIU A0, A0, 101
9D008EB8  50800001   BEQL A0, ZERO, 0x9D008EC0
9D008EBC  A04B0000   SB T3, 0(V0)
162:                             (worldGrid[i][j-1] > DETECT_THRESH)){
163:                           worldGrid[i][j] = DETECT_THRESH+THING;
9D008E50  240B0067   ADDIU T3, ZERO, 103
9D008E54  0B4023B6   J 0x9D008ED8
9D008E58  2406001E   ADDIU A2, ZERO, 30
9D008E5C  00801021   ADDU V0, A0, ZERO
9D008E60  0B402373   J 0x9D008DCC
9D008E64  00001821   ADDU V1, ZERO, ZERO
9D008E68  90440000   LBU A0, 0(V0)
9D008E6C  2C840064   SLTIU A0, A0, 100
9D008E70  50800014   BEQL A0, ZERO, 0x9D008EC4
9D008E74  24630001   ADDIU V1, V1, 1
9D008E78  00E32021   ADDU A0, A3, V1
9D008E7C  90840000   LBU A0, 0(A0)
9D008E80  2C840065   SLTIU A0, A0, 101
9D008E84  5480000F   BNEL A0, ZERO, 0x9D008EC4
9D008E88  24630001   ADDIU V1, V1, 1
9D008E8C  01032021   ADDU A0, T0, V1
9D008E90  90840000   LBU A0, 0(A0)
9D008E94  2C840065   SLTIU A0, A0, 101
9D008E98  5480000A   BNEL A0, ZERO, 0x9D008EC4
9D008E9C  24630001   ADDIU V1, V1, 1
9D008EA0  90440001   LBU A0, 1(V0)
9D008EA4  2C840065   SLTIU A0, A0, 101
9D008EA8  54800006   BNEL A0, ZERO, 0x9D008EC4
9D008EAC  24630001   ADDIU V1, V1, 1
9D008EB0  9044FFFF   LBU A0, -1(V0)
9D008EB4  2C840065   SLTIU A0, A0, 101
9D008EB8  50800001   BEQL A0, ZERO, 0x9D008EC0
9D008EBC  A04B0000   SB T3, 0(V0)
9D008EC0  24630001   ADDIU V1, V1, 1
9D008EC4  1466FFE8   BNE V1, A2, 0x9D008E68
9D008EC8  24420001   ADDIU V0, V0, 1
9D008ECC  25290001   ADDIU T1, T1, 1
9D008ED0  11260006   BEQ T1, A2, 0x9D008EEC
9D008ED4  01401021   ADDU V0, T2, ZERO
9D008ED8  244A001E   ADDIU T2, V0, 30
9D008EDC  01403821   ADDU A3, T2, ZERO
9D008EE0  2448FFE2   ADDIU T0, V0, -30
9D008EE4  0B40239A   J 0x9D008E68
9D008EE8  00001821   ADDU V1, ZERO, ZERO
9D008EEC  03E00008   JR RA
9D008EF0  00000000   NOP
164:                         }
165:                       }
166:                     }
167:                   }
168:                 }
169:                 
170:                 ////////////////////////////////////////////////////////////////////////////////
171:                 ///
172:                 ///
173:                 ///takes the absolute world and rover location to generate a relative map of some size
174:                 void transposeAbsoluteToRelative(uint8_t worldGrid[][MAPDIM],
175:                         uint8_t x_loc, 
176:                         uint8_t y_loc, 
177:                         int16_t theta, 
178:                         uint8_t relGrid[][GRID_SIZE],
179:                         uint8_t sizeofRel)
180:                 {
00000000  00000000   NOP
181:                      int i, j;
182:                   float angle = theta*2*M_PI/360;
00000048  00000000   NOP
183:                   float sin_i = sin(angle);
00000074  00000000   NOP
184:                   float cos_i = cos(angle);
00000080  00000000   NOP
185:                   float new_x, new_y;
186:                   for(i = 0; i< sizeofRel;i++){
00000088  00000000   NOP
000001D4  00000000   NOP
187:                     for(j = 0; j<sizeofRel; j++){
000001C8  00000000   NOP
188:                       // new_x = i*sin_i + j*cos_i;
189:                       // new_y = i*cos_i - j*sin_i;
190:                       new_x = i*cos_i - j*sin_i;
000000A0  00000000   NOP
000001F4  00000000   NOP
191:                       new_y = i*sin_i + j*cos_i;
000000C8  00000000   NOP
00000210  00000000   NOP
192:                       int8_t x_val, y_val;
193:                       x_val = ROUND(new_x);
000000E4  00000000   NOP
194:                       y_val = ROUND(new_y);
0000013C  00000000   NOP
195:                       relGrid[i][j] = worldGrid[x_val+x_loc - GRID_SIZE/2][y_val+y_loc - GRID_SIZE/2];
00000194  00000000   NOP
00000220  00000000   NOP
196:                       //// fprintf(stdout, "rel: %i %i\nx_location: %i\ny_location: %i\nValue: %i\n\n", i, j, x_val+x_loc, y_val+y_loc, worldGrid[x_val+x_loc][y_val+y_loc]);
197:                       // abs_select[i][j].x = x_val + x_loc;
198:                       // abs_select[i][j].y = y_val + y_loc;
199:                       // abs_select[i][j].value = relGrid[i][j];
200:                     }
201:                   }
202:                   // fprintf(stdout, "ABOUT TO TRANSMIT RELATIVE\n\n");
203:                   uint8_t msgID = 10;
204:                   printRel(relGrid);
205:                   transmitRelative(relGrid, msgID);
00000230  00000000   NOP
206:                   printRel(relGrid);
207:                 }
0000023C  00000000   NOP
208:                 
209:                 ////////////////////////////////////////////////////////////////////////////////
210:                 ///
211:                 ///
212:                 ///
213:                 void recursiveSearch(bool tempGrid[][MAPDIM], uint8_t x, uint8_t y, GRID_ITEM_t *LEFT_Item, GRID_ITEM_t *BOT_Item, GRID_ITEM_t *TOP_Item, GRID_ITEM_t *RIGHT_Item)
214:                 {
9D005BC0  27BDFFB8   ADDIU SP, SP, -72
9D005BC4  AFBF0044   SW RA, 68(SP)
9D005BC8  AFBE0040   SW S8, 64(SP)
9D005BCC  AFB7003C   SW S7, 60(SP)
9D005BD0  AFB60038   SW S6, 56(SP)
9D005BD4  AFB50034   SW S5, 52(SP)
9D005BD8  AFB40030   SW S4, 48(SP)
9D005BDC  AFB3002C   SW S3, 44(SP)
9D005BE0  AFB20028   SW S2, 40(SP)
9D005BE4  AFB10024   SW S1, 36(SP)
9D005BE8  AFB00020   SW S0, 32(SP)
9D005BEC  0080B021   ADDU S6, A0, ZERO
9D005BF0  00E09021   ADDU S2, A3, ZERO
9D005BF4  8FB50058   LW S5, 88(SP)
9D005BF8  8FB4005C   LW S4, 92(SP)
9D005BFC  8FB30060   LW S3, 96(SP)
9D005C00  30B100FF   ANDI S1, A1, 255
215:                   if(x < LEFT_Item->x || (x == LEFT_Item->x && y < LEFT_Item->y)){//left+bottom
9D005C04  90E20000   LBU V0, 0(A3)
9D005C08  0222182B   SLTU V1, S1, V0
9D005C0C  14600007   BNE V1, ZERO, 0x9D005C2C
9D005C10  30D000FF   ANDI S0, A2, 255
9D005C14  54510008   BNEL V0, S1, 0x9D005C38
9D005C18  92A20001   LBU V0, 1(S5)
9D005C1C  90E20001   LBU V0, 1(A3)
9D005C20  0202102B   SLTU V0, S0, V0
9D005C24  50400004   BEQL V0, ZERO, 0x9D005C38
9D005C28  92A20001   LBU V0, 1(S5)
216:                     LEFT_Item->x = x;
9D005C2C  A2510000   SB S1, 0(S2)
217:                     LEFT_Item->y = y;
9D005C30  A2500001   SB S0, 1(S2)
218:                   }
219:                   // if(x == LEFT_Item->x && y < LEFT_Item->y)
220:                   if(y < BOT_Item->y || (y == BOT_Item->y && x > BOT_Item->x)){//bottom+right
9D005C34  92A20001   LBU V0, 1(S5)
9D005C38  0202182B   SLTU V1, S0, V0
9D005C3C  54600008   BNEL V1, ZERO, 0x9D005C60
9D005C40  A2B10000   SB S1, 0(S5)
9D005C44  56020008   BNEL S0, V0, 0x9D005C68
9D005C48  92820001   LBU V0, 1(S4)
9D005C4C  92A20000   LBU V0, 0(S5)
9D005C50  0051102B   SLTU V0, V0, S1
9D005C54  50400004   BEQL V0, ZERO, 0x9D005C68
9D005C58  92820001   LBU V0, 1(S4)
221:                     BOT_Item->x = x;
9D005C5C  A2B10000   SB S1, 0(S5)
222:                     BOT_Item->y = y;
9D005C60  A2B00001   SB S0, 1(S5)
223:                   }
224:                   if(y > TOP_Item->y || (y == TOP_Item->y && x < TOP_Item->x)){//top+left
9D005C64  92820001   LBU V0, 1(S4)
9D005C68  0050182B   SLTU V1, V0, S0
9D005C6C  54600008   BNEL V1, ZERO, 0x9D005C90
9D005C70  A2910000   SB S1, 0(S4)
9D005C74  56020008   BNEL S0, V0, 0x9D005C98
9D005C78  92620000   LBU V0, 0(S3)
9D005C7C  92820000   LBU V0, 0(S4)
9D005C80  0222102B   SLTU V0, S1, V0
9D005C84  50400004   BEQL V0, ZERO, 0x9D005C98
9D005C88  92620000   LBU V0, 0(S3)
225:                     TOP_Item->x = x;
9D005C8C  A2910000   SB S1, 0(S4)
226:                     TOP_Item->y = y;
9D005C90  A2900001   SB S0, 1(S4)
227:                   }
228:                   if(x > RIGHT_Item->x || (x == RIGHT_Item->x && y > RIGHT_Item->y)){//top+right
9D005C94  92620000   LBU V0, 0(S3)
9D005C98  0051182B   SLTU V1, V0, S1
9D005C9C  54600008   BNEL V1, ZERO, 0x9D005CC0
9D005CA0  A2710000   SB S1, 0(S3)
9D005CA4  16220008   BNE S1, V0, 0x9D005CC8
9D005CA8  0011F040   SLL S8, S1, 1
9D005CAC  92620001   LBU V0, 1(S3)
9D005CB0  0050102B   SLTU V0, V0, S0
9D005CB4  10400005   BEQ V0, ZERO, 0x9D005CCC
9D005CB8  00111140   SLL V0, S1, 5
229:                     RIGHT_Item->x = x;
9D005CBC  A2710000   SB S1, 0(S3)
230:                     RIGHT_Item->y = y;
9D005CC0  A2700001   SB S0, 1(S3)
231:                   }
232:                   
233:                   tempGrid[x][y] = 0;
9D005CC4  0011F040   SLL S8, S1, 1
9D005CC8  00111140   SLL V0, S1, 5
9D005CCC  005EF023   SUBU S8, V0, S8
9D005CD0  02DEB821   ADDU S7, S6, S8
9D005CD4  02F01021   ADDU V0, S7, S0
234:                   //// fprintf(stdout, "Object @ %i, %i\n", x, y);
235:                   bool found = 0;
236:                   if(x > 0){
9D005CD8  12200011   BEQ S1, ZERO, 0x9D005D20
9D005CDC  A0400000   SB ZERO, 0(V0)
237:                     if(tempGrid[x-1][y]){
9D005CE0  02F01021   ADDU V0, S7, S0
9D005CE4  9042FFE2   LBU V0, -30(V0)
9D005CE8  1040000B   BEQ V0, ZERO, 0x9D005D18
9D005CEC  2E22001D   SLTIU V0, S1, 29
238:                       recursiveSearch(tempGrid, x-1, y, LEFT_Item, BOT_Item, TOP_Item, RIGHT_Item);
9D005CF0  2625FFFF   ADDIU A1, S1, -1
9D005CF4  AFB50010   SW S5, 16(SP)
9D005CF8  AFB40014   SW S4, 20(SP)
9D005CFC  AFB30018   SW S3, 24(SP)
9D005D00  02C02021   ADDU A0, S6, ZERO
9D005D04  30A500FF   ANDI A1, A1, 255
9D005D08  02003021   ADDU A2, S0, ZERO
9D005D0C  0F4016F0   JAL recursiveSearch
9D005D10  02403821   ADDU A3, S2, ZERO
239:                       found = 1;
240:                     }
241:                   }
242:                   if(x < MAPDIM-1){
9D005D14  2E22001D   SLTIU V0, S1, 29
9D005D18  1040000E   BEQ V0, ZERO, 0x9D005D54
9D005D1C  00000000   NOP
243:                     if(tempGrid[x+1][y]){
9D005D20  02DEF021   ADDU S8, S6, S8
9D005D24  03D0F021   ADDU S8, S8, S0
9D005D28  93C2001E   LBU V0, 30(S8)
9D005D2C  10400009   BEQ V0, ZERO, 0x9D005D54
9D005D30  26250001   ADDIU A1, S1, 1
244:                       recursiveSearch(tempGrid, x+1, y, LEFT_Item, BOT_Item, TOP_Item, RIGHT_Item);
9D005D34  AFB50010   SW S5, 16(SP)
9D005D38  AFB40014   SW S4, 20(SP)
9D005D3C  AFB30018   SW S3, 24(SP)
9D005D40  02C02021   ADDU A0, S6, ZERO
9D005D44  30A500FF   ANDI A1, A1, 255
9D005D48  02003021   ADDU A2, S0, ZERO
9D005D4C  0F4016F0   JAL recursiveSearch
9D005D50  02403821   ADDU A3, S2, ZERO
245:                       found = 1;
246:                     }
247:                   }
248:                   if(y > 0){
9D005D54  52000012   BEQL S0, ZERO, 0x9D005DA0
9D005D58  02F0B821   ADDU S7, S7, S0
249:                     if(tempGrid[x][y-1]){
9D005D5C  02F01021   ADDU V0, S7, S0
9D005D60  9042FFFF   LBU V0, -1(V0)
9D005D64  1040000B   BEQ V0, ZERO, 0x9D005D94
9D005D68  2E02001D   SLTIU V0, S0, 29
250:                       recursiveSearch(tempGrid, x, y-1, LEFT_Item, BOT_Item, TOP_Item, RIGHT_Item);
9D005D6C  2606FFFF   ADDIU A2, S0, -1
9D005D70  AFB50010   SW S5, 16(SP)
9D005D74  AFB40014   SW S4, 20(SP)
9D005D78  AFB30018   SW S3, 24(SP)
9D005D7C  02C02021   ADDU A0, S6, ZERO
9D005D80  02202821   ADDU A1, S1, ZERO
9D005D84  30C600FF   ANDI A2, A2, 255
9D005D88  0F4016F0   JAL recursiveSearch
9D005D8C  02403821   ADDU A3, S2, ZERO
251:                       found = 1;
252:                     }
253:                   }
254:                   if(y < MAPDIM-1){
9D005D90  2E02001D   SLTIU V0, S0, 29
9D005D94  1040000F   BEQ V0, ZERO, 0x9D005DD4
9D005D98  8FBF0044   LW RA, 68(SP)
255:                     if(tempGrid[x][y+1]){
9D005D9C  02F0B821   ADDU S7, S7, S0
9D005DA0  92E20001   LBU V0, 1(S7)
9D005DA4  1040000B   BEQ V0, ZERO, 0x9D005DD4
9D005DA8  8FBF0044   LW RA, 68(SP)
256:                       recursiveSearch(tempGrid, x, y+1, LEFT_Item, BOT_Item, TOP_Item, RIGHT_Item);
9D005DAC  26060001   ADDIU A2, S0, 1
9D005DB0  AFB50010   SW S5, 16(SP)
9D005DB4  AFB40014   SW S4, 20(SP)
9D005DB8  AFB30018   SW S3, 24(SP)
9D005DBC  02C02021   ADDU A0, S6, ZERO
9D005DC0  02202821   ADDU A1, S1, ZERO
9D005DC4  30C600FF   ANDI A2, A2, 255
9D005DC8  0F4016F0   JAL recursiveSearch
9D005DCC  02403821   ADDU A3, S2, ZERO
257:                       found = 1;
258:                     }
259:                   }
260:                 }
9D005DD0  8FBF0044   LW RA, 68(SP)
9D005DD4  8FBE0040   LW S8, 64(SP)
9D005DD8  8FB7003C   LW S7, 60(SP)
9D005DDC  8FB60038   LW S6, 56(SP)
9D005DE0  8FB50034   LW S5, 52(SP)
9D005DE4  8FB40030   LW S4, 48(SP)
9D005DE8  8FB3002C   LW S3, 44(SP)
9D005DEC  8FB20028   LW S2, 40(SP)
9D005DF0  8FB10024   LW S1, 36(SP)
9D005DF4  8FB00020   LW S0, 32(SP)
9D005DF8  03E00008   JR RA
9D005DFC  27BD0048   ADDIU SP, SP, 72
261:                 
262:                 
263:                 ////////////////////////////////////////////////////////////////////////////////
264:                 ///
265:                 ///
266:                 ///scan world grid and identify where there are objects and what they are
267:                 void classifyObjects(uint8_t worldGrid[][MAPDIM], uint8_t msgID)
268:                 {
9D003580  27BDFC00   ADDIU SP, SP, -1024
9D003584  AFBF03FC   SW RA, 1020(SP)
9D003588  AFBE03F8   SW S8, 1016(SP)
9D00358C  AFB703F4   SW S7, 1012(SP)
9D003590  AFB603F0   SW S6, 1008(SP)
9D003594  AFB503EC   SW S5, 1004(SP)
9D003598  AFB403E8   SW S4, 1000(SP)
9D00359C  AFB303E4   SW S3, 996(SP)
9D0035A0  AFB203E0   SW S2, 992(SP)
9D0035A4  AFB103DC   SW S1, 988(SP)
9D0035A8  AFB003D8   SW S0, 984(SP)
9D0035AC  30A500FF   ANDI A1, A1, 255
9D0035B0  AFA503D0   SW A1, 976(SP)
9D0035B4  00004821   ADDU T1, ZERO, ZERO
9D00361C  00001021   ADDU V0, ZERO, ZERO
9D003620  27A30020   ADDIU V1, SP, 32
9D003624  0B400D71   J 0x9D0035C4
9D003628  01233021   ADDU A2, T1, V1
9D00362C  02B01021   ADDU V0, S5, S0
9D003B04  0B400D8B   J 0x9D00362C
9D003B08  00008021   ADDU S0, ZERO, ZERO
269:                   bool tempGrid[MAPDIM][MAPDIM];
270:                   int i, j;
271:                   for(i = 0; i < MAPDIM; i++){
9D0035BC  0B400D86   J 0x9D003618
9D0035C0  240A0384   ADDIU T2, ZERO, 900
9D0035C4  27B50020   ADDIU S5, SP, 32
9D0035C8  00C21821   ADDU V1, A2, V0
9D0035CC  00E22821   ADDU A1, A3, V0
9D0035EC  552A000B   BNEL T1, T2, 0x9D00361C
9D0035F0  00893821   ADDU A3, A0, T1
9D0035F4  AFA003C0   SW ZERO, 960(SP)
272:                     for(j = 0; j < MAPDIM; j++){
9D0035B8  2408001E   ADDIU T0, ZERO, 30
9D0035DC  24420001   ADDIU V0, V0, 1
9D0035E0  1448FFF9   BNE V0, T0, 0x9D0035C8
9D0035E4  A0650000   SB A1, 0(V1)
9D0035E8  2529001E   ADDIU T1, T1, 30
273:                       tempGrid[i][j] = (worldGrid[i][j] > DETECT_THRESH);
9D0035D0  90A50000   LBU A1, 0(A1)
9D0035D4  2CA50065   SLTIU A1, A1, 101
9D0035D8  38A50001   XORI A1, A1, 1
274:                     }
275:                   }
276:                   
277:                   for(i = 0; i < MAPDIM; i++){
9D003AE8  8FA203C0   LW V0, 960(SP)
9D003AEC  24420001   ADDIU V0, V0, 1
9D003AF0  AFA203C0   SW V0, 960(SP)
9D003AF4  2402001E   ADDIU V0, ZERO, 30
9D003AF8  8FA303C0   LW V1, 960(SP)
9D003AFC  10620003   BEQ V1, V0, 0x9D003B0C
9D003B00  26B5001E   ADDIU S5, S5, 30
278:                     for(j = 0; j < MAPDIM; j++){
9D003A74  0B400EB7   J 0x9D003ADC
9D003A78  26100001   ADDIU S0, S0, 1
9D003AD8  26100001   ADDIU S0, S0, 1
9D003ADC  2402001E   ADDIU V0, ZERO, 30
9D003AE0  1602FED3   BNE S0, V0, 0x9D003630
9D003AE4  02B01021   ADDU V0, S5, S0
279:                       if(tempGrid[i][j]){
9D003630  90420000   LBU V0, 0(V0)
9D003634  50400129   BEQL V0, ZERO, 0x9D003ADC
9D003638  26100001   ADDIU S0, S0, 1
280:                         // fprintf(stdout, "CLASSIFYING\n\n");
281:                         GRID_ITEM_t LEFT_Item, BOT_Item, TOP_Item, RIGHT_Item;
282:                         LEFT_Item.x = MAPDIM;
9D00363C  2402001E   ADDIU V0, ZERO, 30
9D003640  A3A203B8   SB V0, 952(SP)
283:                         LEFT_Item.y = MAPDIM;
9D003644  A3A203B9   SB V0, 953(SP)
284:                         BOT_Item.x = 0;
9D003648  A3A003B4   SB ZERO, 948(SP)
285:                         BOT_Item.y = MAPDIM;
9D00364C  A3A203B5   SB V0, 949(SP)
286:                         TOP_Item.x = MAPDIM;
9D003650  A3A203B0   SB V0, 944(SP)
287:                         TOP_Item.y = 0;
9D003654  A3A003B1   SB ZERO, 945(SP)
288:                         RIGHT_Item.x = 0;
9D003658  A3A003AC   SB ZERO, 940(SP)
289:                         RIGHT_Item.y = 0;
9D00365C  A3A003AD   SB ZERO, 941(SP)
290:                         recursiveSearch(tempGrid, i, j, &LEFT_Item, &BOT_Item, &TOP_Item, &RIGHT_Item);
9D003660  27A203B4   ADDIU V0, SP, 948
9D003664  AFA20010   SW V0, 16(SP)
9D003668  27A203B0   ADDIU V0, SP, 944
9D00366C  AFA20014   SW V0, 20(SP)
9D003670  27A203AC   ADDIU V0, SP, 940
9D003674  AFA20018   SW V0, 24(SP)
9D003678  27A40020   ADDIU A0, SP, 32
9D00367C  8FA203C0   LW V0, 960(SP)
9D003680  304500FF   ANDI A1, V0, 255
9D003684  320600FF   ANDI A2, S0, 255
9D003688  0F4016F0   JAL recursiveSearch
9D00368C  27A703B8   ADDIU A3, SP, 952
291:                         // fprintf(stdout, "Left: %i, %i\nBottom: %i, %i\nTop: %i, %i\nRight: %i, %i\n\n", LEFT_Item.x, LEFT_Item.y, BOT_Item.x, BOT_Item.y, TOP_Item.x, TOP_Item.y, RIGHT_Item.x, RIGHT_Item.y);
292:                         float angle1 = (360.0/(2*M_PI))*atan(((float)(RIGHT_Item.y - BOT_Item.y))/((float)(RIGHT_Item.x - BOT_Item.x)));
9D0035F8  3C029D01   LUI V0, -25343
9D0035FC  8C428608   LW V0, -31224(V0)
9D003600  AFA203C8   SW V0, 968(SP)
9D003690  93A403AD   LBU A0, 941(SP)
9D003694  93A203B5   LBU V0, 949(SP)
9D003698  0F403283   JAL __floatsisf
9D00369C  00822023   SUBU A0, A0, V0
9D0036A0  00409021   ADDU S2, V0, ZERO
9D0036A4  93A403AC   LBU A0, 940(SP)
9D0036A8  93A203B4   LBU V0, 948(SP)
9D0036AC  0F403283   JAL __floatsisf
9D0036B0  00822023   SUBU A0, A0, V0
9D0036B4  00409821   ADDU S3, V0, ZERO
9D0036B8  02402021   ADDU A0, S2, ZERO
9D0036BC  0F401780   JAL __divsf3
9D0036C0  00402821   ADDU A1, V0, ZERO
9D0036C4  0F402C81   JAL 0x9D00B204
9D0036C8  00402021   ADDU A0, V0, ZERO
9D0036CC  0040B021   ADDU S6, V0, ZERO
9D00370C  02C02021   ADDU A0, S6, ZERO
9D003710  0F401B08   JAL fpmul
9D003714  8FA503C8   LW A1, 968(SP)
9D003718  0040B021   ADDU S6, V0, ZERO
293:                         float angle2 = (360.0/(2*M_PI))*atan(((float)(TOP_Item.y - LEFT_Item.y))/((float)(TOP_Item.x - LEFT_Item.x)));
9D0036D0  93A403B1   LBU A0, 945(SP)
9D0036D4  93A203B9   LBU V0, 953(SP)
9D0036D8  0F403283   JAL __floatsisf
9D0036DC  00822023   SUBU A0, A0, V0
9D0036E0  0040B821   ADDU S7, V0, ZERO
9D0036E4  93A403B0   LBU A0, 944(SP)
9D0036E8  93A203B8   LBU V0, 952(SP)
9D0036EC  0F403283   JAL __floatsisf
9D0036F0  00822023   SUBU A0, A0, V0
9D0036F4  02E02021   ADDU A0, S7, ZERO
9D0036F8  0F401780   JAL __divsf3
9D0036FC  00402821   ADDU A1, V0, ZERO
9D003700  0F402C81   JAL 0x9D00B204
9D003704  00402021   ADDU A0, V0, ZERO
9D003708  0040B821   ADDU S7, V0, ZERO
9D00371C  02E02021   ADDU A0, S7, ZERO
9D003720  3C039D01   LUI V1, -25343
9D003724  0F401B08   JAL fpmul
9D003728  8C658608   LW A1, -31224(V1)
294:                         int8_t angle = ROUND(((angle1+angle2)/2));
9D003604  3C119D01   LUI S1, -25343
9D003608  8E238604   LW V1, -31228(S1)
9D00360C  AFA303CC   SW V1, 972(SP)
9D00372C  02C02021   ADDU A0, S6, ZERO
9D003730  0F401525   JAL fpadd
9D003734  00402821   ADDU A1, V0, ZERO
9D003738  00402021   ADDU A0, V0, ZERO
9D00373C  0F401B08   JAL fpmul
9D003740  8FA503CC   LW A1, 972(SP)
9D003744  0040B021   ADDU S6, V0, ZERO
9D003748  0F402B2E   JAL fpfloor
9D00374C  00402021   ADDU A0, V0, ZERO
9D003750  0040B821   ADDU S7, V0, ZERO
9D003754  00402021   ADDU A0, V0, ZERO
9D003758  0F401525   JAL fpadd
9D00375C  8E258604   LW A1, -31228(S1)
9D003760  00402021   ADDU A0, V0, ZERO
9D003764  0F402CA9   JAL __ltsf2
9D003768  02C02821   ADDU A1, S6, ZERO
9D00376C  04410008   BGEZ V0, 0x9D003790
9D003770  00000000   NOP
9D003774  0F402B5B   JAL fpceil
9D003778  02C02021   ADDU A0, S6, ZERO
9D00377C  0F402F9D   JAL __fixsfsi
9D003780  00402021   ADDU A0, V0, ZERO
9D003784  7C021420   SEB V0, V0
9D003788  0B400DE8   J 0x9D0037A0
9D00378C  AFA203C4   SW V0, 964(SP)
9D003790  0F402F9D   JAL __fixsfsi
9D003794  02E02021   ADDU A0, S7, ZERO
9D003798  7C021420   SEB V0, V0
9D00379C  AFA203C4   SW V0, 964(SP)
295:                         //// fprintf(stdout, "Angle1: %f\nAngle2: %f\n\n", angle1, angle2);
296:                         // fprintf(stdout, "Final Angle: %i\n\n", angle);
297:                         uint8_t length, width;
298:                         float length1 = sqrt(((float)pow(RIGHT_Item.y - BOT_Item.y, 2))+((float)pow(RIGHT_Item.x - BOT_Item.x, 2)));
9D0037A0  02602021   ADDU A0, S3, ZERO
9D0037A4  0F401B08   JAL fpmul
9D0037A8  02602821   ADDU A1, S3, ZERO
9D0037AC  00409821   ADDU S3, V0, ZERO
9D0037B0  02402021   ADDU A0, S2, ZERO
9D0037B4  0F401B08   JAL fpmul
9D0037B8  02402821   ADDU A1, S2, ZERO
9D0037BC  02602021   ADDU A0, S3, ZERO
9D0037C0  0F401525   JAL fpadd
9D0037C4  00402821   ADDU A1, V0, ZERO
9D0037C8  0F4031D3   JAL sqrtf
9D0037CC  00402021   ADDU A0, V0, ZERO
9D0037D0  0040B021   ADDU S6, V0, ZERO
299:                         float length2 = sqrt(((float)pow(TOP_Item.y - LEFT_Item.y, 2))+((float)pow(TOP_Item.x - LEFT_Item.x, 2)));
9D0037D4  93A403B1   LBU A0, 945(SP)
9D0037D8  93A203B9   LBU V0, 953(SP)
9D0037DC  0F403283   JAL __floatsisf
9D0037E0  00822023   SUBU A0, A0, V0
9D0037E4  00409821   ADDU S3, V0, ZERO
9D0037E8  93A403B0   LBU A0, 944(SP)
9D0037EC  93A203B8   LBU V0, 952(SP)
9D0037F0  0F403283   JAL __floatsisf
9D0037F4  00822023   SUBU A0, A0, V0
9D0037F8  00409021   ADDU S2, V0, ZERO
9D0037FC  02602021   ADDU A0, S3, ZERO
9D003800  0F401B08   JAL fpmul
9D003804  02602821   ADDU A1, S3, ZERO
9D003808  00409821   ADDU S3, V0, ZERO
9D00380C  02402021   ADDU A0, S2, ZERO
9D003810  0F401B08   JAL fpmul
9D003814  02402821   ADDU A1, S2, ZERO
9D003818  02602021   ADDU A0, S3, ZERO
9D00381C  0F401525   JAL fpadd
9D003820  00402821   ADDU A1, V0, ZERO
9D003824  0F4031D3   JAL sqrtf
9D003828  00402021   ADDU A0, V0, ZERO
300:                         length = ROUND((((length1+length2) - 1)/2 + 1));
9D003610  0B400EC1   J 0x9D003B04
9D003614  3C149D01   LUI S4, -25343
9D003618  00893821   ADDU A3, A0, T1
9D00382C  02C02021   ADDU A0, S6, ZERO
9D003830  0F401525   JAL fpadd
9D003834  00402821   ADDU A1, V0, ZERO
9D003838  00402021   ADDU A0, V0, ZERO
9D00383C  0F401523   JAL fpsub
9D003840  8E85860C   LW A1, -31220(S4)
9D003844  00402021   ADDU A0, V0, ZERO
9D003848  0F401B08   JAL fpmul
9D00384C  8E258604   LW A1, -31228(S1)
9D003850  00402021   ADDU A0, V0, ZERO
9D003854  0F401525   JAL fpadd
9D003858  8E85860C   LW A1, -31220(S4)
9D00385C  00409021   ADDU S2, V0, ZERO
9D003860  0F402B2E   JAL fpfloor
9D003864  00402021   ADDU A0, V0, ZERO
9D003868  00409821   ADDU S3, V0, ZERO
9D00386C  00402021   ADDU A0, V0, ZERO
9D003870  0F401525   JAL fpadd
9D003874  8E258604   LW A1, -31228(S1)
9D003878  00402021   ADDU A0, V0, ZERO
9D00387C  0F402CA9   JAL __ltsf2
9D003880  02402821   ADDU A1, S2, ZERO
9D003884  04410007   BGEZ V0, 0x9D0038A4
9D003888  00000000   NOP
9D00388C  0F402B5B   JAL fpceil
9D003890  02402021   ADDU A0, S2, ZERO
9D003894  0F403039   JAL __fixunssfsi
9D003898  00402021   ADDU A0, V0, ZERO
9D00389C  0B400E2C   J 0x9D0038B0
9D0038A0  305600FF   ANDI S6, V0, 255
9D0038A4  0F403039   JAL __fixunssfsi
9D0038A8  02602021   ADDU A0, S3, ZERO
9D0038AC  305600FF   ANDI S6, V0, 255
301:                         //// fprintf(stdout, "Length1: %f\nLength2: %f\n\n", length1, length2);
302:                         // fprintf(stdout, "Final Length: %i\n\n", length);
303:                         float width1 = sqrt(((float)pow(TOP_Item.y - RIGHT_Item.y, 2))+((float)pow(TOP_Item.x - RIGHT_Item.x, 2)));
9D0038B0  93A403B1   LBU A0, 945(SP)
9D0038B4  93A203AD   LBU V0, 941(SP)
9D0038B8  0F403283   JAL __floatsisf
9D0038BC  00822023   SUBU A0, A0, V0
9D0038C0  00409821   ADDU S3, V0, ZERO
9D0038C4  93A403B0   LBU A0, 944(SP)
9D0038C8  93A203AC   LBU V0, 940(SP)
9D0038CC  0F403283   JAL __floatsisf
9D0038D0  00822023   SUBU A0, A0, V0
9D0038D4  00409021   ADDU S2, V0, ZERO
9D0038D8  02602021   ADDU A0, S3, ZERO
9D0038DC  0F401B08   JAL fpmul
9D0038E0  02602821   ADDU A1, S3, ZERO
9D0038E4  00409821   ADDU S3, V0, ZERO
9D0038E8  02402021   ADDU A0, S2, ZERO
9D0038EC  0F401B08   JAL fpmul
9D0038F0  02402821   ADDU A1, S2, ZERO
9D0038F4  02602021   ADDU A0, S3, ZERO
9D0038F8  0F401525   JAL fpadd
9D0038FC  00402821   ADDU A1, V0, ZERO
9D003900  0F4031D3   JAL sqrtf
9D003904  00402021   ADDU A0, V0, ZERO
9D003908  0040B821   ADDU S7, V0, ZERO
304:                         float width2 = sqrt(((float)pow(LEFT_Item.y - BOT_Item.y, 2))+((float)pow(LEFT_Item.x - BOT_Item.x, 2)));
9D00390C  93A403B9   LBU A0, 953(SP)
9D003910  93A203B5   LBU V0, 949(SP)
9D003914  0F403283   JAL __floatsisf
9D003918  00822023   SUBU A0, A0, V0
9D00391C  00409821   ADDU S3, V0, ZERO
9D003920  93A403B8   LBU A0, 952(SP)
9D003924  93A203B4   LBU V0, 948(SP)
9D003928  0F403283   JAL __floatsisf
9D00392C  00822023   SUBU A0, A0, V0
9D003930  00409021   ADDU S2, V0, ZERO
9D003934  02602021   ADDU A0, S3, ZERO
9D003938  0F401B08   JAL fpmul
9D00393C  02602821   ADDU A1, S3, ZERO
9D003940  00409821   ADDU S3, V0, ZERO
9D003944  02402021   ADDU A0, S2, ZERO
9D003948  0F401B08   JAL fpmul
9D00394C  02402821   ADDU A1, S2, ZERO
9D003950  02602021   ADDU A0, S3, ZERO
9D003954  0F401525   JAL fpadd
9D003958  00402821   ADDU A1, V0, ZERO
9D00395C  0F4031D3   JAL sqrtf
9D003960  00402021   ADDU A0, V0, ZERO
305:                         width = ROUND((((width1+width2) - 1)/2 + 1));
9D003964  02E02021   ADDU A0, S7, ZERO
9D003968  0F401525   JAL fpadd
9D00396C  00402821   ADDU A1, V0, ZERO
9D003970  00402021   ADDU A0, V0, ZERO
9D003974  0F401523   JAL fpsub
9D003978  8E85860C   LW A1, -31220(S4)
9D00397C  00402021   ADDU A0, V0, ZERO
9D003980  0F401B08   JAL fpmul
9D003984  8E258604   LW A1, -31228(S1)
9D003988  00402021   ADDU A0, V0, ZERO
9D00398C  0F401525   JAL fpadd
9D003990  8E85860C   LW A1, -31220(S4)
9D003994  00409021   ADDU S2, V0, ZERO
9D003998  0F402B2E   JAL fpfloor
9D00399C  00402021   ADDU A0, V0, ZERO
9D0039A0  00409821   ADDU S3, V0, ZERO
9D0039A4  00402021   ADDU A0, V0, ZERO
9D0039A8  0F401525   JAL fpadd
9D0039AC  8E258604   LW A1, -31228(S1)
9D0039B0  00402021   ADDU A0, V0, ZERO
9D0039B4  0F402CA9   JAL __ltsf2
9D0039B8  02402821   ADDU A1, S2, ZERO
9D0039BC  04410007   BGEZ V0, 0x9D0039DC
9D0039C0  00000000   NOP
9D0039C4  0F402B5B   JAL fpceil
9D0039C8  02402021   ADDU A0, S2, ZERO
9D0039CC  0F403039   JAL __fixunssfsi
9D0039D0  00402021   ADDU A0, V0, ZERO
9D0039D4  0B400E7A   J 0x9D0039E8
9D0039D8  304200FF   ANDI V0, V0, 255
9D0039DC  0F403039   JAL __fixunssfsi
9D0039E0  02602021   ADDU A0, S3, ZERO
9D0039E4  304200FF   ANDI V0, V0, 255
306:                         //// fprintf(stdout, "Width1: %f\nWidth2: %f\n\n", width1, width2);
307:                         // fprintf(stdout, "Final Width: %i\n\n", width);
308:                         //float angle = atan(((float)(RIGHT_Item.y - BOT_Item.y))/((float)(RIGHT_Item.x - BOT_Item.x)));
309:                         //TODO process 4 corners to make box
310:                         if(length < 6 || width < 6){
9D0039E8  2EC30006   SLTIU V1, S6, 6
9D0039EC  54600005   BNEL V1, ZERO, 0x9D003A04
9D0039F0  26D6FFFC   ADDIU S6, S6, -4
9D0039F4  2C430006   SLTIU V1, V0, 6
9D0039F8  10600020   BEQ V1, ZERO, 0x9D003A7C
9D0039FC  93A303B8   LBU V1, 952(SP)
311:                           //not an obstacle
312:                           if(length >= 4 && length <= 6 && width >= 4 && width <= 6){
9D003A00  26D6FFFC   ADDIU S6, S6, -4
9D003A04  32D600FF   ANDI S6, S6, 255
9D003A08  2ED60003   SLTIU S6, S6, 3
9D003A0C  52C00033   BEQL S6, ZERO, 0x9D003ADC
9D003A10  26100001   ADDIU S0, S0, 1
9D003A14  2442FFFC   ADDIU V0, V0, -4
9D003A18  304200FF   ANDI V0, V0, 255
9D003A1C  2C420003   SLTIU V0, V0, 3
9D003A20  5040002E   BEQL V0, ZERO, 0x9D003ADC
9D003A24  26100001   ADDIU S0, S0, 1
313:                             //target
314:                             TARGET_t new_target;
315:                             new_target.x_center = (RIGHT_Item.x - LEFT_Item.x)/2 + LEFT_Item.x;
9D003A28  93A203B8   LBU V0, 952(SP)
9D003A2C  93A303AC   LBU V1, 940(SP)
9D003A30  00621823   SUBU V1, V1, V0
9D003A34  000327C2   SRL A0, V1, 31
9D003A38  00831821   ADDU V1, A0, V1
9D003A3C  00031843   SRA V1, V1, 1
9D003A40  00431021   ADDU V0, V0, V1
9D003A44  A3A203A4   SB V0, 932(SP)
316:                             new_target.y_center = (TOP_Item.y - BOT_Item.y)/2 + BOT_Item.y;
9D003A48  93A203B5   LBU V0, 949(SP)
9D003A4C  93A303B1   LBU V1, 945(SP)
9D003A50  00621823   SUBU V1, V1, V0
9D003A54  000327C2   SRL A0, V1, 31
9D003A58  00831821   ADDU V1, A0, V1
9D003A5C  00031843   SRA V1, V1, 1
9D003A60  00431021   ADDU V0, V0, V1
9D003A64  A3A203A5   SB V0, 933(SP)
317:                             transmitTarget(new_target, msgID);
9D003A68  8FA403A4   LW A0, 932(SP)
9D003A6C  0F4033FE   JAL transmitTarget
9D003A70  8FA503D0   LW A1, 976(SP)
318:                           }
319:                         }
320:                         else{
321:                           OBSTACLE_t new_obstacle;
322:                           new_obstacle.x_center = (RIGHT_Item.x - LEFT_Item.x)/2 + LEFT_Item.x;;
9D003A7C  93A403AC   LBU A0, 940(SP)
9D003A80  00832023   SUBU A0, A0, V1
9D003A84  00042FC2   SRL A1, A0, 31
9D003A88  00A42021   ADDU A0, A1, A0
9D003A8C  00042043   SRA A0, A0, 1
9D003A90  00641821   ADDU V1, V1, A0
9D003A94  A3A303A4   SB V1, 932(SP)
323:                           new_obstacle.y_center = (TOP_Item.y - BOT_Item.y)/2 + BOT_Item.y;
9D003A98  93A303B5   LBU V1, 949(SP)
9D003A9C  93A403B1   LBU A0, 945(SP)
9D003AA0  00832023   SUBU A0, A0, V1
9D003AA4  00042FC2   SRL A1, A0, 31
9D003AA8  00A42021   ADDU A0, A1, A0
9D003AAC  00042043   SRA A0, A0, 1
9D003AB0  00641821   ADDU V1, V1, A0
9D003AB4  A3A303A5   SB V1, 933(SP)
324:                           new_obstacle.theta = angle;
9D003AB8  8FA303C4   LW V1, 964(SP)
9D003ABC  A7A303A6   SH V1, 934(SP)
325:                           new_obstacle.length = length;
9D003AC0  A3B603A8   SB S6, 936(SP)
326:                           new_obstacle.width = width;
9D003AC4  A3A203A9   SB V0, 937(SP)
327:                           transmitObstacle(new_obstacle, msgID);
9D003AC8  8FA403A4   LW A0, 932(SP)
9D003ACC  8FA503A8   LW A1, 936(SP)
9D003AD0  0F4029B0   JAL transmitObstacle
9D003AD4  8FA603D0   LW A2, 976(SP)
328:                         }
329:                       }
330:                     }
331:                   }
332:                     //TODO find where threshold met, identify collections
333:                     //determine size of collections
334:                     //if more than target/vertex
335:                     //check where other robot should be
336:                     //if robot, update pathfinder location
337:                     //if not, classify obstacle, x, y, l, w, theta
338:                 }
9D003B0C  8FBF03FC   LW RA, 1020(SP)
9D003B10  8FBE03F8   LW S8, 1016(SP)
9D003B14  8FB703F4   LW S7, 1012(SP)
9D003B18  8FB603F0   LW S6, 1008(SP)
9D003B1C  8FB503EC   LW S5, 1004(SP)
9D003B20  8FB403E8   LW S4, 1000(SP)
9D003B24  8FB303E4   LW S3, 996(SP)
9D003B28  8FB203E0   LW S2, 992(SP)
9D003B2C  8FB103DC   LW S1, 988(SP)
9D003B30  8FB003D8   LW S0, 984(SP)
9D003B34  03E00008   JR RA
9D003B38  27BD0400   ADDIU SP, SP, 1024
339:                 
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/debug.c  ------------------
1:                   #include "debug.h"
2:                   
3:                   //Controls debug pins
4:                   //also contains error handler function
5:                   
6:                   
7:                   //Takes the provided pin information and direction and sets or clears the pin accordingly
8:                   void pinSetOrClearPin(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos, bool dir)
9:                   {
9D00BF70  30E700FF   ANDI A3, A3, 255
10:                      if (dir){
9D00BF74  10E0000F   BEQ A3, ZERO, pinSetOrClearPin::PLIB_PORTS_PinClear
9D00BF78  00000000   NOP
9D00BF7C  1480000B   BNE A0, ZERO, 0x9D00BFAC
9D00BF80  3C0203FF   LUI V0, 1023
9D00BF84  3442FFFF   ORI V0, V0, -1
9D00BF88  00A21021   ADDU V0, A1, V0
9D00BF8C  00021180   SLL V0, V0, 6
9D00BF90  24420008   ADDIU V0, V0, 8
9D00BF94  3C05BF88   LUI A1, -16504
9D00BF98  24A56060   ADDIU A1, A1, 24672
9D00BF9C  00A22821   ADDU A1, A1, V0
9D00BFA0  24020001   ADDIU V0, ZERO, 1
9D00BFA4  00C23004   SLLV A2, V0, A2
9D00BFA8  ACA60000   SW A2, 0(A1)
9D00BFAC  03E00008   JR RA
9D00BFB0  00000000   NOP
9D00BFB4  1480FFFD   BNE A0, ZERO, 0x9D00BFAC
9D00BFB8  3C0203FF   LUI V0, 1023
9D00BFBC  3442FFFF   ORI V0, V0, -1
9D00BFC0  00A21021   ADDU V0, A1, V0
9D00BFC4  00021180   SLL V0, V0, 6
9D00BFC8  24420004   ADDIU V0, V0, 4
9D00BFCC  3C05BF88   LUI A1, -16504
9D00BFD0  24A56060   ADDIU A1, A1, 24672
9D00BFD4  00A22821   ADDU A1, A1, V0
9D00BFD8  24020001   ADDIU V0, ZERO, 1
9D00BFDC  00C23004   SLLV A2, V0, A2
9D00BFE0  ACA60000   SW A2, 0(A1)
9D00BFE4  03E00008   JR RA
9D00BFE8  00000000   NOP
11:                          PLIB_PORTS_PinSet(index, channel, bitPos);
12:                      }
13:                      else{
14:                          PLIB_PORTS_PinClear(index, channel, bitPos);
15:                      }
16:                  }
17:                  
18:                  void enableDbgVal()
19:                  {
20:                      PLIB_PORTS_PinOpenDrainEnable(CHIPKIT_46);
21:                      PLIB_PORTS_PinWrite(CHIPKIT_46, 0);
22:                      PLIB_PORTS_PinDirectionOutputSet(CHIPKIT_46);
23:                      PLIB_PORTS_PinOpenDrainEnable(CHIPKIT_47);
24:                      PLIB_PORTS_PinWrite(CHIPKIT_47, 0);
25:                      PLIB_PORTS_PinDirectionOutputSet(CHIPKIT_47);
26:                      PLIB_PORTS_PinOpenDrainEnable(CHIPKIT_48);
27:                      PLIB_PORTS_PinWrite(CHIPKIT_48, 0);
28:                      PLIB_PORTS_PinDirectionOutputSet(CHIPKIT_48);
29:                      PLIB_PORTS_PinOpenDrainEnable(CHIPKIT_49);
30:                      PLIB_PORTS_PinWrite(CHIPKIT_49, 0);
31:                      PLIB_PORTS_PinDirectionOutputSet(CHIPKIT_49);
32:                      PLIB_PORTS_PinOpenDrainEnable(CHIPKIT_50);
33:                      PLIB_PORTS_PinWrite(CHIPKIT_50, 0);
34:                      PLIB_PORTS_PinDirectionOutputSet(CHIPKIT_50);
35:                      PLIB_PORTS_PinOpenDrainEnable(CHIPKIT_51);
36:                      PLIB_PORTS_PinWrite(CHIPKIT_51, 0);
37:                      PLIB_PORTS_PinDirectionOutputSet(CHIPKIT_51);
38:                      PLIB_PORTS_PinOpenDrainEnable(CHIPKIT_52);
39:                      PLIB_PORTS_PinWrite(CHIPKIT_52, 0);
40:                      PLIB_PORTS_PinDirectionOutputSet(CHIPKIT_52);
41:                      PLIB_PORTS_PinOpenDrainEnable(CHIPKIT_53);
42:                      PLIB_PORTS_PinWrite(CHIPKIT_53, 0);
43:                      PLIB_PORTS_PinDirectionOutputSet(CHIPKIT_53);
44:                  }
45:                  #define SYS_PORT_E_TRIS         0x300
46:                  #define SYS_PORT_E_LAT          0x0
47:                  #define SYS_PORT_E_ODC          0x0
48:                  
49:                  void enable_dbgOutputLoc()
50:                  {
51:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_ODC);
52:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_LAT);
53:                  	PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_TRIS ^ 0xFFFF);
54:                  }
55:                  
56:                  //sets chipkit pins 46-53 to the provided value
57:                  void dbgOutputVal(unsigned char outVal)
58:                  {
9D00A84C  27BDFFE8   ADDIU SP, SP, -24
9D00A850  AFBF0014   SW RA, 20(SP)
9D00A854  AFB00010   SW S0, 16(SP)
9D00A858  309000FF   ANDI S0, A0, 255
59:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_F, PORTS_BIT_POS_1, ((outVal >> 0) & 0x01));
9D00A85C  00002021   ADDU A0, ZERO, ZERO
9D00A860  24050005   ADDIU A1, ZERO, 5
9D00A864  24060001   ADDIU A2, ZERO, 1
9D00A868  0F402FDC   JAL pinSetOrClearPin
9D00A86C  32070001   ANDI A3, S0, 1
60:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_D, PORTS_BIT_POS_6, ((outVal >> 1) & 0x01));
9D00A870  00002021   ADDU A0, ZERO, ZERO
9D00A874  24050003   ADDIU A1, ZERO, 3
9D00A878  24060006   ADDIU A2, ZERO, 6
9D00A87C  0F402FDC   JAL pinSetOrClearPin
9D00A880  7E070040   EXT A3, S0, 1, 1
61:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_D, PORTS_BIT_POS_8, ((outVal >> 2) & 0x01));
9D00A884  00002021   ADDU A0, ZERO, ZERO
9D00A888  24050003   ADDIU A1, ZERO, 3
9D00A88C  24060008   ADDIU A2, ZERO, 8
9D00A890  0F402FDC   JAL pinSetOrClearPin
9D00A894  7E070080   EXT A3, S0, 2, 1
62:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_D, PORTS_BIT_POS_11, ((outVal >> 3) & 0x01));
9D00A898  00002021   ADDU A0, ZERO, ZERO
9D00A89C  24050003   ADDIU A1, ZERO, 3
9D00A8A0  2406000B   ADDIU A2, ZERO, 11
9D00A8A4  0F402FDC   JAL pinSetOrClearPin
9D00A8A8  7E0700C0   EXT A3, S0, 3, 1
63:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_G, PORTS_BIT_POS_7, ((outVal >> 4) & 0x01));
9D00A8AC  00002021   ADDU A0, ZERO, ZERO
9D00A8B0  24050006   ADDIU A1, ZERO, 6
9D00A8B4  24060007   ADDIU A2, ZERO, 7
9D00A8B8  0F402FDC   JAL pinSetOrClearPin
9D00A8BC  7E070100   EXT A3, S0, 4, 1
64:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_G, PORTS_BIT_POS_8, ((outVal >> 5) & 0x01));
9D00A8C0  00002021   ADDU A0, ZERO, ZERO
9D00A8C4  24050006   ADDIU A1, ZERO, 6
9D00A8C8  24060008   ADDIU A2, ZERO, 8
9D00A8CC  0F402FDC   JAL pinSetOrClearPin
9D00A8D0  7E070140   EXT A3, S0, 5, 1
65:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_G, PORTS_BIT_POS_6, ((outVal >> 6) & 0x01));
9D00A8D4  00002021   ADDU A0, ZERO, ZERO
9D00A8D8  24050006   ADDIU A1, ZERO, 6
9D00A8DC  24060006   ADDIU A2, ZERO, 6
9D00A8E0  0F402FDC   JAL pinSetOrClearPin
9D00A8E4  7E070180   EXT A3, S0, 6, 1
66:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_G, PORTS_BIT_POS_9, ((outVal >> 7) & 0x01));
9D00A8E8  00002021   ADDU A0, ZERO, ZERO
9D00A8EC  24050006   ADDIU A1, ZERO, 6
9D00A8F0  24060009   ADDIU A2, ZERO, 9
9D00A8F4  0F402FDC   JAL pinSetOrClearPin
9D00A8F8  001039C2   SRL A3, S0, 7
67:                  }
9D00A8FC  8FBF0014   LW RA, 20(SP)
9D00A900  8FB00010   LW S0, 16(SP)
9D00A904  03E00008   JR RA
9D00A908  27BD0018   ADDIU SP, SP, 24
68:                  
69:                  //sets chipkit pins 30-37 to the provided value
70:                  void dbgOutputLoc(unsigned char outVal)
71:                  {
9D00A90C  27BDFFE8   ADDIU SP, SP, -24
9D00A910  AFBF0014   SW RA, 20(SP)
9D00A914  AFB00010   SW S0, 16(SP)
9D00A918  309000FF   ANDI S0, A0, 255
72:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_E, PORTS_BIT_POS_7, ((outVal >> 0) & 0x01));
9D00A91C  00002021   ADDU A0, ZERO, ZERO
9D00A920  24050004   ADDIU A1, ZERO, 4
9D00A924  24060007   ADDIU A2, ZERO, 7
9D00A928  0F402FDC   JAL pinSetOrClearPin
9D00A92C  32070001   ANDI A3, S0, 1
73:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_E, PORTS_BIT_POS_6, ((outVal >> 1) & 0x01));
9D00A930  00002021   ADDU A0, ZERO, ZERO
9D00A934  24050004   ADDIU A1, ZERO, 4
9D00A938  24060006   ADDIU A2, ZERO, 6
9D00A93C  0F402FDC   JAL pinSetOrClearPin
9D00A940  7E070040   EXT A3, S0, 1, 1
74:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_E, PORTS_BIT_POS_5, ((outVal >> 2) & 0x01));
9D00A944  00002021   ADDU A0, ZERO, ZERO
9D00A948  24050004   ADDIU A1, ZERO, 4
9D00A94C  24060005   ADDIU A2, ZERO, 5
9D00A950  0F402FDC   JAL pinSetOrClearPin
9D00A954  7E070080   EXT A3, S0, 2, 1
75:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_E, PORTS_BIT_POS_4, ((outVal >> 3) & 0x01));
9D00A958  00002021   ADDU A0, ZERO, ZERO
9D00A95C  24050004   ADDIU A1, ZERO, 4
9D00A960  24060004   ADDIU A2, ZERO, 4
9D00A964  0F402FDC   JAL pinSetOrClearPin
9D00A968  7E0700C0   EXT A3, S0, 3, 1
76:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_E, PORTS_BIT_POS_3, ((outVal >> 4) & 0x01));
9D00A96C  00002021   ADDU A0, ZERO, ZERO
9D00A970  24050004   ADDIU A1, ZERO, 4
9D00A974  24060003   ADDIU A2, ZERO, 3
9D00A978  0F402FDC   JAL pinSetOrClearPin
9D00A97C  7E070100   EXT A3, S0, 4, 1
77:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_E, PORTS_BIT_POS_2, ((outVal >> 5) & 0x01));
9D00A980  00002021   ADDU A0, ZERO, ZERO
9D00A984  24050004   ADDIU A1, ZERO, 4
9D00A988  24060002   ADDIU A2, ZERO, 2
9D00A98C  0F402FDC   JAL pinSetOrClearPin
9D00A990  7E070140   EXT A3, S0, 5, 1
78:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_E, PORTS_BIT_POS_1, ((outVal >> 6) & 0x01));
9D00A994  00002021   ADDU A0, ZERO, ZERO
9D00A998  24050004   ADDIU A1, ZERO, 4
9D00A99C  24060001   ADDIU A2, ZERO, 1
9D00A9A0  0F402FDC   JAL pinSetOrClearPin
9D00A9A4  7E070180   EXT A3, S0, 6, 1
79:                      pinSetOrClearPin(PORTS_ID_0, PORT_CHANNEL_E, PORTS_BIT_POS_0, ((outVal >> 7) & 0x01));
9D00A9A8  00002021   ADDU A0, ZERO, ZERO
9D00A9AC  24050004   ADDIU A1, ZERO, 4
9D00A9B0  00003021   ADDU A2, ZERO, ZERO
9D00A9B4  0F402FDC   JAL pinSetOrClearPin
9D00A9B8  001039C2   SRL A3, S0, 7
80:                  }
9D00A9BC  8FBF0014   LW RA, 20(SP)
9D00A9C0  8FB00010   LW S0, 16(SP)
9D00A9C4  03E00008   JR RA
9D00A9C8  27BD0018   ADDIU SP, SP, 24
81:                  
82:                  void errorHandler(uint8_t val)
83:                  {
9D00DA04  27BDFFE8   ADDIU SP, SP, -24
9D00DA08  AFBF0014   SW RA, 20(SP)
9D00DA0C  AFB00010   SW S0, 16(SP)
9D00DA10  309000FF   ANDI S0, A0, 255
84:                      //dbgOutputLoc(0xFF);
85:                      //SYS_DEBUG_BreakPoint();
86:                      while(1)
87:                          dbgOutputLoc(val);
9D00DA14  0F402A43   JAL dbgOutputLoc
9D00DA18  02002021   ADDU A0, S0, ZERO
9D00DA1C  0B403685   J 0x9D00DA14
9D00DA20  00000000   NOP
88:                  }
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/app8.c  -------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app8.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app8.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  APP8_DATA app8Data;
80:                  
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  // Section: Application Callback Functions
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  
87:                  /* TODO:  Add any necessary callback functions.
88:                  */
89:                  
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Application Local Functions
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  
96:                  
97:                  /* TODO:  Add any necessary local functions.
98:                  */
99:                  
100:                 
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 // Section: Application Initialization and State Machine Functions
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 
107:                 /*******************************************************************************
108:                   Function:
109:                     void APP8_Initialize ( void )
110:                 
111:                   Remarks:
112:                     See prototype in app8.h.
113:                  */
114:                 
115:                 void APP8_Initialize ( void )
116:                 {
117:                     /* Place the App state machine in its initial state. */
118:                     app8Data.state = APP8_STATE_INIT;
119:                 
120:                     
121:                     /* TODO: Initialize your application's state machine and other
122:                      * parameters.
123:                      */
124:                 }
125:                 
126:                 
127:                 /******************************************************************************
128:                   Function:
129:                     void APP8_Tasks ( void )
130:                 
131:                   Remarks:
132:                     See prototype in app8.h.
133:                  */
134:                 
135:                 void APP8_Tasks ( void )
136:                 {
137:                 
138:                     /* Check the application's current state. */
139:                     switch ( app8Data.state )
00000000  00000000   NOP
140:                     {
141:                         /* Application's initial state. */
142:                         case APP8_STATE_INIT:
143:                         {
144:                             bool appInitialized = true;
145:                        
146:                         
147:                             if (appInitialized)
148:                             {
149:                             
150:                                 app8Data.state = APP8_STATE_SERVICE_TASKS;
0000000C  00000000   NOP
151:                             }
152:                             break;
153:                         }
154:                 
155:                         case APP8_STATE_SERVICE_TASKS:
156:                         {
157:                         
158:                             break;
159:                         }
160:                 
161:                         /* TODO: implement your application state machine.*/
162:                         
163:                 
164:                         /* The default state should never be executed. */
165:                         default:
166:                         {
167:                             /* TODO: Handle error in application's state machine. */
168:                             break;
169:                         }
170:                     }
171:                 }
172:                 
173:                  
174:                 
175:                 /*******************************************************************************
176:                  End of File
177:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/app7.c  -------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app7.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app7.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  APP7_DATA app7Data;
80:                  
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  // Section: Application Callback Functions
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  
87:                  /* TODO:  Add any necessary callback functions.
88:                  */
89:                  
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Application Local Functions
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  
96:                  
97:                  /* TODO:  Add any necessary local functions.
98:                  */
99:                  
100:                 
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 // Section: Application Initialization and State Machine Functions
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 
107:                 /*******************************************************************************
108:                   Function:
109:                     void APP7_Initialize ( void )
110:                 
111:                   Remarks:
112:                     See prototype in app7.h.
113:                  */
114:                 
115:                 void APP7_Initialize ( void )
116:                 {
117:                     /* Place the App state machine in its initial state. */
118:                     app7Data.state = APP7_STATE_INIT;
119:                 
120:                     
121:                     /* TODO: Initialize your application's state machine and other
122:                      * parameters.
123:                      */
124:                 }
125:                 
126:                 
127:                 /******************************************************************************
128:                   Function:
129:                     void APP7_Tasks ( void )
130:                 
131:                   Remarks:
132:                     See prototype in app7.h.
133:                  */
134:                 
135:                 void APP7_Tasks ( void )
136:                 {
137:                 
138:                     /* Check the application's current state. */
139:                     switch ( app7Data.state )
00000000  00000000   NOP
140:                     {
141:                         /* Application's initial state. */
142:                         case APP7_STATE_INIT:
143:                         {
144:                             bool appInitialized = true;
145:                        
146:                         
147:                             if (appInitialized)
148:                             {
149:                             
150:                                 app7Data.state = APP7_STATE_SERVICE_TASKS;
0000000C  00000000   NOP
151:                             }
152:                             break;
153:                         }
154:                 
155:                         case APP7_STATE_SERVICE_TASKS:
156:                         {
157:                         
158:                             break;
159:                         }
160:                 
161:                         /* TODO: implement your application state machine.*/
162:                         
163:                 
164:                         /* The default state should never be executed. */
165:                         default:
166:                         {
167:                             /* TODO: Handle error in application's state machine. */
168:                             break;
169:                         }
170:                     }
171:                 }
172:                 
173:                  
174:                 
175:                 /*******************************************************************************
176:                  End of File
177:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/app6.c  -------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app6.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app6.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  APP6_DATA app6Data;
80:                  
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  // Section: Application Callback Functions
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  
87:                  /* TODO:  Add any necessary callback functions.
88:                  */
89:                  
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Application Local Functions
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  
96:                  
97:                  /* TODO:  Add any necessary local functions.
98:                  */
99:                  
100:                 
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 // Section: Application Initialization and State Machine Functions
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 
107:                 /*******************************************************************************
108:                   Function:
109:                     void APP6_Initialize ( void )
110:                 
111:                   Remarks:
112:                     See prototype in app6.h.
113:                  */
114:                 
115:                 void APP6_Initialize ( void )
116:                 {
117:                     /* Place the App state machine in its initial state. */
118:                     app6Data.state = APP6_STATE_INIT;
119:                 
120:                     
121:                     /* TODO: Initialize your application's state machine and other
122:                      * parameters.
123:                      */
124:                 }
125:                 
126:                 
127:                 /******************************************************************************
128:                   Function:
129:                     void APP6_Tasks ( void )
130:                 
131:                   Remarks:
132:                     See prototype in app6.h.
133:                  */
134:                 
135:                 void APP6_Tasks ( void )
136:                 {
137:                 
138:                     /* Check the application's current state. */
139:                     switch ( app6Data.state )
00000000  00000000   NOP
140:                     {
141:                         /* Application's initial state. */
142:                         case APP6_STATE_INIT:
143:                         {
144:                             bool appInitialized = true;
145:                        
146:                         
147:                             if (appInitialized)
148:                             {
149:                             
150:                                 app6Data.state = APP6_STATE_SERVICE_TASKS;
0000000C  00000000   NOP
151:                             }
152:                             break;
153:                         }
154:                 
155:                         case APP6_STATE_SERVICE_TASKS:
156:                         {
157:                         
158:                             break;
159:                         }
160:                 
161:                         /* TODO: implement your application state machine.*/
162:                         
163:                 
164:                         /* The default state should never be executed. */
165:                         default:
166:                         {
167:                             /* TODO: Handle error in application's state machine. */
168:                             break;
169:                         }
170:                     }
171:                 }
172:                 
173:                  
174:                 
175:                 /*******************************************************************************
176:                  End of File
177:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/app5.c  -------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app5.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app5.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  APP5_DATA app5Data;
80:                  
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  // Section: Application Callback Functions
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  
87:                  /* TODO:  Add any necessary callback functions.
88:                  */
89:                  
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Application Local Functions
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  
96:                  
97:                  /* TODO:  Add any necessary local functions.
98:                  */
99:                  
100:                 
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 // Section: Application Initialization and State Machine Functions
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 
107:                 /*******************************************************************************
108:                   Function:
109:                     void APP5_Initialize ( void )
110:                 
111:                   Remarks:
112:                     See prototype in app5.h.
113:                  */
114:                 
115:                 void APP5_Initialize ( void )
116:                 {
117:                     /* Place the App state machine in its initial state. */
118:                     app5Data.state = APP5_STATE_INIT;
119:                 
120:                     
121:                     /* TODO: Initialize your application's state machine and other
122:                      * parameters.
123:                      */
124:                 }
125:                 
126:                 
127:                 /******************************************************************************
128:                   Function:
129:                     void APP5_Tasks ( void )
130:                 
131:                   Remarks:
132:                     See prototype in app5.h.
133:                  */
134:                 
135:                 void APP5_Tasks ( void )
136:                 {
137:                 
138:                     /* Check the application's current state. */
139:                     switch ( app5Data.state )
00000000  00000000   NOP
140:                     {
141:                         /* Application's initial state. */
142:                         case APP5_STATE_INIT:
143:                         {
144:                             bool appInitialized = true;
145:                        
146:                         
147:                             if (appInitialized)
148:                             {
149:                             
150:                                 app5Data.state = APP5_STATE_SERVICE_TASKS;
0000000C  00000000   NOP
151:                             }
152:                             break;
153:                         }
154:                 
155:                         case APP5_STATE_SERVICE_TASKS:
156:                         {
157:                         
158:                             break;
159:                         }
160:                 
161:                         /* TODO: implement your application state machine.*/
162:                         
163:                 
164:                         /* The default state should never be executed. */
165:                         default:
166:                         {
167:                             /* TODO: Handle error in application's state machine. */
168:                             break;
169:                         }
170:                     }
171:                 }
172:                 
173:                  
174:                 
175:                 /*******************************************************************************
176:                  End of File
177:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/app4.c  -------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app4.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app4.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  APP4_DATA app4Data;
80:                  
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  // Section: Application Callback Functions
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  
87:                  /* TODO:  Add any necessary callback functions.
88:                  */
89:                  
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Application Local Functions
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  
96:                  
97:                  /* TODO:  Add any necessary local functions.
98:                  */
99:                  
100:                 
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 // Section: Application Initialization and State Machine Functions
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 
107:                 /*******************************************************************************
108:                   Function:
109:                     void APP4_Initialize ( void )
110:                 
111:                   Remarks:
112:                     See prototype in app4.h.
113:                  */
114:                 
115:                 void APP4_Initialize ( void )
116:                 {
117:                     /* Place the App state machine in its initial state. */
118:                     app4Data.state = APP4_STATE_INIT;
119:                 
120:                     
121:                     /* TODO: Initialize your application's state machine and other
122:                      * parameters.
123:                      */
124:                 }
125:                 
126:                 
127:                 /******************************************************************************
128:                   Function:
129:                     void APP4_Tasks ( void )
130:                 
131:                   Remarks:
132:                     See prototype in app4.h.
133:                  */
134:                 
135:                 void APP4_Tasks ( void )
136:                 {
137:                 
138:                     /* Check the application's current state. */
139:                     switch ( app4Data.state )
00000000  00000000   NOP
140:                     {
141:                         /* Application's initial state. */
142:                         case APP4_STATE_INIT:
143:                         {
144:                             bool appInitialized = true;
145:                        
146:                         
147:                             if (appInitialized)
148:                             {
149:                             
150:                                 app4Data.state = APP4_STATE_SERVICE_TASKS;
0000000C  00000000   NOP
151:                             }
152:                             break;
153:                         }
154:                 
155:                         case APP4_STATE_SERVICE_TASKS:
156:                         {
157:                         
158:                             break;
159:                         }
160:                 
161:                         /* TODO: implement your application state machine.*/
162:                         
163:                 
164:                         /* The default state should never be executed. */
165:                         default:
166:                         {
167:                             /* TODO: Handle error in application's state machine. */
168:                             break;
169:                         }
170:                     }
171:                 }
172:                 
173:                  
174:                 
175:                 /*******************************************************************************
176:                  End of File
177:                  */
---  c:/users/daniel/documents/vt 2016-2017/embedded/milestone_4/firmware/src/app3.c  -------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app3.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app3.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  APP3_DATA app3Data;
80:                  
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  // Section: Application Callback Functions
84:                  // *****************************************************************************
85:                  // *****************************************************************************
86:                  
87:                  /* TODO:  Add any necessary callback functions.
88:                  */
89:                  
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  // Section: Application Local Functions
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  
96:                  
97:                  /* TODO:  Add any necessary local functions.
98:                  */
99:                  
100:                 
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 // Section: Application Initialization and State Machine Functions
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 
107:                 /*******************************************************************************
108:                   Function:
109:                     void APP3_Initialize ( void )
110:                 
111:                   Remarks:
112:                     See prototype in app3.h.
113:                  */
114:                 
115:                 void APP3_Initialize ( void )
116:                 {
117:                     /* Place the App state machine in its initial state. */
118:                     app3Data.state = APP3_STATE_INIT;
119:                 
120:                     
121:                     /* TODO: Initialize your application's state machine and other
122:                      * parameters.
123:                      */
124:                 }
125:                 
126:                 
127:                 /******************************************************************************
128:                   Function:
129:                     void APP3_Tasks ( void )
130:                 
131:                   Remarks:
132:                     See prototype in app3.h.
133:                  */
134:                 
135:                 void APP3_Tasks ( void )
136:                 {
137:                 
138:                     /* Check the application's current state. */
139:                     switch ( app3Data.state )
00000000  00000000   NOP
140:                     {
141:                         /* Application's initial state. */
142:                         case APP3_STATE_INIT:
143:                         {
144:                             bool appInitialized = true;
145:                        
146:                         
147:                             if (appInitialized)
148:                             {
149:                             
150:                                 app3Data.state = APP3_STATE_SERVICE_TASKS;
0000000C  00000000   NOP
151:                             }
152:                             break;
153:                         }
154:                 
155:                         case APP3_STATE_SERVICE_TASKS:
156:                         {
157:                         
158:                             break;
159:                         }
160:                 
161:                         /* TODO: implement your application state machine.*/
162:                         
163:                 
164:                         /* The default state should never be executed. */
165:                         default:
166:                         {
167:                             /* TODO: Handle error in application's state machine. */
168:                             break;
169:                         }
170:                     }
171:                 }
172:                 
173:                  
174:                 
175:                 /*******************************************************************************
176:                  End of File
177:                  */
---  c:/microchip/harmony/v1_08_01/third_party/rtos/freertos/source/tasks.c  ----------------------------
1:                   /*
2:                       FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /* Standard includes. */
71:                  #include <stdlib.h>
72:                  #include <string.h>
73:                  
74:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
75:                  all the API functions to use the MPU wrappers.  That should only be done when
76:                  task.h is included from an application file. */
77:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
78:                  
79:                  /* FreeRTOS includes. */
80:                  #include "FreeRTOS.h"
81:                  #include "task.h"
82:                  #include "timers.h"
83:                  #include "StackMacros.h"
84:                  
85:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
86:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
87:                  header files above, but not in this file, in order to generate the correct
88:                  privileged Vs unprivileged linkage and placement. */
89:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
90:                  
91:                  /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
92:                  functions but without including stdio.h here. */
93:                  #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
94:                  	/* At the bottom of this file are two optional functions that can be used
95:                  	to generate human readable text from the raw data generated by the
96:                  	uxTaskGetSystemState() function.  Note the formatting functions are provided
97:                  	for convenience only, and are NOT considered part of the kernel. */
98:                  	#include <stdio.h>
99:                  #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
100:                 
101:                 /* Sanity check the configuration. */
102:                 #if( configUSE_TICKLESS_IDLE != 0 )
103:                 	#if( INCLUDE_vTaskSuspend != 1 )
104:                 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
105:                 	#endif /* INCLUDE_vTaskSuspend */
106:                 #endif /* configUSE_TICKLESS_IDLE */
107:                 
108:                 /*
109:                  * Defines the size, in words, of the stack allocated to the idle task.
110:                  */
111:                 #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
112:                 
113:                 #if( configUSE_PREEMPTION == 0 )
114:                 	/* If the cooperative scheduler is being used then a yield should not be
115:                 	performed just because a higher priority task has been woken. */
116:                 	#define taskYIELD_IF_USING_PREEMPTION()
117:                 #else
118:                 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
119:                 #endif
120:                 
121:                 /* Value that can be assigned to the eNotifyState member of the TCB. */
122:                 typedef enum
123:                 {
124:                 	eNotWaitingNotification = 0,
125:                 	eWaitingNotification,
126:                 	eNotified
127:                 } eNotifyValue;
128:                 
129:                 /*
130:                  * Task control block.  A task control block (TCB) is allocated for each task,
131:                  * and stores task state information, including a pointer to the task's context
132:                  * (the task's run time environment, including register values)
133:                  */
134:                 typedef struct tskTaskControlBlock
135:                 {
136:                 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
137:                 
138:                 	#if ( portUSING_MPU_WRAPPERS == 1 )
139:                 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
140:                 		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocated array, and pdFALSE if the stack is dynamically allocated. */
141:                 	#endif
142:                 
143:                 	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
144:                 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
145:                 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
146:                 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
147:                 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
148:                 
149:                 	#if ( portSTACK_GROWTH > 0 )
150:                 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
151:                 	#endif
152:                 
153:                 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
154:                 		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
155:                 	#endif
156:                 
157:                 	#if ( configUSE_TRACE_FACILITY == 1 )
158:                 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
159:                 		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
160:                 	#endif
161:                 
162:                 	#if ( configUSE_MUTEXES == 1 )
163:                 		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
164:                 		UBaseType_t 	uxMutexesHeld;
165:                 	#endif
166:                 
167:                 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
168:                 		TaskHookFunction_t pxTaskTag;
169:                 	#endif
170:                 
171:                 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
172:                 		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
173:                 	#endif
174:                 
175:                 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
176:                 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
177:                 	#endif
178:                 
179:                 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
180:                 		/* Allocate a Newlib reent structure that is specific to this task.
181:                 		Note Newlib support has been included by popular demand, but is not
182:                 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
183:                 		responsible for resulting newlib operation.  User must be familiar with
184:                 		newlib and must provide system-wide implementations of the necessary
185:                 		stubs. Be warned that (at the time of writing) the current newlib design
186:                 		implements a system-wide malloc() that must be provided with locks. */
187:                 		struct 	_reent xNewLib_reent;
188:                 	#endif
189:                 
190:                 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
191:                 		volatile uint32_t ulNotifiedValue;
192:                 		volatile eNotifyValue eNotifyState;
193:                 	#endif
194:                 
195:                 } tskTCB;
196:                 
197:                 /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
198:                 below to enable the use of older kernel aware debuggers. */
199:                 typedef tskTCB TCB_t;
200:                 
201:                 /*
202:                  * Some kernel aware debuggers require the data the debugger needs access to to
203:                  * be global, rather than file scope.
204:                  */
205:                 #ifdef portREMOVE_STATIC_QUALIFIER
206:                 	#define static
207:                 #endif
208:                 
209:                 /*lint -e956 A manual analysis and inspection has been used to determine which
210:                 static variables must be declared volatile. */
211:                 
212:                 PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
213:                 
214:                 /* Lists for ready and blocked tasks. --------------------*/
215:                 PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
216:                 PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
217:                 PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
218:                 PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
219:                 PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
220:                 PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
221:                 
222:                 #if ( INCLUDE_vTaskDelete == 1 )
223:                 
224:                 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
225:                 	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
226:                 
227:                 #endif
228:                 
229:                 #if ( INCLUDE_vTaskSuspend == 1 )
230:                 
231:                 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
232:                 
233:                 #endif
234:                 
235:                 #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
236:                 
237:                 	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
238:                 
239:                 #endif
240:                 
241:                 /* Other file private variables. --------------------------------*/
242:                 PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
243:                 PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
244:                 PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
245:                 PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
246:                 PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
247:                 PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
248:                 PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
249:                 PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
250:                 PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
251:                 
252:                 /* Context switches are held pending while the scheduler is suspended.  Also,
253:                 interrupts must not manipulate the xGenericListItem of a TCB, or any of the
254:                 lists the xGenericListItem can be referenced from, if the scheduler is suspended.
255:                 If an interrupt needs to unblock a task while the scheduler is suspended then it
256:                 moves the task's event list item into the xPendingReadyList, ready for the
257:                 kernel to move the task from the pending ready list into the real ready list
258:                 when the scheduler is unsuspended.  The pending ready list itself can only be
259:                 accessed from a critical section. */
260:                 PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
261:                 
262:                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
263:                 
264:                 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
265:                 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
266:                 
267:                 #endif
268:                 
269:                 /*lint +e956 */
270:                 
271:                 /* Debugging and trace facilities private variables and macros. ------------*/
272:                 
273:                 /*
274:                  * The value used to fill the stack of a task when the task is created.  This
275:                  * is used purely for checking the high water mark for tasks.
276:                  */
277:                 #define tskSTACK_FILL_BYTE	( 0xa5U )
278:                 
279:                 /*
280:                  * Macros used by vListTask to indicate which state a task is in.
281:                  */
282:                 #define tskBLOCKED_CHAR		( 'B' )
283:                 #define tskREADY_CHAR		( 'R' )
284:                 #define tskDELETED_CHAR		( 'D' )
285:                 #define tskSUSPENDED_CHAR	( 'S' )
286:                 
287:                 /*-----------------------------------------------------------*/
288:                 
289:                 #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
290:                 
291:                 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
292:                 	performed in a generic way that is not optimised to any particular
293:                 	microcontroller architecture. */
294:                 
295:                 	/* uxTopReadyPriority holds the priority of the highest priority ready
296:                 	state task. */
297:                 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
298:                 	{																									\
299:                 		if( ( uxPriority ) > uxTopReadyPriority )														\
300:                 		{																								\
301:                 			uxTopReadyPriority = ( uxPriority );														\
302:                 		}																								\
303:                 	} /* taskRECORD_READY_PRIORITY */
304:                 
305:                 	/*-----------------------------------------------------------*/
306:                 
307:                 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
308:                 	{																									\
309:                 		/* Find the highest priority queue that contains ready tasks. */								\
310:                 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
311:                 		{																								\
312:                 			configASSERT( uxTopReadyPriority );															\
313:                 			--uxTopReadyPriority;																		\
314:                 		}																								\
315:                 																										\
316:                 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
317:                 		the	same priority get an equal share of the processor time. */									\
318:                 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
319:                 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
320:                 
321:                 	/*-----------------------------------------------------------*/
322:                 
323:                 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
324:                 	they are only required when a port optimised method of task selection is
325:                 	being used. */
326:                 	#define taskRESET_READY_PRIORITY( uxPriority )
327:                 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
328:                 
329:                 #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
330:                 
331:                 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
332:                 	performed in a way that is tailored to the particular microcontroller
333:                 	architecture being used. */
334:                 
335:                 	/* A port optimised version is provided.  Call the port defined macros. */
336:                 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
337:                 
338:                 	/*-----------------------------------------------------------*/
339:                 
340:                 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
341:                 	{																								\
342:                 	UBaseType_t uxTopPriority;																		\
343:                 																									\
344:                 		/* Find the highest priority queue that contains ready tasks. */							\
345:                 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
346:                 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
347:                 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
348:                 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
349:                 
350:                 	/*-----------------------------------------------------------*/
351:                 
352:                 	/* A port optimised version is provided, call it only if the TCB being reset
353:                 	is being referenced from a ready list.  If it is referenced from a delayed
354:                 	or suspended list then it won't be in a ready list. */
355:                 	#define taskRESET_READY_PRIORITY( uxPriority )														\
356:                 	{																									\
357:                 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
358:                 		{																								\
359:                 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
360:                 		}																								\
361:                 	}
362:                 
363:                 #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
364:                 
365:                 /*-----------------------------------------------------------*/
366:                 
367:                 /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
368:                 count overflows. */
369:                 #define taskSWITCH_DELAYED_LISTS()																	\
370:                 {																									\
371:                 	List_t *pxTemp;																					\
372:                 																									\
373:                 	/* The delayed tasks list should be empty when the lists are switched. */						\
374:                 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
375:                 																									\
376:                 	pxTemp = pxDelayedTaskList;																		\
377:                 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
378:                 	pxOverflowDelayedTaskList = pxTemp;																\
379:                 	xNumOfOverflows++;																				\
380:                 	prvResetNextTaskUnblockTime();																	\
381:                 }
382:                 
383:                 /*-----------------------------------------------------------*/
384:                 
385:                 /*
386:                  * Place the task represented by pxTCB into the appropriate ready list for
387:                  * the task.  It is inserted at the end of the list.
388:                  */
389:                 #define prvAddTaskToReadyList( pxTCB )																\
390:                 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
391:                 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
392:                 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
393:                 /*-----------------------------------------------------------*/
394:                 
395:                 /*
396:                  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
397:                  * where NULL is used to indicate that the handle of the currently executing
398:                  * task should be used in place of the parameter.  This macro simply checks to
399:                  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
400:                  */
401:                 #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
402:                 
403:                 /* The item value of the event list item is normally used to hold the priority
404:                 of the task to which it belongs (coded to allow it to be held in reverse
405:                 priority order).  However, it is occasionally borrowed for other purposes.  It
406:                 is important its value is not updated due to a task priority change while it is
407:                 being used for another purpose.  The following bit definition is used to inform
408:                 the scheduler that the value should not be changed - in which case it is the
409:                 responsibility of whichever module is using the value to ensure it gets set back
410:                 to its original value when it is released. */
411:                 #if configUSE_16_BIT_TICKS == 1
412:                 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
413:                 #else
414:                 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
415:                 #endif
416:                 
417:                 /* Callback function prototypes. --------------------------*/
418:                 #if configCHECK_FOR_STACK_OVERFLOW > 0
419:                 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
420:                 #endif
421:                 
422:                 #if configUSE_TICK_HOOK > 0
423:                 	extern void vApplicationTickHook( void );
424:                 #endif
425:                 
426:                 /* File private functions. --------------------------------*/
427:                 
428:                 /*
429:                  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
430:                  * into the TCB structure.
431:                  */
432:                 static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
433:                 
434:                 /**
435:                  * Utility task that simply returns pdTRUE if the task referenced by xTask is
436:                  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
437:                  * is in any other state.
438:                  */
439:                 #if ( INCLUDE_vTaskSuspend == 1 )
440:                 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
441:                 #endif /* INCLUDE_vTaskSuspend */
442:                 
443:                 /*
444:                  * Utility to ready all the lists used by the scheduler.  This is called
445:                  * automatically upon the creation of the first task.
446:                  */
447:                 static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
448:                 
449:                 /*
450:                  * The idle task, which as all tasks is implemented as a never ending loop.
451:                  * The idle task is automatically created and added to the ready lists upon
452:                  * creation of the first user task.
453:                  *
454:                  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
455:                  * language extensions.  The equivalent prototype for this function is:
456:                  *
457:                  * void prvIdleTask( void *pvParameters );
458:                  *
459:                  */
460:                 static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
461:                 
462:                 /*
463:                  * Utility to free all memory allocated by the scheduler to hold a TCB,
464:                  * including the stack pointed to by the TCB.
465:                  *
466:                  * This does not free memory allocated by the task itself (i.e. memory
467:                  * allocated by calls to pvPortMalloc from within the tasks application code).
468:                  */
469:                 #if ( INCLUDE_vTaskDelete == 1 )
470:                 
471:                 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
472:                 
473:                 #endif
474:                 
475:                 /*
476:                  * Used only by the idle task.  This checks to see if anything has been placed
477:                  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
478:                  * and its TCB deleted.
479:                  */
480:                 static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
481:                 
482:                 /*
483:                  * The currently executing task is entering the Blocked state.  Add the task to
484:                  * either the current or the overflow delayed task list.
485:                  */
486:                 static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
487:                 
488:                 /*
489:                  * Allocates memory from the heap for a TCB and associated stack.  Checks the
490:                  * allocation was successful.
491:                  */
492:                 static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer ) PRIVILEGED_FUNCTION;
493:                 
494:                 /*
495:                  * Fills an TaskStatus_t structure with information on each task that is
496:                  * referenced from the pxList list (which may be a ready list, a delayed list,
497:                  * a suspended list, etc.).
498:                  *
499:                  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
500:                  * NORMAL APPLICATION CODE.
501:                  */
502:                 #if ( configUSE_TRACE_FACILITY == 1 )
503:                 
504:                 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
505:                 
506:                 #endif
507:                 
508:                 /*
509:                  * When a task is created, the stack of the task is filled with a known value.
510:                  * This function determines the 'high water mark' of the task stack by
511:                  * determining how much of the stack remains at the original preset value.
512:                  */
513:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
514:                 
515:                 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
516:                 
517:                 #endif
518:                 
519:                 /*
520:                  * Return the amount of time, in ticks, that will pass before the kernel will
521:                  * next move a task from the Blocked state to the Running state.
522:                  *
523:                  * This conditional compilation should use inequality to 0, not equality to 1.
524:                  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
525:                  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
526:                  * set to a value other than 1.
527:                  */
528:                 #if ( configUSE_TICKLESS_IDLE != 0 )
529:                 
530:                 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
531:                 
532:                 #endif
533:                 
534:                 /*
535:                  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
536:                  * will exit the Blocked state.
537:                  */
538:                 static void prvResetNextTaskUnblockTime( void );
539:                 
540:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
541:                 
542:                 	/*
543:                 	 * Helper function used to pad task names with spaces when printing out
544:                 	 * human readable tables of task information.
545:                 	 */
546:                 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
547:                 
548:                 #endif
549:                 /*-----------------------------------------------------------*/
550:                 
551:                 BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
552:                 {
9D006A60  27BDFFC0   ADDIU SP, SP, -64
9D006A64  AFBF003C   SW RA, 60(SP)
9D006A68  AFB70038   SW S7, 56(SP)
9D006A6C  AFB60034   SW S6, 52(SP)
9D006A70  AFB50030   SW S5, 48(SP)
9D006A74  AFB4002C   SW S4, 44(SP)
9D006A78  AFB30028   SW S3, 40(SP)
9D006A7C  AFB20024   SW S2, 36(SP)
9D006A80  AFB10020   SW S1, 32(SP)
9D006A84  AFB0001C   SW S0, 28(SP)
9D006A88  0080A821   ADDU S5, A0, ZERO
9D006A8C  00A0B021   ADDU S6, A1, ZERO
9D006A90  00E0A021   ADDU S4, A3, ZERO
9D006A94  8FB30050   LW S3, 80(SP)
9D006A98  8FB20054   LW S2, 84(SP)
9D006A9C  30D1FFFF   ANDI S1, A2, -1
553:                 BaseType_t xReturn;
554:                 TCB_t * pxNewTCB;
555:                 StackType_t *pxTopOfStack;
556:                 
557:                 	configASSERT( pxTaskCode );
558:                 	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
559:                 
560:                 	/* Allocate the memory required by the TCB and stack for the new task,
561:                 	checking that the allocation was successful. */
562:                 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
9D006AA0  02202021   ADDU A0, S1, ZERO
9D006AA4  0F402F1B   JAL prvAllocateTCBAndStack
9D006AA8  8FA50058   LW A1, 88(SP)
563:                 
564:                 	if( pxNewTCB != NULL )
9D006AAC  10400050   BEQ V0, ZERO, 0x9D006BF0
9D006AB0  00408021   ADDU S0, V0, ZERO
565:                 	{
566:                 		#if( portUSING_MPU_WRAPPERS == 1 )
567:                 			/* Should the task be created in privileged mode? */
568:                 			BaseType_t xRunPrivileged;
569:                 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
570:                 			{
571:                 				xRunPrivileged = pdTRUE;
572:                 			}
573:                 			else
574:                 			{
575:                 				xRunPrivileged = pdFALSE;
576:                 			}
577:                 			uxPriority &= ~portPRIVILEGE_BIT;
578:                 
579:                 			if( puxStackBuffer != NULL )
580:                 			{
581:                 				/* The application provided its own stack.  Note this so no
582:                 				attempt is made to delete the stack should that task be
583:                 				deleted. */
584:                 				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
585:                 			}
586:                 			else
587:                 			{
588:                 				/* The stack was allocated dynamically.  Note this so it can be
589:                 				deleted again if the task is deleted. */
590:                 				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
591:                 			}
592:                 		#endif /* portUSING_MPU_WRAPPERS == 1 */
593:                 
594:                 		/* Calculate the top of stack address.  This depends on whether the
595:                 		stack grows from high memory to low (as per the 80x86) or vice versa.
596:                 		portSTACK_GROWTH is used to make the result positive or negative as
597:                 		required by the port. */
598:                 		#if( portSTACK_GROWTH < 0 )
599:                 		{
600:                 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
9D006AB4  3C173FFF   LUI S7, 16383
9D006AB8  36F7FFFF   ORI S7, S7, -1
9D006ABC  0237B821   ADDU S7, S1, S7
9D006AC0  0017B880   SLL S7, S7, 2
9D006AC4  8C420030   LW V0, 48(V0)
9D006AC8  0057B821   ADDU S7, V0, S7
601:                 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
9D006ACC  2402FFF8   ADDIU V0, ZERO, -8
9D006AD0  02E2B824   AND S7, S7, V0
602:                 
603:                 			/* Check the alignment of the calculated top of stack is correct. */
604:                 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
605:                 		}
606:                 		#else /* portSTACK_GROWTH */
607:                 		{
608:                 			pxTopOfStack = pxNewTCB->pxStack;
609:                 
610:                 			/* Check the alignment of the stack buffer is correct. */
611:                 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
612:                 
613:                 			/* If we want to use stack checking on architectures that use
614:                 			a positive stack growth direction then we also need to store the
615:                 			other extreme of the stack space. */
616:                 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
617:                 		}
618:                 		#endif /* portSTACK_GROWTH */
619:                 
620:                 		/* Setup the newly allocated TCB with the initial state of the task. */
621:                 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
9D006AD4  AFB10010   SW S1, 16(SP)
9D006AD8  02002021   ADDU A0, S0, ZERO
9D006ADC  02C02821   ADDU A1, S6, ZERO
9D006AE0  02603021   ADDU A2, S3, ZERO
9D006AE4  0F402B01   JAL prvInitialiseTCBVariables
9D006AE8  8FA7005C   LW A3, 92(SP)
622:                 
623:                 		/* Initialize the TCB stack to look as if the task was already running,
624:                 		but had been interrupted by the scheduler.  The return address is set
625:                 		to the start of the task function. Once the stack has been initialised
626:                 		the	top of stack variable is updated. */
627:                 		#if( portUSING_MPU_WRAPPERS == 1 )
628:                 		{
629:                 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
630:                 		}
631:                 		#else /* portUSING_MPU_WRAPPERS */
632:                 		{
633:                 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
9D006AEC  02E02021   ADDU A0, S7, ZERO
9D006AF0  02A02821   ADDU A1, S5, ZERO
9D006AF4  0F40334B   JAL pxPortInitialiseStack
9D006AF8  02803021   ADDU A2, S4, ZERO
634:                 		}
635:                 		#endif /* portUSING_MPU_WRAPPERS */
636:                 
637:                 		if( ( void * ) pxCreatedTask != NULL )
9D006AFC  12400002   BEQ S2, ZERO, 0x9D006B08
9D006B00  AE020000   SW V0, 0(S0)
638:                 		{
639:                 			/* Pass the TCB out - in an anonymous way.  The calling function/
640:                 			task can use this as a handle to delete the task later if
641:                 			required.*/
642:                 			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
9D006B04  AE500000   SW S0, 0(S2)
643:                 		}
644:                 		else
645:                 		{
646:                 			mtCOVERAGE_TEST_MARKER();
647:                 		}
648:                 
649:                 		/* Ensure interrupts don't access the task lists while they are being
650:                 		updated. */
651:                 		taskENTER_CRITICAL();
9D006B08  0F40339E   JAL vTaskEnterCritical
9D006B0C  00000000   NOP
652:                 		{
653:                 			uxCurrentNumberOfTasks++;
9D006B10  8F828080   LW V0, -32640(GP)
9D006B14  24420001   ADDIU V0, V0, 1
9D006B18  AF828080   SW V0, -32640(GP)
654:                 			if( pxCurrentTCB == NULL )
9D006B1C  8F828088   LW V0, -32632(GP)
9D006B20  1440000A   BNE V0, ZERO, 0x9D006B4C
9D006B24  00000000   NOP
655:                 			{
656:                 				/* There are no other tasks, or all the other tasks are in
657:                 				the suspended state - make this the current task. */
658:                 				pxCurrentTCB =  pxNewTCB;
9D006B28  AF908088   SW S0, -32632(GP)
659:                 
660:                 				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
9D006B2C  8F838080   LW V1, -32640(GP)
9D006B30  24020001   ADDIU V0, ZERO, 1
9D006B34  5462000E   BNEL V1, V0, 0x9D006B70
9D006B38  8F828064   LW V0, -32668(GP)
661:                 				{
662:                 					/* This is the first task to be created so do the preliminary
663:                 					initialisation required.  We will not recover if this call
664:                 					fails, but we will report the failure. */
665:                 					prvInitialiseTaskLists();
9D006B3C  0F402E90   JAL prvInitialiseTaskLists
9D006B40  00000000   NOP
9D006B44  0B401ADC   J 0x9D006B70
9D006B48  8F828064   LW V0, -32668(GP)
666:                 				}
667:                 				else
668:                 				{
669:                 					mtCOVERAGE_TEST_MARKER();
670:                 				}
671:                 			}
672:                 			else
673:                 			{
674:                 				/* If the scheduler is not already running, make this task the
675:                 				current task if it is the highest priority task to be created
676:                 				so far. */
677:                 				if( xSchedulerRunning == pdFALSE )
9D006B4C  8F828074   LW V0, -32652(GP)
9D006B50  14400007   BNE V0, ZERO, 0x9D006B70
9D006B54  8F828064   LW V0, -32668(GP)
678:                 				{
679:                 					if( pxCurrentTCB->uxPriority <= uxPriority )
9D006B58  8F828088   LW V0, -32632(GP)
9D006B5C  8C42002C   LW V0, 44(V0)
9D006B60  0262102B   SLTU V0, S3, V0
9D006B64  50400001   BEQL V0, ZERO, 0x9D006B6C
9D006B68  AF908088   SW S0, -32632(GP)
680:                 					{
681:                 						pxCurrentTCB = pxNewTCB;
682:                 					}
683:                 					else
684:                 					{
685:                 						mtCOVERAGE_TEST_MARKER();
686:                 					}
687:                 				}
688:                 				else
689:                 				{
690:                 					mtCOVERAGE_TEST_MARKER();
691:                 				}
692:                 			}
693:                 
694:                 			uxTaskNumber++;
9D006B6C  8F828064   LW V0, -32668(GP)
9D006B70  24420001   ADDIU V0, V0, 1
9D006B74  AF828064   SW V0, -32668(GP)
695:                 
696:                 			#if ( configUSE_TRACE_FACILITY == 1 )
697:                 			{
698:                 				/* Add a counter into the TCB for tracing only. */
699:                 				pxNewTCB->uxTCBNumber = uxTaskNumber;
700:                 			}
701:                 			#endif /* configUSE_TRACE_FACILITY */
702:                 			traceTASK_CREATE( pxNewTCB );
703:                 
704:                 			prvAddTaskToReadyList( pxNewTCB );
9D006B78  8E02002C   LW V0, 44(S0)
9D006B7C  8F848078   LW A0, -32648(GP)
9D006B80  24030001   ADDIU V1, ZERO, 1
9D006B84  00431804   SLLV V1, V1, V0
9D006B88  00641825   OR V1, V1, A0
9D006B8C  AF838078   SW V1, -32648(GP)
9D006B90  00021880   SLL V1, V0, 2
9D006B94  00021100   SLL V0, V0, 4
9D006B98  00621021   ADDU V0, V1, V0
9D006B9C  3C04A000   LUI A0, -24576
9D006BA0  24840BC0   ADDIU A0, A0, 3008
9D006BA4  00822021   ADDU A0, A0, V0
9D006BA8  0F4035EF   JAL vListInsertEnd
9D006BAC  26050004   ADDIU A1, S0, 4
705:                 
706:                 			xReturn = pdPASS;
707:                 			portSETUP_TCB( pxNewTCB );
708:                 		}
709:                 		taskEXIT_CRITICAL();
9D006BB0  0F403151   JAL vTaskExitCritical
9D006BB4  00000000   NOP
710:                 	}
711:                 	else
712:                 	{
713:                 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
9D006BF0  2402FFFF   ADDIU V0, ZERO, -1
714:                 		traceTASK_CREATE_FAILED();
715:                 	}
716:                 
717:                 	if( xReturn == pdPASS )
718:                 	{
719:                 		if( xSchedulerRunning != pdFALSE )
9D006BB8  8F838074   LW V1, -32652(GP)
9D006BBC  1060000D   BEQ V1, ZERO, 0x9D006BF4
9D006BC0  24020001   ADDIU V0, ZERO, 1
720:                 		{
721:                 			/* If the created task is of a higher priority than the current task
722:                 			then it should run now. */
723:                 			if( pxCurrentTCB->uxPriority < uxPriority )
9D006BC4  8F828088   LW V0, -32632(GP)
9D006BC8  8C42002C   LW V0, 44(V0)
9D006BCC  0053982B   SLTU S3, V0, S3
9D006BD0  12600008   BEQ S3, ZERO, 0x9D006BF4
9D006BD4  24020001   ADDIU V0, ZERO, 1
724:                 			{
725:                 				taskYIELD_IF_USING_PREEMPTION();
9D006BD8  40026800   MFC0 V0, Cause
9D006BDC  34420100   ORI V0, V0, 256
9D006BE0  40826800   MTC0 V0, Cause
9D006BE4  000000C0   EHB
9D006BE8  0B401AFD   J 0x9D006BF4
9D006BEC  24020001   ADDIU V0, ZERO, 1
726:                 			}
727:                 			else
728:                 			{
729:                 				mtCOVERAGE_TEST_MARKER();
730:                 			}
731:                 		}
732:                 		else
733:                 		{
734:                 			mtCOVERAGE_TEST_MARKER();
735:                 		}
736:                 	}
737:                 
738:                 	return xReturn;
739:                 }
9D006BF4  8FBF003C   LW RA, 60(SP)
9D006BF8  8FB70038   LW S7, 56(SP)
9D006BFC  8FB60034   LW S6, 52(SP)
9D006C00  8FB50030   LW S5, 48(SP)
9D006C04  8FB4002C   LW S4, 44(SP)
9D006C08  8FB30028   LW S3, 40(SP)
9D006C0C  8FB20024   LW S2, 36(SP)
9D006C10  8FB10020   LW S1, 32(SP)
9D006C14  8FB0001C   LW S0, 28(SP)
9D006C18  03E00008   JR RA
9D006C1C  27BD0040   ADDIU SP, SP, 64
740:                 /*-----------------------------------------------------------*/
741:                 
742:                 #if ( INCLUDE_vTaskDelete == 1 )
743:                 
744:                 	void vTaskDelete( TaskHandle_t xTaskToDelete )
745:                 	{
00000000  00000000   NOP
746:                 	TCB_t *pxTCB;
747:                 
748:                 		taskENTER_CRITICAL();
00000010  00000000   NOP
749:                 		{
750:                 			/* If null is passed in here then it is the calling task that is
751:                 			being deleted. */
752:                 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
00000018  00000000   NOP
753:                 
754:                 			/* Remove task from the ready list and place in the	termination list.
755:                 			This will stop the task from be scheduled.  The idle task will check
756:                 			the termination list and free up any memory allocated by the
757:                 			scheduler for the TCB and stack. */
758:                 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00000020  00000000   NOP
759:                 			{
760:                 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00000034  00000000   NOP
761:                 			}
762:                 			else
763:                 			{
764:                 				mtCOVERAGE_TEST_MARKER();
765:                 			}
766:                 
767:                 			/* Is the task waiting on an event also? */
768:                 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00000074  00000000   NOP
769:                 			{
770:                 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00000080  00000000   NOP
771:                 			}
772:                 			else
773:                 			{
774:                 				mtCOVERAGE_TEST_MARKER();
775:                 			}
776:                 
777:                 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
00000088  00000000   NOP
778:                 
779:                 			/* Increment the ucTasksDeleted variable so the idle task knows
780:                 			there is a task that has been deleted and that it should therefore
781:                 			check the xTasksWaitingTermination list. */
782:                 			++uxTasksDeleted;
00000098  00000000   NOP
783:                 
784:                 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
785:                 			can detect that the task lists need re-generating. */
786:                 			uxTaskNumber++;
000000A4  00000000   NOP
787:                 
788:                 			traceTASK_DELETE( pxTCB );
789:                 		}
790:                 		taskEXIT_CRITICAL();
000000AC  00000000   NOP
791:                 
792:                 		/* Force a reschedule if it is the currently running task that has just
793:                 		been deleted. */
794:                 		if( xSchedulerRunning != pdFALSE )
000000B4  00000000   NOP
795:                 		{
796:                 			if( pxTCB == pxCurrentTCB )
000000C0  00000000   NOP
797:                 			{
798:                 				configASSERT( uxSchedulerSuspended == 0 );
799:                 
800:                 				/* The pre-delete hook is primarily for the Windows simulator,
801:                 				in which Windows specific clean up operations are performed,
802:                 				after which it is not possible to yield away from this task -
803:                 				hence xYieldPending is used to latch that a context switch is
804:                 				required. */
805:                 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
806:                 				portYIELD_WITHIN_API();
000000CC  00000000   NOP
807:                 			}
808:                 			else
809:                 			{
810:                 				/* Reset the next expected unblock time in case it referred to
811:                 				the task that has just been deleted. */
812:                 				taskENTER_CRITICAL();
000000E4  00000000   NOP
813:                 				{
814:                 					prvResetNextTaskUnblockTime();
000000EC  00000000   NOP
815:                 				}
816:                 				taskEXIT_CRITICAL();
000000F4  00000000   NOP
817:                 			}
818:                 		}
819:                 	}
000000FC  00000000   NOP
820:                 
821:                 #endif /* INCLUDE_vTaskDelete */
822:                 /*-----------------------------------------------------------*/
823:                 
824:                 #if ( INCLUDE_vTaskDelayUntil == 1 )
825:                 
826:                 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
827:                 	{
00000000  00000000   NOP
828:                 	TickType_t xTimeToWake;
829:                 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
830:                 
831:                 		configASSERT( pxPreviousWakeTime );
832:                 		configASSERT( ( xTimeIncrement > 0U ) );
833:                 		configASSERT( uxSchedulerSuspended == 0 );
834:                 
835:                 		vTaskSuspendAll();
00000014  00000000   NOP
836:                 		{
837:                 			/* Minor optimisation.  The tick count cannot change in this
838:                 			block. */
839:                 			const TickType_t xConstTickCount = xTickCount;
0000001C  00000000   NOP
840:                 
841:                 			/* Generate the tick time at which the task wants to wake. */
842:                 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
00000020  00000000   NOP
843:                 
844:                 			if( xConstTickCount < *pxPreviousWakeTime )
00000024  00000000   NOP
845:                 			{
846:                 				/* The tick count has overflowed since this function was
847:                 				lasted called.  In this case the only time we should ever
848:                 				actually delay is if the wake time has also	overflowed,
849:                 				and the wake time is greater than the tick time.  When this
850:                 				is the case it is as if neither time had overflowed. */
851:                 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
00000030  00000000   NOP
852:                 				{
853:                 					xShouldDelay = pdTRUE;
854:                 				}
855:                 				else
856:                 				{
857:                 					mtCOVERAGE_TEST_MARKER();
858:                 				}
859:                 			}
860:                 			else
861:                 			{
862:                 				/* The tick time has not overflowed.  In this case we will
863:                 				delay if either the wake time has overflowed, and/or the
864:                 				tick time is less than the wake time. */
865:                 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
00000050  00000000   NOP
866:                 				{
867:                 					xShouldDelay = pdTRUE;
868:                 				}
869:                 				else
870:                 				{
871:                 					mtCOVERAGE_TEST_MARKER();
872:                 				}
873:                 			}
874:                 
875:                 			/* Update the wake time ready for the next call. */
876:                 			*pxPreviousWakeTime = xTimeToWake;
877:                 
878:                 			if( xShouldDelay != pdFALSE )
0000003C  00000000   NOP
879:                 			{
880:                 				traceTASK_DELAY_UNTIL();
881:                 
882:                 				/* Remove the task from the ready list before adding it to the
883:                 				blocked list as the same list item is used for both lists. */
884:                 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00000068  00000000   NOP
885:                 				{
886:                 					/* The current task must be in a ready list, so there is
887:                 					no need to check, and the port reset macro can be called
888:                 					directly. */
889:                 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
0000007C  00000000   NOP
890:                 				}
891:                 				else
892:                 				{
893:                 					mtCOVERAGE_TEST_MARKER();
894:                 				}
895:                 
896:                 				prvAddCurrentTaskToDelayedList( xTimeToWake );
0000009C  00000000   NOP
897:                 			}
898:                 			else
899:                 			{
900:                 				mtCOVERAGE_TEST_MARKER();
901:                 			}
902:                 		}
903:                 		xAlreadyYielded = xTaskResumeAll();
000000A4  00000000   NOP
904:                 
905:                 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
906:                 		have put ourselves to sleep. */
907:                 		if( xAlreadyYielded == pdFALSE )
000000AC  00000000   NOP
908:                 		{
909:                 			portYIELD_WITHIN_API();
000000B4  00000000   NOP
910:                 		}
911:                 		else
912:                 		{
913:                 			mtCOVERAGE_TEST_MARKER();
914:                 		}
915:                 	}
000000C8  00000000   NOP
916:                 
917:                 #endif /* INCLUDE_vTaskDelayUntil */
918:                 /*-----------------------------------------------------------*/
919:                 
920:                 #if ( INCLUDE_vTaskDelay == 1 )
921:                 
922:                 	void vTaskDelay( const TickType_t xTicksToDelay )
923:                 	{
00000000  00000000   NOP
924:                 	TickType_t xTimeToWake;
925:                 	BaseType_t xAlreadyYielded = pdFALSE;
926:                 
927:                 
928:                 		/* A delay time of zero just forces a reschedule. */
929:                 		if( xTicksToDelay > ( TickType_t ) 0U )
0000000C  00000000   NOP
930:                 		{
931:                 			configASSERT( uxSchedulerSuspended == 0 );
932:                 			vTaskSuspendAll();
00000014  00000000   NOP
933:                 			{
934:                 				traceTASK_DELAY();
935:                 
936:                 				/* A task that is removed from the event list while the
937:                 				scheduler is suspended will not get placed in the ready
938:                 				list or removed from the blocked list until the scheduler
939:                 				is resumed.
940:                 
941:                 				This task cannot be in an event list as it is the currently
942:                 				executing task. */
943:                 
944:                 				/* Calculate the time to wake - this may overflow but this is
945:                 				not a problem. */
946:                 				xTimeToWake = xTickCount + xTicksToDelay;
0000001C  00000000   NOP
947:                 
948:                 				/* We must remove ourselves from the ready list before adding
949:                 				ourselves to the blocked list as the same list item is used for
950:                 				both lists. */
951:                 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00000024  00000000   NOP
952:                 				{
953:                 					/* The current task must be in a ready list, so there is
954:                 					no need to check, and the port reset macro can be called
955:                 					directly. */
956:                 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
00000038  00000000   NOP
957:                 				}
958:                 				else
959:                 				{
960:                 					mtCOVERAGE_TEST_MARKER();
961:                 				}
962:                 				prvAddCurrentTaskToDelayedList( xTimeToWake );
00000058  00000000   NOP
963:                 			}
964:                 			xAlreadyYielded = xTaskResumeAll();
00000060  00000000   NOP
965:                 		}
966:                 		else
967:                 		{
968:                 			mtCOVERAGE_TEST_MARKER();
969:                 		}
970:                 
971:                 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
972:                 		have put ourselves to sleep. */
973:                 		if( xAlreadyYielded == pdFALSE )
00000068  00000000   NOP
974:                 		{
975:                 			portYIELD_WITHIN_API();
00000070  00000000   NOP
976:                 		}
977:                 		else
978:                 		{
979:                 			mtCOVERAGE_TEST_MARKER();
980:                 		}
981:                 	}
00000080  00000000   NOP
982:                 
983:                 #endif /* INCLUDE_vTaskDelay */
984:                 /*-----------------------------------------------------------*/
985:                 
986:                 #if ( INCLUDE_eTaskGetState == 1 )
987:                 
988:                 	eTaskState eTaskGetState( TaskHandle_t xTask )
989:                 	{
990:                 	eTaskState eReturn;
991:                 	List_t *pxStateList;
992:                 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
993:                 
994:                 		configASSERT( pxTCB );
995:                 
996:                 		if( pxTCB == pxCurrentTCB )
997:                 		{
998:                 			/* The task calling this function is querying its own state. */
999:                 			eReturn = eRunning;
1000:                		}
1001:                		else
1002:                		{
1003:                			taskENTER_CRITICAL();
1004:                			{
1005:                				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
1006:                			}
1007:                			taskEXIT_CRITICAL();
1008:                
1009:                			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1010:                			{
1011:                				/* The task being queried is referenced from one of the Blocked
1012:                				lists. */
1013:                				eReturn = eBlocked;
1014:                			}
1015:                
1016:                			#if ( INCLUDE_vTaskSuspend == 1 )
1017:                				else if( pxStateList == &xSuspendedTaskList )
1018:                				{
1019:                					/* The task being queried is referenced from the suspended
1020:                					list.  Is it genuinely suspended or is it block
1021:                					indefinitely? */
1022:                					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1023:                					{
1024:                						eReturn = eSuspended;
1025:                					}
1026:                					else
1027:                					{
1028:                						eReturn = eBlocked;
1029:                					}
1030:                				}
1031:                			#endif
1032:                
1033:                			#if ( INCLUDE_vTaskDelete == 1 )
1034:                				else if( pxStateList == &xTasksWaitingTermination )
1035:                				{
1036:                					/* The task being queried is referenced from the deleted
1037:                					tasks list. */
1038:                					eReturn = eDeleted;
1039:                				}
1040:                			#endif
1041:                
1042:                			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1043:                			{
1044:                				/* If the task is not in any other state, it must be in the
1045:                				Ready (including pending ready) state. */
1046:                				eReturn = eReady;
1047:                			}
1048:                		}
1049:                
1050:                		return eReturn;
1051:                	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1052:                
1053:                #endif /* INCLUDE_eTaskGetState */
1054:                /*-----------------------------------------------------------*/
1055:                
1056:                #if ( INCLUDE_uxTaskPriorityGet == 1 )
1057:                
1058:                	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1059:                	{
00000000  00000000   NOP
1060:                	TCB_t *pxTCB;
1061:                	UBaseType_t uxReturn;
1062:                
1063:                		taskENTER_CRITICAL();
0000000C  00000000   NOP
1064:                		{
1065:                			/* If null is passed in here then it is the priority of the that
1066:                			called uxTaskPriorityGet() that is being queried. */
1067:                			pxTCB = prvGetTCBFromHandle( xTask );
00000014  00000000   NOP
1068:                			uxReturn = pxTCB->uxPriority;
1069:                		}
1070:                		taskEXIT_CRITICAL();
0000001C  00000000   NOP
1071:                
1072:                		return uxReturn;
1073:                	}
00000024  00000000   NOP
1074:                
1075:                #endif /* INCLUDE_uxTaskPriorityGet */
1076:                /*-----------------------------------------------------------*/
1077:                
1078:                #if ( INCLUDE_uxTaskPriorityGet == 1 )
1079:                
1080:                	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1081:                	{
00000000  00000000   NOP
1082:                	TCB_t *pxTCB;
1083:                	UBaseType_t uxReturn, uxSavedInterruptState;
1084:                
1085:                		/* RTOS ports that support interrupt nesting have the concept of a
1086:                		maximum	system call (or maximum API call) interrupt priority.
1087:                		Interrupts that are	above the maximum system call priority are keep
1088:                		permanently enabled, even when the RTOS kernel is in a critical section,
1089:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1090:                		is defined in FreeRTOSConfig.h then
1091:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1092:                		failure if a FreeRTOS API function is called from an interrupt that has
1093:                		been assigned a priority above the configured maximum system call
1094:                		priority.  Only FreeRTOS functions that end in FromISR can be called
1095:                		from interrupts	that have been assigned a priority at or (logically)
1096:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
1097:                		separate interrupt safe API to ensure interrupt entry is as fast and as
1098:                		simple as possible.  More information (albeit Cortex-M specific) is
1099:                		provided on the following link:
1100:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1101:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1102:                
1103:                		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
0000000C  00000000   NOP
1104:                		{
1105:                			/* If null is passed in here then it is the priority of the calling
1106:                			task that is being queried. */
1107:                			pxTCB = prvGetTCBFromHandle( xTask );
00000014  00000000   NOP
1108:                			uxReturn = pxTCB->uxPriority;
0000001C  00000000   NOP
1109:                		}
1110:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
00000020  00000000   NOP
1111:                
1112:                		return uxReturn;
1113:                	}
00000028  00000000   NOP
1114:                
1115:                #endif /* INCLUDE_uxTaskPriorityGet */
1116:                /*-----------------------------------------------------------*/
1117:                
1118:                #if ( INCLUDE_vTaskPrioritySet == 1 )
1119:                
1120:                	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1121:                	{
00000000  00000000   NOP
1122:                	TCB_t *pxTCB;
1123:                	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1124:                	BaseType_t xYieldRequired = pdFALSE;
1125:                
1126:                		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1127:                
1128:                		/* Ensure the new priority is valid. */
1129:                		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1130:                		{
1131:                			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1132:                		}
1133:                		else
1134:                		{
1135:                			mtCOVERAGE_TEST_MARKER();
1136:                		}
1137:                
1138:                		taskENTER_CRITICAL();
00000028  00000000   NOP
1139:                		{
1140:                			/* If null is passed in here then it is the priority of the calling
1141:                			task that is being changed. */
1142:                			pxTCB = prvGetTCBFromHandle( xTask );
00000030  00000000   NOP
1143:                
1144:                			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1145:                
1146:                			#if ( configUSE_MUTEXES == 1 )
1147:                			{
1148:                				uxCurrentBasePriority = pxTCB->uxBasePriority;
00000038  00000000   NOP
1149:                			}
1150:                			#else
1151:                			{
1152:                				uxCurrentBasePriority = pxTCB->uxPriority;
1153:                			}
1154:                			#endif
1155:                
1156:                			if( uxCurrentBasePriority != uxNewPriority )
0000003C  00000000   NOP
1157:                			{
1158:                				/* The priority change may have readied a task of higher
1159:                				priority than the calling task. */
1160:                				if( uxNewPriority > uxCurrentBasePriority )
00000044  00000000   NOP
1161:                				{
1162:                					if( pxTCB != pxCurrentTCB )
0000004C  00000000   NOP
1163:                					{
1164:                						/* The priority of a task other than the currently
1165:                						running task is being raised.  Is the priority being
1166:                						raised above that of the running task? */
1167:                						if( uxNewPriority >= pxCurrentTCB->uxPriority )
00000058  00000000   NOP
1168:                						{
1169:                							xYieldRequired = pdTRUE;
1170:                						}
1171:                						else
1172:                						{
1173:                							mtCOVERAGE_TEST_MARKER();
1174:                						}
1175:                					}
1176:                					else
1177:                					{
1178:                						/* The priority of the running task is being raised,
1179:                						but the running task must already be the highest
1180:                						priority task able to run so no yield is required. */
1181:                					}
1182:                				}
1183:                				else if( pxTCB == pxCurrentTCB )
0000006C  00000000   NOP
1184:                				{
1185:                					/* Setting the priority of the running task down means
1186:                					there may now be another task of higher priority that
1187:                					is ready to execute. */
1188:                					xYieldRequired = pdTRUE;
1189:                				}
1190:                				else
1191:                				{
1192:                					/* Setting the priority of any other task down does not
1193:                					require a yield as the running task must be above the
1194:                					new priority of the task being modified. */
1195:                				}
1196:                
1197:                				/* Remember the ready list the task might be referenced from
1198:                				before its uxPriority member is changed so the
1199:                				taskRESET_READY_PRIORITY() macro can function correctly. */
1200:                				uxPriorityUsedOnEntry = pxTCB->uxPriority;
00000078  00000000   NOP
1201:                
1202:                				#if ( configUSE_MUTEXES == 1 )
1203:                				{
1204:                					/* Only change the priority being used if the task is not
1205:                					currently using an inherited priority. */
1206:                					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
0000007C  00000000   NOP
1207:                					{
1208:                						pxTCB->uxPriority = uxNewPriority;
1209:                					}
1210:                					else
1211:                					{
1212:                						mtCOVERAGE_TEST_MARKER();
1213:                					}
1214:                
1215:                					/* The base priority gets set whatever. */
1216:                					pxTCB->uxBasePriority = uxNewPriority;
00000084  00000000   NOP
1217:                				}
1218:                				#else
1219:                				{
1220:                					pxTCB->uxPriority = uxNewPriority;
1221:                				}
1222:                				#endif
1223:                
1224:                				/* Only reset the event list item value if the value is not
1225:                				being used for anything else. */
1226:                				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
00000088  00000000   NOP
1227:                				{
1228:                					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00000094  00000000   NOP
1229:                				}
1230:                				else
1231:                				{
1232:                					mtCOVERAGE_TEST_MARKER();
1233:                				}
1234:                
1235:                				/* If the task is in the blocked or suspended list we need do
1236:                				nothing more than change it's priority variable. However, if
1237:                				the task is in a ready list it needs to be removed and placed
1238:                				in the list appropriate to its new priority. */
1239:                				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
0000009C  00000000   NOP
1240:                				{
1241:                					/* The task is currently in its ready list - remove before adding
1242:                					it to it's new ready list.  As we are in a critical section we
1243:                					can do this even if the scheduler is suspended. */
1244:                					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000000C0  00000000   NOP
1245:                					{
1246:                						/* It is known that the task is in its ready list so
1247:                						there is no need to check again and the port level
1248:                						reset macro can be called directly. */
1249:                						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
000000D0  00000000   NOP
1250:                					}
1251:                					else
1252:                					{
1253:                						mtCOVERAGE_TEST_MARKER();
1254:                					}
1255:                					prvAddTaskToReadyList( pxTCB );
000000E8  00000000   NOP
1256:                				}
1257:                				else
1258:                				{
1259:                					mtCOVERAGE_TEST_MARKER();
1260:                				}
1261:                
1262:                				if( xYieldRequired == pdTRUE )
00000120  00000000   NOP
1263:                				{
1264:                					taskYIELD_IF_USING_PREEMPTION();
00000128  00000000   NOP
1265:                				}
1266:                				else
1267:                				{
1268:                					mtCOVERAGE_TEST_MARKER();
1269:                				}
1270:                
1271:                				/* Remove compiler warning about unused variables when the port
1272:                				optimised task selection is not being used. */
1273:                				( void ) uxPriorityUsedOnEntry;
1274:                			}
1275:                		}
1276:                		taskEXIT_CRITICAL();
00000138  00000000   NOP
1277:                	}
00000140  00000000   NOP
1278:                
1279:                #endif /* INCLUDE_vTaskPrioritySet */
1280:                /*-----------------------------------------------------------*/
1281:                
1282:                #if ( INCLUDE_vTaskSuspend == 1 )
1283:                
1284:                	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1285:                	{
00000000  00000000   NOP
1286:                	TCB_t *pxTCB;
1287:                
1288:                		taskENTER_CRITICAL();
00000010  00000000   NOP
1289:                		{
1290:                			/* If null is passed in here then it is the running task that is
1291:                			being suspended. */
1292:                			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
00000018  00000000   NOP
1293:                
1294:                			traceTASK_SUSPEND( pxTCB );
1295:                
1296:                			/* Remove task from the ready/delayed list and place in the
1297:                			suspended list. */
1298:                			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00000020  00000000   NOP
1299:                			{
1300:                				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00000034  00000000   NOP
1301:                			}
1302:                			else
1303:                			{
1304:                				mtCOVERAGE_TEST_MARKER();
1305:                			}
1306:                
1307:                			/* Is the task waiting on an event also? */
1308:                			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00000074  00000000   NOP
1309:                			{
1310:                				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00000080  00000000   NOP
1311:                			}
1312:                			else
1313:                			{
1314:                				mtCOVERAGE_TEST_MARKER();
1315:                			}
1316:                
1317:                			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
00000088  00000000   NOP
1318:                		}
1319:                		taskEXIT_CRITICAL();
00000098  00000000   NOP
1320:                
1321:                		if( pxTCB == pxCurrentTCB )
000000A0  00000000   NOP
1322:                		{
1323:                			if( xSchedulerRunning != pdFALSE )
000000AC  00000000   NOP
1324:                			{
1325:                				/* The current task has just been suspended. */
1326:                				configASSERT( uxSchedulerSuspended == 0 );
1327:                				portYIELD_WITHIN_API();
000000B8  00000000   NOP
1328:                			}
1329:                			else
1330:                			{
1331:                				/* The scheduler is not running, but the task that was pointed
1332:                				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1333:                				must be adjusted to point to a different task. */
1334:                				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
000000D0  00000000   NOP
1335:                				{
1336:                					/* No other tasks are ready, so set pxCurrentTCB back to
1337:                					NULL so when the next task is created pxCurrentTCB will
1338:                					be set to point to it no matter what its relative priority
1339:                					is. */
1340:                					pxCurrentTCB = NULL;
000000E4  00000000   NOP
1341:                				}
1342:                				else
1343:                				{
1344:                					vTaskSwitchContext();
000000F0  00000000   NOP
1345:                				}
1346:                			}
1347:                		}
1348:                		else
1349:                		{
1350:                			if( xSchedulerRunning != pdFALSE )
00000100  00000000   NOP
1351:                			{
1352:                				/* A task other than the currently running task was suspended,
1353:                				reset the next expected unblock time in case it referred to the
1354:                				task that is now in the Suspended state. */
1355:                				taskENTER_CRITICAL();
0000010C  00000000   NOP
1356:                				{
1357:                					prvResetNextTaskUnblockTime();
00000114  00000000   NOP
1358:                				}
1359:                				taskEXIT_CRITICAL();
0000011C  00000000   NOP
1360:                			}
1361:                			else
1362:                			{
1363:                				mtCOVERAGE_TEST_MARKER();
1364:                			}
1365:                		}
1366:                	}
000000F8  00000000   NOP
00000124  00000000   NOP
1367:                
1368:                #endif /* INCLUDE_vTaskSuspend */
1369:                /*-----------------------------------------------------------*/
1370:                
1371:                #if ( INCLUDE_vTaskSuspend == 1 )
1372:                
1373:                	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1374:                	{
1375:                	BaseType_t xReturn = pdFALSE;
1376:                	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1377:                
1378:                		/* Accesses xPendingReadyList so must be called from a critical
1379:                		section. */
1380:                
1381:                		/* It does not make sense to check if the calling task is suspended. */
1382:                		configASSERT( xTask );
1383:                
1384:                		/* Is the task being resumed actually in the suspended list? */
1385:                		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
00000000  00000000   NOP
1386:                		{
1387:                			/* Has the task already been resumed from within an ISR? */
1388:                			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
00000014  00000000   NOP
1389:                			{
1390:                				/* Is it in the suspended list because it is in the	Suspended
1391:                				state, or because is is blocked with no timeout? */
1392:                				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
00000018  00000000   NOP
1393:                				{
1394:                					xReturn = pdTRUE;
1395:                				}
1396:                				else
1397:                				{
1398:                					mtCOVERAGE_TEST_MARKER();
1399:                				}
1400:                			}
1401:                			else
1402:                			{
1403:                				mtCOVERAGE_TEST_MARKER();
1404:                			}
1405:                		}
1406:                		else
1407:                		{
1408:                			mtCOVERAGE_TEST_MARKER();
1409:                		}
1410:                
1411:                		return xReturn;
1412:                	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00000030  00000000   NOP
1413:                
1414:                #endif /* INCLUDE_vTaskSuspend */
1415:                /*-----------------------------------------------------------*/
1416:                
1417:                #if ( INCLUDE_vTaskSuspend == 1 )
1418:                
1419:                	void vTaskResume( TaskHandle_t xTaskToResume )
1420:                	{
00000000  00000000   NOP
1421:                	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1422:                
1423:                		/* It does not make sense to resume the calling task. */
1424:                		configASSERT( xTaskToResume );
1425:                
1426:                		/* The parameter cannot be NULL as it is impossible to resume the
1427:                		currently executing task. */
1428:                		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
00000010  00000000   NOP
1429:                		{
1430:                			taskENTER_CRITICAL();
00000024  00000000   NOP
1431:                			{
1432:                				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
0000002C  00000000   NOP
1433:                				{
1434:                					traceTASK_RESUME( pxTCB );
1435:                
1436:                					/* As we are in a critical section we can access the ready
1437:                					lists even if the scheduler is suspended. */
1438:                					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
00000040  00000000   NOP
1439:                					prvAddTaskToReadyList( pxTCB );
00000048  00000000   NOP
1440:                
1441:                					/* We may have just resumed a higher priority task. */
1442:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00000080  00000000   NOP
1443:                					{
1444:                						/* This yield may not cause the task just resumed to run,
1445:                						but will leave the lists in the correct state for the
1446:                						next yield. */
1447:                						taskYIELD_IF_USING_PREEMPTION();
00000098  00000000   NOP
1448:                					}
1449:                					else
1450:                					{
1451:                						mtCOVERAGE_TEST_MARKER();
1452:                					}
1453:                				}
1454:                				else
1455:                				{
1456:                					mtCOVERAGE_TEST_MARKER();
1457:                				}
1458:                			}
1459:                			taskEXIT_CRITICAL();
000000A8  00000000   NOP
1460:                		}
1461:                		else
1462:                		{
1463:                			mtCOVERAGE_TEST_MARKER();
1464:                		}
1465:                	}
000000B0  00000000   NOP
1466:                
1467:                #endif /* INCLUDE_vTaskSuspend */
1468:                
1469:                /*-----------------------------------------------------------*/
1470:                
1471:                #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1472:                
1473:                	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1474:                	{
00000000  00000000   NOP
1475:                	BaseType_t xYieldRequired = pdFALSE;
000000B0  00000000   NOP
1476:                	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1477:                	UBaseType_t uxSavedInterruptStatus;
1478:                
1479:                		configASSERT( xTaskToResume );
1480:                
1481:                		/* RTOS ports that support interrupt nesting have the concept of a
1482:                		maximum	system call (or maximum API call) interrupt priority.
1483:                		Interrupts that are	above the maximum system call priority are keep
1484:                		permanently enabled, even when the RTOS kernel is in a critical section,
1485:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1486:                		is defined in FreeRTOSConfig.h then
1487:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1488:                		failure if a FreeRTOS API function is called from an interrupt that has
1489:                		been assigned a priority above the configured maximum system call
1490:                		priority.  Only FreeRTOS functions that end in FromISR can be called
1491:                		from interrupts	that have been assigned a priority at or (logically)
1492:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
1493:                		separate interrupt safe API to ensure interrupt entry is as fast and as
1494:                		simple as possible.  More information (albeit Cortex-M specific) is
1495:                		provided on the following link:
1496:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1497:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1498:                
1499:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000018  00000000   NOP
1500:                		{
1501:                			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
00000024  00000000   NOP
1502:                			{
1503:                				traceTASK_RESUME_FROM_ISR( pxTCB );
1504:                
1505:                				/* Check the ready lists can be accessed. */
1506:                				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00000038  00000000   NOP
1507:                				{
1508:                					/* Ready lists can be accessed so move the task from the
1509:                					suspended list to the ready list directly. */
1510:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00000044  00000000   NOP
1511:                					{
1512:                						xYieldRequired = pdTRUE;
1513:                					}
1514:                					else
1515:                					{
1516:                						mtCOVERAGE_TEST_MARKER();
1517:                					}
1518:                
1519:                					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
00000058  00000000   NOP
1520:                					prvAddTaskToReadyList( pxTCB );
00000064  00000000   NOP
1521:                				}
1522:                				else
1523:                				{
1524:                					/* The delayed or ready lists cannot be accessed so the task
1525:                					is held in the pending ready list until the scheduler is
1526:                					unsuspended. */
1527:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000000A4  00000000   NOP
1528:                				}
1529:                			}
1530:                			else
1531:                			{
1532:                				mtCOVERAGE_TEST_MARKER();
1533:                			}
1534:                		}
1535:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000000B4  00000000   NOP
1536:                
1537:                		return xYieldRequired;
1538:                	}
000000BC  00000000   NOP
1539:                
1540:                #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1541:                /*-----------------------------------------------------------*/
1542:                
1543:                void vTaskStartScheduler( void )
1544:                {
9D00BCF0  27BDFFD8   ADDIU SP, SP, -40
9D00BCF4  AFBF0024   SW RA, 36(SP)
1545:                BaseType_t xReturn;
1546:                
1547:                	/* Add the idle task at the lowest priority. */
1548:                	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1549:                	{
1550:                		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1551:                		be returned by the xTaskGetIdleTaskHandle() function. */
1552:                		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1553:                	}
1554:                	#else
1555:                	{
1556:                		/* Create the idle task without storing its handle. */
1557:                		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
9D00BCF8  AFA00010   SW ZERO, 16(SP)
9D00BCFC  AFA00014   SW ZERO, 20(SP)
9D00BD00  AFA00018   SW ZERO, 24(SP)
9D00BD04  AFA0001C   SW ZERO, 28(SP)
9D00BD08  3C049D01   LUI A0, -25343
9D00BD0C  2484D37C   ADDIU A0, A0, -11396
9D00BD10  3C059D01   LUI A1, -25343
9D00BD14  24A5DD78   ADDIU A1, A1, -8840
9D00BD18  24060080   ADDIU A2, ZERO, 128
9D00BD1C  0F401A98   JAL xTaskGenericCreate
9D00BD20  00003821   ADDU A3, ZERO, ZERO
1558:                	}
1559:                	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1560:                
1561:                	#if ( configUSE_TIMERS == 1 )
1562:                	{
1563:                		if( xReturn == pdPASS )
1564:                		{
1565:                			xReturn = xTimerCreateTimerTask();
1566:                		}
1567:                		else
1568:                		{
1569:                			mtCOVERAGE_TEST_MARKER();
1570:                		}
1571:                	}
1572:                	#endif /* configUSE_TIMERS */
1573:                
1574:                	if( xReturn == pdPASS )
9D00BD24  24030001   ADDIU V1, ZERO, 1
9D00BD28  14430010   BNE V0, V1, 0x9D00BD6C
9D00BD2C  8FBF0024   LW RA, 36(SP)
1575:                	{
1576:                		/* Interrupts are turned off here, to ensure a tick does not occur
1577:                		before or during the call to xPortStartScheduler().  The stacks of
1578:                		the created tasks contain a status word with interrupts switched on
1579:                		so interrupts will automatically get re-enabled when the first task
1580:                		starts to run. */
1581:                		portDISABLE_INTERRUPTS();
9D00BD30  40036000   MFC0 V1, Status
9D00BD34  3C02FFFF   LUI V0, -1
9D00BD38  244203FF   ADDIU V0, V0, 1023
9D00BD3C  00621024   AND V0, V1, V0
9D00BD40  34420C00   ORI V0, V0, 3072
9D00BD44  40826000   MTC0 V0, Status
9D00BD48  000000C0   EHB
1582:                
1583:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1584:                		{
1585:                			/* Switch Newlib's _impure_ptr variable to point to the _reent
1586:                			structure specific to the task that will run first. */
1587:                			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1588:                		}
1589:                		#endif /* configUSE_NEWLIB_REENTRANT */
1590:                
1591:                		xNextTaskUnblockTime = portMAX_DELAY;
9D00BD4C  2402FFFF   ADDIU V0, ZERO, -1
9D00BD50  AF828060   SW V0, -32672(GP)
1592:                		xSchedulerRunning = pdTRUE;
9D00BD54  24020001   ADDIU V0, ZERO, 1
9D00BD58  AF828074   SW V0, -32652(GP)
1593:                		xTickCount = ( TickType_t ) 0U;
9D00BD5C  AF80807C   SW ZERO, -32644(GP)
1594:                
1595:                		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1596:                		macro must be defined to configure the timer/counter used to generate
1597:                		the run time counter time base. */
1598:                		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1599:                
1600:                		/* Setting up the timer tick is hardware specific and thus in the
1601:                		portable interface. */
1602:                		if( xPortStartScheduler() != pdFALSE )
9D00BD60  0F4032B2   JAL xPortStartScheduler
9D00BD64  00000000   NOP
1603:                		{
1604:                			/* Should not reach here as if the scheduler is running the
1605:                			function will not return. */
1606:                		}
1607:                		else
1608:                		{
1609:                			/* Should only reach here if a task calls xTaskEndScheduler(). */
1610:                		}
1611:                	}
1612:                	else
1613:                	{
1614:                		/* This line will only be reached if the kernel could not be started,
1615:                		because there was not enough FreeRTOS heap to create the idle task
1616:                		or the timer task. */
1617:                		configASSERT( xReturn );
1618:                	}
1619:                }
9D00BD68  8FBF0024   LW RA, 36(SP)
9D00BD6C  03E00008   JR RA
9D00BD70  27BD0028   ADDIU SP, SP, 40
1620:                /*-----------------------------------------------------------*/
1621:                
1622:                void vTaskEndScheduler( void )
1623:                {
00000000  00000000   NOP
1624:                	/* Stop the scheduler interrupts and call the portable scheduler end
1625:                	routine so the original ISRs can be restored if necessary.  The port
1626:                	layer must ensure interrupts enable	bit is left in the correct state. */
1627:                	portDISABLE_INTERRUPTS();
00000008  00000000   NOP
1628:                	xSchedulerRunning = pdFALSE;
00000024  00000000   NOP
1629:                	vPortEndScheduler();
00000028  00000000   NOP
1630:                }
00000030  00000000   NOP
1631:                /*----------------------------------------------------------*/
1632:                
1633:                void vTaskSuspendAll( void )
1634:                {
1635:                	/* A critical section is not required as the variable is of type
1636:                	BaseType_t.  Please read Richard Barry's reply in the following link to a
1637:                	post in the FreeRTOS support forum before reporting this as a bug! -
1638:                	http://goo.gl/wu4acr */
1639:                	++uxSchedulerSuspended;
9D00DCD8  8F82805C   LW V0, -32676(GP)
9D00DCDC  24420001   ADDIU V0, V0, 1
9D00DCE0  AF82805C   SW V0, -32676(GP)
9D00DCE4  03E00008   JR RA
9D00DCE8  00000000   NOP
1640:                }
1641:                /*----------------------------------------------------------*/
1642:                
1643:                #if ( configUSE_TICKLESS_IDLE != 0 )
1644:                
1645:                	static TickType_t prvGetExpectedIdleTime( void )
1646:                	{
1647:                	TickType_t xReturn;
1648:                
1649:                		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1650:                		{
1651:                			xReturn = 0;
1652:                		}
1653:                		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1654:                		{
1655:                			/* There are other idle priority tasks in the ready state.  If
1656:                			time slicing is used then the very next tick interrupt must be
1657:                			processed. */
1658:                			xReturn = 0;
1659:                		}
1660:                		else
1661:                		{
1662:                			xReturn = xNextTaskUnblockTime - xTickCount;
1663:                		}
1664:                
1665:                		return xReturn;
1666:                	}
1667:                
1668:                #endif /* configUSE_TICKLESS_IDLE */
1669:                /*----------------------------------------------------------*/
1670:                
1671:                BaseType_t xTaskResumeAll( void )
1672:                {
9D008610  27BDFFD8   ADDIU SP, SP, -40
9D008614  AFBF0024   SW RA, 36(SP)
9D008618  AFB40020   SW S4, 32(SP)
9D00861C  AFB3001C   SW S3, 28(SP)
9D008620  AFB20018   SW S2, 24(SP)
9D008624  AFB10014   SW S1, 20(SP)
1673:                TCB_t *pxTCB;
1674:                BaseType_t xAlreadyYielded = pdFALSE;
1675:                
1676:                	/* If uxSchedulerSuspended is zero then this function does not match a
1677:                	previous call to vTaskSuspendAll(). */
1678:                	configASSERT( uxSchedulerSuspended );
1679:                
1680:                	/* It is possible that an ISR caused a task to be removed from an event
1681:                	list while the scheduler was suspended.  If this was the case then the
1682:                	removed task will have been added to the xPendingReadyList.  Once the
1683:                	scheduler has been resumed it is safe to move all the pending ready
1684:                	tasks from this list into their appropriate ready list. */
1685:                	taskENTER_CRITICAL();
9D008628  0F40339E   JAL vTaskEnterCritical
9D00862C  AFB00010   SW S0, 16(SP)
1686:                	{
1687:                		--uxSchedulerSuspended;
9D008630  8F82805C   LW V0, -32676(GP)
9D008634  2442FFFF   ADDIU V0, V0, -1
9D008638  AF82805C   SW V0, -32676(GP)
1688:                
1689:                		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
9D00863C  8F82805C   LW V0, -32676(GP)
9D008640  1440003D   BNE V0, ZERO, 0x9D008738
9D008644  00008021   ADDU S0, ZERO, ZERO
1690:                		{
1691:                			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
9D008648  8F828080   LW V0, -32640(GP)
9D00864C  1040003A   BEQ V0, ZERO, 0x9D008738
9D008650  3C12A000   LUI S2, -24576
1692:                			{
1693:                				/* Move any readied tasks from the pending list into the
1694:                				appropriate ready list. */
1695:                				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
9D0086C4  8E420C24   LW V0, 3108(S2)
9D0086C8  1440FFE6   BNE V0, ZERO, 0x9D008664
9D0086CC  26420C24   ADDIU V0, S2, 3108
1696:                				{
1697:                					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
9D008664  8C42000C   LW V0, 12(V0)
9D008668  8C50000C   LW S0, 12(V0)
1698:                					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
9D00866C  0F40348C   JAL uxListRemove
9D008670  26040018   ADDIU A0, S0, 24
1699:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
9D008674  26110004   ADDIU S1, S0, 4
9D008678  0F40348C   JAL uxListRemove
9D00867C  02202021   ADDU A0, S1, ZERO
1700:                					prvAddTaskToReadyList( pxTCB );
9D008654  24130001   ADDIU S3, ZERO, 1
9D008658  3C14A000   LUI S4, -24576
9D00865C  0B4021B1   J 0x9D0086C4
9D008660  26940BC0   ADDIU S4, S4, 3008
9D008680  8E02002C   LW V0, 44(S0)
9D008684  8F838078   LW V1, -32648(GP)
9D008688  00532004   SLLV A0, S3, V0
9D00868C  00831825   OR V1, A0, V1
9D008690  AF838078   SW V1, -32648(GP)
9D008694  00022080   SLL A0, V0, 2
9D008698  00021100   SLL V0, V0, 4
9D00869C  00822021   ADDU A0, A0, V0
9D0086A0  02842021   ADDU A0, S4, A0
9D0086A4  0F4035EF   JAL vListInsertEnd
9D0086A8  02202821   ADDU A1, S1, ZERO
1701:                
1702:                					/* If the moved task has a priority higher than the current
1703:                					task then a yield must be performed. */
1704:                					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
9D0086AC  8F828088   LW V0, -32632(GP)
9D0086B0  8E03002C   LW V1, 44(S0)
9D0086B4  8C42002C   LW V0, 44(V0)
9D0086B8  0062102B   SLTU V0, V1, V0
9D0086BC  50400001   BEQL V0, ZERO, 0x9D0086C4
9D0086C0  AF93806C   SW S3, -32660(GP)
1705:                					{
1706:                						xYieldPending = pdTRUE;
1707:                					}
1708:                					else
1709:                					{
1710:                						mtCOVERAGE_TEST_MARKER();
1711:                					}
1712:                				}
1713:                
1714:                				/* If any ticks occurred while the scheduler was suspended then
1715:                				they should be processed now.  This ensures the tick count does
1716:                				not	slip, and that any delayed tasks are resumed at the correct
1717:                				time. */
1718:                				if( uxPendedTicks > ( UBaseType_t ) 0U )
9D0086D0  8F828070   LW V0, -32656(GP)
9D0086D4  1040000F   BEQ V0, ZERO, 0x9D008714
9D0086D8  00000000   NOP
1719:                				{
1720:                					while( uxPendedTicks > ( UBaseType_t ) 0U )
9D0086DC  8F828070   LW V0, -32656(GP)
9D0086E0  1040000C   BEQ V0, ZERO, 0x9D008714
9D0086E4  00000000   NOP
9D008708  8F828070   LW V0, -32656(GP)
9D00870C  1440FFF7   BNE V0, ZERO, 0x9D0086EC
9D008710  00000000   NOP
1721:                					{
1722:                						if( xTaskIncrementTick() != pdFALSE )
9D0086EC  0F401FB2   JAL xTaskIncrementTick
9D0086F0  00000000   NOP
9D0086F4  54400001   BNEL V0, ZERO, 0x9D0086FC
9D0086F8  AF90806C   SW S0, -32660(GP)
1723:                						{
1724:                							xYieldPending = pdTRUE;
9D0086E8  24100001   ADDIU S0, ZERO, 1
1725:                						}
1726:                						else
1727:                						{
1728:                							mtCOVERAGE_TEST_MARKER();
1729:                						}
1730:                						--uxPendedTicks;
9D0086FC  8F828070   LW V0, -32656(GP)
9D008700  2442FFFF   ADDIU V0, V0, -1
9D008704  AF828070   SW V0, -32656(GP)
1731:                					}
1732:                				}
1733:                				else
1734:                				{
1735:                					mtCOVERAGE_TEST_MARKER();
1736:                				}
1737:                
1738:                				if( xYieldPending == pdTRUE )
9D008714  8F83806C   LW V1, -32660(GP)
9D008718  24020001   ADDIU V0, ZERO, 1
9D00871C  14620006   BNE V1, V0, 0x9D008738
9D008720  00008021   ADDU S0, ZERO, ZERO
1739:                				{
1740:                					#if( configUSE_PREEMPTION != 0 )
1741:                					{
1742:                						xAlreadyYielded = pdTRUE;
9D008734  24100001   ADDIU S0, ZERO, 1
1743:                					}
1744:                					#endif
1745:                					taskYIELD_IF_USING_PREEMPTION();
9D008724  40026800   MFC0 V0, Cause
9D008728  34420100   ORI V0, V0, 256
9D00872C  40826800   MTC0 V0, Cause
9D008730  000000C0   EHB
1746:                				}
1747:                				else
1748:                				{
1749:                					mtCOVERAGE_TEST_MARKER();
1750:                				}
1751:                			}
1752:                		}
1753:                		else
1754:                		{
1755:                			mtCOVERAGE_TEST_MARKER();
1756:                		}
1757:                	}
1758:                	taskEXIT_CRITICAL();
9D008738  0F403151   JAL vTaskExitCritical
9D00873C  00000000   NOP
1759:                
1760:                	return xAlreadyYielded;
1761:                }
9D008740  02001021   ADDU V0, S0, ZERO
9D008744  8FBF0024   LW RA, 36(SP)
9D008748  8FB40020   LW S4, 32(SP)
9D00874C  8FB3001C   LW S3, 28(SP)
9D008750  8FB20018   LW S2, 24(SP)
9D008754  8FB10014   LW S1, 20(SP)
9D008758  8FB00010   LW S0, 16(SP)
9D00875C  03E00008   JR RA
9D008760  27BD0028   ADDIU SP, SP, 40
1762:                /*-----------------------------------------------------------*/
1763:                
1764:                TickType_t xTaskGetTickCount( void )
1765:                {
1766:                TickType_t xTicks;
1767:                
1768:                	/* Critical section required if running on a 16 bit processor. */
1769:                	portTICK_TYPE_ENTER_CRITICAL();
1770:                	{
1771:                		xTicks = xTickCount;
00000000  00000000   NOP
1772:                	}
1773:                	portTICK_TYPE_EXIT_CRITICAL();
1774:                
1775:                	return xTicks;
1776:                }
00000004  00000000   NOP
1777:                /*-----------------------------------------------------------*/
1778:                
1779:                TickType_t xTaskGetTickCountFromISR( void )
1780:                {
1781:                TickType_t xReturn;
1782:                UBaseType_t uxSavedInterruptStatus;
1783:                
1784:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1785:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1786:                	above the maximum system call priority are kept permanently enabled, even
1787:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1788:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1789:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1790:                	failure if a FreeRTOS API function is called from an interrupt that has been
1791:                	assigned a priority above the configured maximum system call priority.
1792:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1793:                	that have been assigned a priority at or (logically) below the maximum
1794:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1795:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1796:                	More information (albeit Cortex-M specific) is provided on the following
1797:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1798:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1799:                
1800:                	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
1801:                	{
1802:                		xReturn = xTickCount;
00000000  00000000   NOP
1803:                	}
1804:                	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1805:                
1806:                	return xReturn;
1807:                }
00000004  00000000   NOP
1808:                /*-----------------------------------------------------------*/
1809:                
1810:                UBaseType_t uxTaskGetNumberOfTasks( void )
1811:                {
1812:                	/* A critical section is not required because the variables are of type
1813:                	BaseType_t. */
1814:                	return uxCurrentNumberOfTasks;
00000000  00000000   NOP
1815:                }
00000004  00000000   NOP
1816:                /*-----------------------------------------------------------*/
1817:                
1818:                #if ( INCLUDE_pcTaskGetTaskName == 1 )
1819:                
1820:                	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
1821:                	{
1822:                	TCB_t *pxTCB;
1823:                
1824:                		/* If null is passed in here then the name of the calling task is being queried. */
1825:                		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1826:                		configASSERT( pxTCB );
1827:                		return &( pxTCB->pcTaskName[ 0 ] );
1828:                	}
1829:                
1830:                #endif /* INCLUDE_pcTaskGetTaskName */
1831:                /*-----------------------------------------------------------*/
1832:                
1833:                #if ( configUSE_TRACE_FACILITY == 1 )
1834:                
1835:                	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
1836:                	{
1837:                	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1838:                
1839:                		vTaskSuspendAll();
1840:                		{
1841:                			/* Is there a space in the array for each task in the system? */
1842:                			if( uxArraySize >= uxCurrentNumberOfTasks )
1843:                			{
1844:                				/* Fill in an TaskStatus_t structure with information on each
1845:                				task in the Ready state. */
1846:                				do
1847:                				{
1848:                					uxQueue--;
1849:                					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
1850:                
1851:                				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1852:                
1853:                				/* Fill in an TaskStatus_t structure with information on each
1854:                				task in the Blocked state. */
1855:                				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
1856:                				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
1857:                
1858:                				#if( INCLUDE_vTaskDelete == 1 )
1859:                				{
1860:                					/* Fill in an TaskStatus_t structure with information on
1861:                					each task that has been deleted but not yet cleaned up. */
1862:                					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
1863:                				}
1864:                				#endif
1865:                
1866:                				#if ( INCLUDE_vTaskSuspend == 1 )
1867:                				{
1868:                					/* Fill in an TaskStatus_t structure with information on
1869:                					each task in the Suspended state. */
1870:                					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
1871:                				}
1872:                				#endif
1873:                
1874:                				#if ( configGENERATE_RUN_TIME_STATS == 1)
1875:                				{
1876:                					if( pulTotalRunTime != NULL )
1877:                					{
1878:                						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1879:                							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1880:                						#else
1881:                							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1882:                						#endif
1883:                					}
1884:                				}
1885:                				#else
1886:                				{
1887:                					if( pulTotalRunTime != NULL )
1888:                					{
1889:                						*pulTotalRunTime = 0;
1890:                					}
1891:                				}
1892:                				#endif
1893:                			}
1894:                			else
1895:                			{
1896:                				mtCOVERAGE_TEST_MARKER();
1897:                			}
1898:                		}
1899:                		( void ) xTaskResumeAll();
1900:                
1901:                		return uxTask;
1902:                	}
1903:                
1904:                #endif /* configUSE_TRACE_FACILITY */
1905:                /*----------------------------------------------------------*/
1906:                
1907:                #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1908:                
1909:                	TaskHandle_t xTaskGetIdleTaskHandle( void )
1910:                	{
1911:                		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1912:                		started, then xIdleTaskHandle will be NULL. */
1913:                		configASSERT( ( xIdleTaskHandle != NULL ) );
1914:                		return xIdleTaskHandle;
1915:                	}
1916:                
1917:                #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1918:                /*----------------------------------------------------------*/
1919:                
1920:                /* This conditional compilation should use inequality to 0, not equality to 1.
1921:                This is to ensure vTaskStepTick() is available when user defined low power mode
1922:                implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1923:                1. */
1924:                #if ( configUSE_TICKLESS_IDLE != 0 )
1925:                
1926:                	void vTaskStepTick( const TickType_t xTicksToJump )
1927:                	{
1928:                		/* Correct the tick count value after a period during which the tick
1929:                		was suppressed.  Note this does *not* call the tick hook function for
1930:                		each stepped tick. */
1931:                		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1932:                		xTickCount += xTicksToJump;
1933:                		traceINCREASE_TICK_COUNT( xTicksToJump );
1934:                	}
1935:                
1936:                #endif /* configUSE_TICKLESS_IDLE */
1937:                /*----------------------------------------------------------*/
1938:                
1939:                BaseType_t xTaskIncrementTick( void )
1940:                {
9D007EC8  27BDFFD0   ADDIU SP, SP, -48
9D007ECC  AFBF002C   SW RA, 44(SP)
9D007ED0  AFB50028   SW S5, 40(SP)
9D007ED4  AFB40024   SW S4, 36(SP)
9D007ED8  AFB30020   SW S3, 32(SP)
9D007EDC  AFB2001C   SW S2, 28(SP)
9D007EE0  AFB10018   SW S1, 24(SP)
9D007EE4  AFB00014   SW S0, 20(SP)
1941:                TCB_t * pxTCB;
1942:                TickType_t xItemValue;
1943:                BaseType_t xSwitchRequired = pdFALSE;
9D008030  00008821   ADDU S1, ZERO, ZERO
1944:                
1945:                	/* Called by the portable layer each time a tick interrupt occurs.
1946:                	Increments the tick then checks to see if the new tick value will cause any
1947:                	tasks to be unblocked. */
1948:                	traceTASK_INCREMENT_TICK( xTickCount );
1949:                	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
9D007EE8  8F82805C   LW V0, -32676(GP)
9D007EEC  1440004D   BNE V0, ZERO, 0x9D008024
9D007EF0  00000000   NOP
1950:                	{
1951:                		/* Increment the RTOS tick, switching the delayed and overflowed
1952:                		delayed lists if it wraps to 0. */
1953:                		++xTickCount;
9D007EF4  8F82807C   LW V0, -32644(GP)
9D007EF8  24420001   ADDIU V0, V0, 1
9D007EFC  AF82807C   SW V0, -32644(GP)
1954:                
1955:                		{
1956:                			/* Minor optimisation.  The tick count cannot change in this
1957:                			block. */
1958:                			const TickType_t xConstTickCount = xTickCount;
9D007F00  8F94807C   LW S4, -32644(GP)
1959:                
1960:                			if( xConstTickCount == ( TickType_t ) 0U )
9D007F04  1680000A   BNE S4, ZERO, 0x9D007F30
9D007F08  00000000   NOP
1961:                			{
1962:                				taskSWITCH_DELAYED_LISTS();
9D007F0C  8F828108   LW V0, -32504(GP)
9D007F10  8F83810C   LW V1, -32500(GP)
9D007F14  AF838108   SW V1, -32504(GP)
9D007F18  AF82810C   SW V0, -32500(GP)
9D007F1C  8F828068   LW V0, -32664(GP)
9D007F20  24420001   ADDIU V0, V0, 1
9D007F24  AF828068   SW V0, -32664(GP)
9D007F28  0F403567   JAL prvResetNextTaskUnblockTime
9D007F2C  00000000   NOP
1963:                			}
1964:                			else
1965:                			{
1966:                				mtCOVERAGE_TEST_MARKER();
1967:                			}
1968:                
1969:                			/* See if this tick has made a timeout expire.  Tasks are stored in
1970:                			the	queue in the order of their wake time - meaning once one task
1971:                			has been found whose block time has not expired there is no need to
1972:                			look any further down the list. */
1973:                			if( xConstTickCount >= xNextTaskUnblockTime )
9D007F30  8F828060   LW V0, -32672(GP)
9D007F34  0282102B   SLTU V0, S4, V0
9D007F38  1440002D   BNE V0, ZERO, 0x9D007FF0
9D007F3C  00008821   ADDU S1, ZERO, ZERO
1974:                			{
1975:                				for( ;; )
1976:                				{
1977:                					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
9D007F4C  8F828108   LW V0, -32504(GP)
9D007F50  8C420000   LW V0, 0(V0)
9D007F54  14400004   BNE V0, ZERO, 0x9D007F68
9D007F58  2402FFFF   ADDIU V0, ZERO, -1
1978:                					{
1979:                						/* The delayed list is empty.  Set xNextTaskUnblockTime
1980:                						to the maximum possible value so it is extremely
1981:                						unlikely that the
1982:                						if( xTickCount >= xNextTaskUnblockTime ) test will pass
1983:                						next time through. */
1984:                						xNextTaskUnblockTime = portMAX_DELAY;
9D007F5C  AF828060   SW V0, -32672(GP)
1985:                						break;
9D007F60  0B401FFC   J 0x9D007FF0
9D007F64  00000000   NOP
1986:                					}
1987:                					else
1988:                					{
1989:                						/* The delayed list is not empty, get the value of the
1990:                						item at the head of the delayed list.  This is the time
1991:                						at which the task at the head of the delayed list must
1992:                						be removed from the Blocked state. */
1993:                						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
9D007F68  8F828108   LW V0, -32504(GP)
9D007F6C  8C42000C   LW V0, 12(V0)
9D007F70  8C50000C   LW S0, 12(V0)
1994:                						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
9D007F74  8E020004   LW V0, 4(S0)
1995:                
1996:                						if( xConstTickCount < xItemValue )
9D007F78  0282182B   SLTU V1, S4, V0
9D007F7C  10600004   BEQ V1, ZERO, 0x9D007F90
9D007F80  26120004   ADDIU S2, S0, 4
1997:                						{
1998:                							/* It is not time to unblock this item yet, but the
1999:                							item value is the time at which the task at the head
2000:                							of the blocked list must be removed from the Blocked
2001:                							state -	so record the item value in
2002:                							xNextTaskUnblockTime. */
2003:                							xNextTaskUnblockTime = xItemValue;
9D007F84  AF828060   SW V0, -32672(GP)
2004:                							break;
9D007F88  0B401FFC   J 0x9D007FF0
9D007F8C  00000000   NOP
2005:                						}
2006:                						else
2007:                						{
2008:                							mtCOVERAGE_TEST_MARKER();
2009:                						}
2010:                
2011:                						/* It is time to remove the item from the Blocked state. */
2012:                						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
9D007F90  0F40348C   JAL uxListRemove
9D007F94  02402021   ADDU A0, S2, ZERO
2013:                
2014:                						/* Is the task waiting on an event also?  If so remove
2015:                						it from the event list. */
2016:                						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
9D007F98  8E020028   LW V0, 40(S0)
9D007F9C  50400004   BEQL V0, ZERO, 0x9D007FB0
9D007FA0  8E03002C   LW V1, 44(S0)
2017:                						{
2018:                							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
9D007FA4  0F40348C   JAL uxListRemove
9D007FA8  26040018   ADDIU A0, S0, 24
2019:                						}
2020:                						else
2021:                						{
2022:                							mtCOVERAGE_TEST_MARKER();
2023:                						}
2024:                
2025:                						/* Place the unblocked task into the appropriate ready
2026:                						list. */
2027:                						prvAddTaskToReadyList( pxTCB );
9D007F40  24130001   ADDIU S3, ZERO, 1
9D007F44  3C15A000   LUI S5, -24576
9D007F48  26B50BC0   ADDIU S5, S5, 3008
9D007FAC  8E03002C   LW V1, 44(S0)
9D007FB0  8F828078   LW V0, -32648(GP)
9D007FB4  00732004   SLLV A0, S3, V1
9D007FB8  00821025   OR V0, A0, V0
9D007FBC  AF828078   SW V0, -32648(GP)
9D007FC0  00032080   SLL A0, V1, 2
9D007FC4  00031900   SLL V1, V1, 4
9D007FC8  00832021   ADDU A0, A0, V1
9D007FCC  02A42021   ADDU A0, S5, A0
9D007FD0  0F4035EF   JAL vListInsertEnd
9D007FD4  02402821   ADDU A1, S2, ZERO
2028:                
2029:                						/* A task being unblocked cannot cause an immediate
2030:                						context switch if preemption is turned off. */
2031:                						#if (  configUSE_PREEMPTION == 1 )
2032:                						{
2033:                							/* Preemption is on, but a context switch should
2034:                							only be performed if the unblocked task has a
2035:                							priority that is equal to or higher than the
2036:                							currently executing task. */
2037:                							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
9D007FD8  8F828088   LW V0, -32632(GP)
9D007FDC  8E03002C   LW V1, 44(S0)
9D007FE0  8C42002C   LW V0, 44(V0)
9D007FE4  0062102B   SLTU V0, V1, V0
9D007FE8  0B401FD3   J 0x9D007F4C
9D007FEC  0262880A   MOVZ S1, S3, V0
2038:                							{
2039:                								xSwitchRequired = pdTRUE;
2040:                							}
2041:                							else
2042:                							{
2043:                								mtCOVERAGE_TEST_MARKER();
2044:                							}
2045:                						}
2046:                						#endif /* configUSE_PREEMPTION */
2047:                					}
2048:                				}
2049:                			}
2050:                		}
2051:                
2052:                		/* Tasks of equal priority to the currently running task will share
2053:                		processing time (time slice) if preemption is on, and the application
2054:                		writer has not explicitly turned time slicing off. */
2055:                		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2056:                		{
2057:                			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
9D007FF0  8F828088   LW V0, -32632(GP)
9D007FF4  8C42002C   LW V0, 44(V0)
9D007FF8  00021880   SLL V1, V0, 2
9D007FFC  00021100   SLL V0, V0, 4
9D008000  00621021   ADDU V0, V1, V0
9D008004  3C03A000   LUI V1, -24576
9D008008  24630BC0   ADDIU V1, V1, 3008
9D00800C  00431021   ADDU V0, V0, V1
9D008010  8C430000   LW V1, 0(V0)
9D008014  2C630002   SLTIU V1, V1, 2
2058:                			{
2059:                				xSwitchRequired = pdTRUE;
9D008018  24020001   ADDIU V0, ZERO, 1
9D00801C  0B40200D   J 0x9D008034
9D008020  0043880A   MOVZ S1, V0, V1
2060:                			}
2061:                			else
2062:                			{
2063:                				mtCOVERAGE_TEST_MARKER();
2064:                			}
2065:                		}
2066:                		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2067:                
2068:                		#if ( configUSE_TICK_HOOK == 1 )
2069:                		{
2070:                			/* Guard against the tick hook being called when the pended tick
2071:                			count is being unwound (when the scheduler is being unlocked). */
2072:                			if( uxPendedTicks == ( UBaseType_t ) 0U )
2073:                			{
2074:                				vApplicationTickHook();
2075:                			}
2076:                			else
2077:                			{
2078:                				mtCOVERAGE_TEST_MARKER();
2079:                			}
2080:                		}
2081:                		#endif /* configUSE_TICK_HOOK */
2082:                	}
2083:                	else
2084:                	{
2085:                		++uxPendedTicks;
9D008024  8F828070   LW V0, -32656(GP)
9D008028  24420001   ADDIU V0, V0, 1
9D00802C  AF828070   SW V0, -32656(GP)
2086:                
2087:                		/* The tick hook gets called at regular intervals, even if the
2088:                		scheduler is locked. */
2089:                		#if ( configUSE_TICK_HOOK == 1 )
2090:                		{
2091:                			vApplicationTickHook();
2092:                		}
2093:                		#endif
2094:                	}
2095:                
2096:                	#if ( configUSE_PREEMPTION == 1 )
2097:                	{
2098:                		if( xYieldPending != pdFALSE )
9D008034  8F83806C   LW V1, -32660(GP)
2099:                		{
2100:                			xSwitchRequired = pdTRUE;
2101:                		}
2102:                		else
2103:                		{
2104:                			mtCOVERAGE_TEST_MARKER();
2105:                		}
2106:                	}
2107:                	#endif /* configUSE_PREEMPTION */
2108:                
2109:                	return xSwitchRequired;
2110:                }
9D008038  24020001   ADDIU V0, ZERO, 1
9D00803C  0223100A   MOVZ V0, S1, V1
9D008040  8FBF002C   LW RA, 44(SP)
9D008044  8FB50028   LW S5, 40(SP)
9D008048  8FB40024   LW S4, 36(SP)
9D00804C  8FB30020   LW S3, 32(SP)
9D008050  8FB2001C   LW S2, 28(SP)
9D008054  8FB10018   LW S1, 24(SP)
9D008058  8FB00014   LW S0, 20(SP)
9D00805C  03E00008   JR RA
9D008060  27BD0030   ADDIU SP, SP, 48
2111:                /*-----------------------------------------------------------*/
2112:                
2113:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2114:                
2115:                	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2116:                	{
2117:                	TCB_t *xTCB;
2118:                
2119:                		/* If xTask is NULL then it is the task hook of the calling task that is
2120:                		getting set. */
2121:                		if( xTask == NULL )
2122:                		{
2123:                			xTCB = ( TCB_t * ) pxCurrentTCB;
2124:                		}
2125:                		else
2126:                		{
2127:                			xTCB = ( TCB_t * ) xTask;
2128:                		}
2129:                
2130:                		/* Save the hook function in the TCB.  A critical section is required as
2131:                		the value can be accessed from an interrupt. */
2132:                		taskENTER_CRITICAL();
2133:                			xTCB->pxTaskTag = pxHookFunction;
2134:                		taskEXIT_CRITICAL();
2135:                	}
2136:                
2137:                #endif /* configUSE_APPLICATION_TASK_TAG */
2138:                /*-----------------------------------------------------------*/
2139:                
2140:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2141:                
2142:                	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2143:                	{
2144:                	TCB_t *xTCB;
2145:                	TaskHookFunction_t xReturn;
2146:                
2147:                		/* If xTask is NULL then we are setting our own task hook. */
2148:                		if( xTask == NULL )
2149:                		{
2150:                			xTCB = ( TCB_t * ) pxCurrentTCB;
2151:                		}
2152:                		else
2153:                		{
2154:                			xTCB = ( TCB_t * ) xTask;
2155:                		}
2156:                
2157:                		/* Save the hook function in the TCB.  A critical section is required as
2158:                		the value can be accessed from an interrupt. */
2159:                		taskENTER_CRITICAL();
2160:                		{
2161:                			xReturn = xTCB->pxTaskTag;
2162:                		}
2163:                		taskEXIT_CRITICAL();
2164:                
2165:                		return xReturn;
2166:                	}
2167:                
2168:                #endif /* configUSE_APPLICATION_TASK_TAG */
2169:                /*-----------------------------------------------------------*/
2170:                
2171:                #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2172:                
2173:                	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2174:                	{
2175:                	TCB_t *xTCB;
2176:                	BaseType_t xReturn;
2177:                
2178:                		/* If xTask is NULL then we are calling our own task hook. */
2179:                		if( xTask == NULL )
2180:                		{
2181:                			xTCB = ( TCB_t * ) pxCurrentTCB;
2182:                		}
2183:                		else
2184:                		{
2185:                			xTCB = ( TCB_t * ) xTask;
2186:                		}
2187:                
2188:                		if( xTCB->pxTaskTag != NULL )
2189:                		{
2190:                			xReturn = xTCB->pxTaskTag( pvParameter );
2191:                		}
2192:                		else
2193:                		{
2194:                			xReturn = pdFAIL;
2195:                		}
2196:                
2197:                		return xReturn;
2198:                	}
2199:                
2200:                #endif /* configUSE_APPLICATION_TASK_TAG */
2201:                /*-----------------------------------------------------------*/
2202:                
2203:                void vTaskSwitchContext( void )
2204:                {
9D009FF4  27BDFFE8   ADDIU SP, SP, -24
9D009FF8  AFBF0014   SW RA, 20(SP)
2205:                	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
9D009FFC  8F82805C   LW V0, -32676(GP)
9D00A000  10400004   BEQ V0, ZERO, 0x9D00A014
9D00A004  24020001   ADDIU V0, ZERO, 1
2206:                	{
2207:                		/* The scheduler is currently suspended - do not allow a context
2208:                		switch. */
2209:                		xYieldPending = pdTRUE;
9D00A008  AF82806C   SW V0, -32660(GP)
9D00A00C  0B402833   J 0x9D00A0CC
9D00A010  8FBF0014   LW RA, 20(SP)
2210:                	}
2211:                	else
2212:                	{
2213:                		xYieldPending = pdFALSE;
9D00A014  AF80806C   SW ZERO, -32660(GP)
2214:                		traceTASK_SWITCHED_OUT();
2215:                
2216:                		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2217:                		{
2218:                				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2219:                					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2220:                				#else
2221:                					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2222:                				#endif
2223:                
2224:                				/* Add the amount of time the task has been running to the
2225:                				accumulated	time so far.  The time the task started running was
2226:                				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2227:                				protection here	so count values are only valid until the timer
2228:                				overflows.  The guard against negative values is to protect
2229:                				against suspect run time stat counter implementations - which
2230:                				are provided by the application, not the kernel. */
2231:                				if( ulTotalRunTime > ulTaskSwitchedInTime )
2232:                				{
2233:                					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2234:                				}
2235:                				else
2236:                				{
2237:                					mtCOVERAGE_TEST_MARKER();
2238:                				}
2239:                				ulTaskSwitchedInTime = ulTotalRunTime;
2240:                		}
2241:                		#endif /* configGENERATE_RUN_TIME_STATS */
2242:                
2243:                		/* Check for stack overflow, if configured. */
2244:                		taskCHECK_FOR_STACK_OVERFLOW();
9D00A018  8F828088   LW V0, -32632(GP)
9D00A01C  8C420030   LW V0, 48(V0)
9D00A020  8C440000   LW A0, 0(V0)
9D00A024  3C03A5A5   LUI V1, -23131
9D00A028  3463A5A5   ORI V1, V1, -23131
9D00A02C  1483000E   BNE A0, V1, 0x9D00A068
9D00A030  3C03A5A5   LUI V1, -23131
9D00A034  8C440004   LW A0, 4(V0)
9D00A038  3463A5A5   ORI V1, V1, -23131
9D00A03C  1483000A   BNE A0, V1, 0x9D00A068
9D00A040  3C03A5A5   LUI V1, -23131
9D00A044  8C440008   LW A0, 8(V0)
9D00A048  3463A5A5   ORI V1, V1, -23131
9D00A04C  14830006   BNE A0, V1, 0x9D00A068
9D00A050  00000000   NOP
9D00A054  8C43000C   LW V1, 12(V0)
9D00A058  3C02A5A5   LUI V0, -23131
9D00A05C  3442A5A5   ORI V0, V0, -23131
9D00A060  10620005   BEQ V1, V0, 0x9D00A078
9D00A064  00000000   NOP
9D00A068  8F848088   LW A0, -32632(GP)
9D00A06C  8F858088   LW A1, -32632(GP)
9D00A070  0F403628   JAL vApplicationStackOverflowHook
9D00A074  24A50034   ADDIU A1, A1, 52
2245:                
2246:                		/* Select a new task to run using either the generic C or port
2247:                		optimised asm code. */
2248:                		taskSELECT_HIGHEST_PRIORITY_TASK();
9D00A078  8F838078   LW V1, -32648(GP)
9D00A07C  70631820   CLZ V1, V1
9D00A080  2402001F   ADDIU V0, ZERO, 31
9D00A084  00431823   SUBU V1, V0, V1
9D00A088  00031080   SLL V0, V1, 2
9D00A08C  00031900   SLL V1, V1, 4
9D00A090  00431821   ADDU V1, V0, V1
9D00A094  3C02A000   LUI V0, -24576
9D00A098  24420BC0   ADDIU V0, V0, 3008
9D00A09C  00431021   ADDU V0, V0, V1
9D00A0A0  8C430004   LW V1, 4(V0)
9D00A0A4  8C630004   LW V1, 4(V1)
9D00A0A8  24440008   ADDIU A0, V0, 8
9D00A0AC  14640003   BNE V1, A0, 0x9D00A0BC
9D00A0B0  AC430004   SW V1, 4(V0)
9D00A0B4  8C630004   LW V1, 4(V1)
9D00A0B8  AC430004   SW V1, 4(V0)
9D00A0BC  8C420004   LW V0, 4(V0)
9D00A0C0  8C42000C   LW V0, 12(V0)
9D00A0C4  AF828088   SW V0, -32632(GP)
2249:                		traceTASK_SWITCHED_IN();
2250:                
2251:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2252:                		{
2253:                			/* Switch Newlib's _impure_ptr variable to point to the _reent
2254:                			structure specific to this task. */
2255:                			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2256:                		}
2257:                		#endif /* configUSE_NEWLIB_REENTRANT */
2258:                	}
2259:                }
9D00A0C8  8FBF0014   LW RA, 20(SP)
9D00A0CC  03E00008   JR RA
9D00A0D0  27BD0018   ADDIU SP, SP, 24
2260:                /*-----------------------------------------------------------*/
2261:                
2262:                void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2263:                {
9D00B764  27BDFFE8   ADDIU SP, SP, -24
9D00B768  AFBF0014   SW RA, 20(SP)
9D00B76C  AFB00010   SW S0, 16(SP)
9D00B770  00A08021   ADDU S0, A1, ZERO
2264:                TickType_t xTimeToWake;
2265:                
2266:                	configASSERT( pxEventList );
2267:                
2268:                	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2269:                	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2270:                
2271:                	/* Place the event list item of the TCB in the appropriate event list.
2272:                	This is placed in the list in priority order so the highest priority task
2273:                	is the first to be woken by the event.  The queue that contains the event
2274:                	list is locked, preventing simultaneous access from interrupts. */
2275:                	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
9D00B774  8F858088   LW A1, -32632(GP)
9D00B778  0F40329B   JAL vListInsert
9D00B77C  24A50018   ADDIU A1, A1, 24
2276:                
2277:                	/* The task must be removed from from the ready list before it is added to
2278:                	the blocked list as the same list item is used for both lists.  Exclusive
2279:                	access to the ready lists guaranteed because the scheduler is locked. */
2280:                	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
9D00B780  8F848088   LW A0, -32632(GP)
9D00B784  0F40348C   JAL uxListRemove
9D00B788  24840004   ADDIU A0, A0, 4
9D00B78C  1440000A   BNE V0, ZERO, 0x9D00B7B8
9D00B790  2402FFFF   ADDIU V0, ZERO, -1
2281:                	{
2282:                		/* The current task must be in a ready list, so there is no need to
2283:                		check, and the port reset macro can be called directly. */
2284:                		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
9D00B794  8F828088   LW V0, -32632(GP)
9D00B798  8F838078   LW V1, -32648(GP)
9D00B79C  8C42002C   LW V0, 44(V0)
9D00B7A0  24040001   ADDIU A0, ZERO, 1
9D00B7A4  00441004   SLLV V0, A0, V0
9D00B7A8  00021027   NOR V0, ZERO, V0
9D00B7AC  00431024   AND V0, V0, V1
9D00B7B0  AF828078   SW V0, -32648(GP)
2285:                	}
2286:                	else
2287:                	{
2288:                		mtCOVERAGE_TEST_MARKER();
2289:                	}
2290:                
2291:                	#if ( INCLUDE_vTaskSuspend == 1 )
2292:                	{
2293:                		if( xTicksToWait == portMAX_DELAY )
9D00B7B4  2402FFFF   ADDIU V0, ZERO, -1
9D00B7B8  16020008   BNE S0, V0, 0x9D00B7DC
9D00B7BC  00000000   NOP
2294:                		{
2295:                			/* Add the task to the suspended task list instead of a delayed task
2296:                			list to ensure the task is not woken by a timing event.  It will
2297:                			block indefinitely. */
2298:                			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
9D00B7C0  8F858088   LW A1, -32632(GP)
9D00B7C4  3C04A000   LUI A0, -24576
9D00B7C8  24840C4C   ADDIU A0, A0, 3148
9D00B7CC  0F4035EF   JAL vListInsertEnd
9D00B7D0  24A50004   ADDIU A1, A1, 4
9D00B7D4  0B402DFB   J 0x9D00B7EC
9D00B7D8  8FBF0014   LW RA, 20(SP)
2299:                		}
2300:                		else
2301:                		{
2302:                			/* Calculate the time at which the task should be woken if the event
2303:                			does not occur.  This may overflow but this doesn't matter, the
2304:                			scheduler will handle it. */
2305:                			xTimeToWake = xTickCount + xTicksToWait;
9D00B7DC  8F84807C   LW A0, -32644(GP)
2306:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
9D00B7E0  0F4030AF   JAL prvAddCurrentTaskToDelayedList
9D00B7E4  02042021   ADDU A0, S0, A0
2307:                		}
2308:                	}
2309:                	#else /* INCLUDE_vTaskSuspend */
2310:                	{
2311:                			/* Calculate the time at which the task should be woken if the event does
2312:                			not occur.  This may overflow but this doesn't matter, the scheduler
2313:                			will handle it. */
2314:                			xTimeToWake = xTickCount + xTicksToWait;
2315:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
2316:                	}
2317:                	#endif /* INCLUDE_vTaskSuspend */
2318:                }
9D00B7E8  8FBF0014   LW RA, 20(SP)
9D00B7EC  8FB00010   LW S0, 16(SP)
9D00B7F0  03E00008   JR RA
9D00B7F4  27BD0018   ADDIU SP, SP, 24
2319:                /*-----------------------------------------------------------*/
2320:                
2321:                void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
2322:                {
00000000  00000000   NOP
2323:                TickType_t xTimeToWake;
2324:                
2325:                	configASSERT( pxEventList );
2326:                
2327:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2328:                	the event groups implementation. */
2329:                	configASSERT( uxSchedulerSuspended != 0 );
2330:                
2331:                	/* Store the item value in the event list item.  It is safe to access the
2332:                	event list item here as interrupts won't access the event list item of a
2333:                	task that is not in the Blocked state. */
2334:                	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
00000010  00000000   NOP
2335:                
2336:                	/* Place the event list item of the TCB at the end of the appropriate event
2337:                	list.  It is safe to access the event list here because it is part of an
2338:                	event group implementation - and interrupts don't access event groups
2339:                	directly (instead they access them indirectly by pending function calls to
2340:                	the task level). */
2341:                	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00000020  00000000   NOP
2342:                
2343:                	/* The task must be removed from the ready list before it is added to the
2344:                	blocked list.  Exclusive access can be assured to the ready list as the
2345:                	scheduler is locked. */
2346:                	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0000002C  00000000   NOP
2347:                	{
2348:                		/* The current task must be in a ready list, so there is no need to
2349:                		check, and the port reset macro can be called directly. */
2350:                		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
00000040  00000000   NOP
2351:                	}
2352:                	else
2353:                	{
2354:                		mtCOVERAGE_TEST_MARKER();
2355:                	}
2356:                
2357:                	#if ( INCLUDE_vTaskSuspend == 1 )
2358:                	{
2359:                		if( xTicksToWait == portMAX_DELAY )
00000060  00000000   NOP
2360:                		{
2361:                			/* Add the task to the suspended task list instead of a delayed task
2362:                			list to ensure it is not woken by a timing event.  It will block
2363:                			indefinitely. */
2364:                			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
0000006C  00000000   NOP
2365:                		}
2366:                		else
2367:                		{
2368:                			/* Calculate the time at which the task should be woken if the event
2369:                			does not occur.  This may overflow but this doesn't matter, the
2370:                			kernel will manage it correctly. */
2371:                			xTimeToWake = xTickCount + xTicksToWait;
00000088  00000000   NOP
2372:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
0000008C  00000000   NOP
2373:                		}
2374:                	}
2375:                	#else /* INCLUDE_vTaskSuspend */
2376:                	{
2377:                			/* Calculate the time at which the task should be woken if the event does
2378:                			not occur.  This may overflow but this doesn't matter, the kernel
2379:                			will manage it correctly. */
2380:                			xTimeToWake = xTickCount + xTicksToWait;
2381:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
2382:                	}
2383:                	#endif /* INCLUDE_vTaskSuspend */
2384:                }
00000094  00000000   NOP
2385:                /*-----------------------------------------------------------*/
2386:                
2387:                #if configUSE_TIMERS == 1
2388:                
2389:                	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2390:                	{
2391:                	TickType_t xTimeToWake;
2392:                
2393:                		configASSERT( pxEventList );
2394:                
2395:                		/* This function should not be called by application code hence the
2396:                		'Restricted' in its name.  It is not part of the public API.  It is
2397:                		designed for use by kernel code, and has special calling requirements -
2398:                		it should be called with the scheduler suspended. */
2399:                
2400:                
2401:                		/* Place the event list item of the TCB in the appropriate event list.
2402:                		In this case it is assume that this is the only task that is going to
2403:                		be waiting on this event list, so the faster vListInsertEnd() function
2404:                		can be used in place of vListInsert. */
2405:                		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2406:                
2407:                		/* We must remove this task from the ready list before adding it to the
2408:                		blocked list as the same list item is used for both lists.  This
2409:                		function is called with the scheduler locked so interrupts will not
2410:                		access the lists at the same time. */
2411:                		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2412:                		{
2413:                			/* The current task must be in a ready list, so there is no need to
2414:                			check, and the port reset macro can be called directly. */
2415:                			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2416:                		}
2417:                		else
2418:                		{
2419:                			mtCOVERAGE_TEST_MARKER();
2420:                		}
2421:                
2422:                		/* If vTaskSuspend() is available then the suspended task list is also
2423:                		available and a task that is blocking indefinitely can enter the
2424:                		suspended state (it is not really suspended as it will re-enter the
2425:                		Ready state when the event it is waiting indefinitely for occurs).
2426:                		Blocking indefinitely is useful when using tickless idle mode as when
2427:                		all tasks are blocked indefinitely all timers can be turned off. */
2428:                		#if( INCLUDE_vTaskSuspend == 1 )
2429:                		{
2430:                			if( xWaitIndefinitely == pdTRUE )
2431:                			{
2432:                				/* Add the task to the suspended task list instead of a delayed
2433:                				task list to ensure the task is not woken by a timing event.  It
2434:                				will block indefinitely. */
2435:                				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2436:                			}
2437:                			else
2438:                			{
2439:                				/* Calculate the time at which the task should be woken if the
2440:                				event does not occur.  This may overflow but this doesn't
2441:                				matter. */
2442:                				xTimeToWake = xTickCount + xTicksToWait;
2443:                				traceTASK_DELAY_UNTIL();
2444:                				prvAddCurrentTaskToDelayedList( xTimeToWake );
2445:                			}
2446:                		}
2447:                		#else
2448:                		{
2449:                			/* Calculate the time at which the task should be woken if the event
2450:                			does not occur.  This may overflow but this doesn't matter. */
2451:                			xTimeToWake = xTickCount + xTicksToWait;
2452:                			traceTASK_DELAY_UNTIL();
2453:                			prvAddCurrentTaskToDelayedList( xTimeToWake );
2454:                
2455:                			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
2456:                			defined. */
2457:                			( void ) xWaitIndefinitely;
2458:                		}
2459:                		#endif
2460:                	}
2461:                
2462:                #endif /* configUSE_TIMERS */
2463:                /*-----------------------------------------------------------*/
2464:                
2465:                BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2466:                {
9D00AA8C  27BDFFE0   ADDIU SP, SP, -32
9D00AA90  AFBF001C   SW RA, 28(SP)
9D00AA94  AFB10018   SW S1, 24(SP)
9D00AA98  AFB00014   SW S0, 20(SP)
2467:                TCB_t *pxUnblockedTCB;
2468:                BaseType_t xReturn;
2469:                
2470:                	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2471:                	called from a critical section within an ISR. */
2472:                
2473:                	/* The event list is sorted in priority order, so the first in the list can
2474:                	be removed as it is known to be the highest priority.  Remove the TCB from
2475:                	the delayed list, and add it to the ready list.
2476:                
2477:                	If an event is for a queue that is locked then this function will never
2478:                	get called - the lock count on the queue will get modified instead.  This
2479:                	means exclusive access to the event list is guaranteed here.
2480:                
2481:                	This function assumes that a check has already been made to ensure that
2482:                	pxEventList is not empty. */
2483:                	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
9D00AA9C  8C82000C   LW V0, 12(A0)
9D00AAA0  8C50000C   LW S0, 12(V0)
2484:                	configASSERT( pxUnblockedTCB );
2485:                	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
9D00AAA4  26110018   ADDIU S1, S0, 24
9D00AAA8  0F40348C   JAL uxListRemove
9D00AAAC  02202021   ADDU A0, S1, ZERO
2486:                
2487:                	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
9D00AAB0  8F82805C   LW V0, -32676(GP)
9D00AAB4  14400014   BNE V0, ZERO, 0x9D00AB08
9D00AAB8  3C04A000   LUI A0, -24576
2488:                	{
2489:                		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
9D00AABC  26110004   ADDIU S1, S0, 4
9D00AAC0  0F40348C   JAL uxListRemove
9D00AAC4  02202021   ADDU A0, S1, ZERO
2490:                		prvAddTaskToReadyList( pxUnblockedTCB );
9D00AAC8  8E02002C   LW V0, 44(S0)
9D00AACC  8F848078   LW A0, -32648(GP)
9D00AAD0  24030001   ADDIU V1, ZERO, 1
9D00AAD4  00431804   SLLV V1, V1, V0
9D00AAD8  00641825   OR V1, V1, A0
9D00AADC  AF838078   SW V1, -32648(GP)
9D00AAE0  00021880   SLL V1, V0, 2
9D00AAE4  00021100   SLL V0, V0, 4
9D00AAE8  00621021   ADDU V0, V1, V0
9D00AAEC  3C04A000   LUI A0, -24576
9D00AAF0  24840BC0   ADDIU A0, A0, 3008
9D00AAF4  00822021   ADDU A0, A0, V0
9D00AAF8  0F4035EF   JAL vListInsertEnd
9D00AAFC  02202821   ADDU A1, S1, ZERO
9D00AB00  0B402AC5   J 0x9D00AB14
9D00AB04  00000000   NOP
2491:                	}
2492:                	else
2493:                	{
2494:                		/* The delayed and ready lists cannot be accessed, so hold this task
2495:                		pending until the scheduler is resumed. */
2496:                		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
9D00AB08  24840C24   ADDIU A0, A0, 3108
9D00AB0C  0F4035EF   JAL vListInsertEnd
9D00AB10  02202821   ADDU A1, S1, ZERO
2497:                	}
2498:                
2499:                	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
9D00AB14  8F828088   LW V0, -32632(GP)
9D00AB18  8E03002C   LW V1, 44(S0)
9D00AB1C  8C42002C   LW V0, 44(V0)
9D00AB20  0043182B   SLTU V1, V0, V1
9D00AB24  10600003   BEQ V1, ZERO, 0x9D00AB34
9D00AB28  00001021   ADDU V0, ZERO, ZERO
2500:                	{
2501:                		/* Return true if the task removed from the event list has a higher
2502:                		priority than the calling task.  This allows the calling task to know if
2503:                		it should force a context switch now. */
2504:                		xReturn = pdTRUE;
2505:                
2506:                		/* Mark that a yield is pending in case the user is not using the
2507:                		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2508:                		xYieldPending = pdTRUE;
9D00AB2C  24020001   ADDIU V0, ZERO, 1
9D00AB30  AF82806C   SW V0, -32660(GP)
2509:                	}
2510:                	else
2511:                	{
2512:                		xReturn = pdFALSE;
2513:                	}
2514:                
2515:                	#if( configUSE_TICKLESS_IDLE != 0 )
2516:                	{
2517:                		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2518:                		might be set to the blocked task's time out time.  If the task is
2519:                		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2520:                		normally left unchanged, because it is automatically reset to a new
2521:                		value when the tick count equals xNextTaskUnblockTime.  However if
2522:                		tickless idling is used it might be more important to enter sleep mode
2523:                		at the earliest possible time - so reset xNextTaskUnblockTime here to
2524:                		ensure it is updated at the earliest possible time. */
2525:                		prvResetNextTaskUnblockTime();
2526:                	}
2527:                	#endif
2528:                
2529:                	return xReturn;
2530:                }
9D00AB34  8FBF001C   LW RA, 28(SP)
9D00AB38  8FB10018   LW S1, 24(SP)
9D00AB3C  8FB00014   LW S0, 20(SP)
9D00AB40  03E00008   JR RA
9D00AB44  27BD0020   ADDIU SP, SP, 32
2531:                /*-----------------------------------------------------------*/
2532:                
2533:                BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
2534:                {
00000000  00000000   NOP
2535:                TCB_t *pxUnblockedTCB;
2536:                BaseType_t xReturn;
2537:                
2538:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2539:                	the event flags implementation. */
2540:                	configASSERT( uxSchedulerSuspended != pdFALSE );
2541:                
2542:                	/* Store the new item value in the event list. */
2543:                	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
00000010  00000000   NOP
2544:                
2545:                	/* Remove the event list form the event flag.  Interrupts do not access
2546:                	event flags. */
2547:                	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
2548:                	configASSERT( pxUnblockedTCB );
2549:                	( void ) uxListRemove( pxEventListItem );
0000001C  00000000   NOP
2550:                
2551:                	/* Remove the task from the delayed list and add it to the ready list.  The
2552:                	scheduler is suspended so interrupts will not be accessing the ready
2553:                	lists. */
2554:                	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
00000024  00000000   NOP
2555:                	prvAddTaskToReadyList( pxUnblockedTCB );
00000030  00000000   NOP
2556:                
2557:                	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00000068  00000000   NOP
2558:                	{
2559:                		/* Return true if the task removed from the event list has
2560:                		a higher priority than the calling task.  This allows
2561:                		the calling task to know if it should force a context
2562:                		switch now. */
2563:                		xReturn = pdTRUE;
2564:                
2565:                		/* Mark that a yield is pending in case the user is not using the
2566:                		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2567:                		xYieldPending = pdTRUE;
00000080  00000000   NOP
2568:                	}
2569:                	else
2570:                	{
2571:                		xReturn = pdFALSE;
2572:                	}
2573:                
2574:                	return xReturn;
2575:                }
00000088  00000000   NOP
2576:                /*-----------------------------------------------------------*/
2577:                
2578:                void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2579:                {
2580:                	configASSERT( pxTimeOut );
2581:                	pxTimeOut->xOverflowCount = xNumOfOverflows;
9D00DCEC  8F828068   LW V0, -32664(GP)
9D00DCF0  AC820000   SW V0, 0(A0)
2582:                	pxTimeOut->xTimeOnEntering = xTickCount;
9D00DCF4  8F82807C   LW V0, -32644(GP)
9D00DCF8  03E00008   JR RA
9D00DCFC  AC820004   SW V0, 4(A0)
2583:                }
2584:                /*-----------------------------------------------------------*/
2585:                
2586:                BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2587:                {
9D00B164  27BDFFE0   ADDIU SP, SP, -32
9D00B168  AFBF001C   SW RA, 28(SP)
9D00B16C  AFB20018   SW S2, 24(SP)
9D00B170  AFB10014   SW S1, 20(SP)
9D00B174  AFB00010   SW S0, 16(SP)
9D00B178  00808021   ADDU S0, A0, ZERO
2588:                BaseType_t xReturn;
2589:                
2590:                	configASSERT( pxTimeOut );
2591:                	configASSERT( pxTicksToWait );
2592:                
2593:                	taskENTER_CRITICAL();
9D00B17C  0F40339E   JAL vTaskEnterCritical
9D00B180  00A09021   ADDU S2, A1, ZERO
2594:                	{
2595:                		/* Minor optimisation.  The tick count cannot change in this block. */
2596:                		const TickType_t xConstTickCount = xTickCount;
9D00B184  8F82807C   LW V0, -32644(GP)
2597:                
2598:                		#if ( INCLUDE_vTaskSuspend == 1 )
2599:                			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2600:                			the maximum block time then the task should block indefinitely, and
2601:                			therefore never time out. */
2602:                			if( *pxTicksToWait == portMAX_DELAY )
9D00B188  8E430000   LW V1, 0(S2)
9D00B18C  2404FFFF   ADDIU A0, ZERO, -1
9D00B190  50640013   BEQL V1, A0, 0x9D00B1E0
9D00B194  00008821   ADDU S1, ZERO, ZERO
2603:                			{
2604:                				xReturn = pdFALSE;
2605:                			}
2606:                			else /* We are not blocking indefinitely, perform the checks below. */
2607:                		#endif
2608:                
2609:                		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
9D00B198  8F848068   LW A0, -32664(GP)
9D00B19C  8E050000   LW A1, 0(S0)
9D00B1A0  10A40005   BEQ A1, A0, 0x9D00B1B8
9D00B1A4  8E040004   LW A0, 4(S0)
9D00B1A8  0044202B   SLTU A0, V0, A0
9D00B1AC  1080000C   BEQ A0, ZERO, 0x9D00B1E0
9D00B1B0  24110001   ADDIU S1, ZERO, 1
2610:                		{
2611:                			/* The tick count is greater than the time at which vTaskSetTimeout()
2612:                			was called, but has also overflowed since vTaskSetTimeOut() was called.
2613:                			It must have wrapped all the way around and gone past us again. This
2614:                			passed since vTaskSetTimeout() was called. */
2615:                			xReturn = pdTRUE;
2616:                		}
2617:                		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
9D00B1B4  8E040004   LW A0, 4(S0)
9D00B1B8  00442823   SUBU A1, V0, A0
9D00B1BC  00A3282B   SLTU A1, A1, V1
9D00B1C0  10A00007   BEQ A1, ZERO, 0x9D00B1E0
9D00B1C4  24110001   ADDIU S1, ZERO, 1
2618:                		{
2619:                			/* Not a genuine timeout. Adjust parameters for time remaining. */
2620:                			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
9D00B1C8  00821023   SUBU V0, A0, V0
9D00B1CC  00431821   ADDU V1, V0, V1
9D00B1D0  AE430000   SW V1, 0(S2)
2621:                			vTaskSetTimeOutState( pxTimeOut );
9D00B1D4  0F40373B   JAL vTaskSetTimeOutState
9D00B1D8  02002021   ADDU A0, S0, ZERO
9D00B1DC  00008821   ADDU S1, ZERO, ZERO
2622:                			xReturn = pdFALSE;
2623:                		}
2624:                		else
2625:                		{
2626:                			xReturn = pdTRUE;
2627:                		}
2628:                	}
2629:                	taskEXIT_CRITICAL();
9D00B1E0  0F403151   JAL vTaskExitCritical
9D00B1E4  00000000   NOP
2630:                
2631:                	return xReturn;
2632:                }
9D00B1E8  02201021   ADDU V0, S1, ZERO
9D00B1EC  8FBF001C   LW RA, 28(SP)
9D00B1F0  8FB20018   LW S2, 24(SP)
9D00B1F4  8FB10014   LW S1, 20(SP)
9D00B1F8  8FB00010   LW S0, 16(SP)
9D00B1FC  03E00008   JR RA
9D00B200  27BD0020   ADDIU SP, SP, 32
2633:                /*-----------------------------------------------------------*/
2634:                
2635:                void vTaskMissedYield( void )
2636:                {
2637:                	xYieldPending = pdTRUE;
9D00DD00  24020001   ADDIU V0, ZERO, 1
9D00DD04  AF82806C   SW V0, -32660(GP)
9D00DD08  03E00008   JR RA
9D00DD0C  00000000   NOP
2638:                }
2639:                /*-----------------------------------------------------------*/
2640:                
2641:                #if ( configUSE_TRACE_FACILITY == 1 )
2642:                
2643:                	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2644:                	{
2645:                	UBaseType_t uxReturn;
2646:                	TCB_t *pxTCB;
2647:                
2648:                		if( xTask != NULL )
2649:                		{
2650:                			pxTCB = ( TCB_t * ) xTask;
2651:                			uxReturn = pxTCB->uxTaskNumber;
2652:                		}
2653:                		else
2654:                		{
2655:                			uxReturn = 0U;
2656:                		}
2657:                
2658:                		return uxReturn;
2659:                	}
2660:                
2661:                #endif /* configUSE_TRACE_FACILITY */
2662:                /*-----------------------------------------------------------*/
2663:                
2664:                #if ( configUSE_TRACE_FACILITY == 1 )
2665:                
2666:                	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2667:                	{
2668:                	TCB_t *pxTCB;
2669:                
2670:                		if( xTask != NULL )
2671:                		{
2672:                			pxTCB = ( TCB_t * ) xTask;
2673:                			pxTCB->uxTaskNumber = uxHandle;
2674:                		}
2675:                	}
2676:                
2677:                #endif /* configUSE_TRACE_FACILITY */
2678:                
2679:                /*
2680:                 * -----------------------------------------------------------
2681:                 * The Idle task.
2682:                 * ----------------------------------------------------------
2683:                 *
2684:                 * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2685:                 * language extensions.  The equivalent prototype for this function is:
2686:                 *
2687:                 * void prvIdleTask( void *pvParameters );
2688:                 *
2689:                 */
2690:                static portTASK_FUNCTION( prvIdleTask, pvParameters )
2691:                {
9D00D37C  27BDFFE8   ADDIU SP, SP, -24
9D00D380  AFBF0014   SW RA, 20(SP)
9D00D384  AFB00010   SW S0, 16(SP)
2692:                	/* Stop warnings. */
2693:                	( void ) pvParameters;
2694:                
2695:                	for( ;; )
2696:                	{
2697:                		/* See if any tasks have been deleted. */
2698:                		prvCheckTasksWaitingTermination();
9D00D38C  0F402EB4   JAL prvCheckTasksWaitingTermination
9D00D390  00000000   NOP
2699:                
2700:                		#if ( configUSE_PREEMPTION == 0 )
2701:                		{
2702:                			/* If we are not using preemption we keep forcing a task switch to
2703:                			see if any other task has become available.  If we are using
2704:                			preemption we don't need to do this as any task becoming available
2705:                			will automatically get the processor anyway. */
2706:                			taskYIELD();
2707:                		}
2708:                		#endif /* configUSE_PREEMPTION */
2709:                
2710:                		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2711:                		{
2712:                			/* When using preemption tasks of equal priority will be
2713:                			timesliced.  If a task that is sharing the idle priority is ready
2714:                			to run then the idle task should yield before the end of the
2715:                			timeslice.
2716:                
2717:                			A critical region is not required here as we are just reading from
2718:                			the list, and an occasional incorrect value will not matter.  If
2719:                			the ready list at the idle priority contains more than one task
2720:                			then a task other than the idle task is ready to execute. */
2721:                			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
9D00D388  3C10A000   LUI S0, -24576
9D00D394  8E020BC0   LW V0, 3008(S0)
9D00D398  2C420002   SLTIU V0, V0, 2
9D00D39C  1440FFFB   BNE V0, ZERO, 0x9D00D38C
9D00D3A0  00000000   NOP
2722:                			{
2723:                				taskYIELD();
9D00D3A4  40026800   MFC0 V0, Cause
9D00D3A8  34420100   ORI V0, V0, 256
9D00D3AC  40826800   MTC0 V0, Cause
9D00D3B0  000000C0   EHB
9D00D3B4  0B4034E3   J 0x9D00D38C
9D00D3B8  00000000   NOP
2724:                			}
2725:                			else
2726:                			{
2727:                				mtCOVERAGE_TEST_MARKER();
2728:                			}
2729:                		}
2730:                		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2731:                
2732:                		#if ( configUSE_IDLE_HOOK == 1 )
2733:                		{
2734:                			extern void vApplicationIdleHook( void );
2735:                
2736:                			/* Call the user defined function from within the idle task.  This
2737:                			allows the application designer to add background functionality
2738:                			without the overhead of a separate task.
2739:                			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2740:                			CALL A FUNCTION THAT MIGHT BLOCK. */
2741:                			vApplicationIdleHook();
2742:                		}
2743:                		#endif /* configUSE_IDLE_HOOK */
2744:                
2745:                		/* This conditional compilation should use inequality to 0, not equality
2746:                		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2747:                		user defined low power mode	implementations require
2748:                		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2749:                		#if ( configUSE_TICKLESS_IDLE != 0 )
2750:                		{
2751:                		TickType_t xExpectedIdleTime;
2752:                
2753:                			/* It is not desirable to suspend then resume the scheduler on
2754:                			each iteration of the idle task.  Therefore, a preliminary
2755:                			test of the expected idle time is performed without the
2756:                			scheduler suspended.  The result here is not necessarily
2757:                			valid. */
2758:                			xExpectedIdleTime = prvGetExpectedIdleTime();
2759:                
2760:                			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2761:                			{
2762:                				vTaskSuspendAll();
2763:                				{
2764:                					/* Now the scheduler is suspended, the expected idle
2765:                					time can be sampled again, and this time its value can
2766:                					be used. */
2767:                					configASSERT( xNextTaskUnblockTime >= xTickCount );
2768:                					xExpectedIdleTime = prvGetExpectedIdleTime();
2769:                
2770:                					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2771:                					{
2772:                						traceLOW_POWER_IDLE_BEGIN();
2773:                						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2774:                						traceLOW_POWER_IDLE_END();
2775:                					}
2776:                					else
2777:                					{
2778:                						mtCOVERAGE_TEST_MARKER();
2779:                					}
2780:                				}
2781:                				( void ) xTaskResumeAll();
2782:                			}
2783:                			else
2784:                			{
2785:                				mtCOVERAGE_TEST_MARKER();
2786:                			}
2787:                		}
2788:                		#endif /* configUSE_TICKLESS_IDLE */
2789:                	}
2790:                }
2791:                /*-----------------------------------------------------------*/
2792:                
2793:                #if( configUSE_TICKLESS_IDLE != 0 )
2794:                
2795:                	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2796:                	{
2797:                	/* The idle task exists in addition to the application tasks. */
2798:                	const UBaseType_t uxNonApplicationTasks = 1;
2799:                	eSleepModeStatus eReturn = eStandardSleep;
2800:                
2801:                		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2802:                		{
2803:                			/* A task was made ready while the scheduler was suspended. */
2804:                			eReturn = eAbortSleep;
2805:                		}
2806:                		else if( xYieldPending != pdFALSE )
2807:                		{
2808:                			/* A yield was pended while the scheduler was suspended. */
2809:                			eReturn = eAbortSleep;
2810:                		}
2811:                		else
2812:                		{
2813:                			/* If all the tasks are in the suspended list (which might mean they
2814:                			have an infinite block time rather than actually being suspended)
2815:                			then it is safe to turn all clocks off and just wait for external
2816:                			interrupts. */
2817:                			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
2818:                			{
2819:                				eReturn = eNoTasksWaitingTimeout;
2820:                			}
2821:                			else
2822:                			{
2823:                				mtCOVERAGE_TEST_MARKER();
2824:                			}
2825:                		}
2826:                
2827:                		return eReturn;
2828:                	}
2829:                
2830:                #endif /* configUSE_TICKLESS_IDLE */
2831:                /*-----------------------------------------------------------*/
2832:                
2833:                static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2834:                {
9D00AC04  27BDFFE0   ADDIU SP, SP, -32
9D00AC08  AFBF001C   SW RA, 28(SP)
9D00AC0C  AFB10018   SW S1, 24(SP)
9D00AC10  AFB00014   SW S0, 20(SP)
2835:                UBaseType_t x;
2836:                
2837:                	/* Store the task name in the TCB. */
2838:                	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
9D00AC2C  24020001   ADDIU V0, ZERO, 1
9D00AC30  24070010   ADDIU A3, ZERO, 16
9D00AC4C  1447FFF9   BNE V0, A3, 0x9D00AC34
9D00AC50  24A50001   ADDIU A1, A1, 1
2839:                	{
2840:                		pxTCB->pcTaskName[ x ] = pcName[ x ];
9D00AC14  80A20000   LB V0, 0(A1)
9D00AC18  A0820034   SB V0, 52(A0)
9D00AC34  80A40000   LB A0, 0(A1)
9D00AC38  02021821   ADDU V1, S0, V0
9D00AC3C  A0640034   SB A0, 52(V1)
2841:                
2842:                		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2843:                		configMAX_TASK_NAME_LEN characters just in case the memory after the
2844:                		string is not accessible (extremely unlikely). */
2845:                		if( pcName[ x ] == 0x00 )
9D00AC1C  80A20000   LB V0, 0(A1)
9D00AC20  1040000C   BEQ V0, ZERO, 0x9D00AC54
9D00AC24  00808021   ADDU S0, A0, ZERO
9D00AC28  24A50001   ADDIU A1, A1, 1
9D00AC40  80A30000   LB V1, 0(A1)
9D00AC44  10600003   BEQ V1, ZERO, 0x9D00AC54
9D00AC48  24420001   ADDIU V0, V0, 1
2846:                		{
2847:                			break;
2848:                		}
2849:                		else
2850:                		{
2851:                			mtCOVERAGE_TEST_MARKER();
2852:                		}
2853:                	}
2854:                
2855:                	/* Ensure the name string is terminated in the case that the string length
2856:                	was greater or equal to configMAX_TASK_NAME_LEN. */
2857:                	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
9D00AC54  A2000043   SB ZERO, 67(S0)
9D00AC58  2CD10005   SLTIU S1, A2, 5
9D00AC5C  24020004   ADDIU V0, ZERO, 4
9D00AC60  00D1100B   MOVN V0, A2, S1
9D00AC64  00408821   ADDU S1, V0, ZERO
2858:                
2859:                	/* This is used as an array index so must ensure it's not too large.  First
2860:                	remove the privilege bit if one is present. */
2861:                	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
2862:                	{
2863:                		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
2864:                	}
2865:                	else
2866:                	{
2867:                		mtCOVERAGE_TEST_MARKER();
2868:                	}
2869:                
2870:                	pxTCB->uxPriority = uxPriority;
9D00AC68  AE02002C   SW V0, 44(S0)
2871:                	#if ( configUSE_MUTEXES == 1 )
2872:                	{
2873:                		pxTCB->uxBasePriority = uxPriority;
9D00AC6C  AE020048   SW V0, 72(S0)
2874:                		pxTCB->uxMutexesHeld = 0;
9D00AC70  AE00004C   SW ZERO, 76(S0)
2875:                	}
2876:                	#endif /* configUSE_MUTEXES */
2877:                
2878:                	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
9D00AC74  0F40375C   JAL vListInitialiseItem
9D00AC78  26040004   ADDIU A0, S0, 4
2879:                	vListInitialiseItem( &( pxTCB->xEventListItem ) );
9D00AC7C  0F40375C   JAL vListInitialiseItem
9D00AC80  26040018   ADDIU A0, S0, 24
2880:                
2881:                	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2882:                	back to	the containing TCB from a generic item in a list. */
2883:                	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
9D00AC84  AE100010   SW S0, 16(S0)
2884:                
2885:                	/* Event lists are always in priority order. */
2886:                	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D00AC88  24020005   ADDIU V0, ZERO, 5
9D00AC8C  00518823   SUBU S1, V0, S1
9D00AC90  AE110018   SW S1, 24(S0)
2887:                	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
9D00AC94  AE100024   SW S0, 36(S0)
2888:                
2889:                	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2890:                	{
2891:                		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
9D00AC98  AE000044   SW ZERO, 68(S0)
2892:                	}
2893:                	#endif /* portCRITICAL_NESTING_IN_TCB */
2894:                
2895:                	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2896:                	{
2897:                		pxTCB->pxTaskTag = NULL;
2898:                	}
2899:                	#endif /* configUSE_APPLICATION_TASK_TAG */
2900:                
2901:                	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2902:                	{
2903:                		pxTCB->ulRunTimeCounter = 0UL;
2904:                	}
2905:                	#endif /* configGENERATE_RUN_TIME_STATS */
2906:                
2907:                	#if ( portUSING_MPU_WRAPPERS == 1 )
2908:                	{
2909:                		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2910:                	}
2911:                	#else /* portUSING_MPU_WRAPPERS */
2912:                	{
2913:                		( void ) xRegions;
2914:                		( void ) usStackDepth;
2915:                	}
2916:                	#endif /* portUSING_MPU_WRAPPERS */
2917:                
2918:                	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2919:                	{
2920:                		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
2921:                		{
2922:                			pxTCB->pvThreadLocalStoragePointers[ x ] = NULL;
2923:                		}
2924:                	}
2925:                	#endif
2926:                
2927:                	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
2928:                	{
2929:                		pxTCB->ulNotifiedValue = 0;
9D00AC9C  AE000050   SW ZERO, 80(S0)
2930:                		pxTCB->eNotifyState = eNotWaitingNotification;
9D00ACA0  AE000054   SW ZERO, 84(S0)
2931:                	}
2932:                	#endif
2933:                
2934:                	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2935:                	{
2936:                		/* Initialise this task's Newlib reent structure. */
2937:                		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2938:                	}
2939:                	#endif /* configUSE_NEWLIB_REENTRANT */
2940:                }
9D00ACA4  8FBF001C   LW RA, 28(SP)
9D00ACA8  8FB10018   LW S1, 24(SP)
9D00ACAC  8FB00014   LW S0, 20(SP)
9D00ACB0  03E00008   JR RA
9D00ACB4  27BD0020   ADDIU SP, SP, 32
2941:                /*-----------------------------------------------------------*/
2942:                
2943:                #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2944:                
2945:                	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
2946:                	{
2947:                	TCB_t *pxTCB;
2948:                
2949:                		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2950:                		{
2951:                			pxTCB = prvGetTCBFromHandle( xTaskToSet );
2952:                			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
2953:                		}
2954:                	}
2955:                
2956:                #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2957:                /*-----------------------------------------------------------*/
2958:                
2959:                #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2960:                
2961:                	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
2962:                	{
2963:                	void *pvReturn = NULL;
2964:                	TCB_t *pxTCB;
2965:                
2966:                		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2967:                		{
2968:                			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2969:                			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
2970:                		}
2971:                		else
2972:                		{
2973:                			pvReturn = NULL;
2974:                		}
2975:                
2976:                		return pvReturn;
2977:                	}
2978:                
2979:                #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2980:                /*-----------------------------------------------------------*/
2981:                
2982:                #if ( portUSING_MPU_WRAPPERS == 1 )
2983:                
2984:                	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2985:                	{
2986:                	TCB_t *pxTCB;
2987:                
2988:                		/* If null is passed in here then we are modifying the MPU settings of
2989:                		the calling task. */
2990:                		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2991:                
2992:                        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2993:                	}
2994:                
2995:                #endif /* portUSING_MPU_WRAPPERS */
2996:                /*-----------------------------------------------------------*/
2997:                
2998:                static void prvInitialiseTaskLists( void )
2999:                {
9D00BA40  27BDFFE0   ADDIU SP, SP, -32
9D00BA44  AFBF001C   SW RA, 28(SP)
9D00BA48  AFB10018   SW S1, 24(SP)
9D00BA4C  AFB00014   SW S0, 20(SP)
9D00BA50  3C10A000   LUI S0, -24576
9D00BA54  26100BC0   ADDIU S0, S0, 3008
9D00BA58  26110064   ADDIU S1, S0, 100
3000:                UBaseType_t uxPriority;
3001:                
3002:                	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
9D00BA68  1611FFFC   BNE S0, S1, 0x9D00BA5C
9D00BA6C  00000000   NOP
3003:                	{
3004:                		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
9D00BA5C  0F403689   JAL vListInitialise
9D00BA60  02002021   ADDU A0, S0, ZERO
9D00BA64  26100014   ADDIU S0, S0, 20
3005:                	}
3006:                
3007:                	vListInitialise( &xDelayedTaskList1 );
9D00BA70  3C11A000   LUI S1, -24576
9D00BA74  0F403689   JAL vListInitialise
9D00BA78  26240C74   ADDIU A0, S1, 3188
3008:                	vListInitialise( &xDelayedTaskList2 );
9D00BA7C  3C10A000   LUI S0, -24576
9D00BA80  0F403689   JAL vListInitialise
9D00BA84  26040C60   ADDIU A0, S0, 3168
3009:                	vListInitialise( &xPendingReadyList );
9D00BA88  3C04A000   LUI A0, -24576
9D00BA8C  0F403689   JAL vListInitialise
9D00BA90  24840C24   ADDIU A0, A0, 3108
3010:                
3011:                	#if ( INCLUDE_vTaskDelete == 1 )
3012:                	{
3013:                		vListInitialise( &xTasksWaitingTermination );
9D00BA94  3C04A000   LUI A0, -24576
9D00BA98  0F403689   JAL vListInitialise
9D00BA9C  24840C38   ADDIU A0, A0, 3128
3014:                	}
3015:                	#endif /* INCLUDE_vTaskDelete */
3016:                
3017:                	#if ( INCLUDE_vTaskSuspend == 1 )
3018:                	{
3019:                		vListInitialise( &xSuspendedTaskList );
9D00BAA0  3C04A000   LUI A0, -24576
9D00BAA4  0F403689   JAL vListInitialise
9D00BAA8  24840C4C   ADDIU A0, A0, 3148
3020:                	}
3021:                	#endif /* INCLUDE_vTaskSuspend */
3022:                
3023:                	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3024:                	using list2. */
3025:                	pxDelayedTaskList = &xDelayedTaskList1;
9D00BAAC  26310C74   ADDIU S1, S1, 3188
9D00BAB0  AF918108   SW S1, -32504(GP)
3026:                	pxOverflowDelayedTaskList = &xDelayedTaskList2;
9D00BAB4  26100C60   ADDIU S0, S0, 3168
9D00BAB8  AF90810C   SW S0, -32500(GP)
3027:                }
9D00BABC  8FBF001C   LW RA, 28(SP)
9D00BAC0  8FB10018   LW S1, 24(SP)
9D00BAC4  8FB00014   LW S0, 20(SP)
9D00BAC8  03E00008   JR RA
9D00BACC  27BD0020   ADDIU SP, SP, 32
3028:                /*-----------------------------------------------------------*/
3029:                
3030:                static void prvCheckTasksWaitingTermination( void )
3031:                {
9D00BAD0  27BDFFE0   ADDIU SP, SP, -32
9D00BAD4  AFBF001C   SW RA, 28(SP)
9D00BAD8  AFB10018   SW S1, 24(SP)
9D00BADC  AFB00014   SW S0, 20(SP)
3032:                	#if ( INCLUDE_vTaskDelete == 1 )
3033:                	{
3034:                		BaseType_t xListIsEmpty;
3035:                
3036:                		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3037:                		too often in the idle task. */
3038:                		while( uxTasksDeleted > ( UBaseType_t ) 0U )
9D00BAE0  0B402ED1   J 0x9D00BB44
9D00BAE4  3C11A000   LUI S1, -24576
9D00BB44  8F828084   LW V0, -32636(GP)
9D00BB48  1440FFE7   BNE V0, ZERO, 0x9D00BAE8
9D00BB4C  8FBF001C   LW RA, 28(SP)
3039:                		{
3040:                			vTaskSuspendAll();
9D00BAE8  0F403736   JAL vTaskSuspendAll
9D00BAEC  00000000   NOP
3041:                			{
3042:                				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
3043:                			}
3044:                			( void ) xTaskResumeAll();
9D00BAF0  0F402184   JAL xTaskResumeAll
9D00BAF4  8E300C38   LW S0, 3128(S1)
3045:                
3046:                			if( xListIsEmpty == pdFALSE )
9D00BAF8  12000012   BEQ S0, ZERO, 0x9D00BB44
9D00BAFC  00000000   NOP
3047:                			{
3048:                				TCB_t *pxTCB;
3049:                
3050:                				taskENTER_CRITICAL();
9D00BB00  0F40339E   JAL vTaskEnterCritical
9D00BB04  00000000   NOP
3051:                				{
3052:                					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
9D00BB08  26220C38   ADDIU V0, S1, 3128
9D00BB0C  8C42000C   LW V0, 12(V0)
9D00BB10  8C50000C   LW S0, 12(V0)
3053:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
9D00BB14  0F40348C   JAL uxListRemove
9D00BB18  26040004   ADDIU A0, S0, 4
3054:                					--uxCurrentNumberOfTasks;
9D00BB1C  8F828080   LW V0, -32640(GP)
9D00BB20  2442FFFF   ADDIU V0, V0, -1
9D00BB24  AF828080   SW V0, -32640(GP)
3055:                					--uxTasksDeleted;
9D00BB28  8F828084   LW V0, -32636(GP)
9D00BB2C  2442FFFF   ADDIU V0, V0, -1
9D00BB30  AF828084   SW V0, -32636(GP)
3056:                				}
3057:                				taskEXIT_CRITICAL();
9D00BB34  0F403151   JAL vTaskExitCritical
9D00BB38  00000000   NOP
3058:                
3059:                				prvDeleteTCB( pxTCB );
9D00BB3C  0F4035FB   JAL prvDeleteTCB
9D00BB40  02002021   ADDU A0, S0, ZERO
3060:                			}
3061:                			else
3062:                			{
3063:                				mtCOVERAGE_TEST_MARKER();
3064:                			}
3065:                		}
3066:                	}
3067:                	#endif /* vTaskDelete */
3068:                }
9D00BB50  8FB10018   LW S1, 24(SP)
9D00BB54  8FB00014   LW S0, 20(SP)
9D00BB58  03E00008   JR RA
9D00BB5C  27BD0020   ADDIU SP, SP, 32
3069:                /*-----------------------------------------------------------*/
3070:                
3071:                static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
3072:                {
9D00C2BC  27BDFFE8   ADDIU SP, SP, -24
9D00C2C0  AFBF0014   SW RA, 20(SP)
9D00C2C4  AFB00010   SW S0, 16(SP)
9D00C2C8  00808021   ADDU S0, A0, ZERO
3073:                	/* The list item will be inserted in wake time order. */
3074:                	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
9D00C2CC  8F828088   LW V0, -32632(GP)
9D00C2D0  AC440004   SW A0, 4(V0)
3075:                
3076:                	if( xTimeToWake < xTickCount )
9D00C2D4  8F82807C   LW V0, -32644(GP)
9D00C2D8  0082102B   SLTU V0, A0, V0
9D00C2DC  10400007   BEQ V0, ZERO, 0x9D00C2FC
9D00C2E0  00000000   NOP
3077:                	{
3078:                		/* Wake time has overflowed.  Place this item in the overflow list. */
3079:                		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
9D00C2E4  8F84810C   LW A0, -32500(GP)
9D00C2E8  8F858088   LW A1, -32632(GP)
9D00C2EC  0F40329B   JAL vListInsert
9D00C2F0  24A50004   ADDIU A1, A1, 4
9D00C2F4  0B4030C8   J 0x9D00C320
9D00C2F8  8FBF0014   LW RA, 20(SP)
3080:                	}
3081:                	else
3082:                	{
3083:                		/* The wake time has not overflowed, so the current block list is used. */
3084:                		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
9D00C2FC  8F848108   LW A0, -32504(GP)
9D00C300  8F858088   LW A1, -32632(GP)
9D00C304  0F40329B   JAL vListInsert
9D00C308  24A50004   ADDIU A1, A1, 4
3085:                
3086:                		/* If the task entering the blocked state was placed at the head of the
3087:                		list of blocked tasks then xNextTaskUnblockTime needs to be updated
3088:                		too. */
3089:                		if( xTimeToWake < xNextTaskUnblockTime )
9D00C30C  8F828060   LW V0, -32672(GP)
9D00C310  0202102B   SLTU V0, S0, V0
9D00C314  54400001   BNEL V0, ZERO, 0x9D00C31C
9D00C318  AF908060   SW S0, -32672(GP)
3090:                		{
3091:                			xNextTaskUnblockTime = xTimeToWake;
3092:                		}
3093:                		else
3094:                		{
3095:                			mtCOVERAGE_TEST_MARKER();
3096:                		}
3097:                	}
3098:                }
9D00C31C  8FBF0014   LW RA, 20(SP)
9D00C320  8FB00010   LW S0, 16(SP)
9D00C324  03E00008   JR RA
9D00C328  27BD0018   ADDIU SP, SP, 24
3099:                /*-----------------------------------------------------------*/
3100:                
3101:                static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
3102:                {
9D00BC6C  27BDFFE0   ADDIU SP, SP, -32
9D00BC70  AFBF001C   SW RA, 28(SP)
9D00BC74  AFB20018   SW S2, 24(SP)
9D00BC78  AFB10014   SW S1, 20(SP)
9D00BC7C  AFB00010   SW S0, 16(SP)
9D00BC80  3092FFFF   ANDI S2, A0, -1
3103:                TCB_t *pxNewTCB;
3104:                
3105:                	/* If the stack grows down then allocate the stack then the TCB so the stack
3106:                	does not grow into the TCB.  Likewise if the stack grows up then allocate
3107:                	the TCB then the stack. */
3108:                	#if( portSTACK_GROWTH > 0 )
3109:                	{
3110:                		/* Allocate space for the TCB.  Where the memory comes from depends on
3111:                		the implementation of the port malloc function. */
3112:                		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
3113:                
3114:                		if( pxNewTCB != NULL )
3115:                		{
3116:                			/* Allocate space for the stack used by the task being created.
3117:                			The base of the stack memory stored in the TCB so the task can
3118:                			be deleted later if required. */
3119:                			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
3120:                
3121:                			if( pxNewTCB->pxStack == NULL )
3122:                			{
3123:                				/* Could not allocate the stack.  Delete the allocated TCB. */
3124:                				vPortFree( pxNewTCB );
3125:                				pxNewTCB = NULL;
3126:                			}
3127:                		}
3128:                	}
3129:                	#else /* portSTACK_GROWTH */
3130:                	{
3131:                	StackType_t *pxStack;
3132:                
3133:                		/* Allocate space for the stack used by the task being created. */
3134:                		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D00BC84  14A00005   BNE A1, ZERO, 0x9D00BC9C
9D00BC88  00A08821   ADDU S1, A1, ZERO
9D00BC8C  0F402A73   JAL pvPortMalloc
9D00BC90  00122080   SLL A0, S2, 2
9D00BCD0  00008021   ADDU S0, ZERO, ZERO
3135:                
3136:                		if( pxStack != NULL )
9D00BC94  1040000E   BEQ V0, ZERO, 0x9D00BCD0
9D00BC98  00408821   ADDU S1, V0, ZERO
3137:                		{
3138:                			/* Allocate space for the TCB.  Where the memory comes from depends
3139:                			on the implementation of the port malloc function. */
3140:                			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
9D00BC9C  0F402A73   JAL pvPortMalloc
9D00BCA0  24040058   ADDIU A0, ZERO, 88
3141:                
3142:                			if( pxNewTCB != NULL )
9D00BCA4  10400008   BEQ V0, ZERO, 0x9D00BCC8
9D00BCA8  00408021   ADDU S0, V0, ZERO
3143:                			{
3144:                				/* Store the stack location in the TCB. */
3145:                				pxNewTCB->pxStack = pxStack;
9D00BCAC  AC510030   SW S1, 48(V0)
3146:                			}
3147:                			else
3148:                			{
3149:                				/* The stack cannot be used as the TCB was not created.  Free it
3150:                				again. */
3151:                				vPortFree( pxStack );
9D00BCC8  0F403760   JAL vPortFree
9D00BCCC  02202021   ADDU A0, S1, ZERO
3152:                			}
3153:                		}
3154:                		else
3155:                		{
3156:                			pxNewTCB = NULL;
3157:                		}
3158:                	}
3159:                	#endif /* portSTACK_GROWTH */
3160:                
3161:                	if( pxNewTCB != NULL )
3162:                	{
3163:                		/* Avoid dependency on memset() if it is not required. */
3164:                		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3165:                		{
3166:                			/* Just to help debugging. */
3167:                			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
9D00BCB0  02202021   ADDU A0, S1, ZERO
9D00BCB4  240500A5   ADDIU A1, ZERO, 165
9D00BCB8  0F402BDD   JAL 0x9D00AF74
9D00BCBC  00123080   SLL A2, S2, 2
3168:                		}
3169:                		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
3170:                	}
3171:                
3172:                	return pxNewTCB;
3173:                }
9D00BCC0  0B402F36   J 0x9D00BCD8
9D00BCC4  02001021   ADDU V0, S0, ZERO
9D00BCD4  02001021   ADDU V0, S0, ZERO
9D00BCD8  8FBF001C   LW RA, 28(SP)
9D00BCDC  8FB20018   LW S2, 24(SP)
9D00BCE0  8FB10014   LW S1, 20(SP)
9D00BCE4  8FB00010   LW S0, 16(SP)
9D00BCE8  03E00008   JR RA
9D00BCEC  27BD0020   ADDIU SP, SP, 32
3174:                /*-----------------------------------------------------------*/
3175:                
3176:                #if ( configUSE_TRACE_FACILITY == 1 )
3177:                
3178:                	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
3179:                	{
3180:                	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3181:                	UBaseType_t uxTask = 0;
3182:                
3183:                		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3184:                		{
3185:                			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3186:                
3187:                			/* Populate an TaskStatus_t structure within the
3188:                			pxTaskStatusArray array for each task that is referenced from
3189:                			pxList.  See the definition of TaskStatus_t in task.h for the
3190:                			meaning of each TaskStatus_t structure member. */
3191:                			do
3192:                			{
3193:                				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3194:                
3195:                				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
3196:                				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
3197:                				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
3198:                				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
3199:                				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
3200:                
3201:                				#if ( INCLUDE_vTaskSuspend == 1 )
3202:                				{
3203:                					/* If the task is in the suspended list then there is a chance
3204:                					it is actually just blocked indefinitely - so really it should
3205:                					be reported as being in the Blocked state. */
3206:                					if( eState == eSuspended )
3207:                					{
3208:                						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
3209:                						{
3210:                							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
3211:                						}
3212:                					}
3213:                				}
3214:                				#endif /* INCLUDE_vTaskSuspend */
3215:                
3216:                				#if ( configUSE_MUTEXES == 1 )
3217:                				{
3218:                					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
3219:                				}
3220:                				#else
3221:                				{
3222:                					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
3223:                				}
3224:                				#endif
3225:                
3226:                				#if ( configGENERATE_RUN_TIME_STATS == 1 )
3227:                				{
3228:                					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
3229:                				}
3230:                				#else
3231:                				{
3232:                					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
3233:                				}
3234:                				#endif
3235:                
3236:                				#if ( portSTACK_GROWTH > 0 )
3237:                				{
3238:                					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
3239:                				}
3240:                				#else
3241:                				{
3242:                					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
3243:                				}
3244:                				#endif
3245:                
3246:                				uxTask++;
3247:                
3248:                			} while( pxNextTCB != pxFirstTCB );
3249:                		}
3250:                		else
3251:                		{
3252:                			mtCOVERAGE_TEST_MARKER();
3253:                		}
3254:                
3255:                		return uxTask;
3256:                	}
3257:                
3258:                #endif /* configUSE_TRACE_FACILITY */
3259:                /*-----------------------------------------------------------*/
3260:                
3261:                #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3262:                
3263:                	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3264:                	{
3265:                	uint32_t ulCount = 0U;
3266:                
3267:                		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3268:                		{
3269:                			pucStackByte -= portSTACK_GROWTH;
3270:                			ulCount++;
3271:                		}
3272:                
3273:                		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
3274:                
3275:                		return ( uint16_t ) ulCount;
3276:                	}
3277:                
3278:                #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3279:                /*-----------------------------------------------------------*/
3280:                
3281:                #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3282:                
3283:                	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3284:                	{
3285:                	TCB_t *pxTCB;
3286:                	uint8_t *pucEndOfStack;
3287:                	UBaseType_t uxReturn;
3288:                
3289:                		pxTCB = prvGetTCBFromHandle( xTask );
3290:                
3291:                		#if portSTACK_GROWTH < 0
3292:                		{
3293:                			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3294:                		}
3295:                		#else
3296:                		{
3297:                			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3298:                		}
3299:                		#endif
3300:                
3301:                		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3302:                
3303:                		return uxReturn;
3304:                	}
3305:                
3306:                #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3307:                /*-----------------------------------------------------------*/
3308:                
3309:                #if ( INCLUDE_vTaskDelete == 1 )
3310:                
3311:                	static void prvDeleteTCB( TCB_t *pxTCB )
3312:                	{
9D00D7EC  27BDFFE8   ADDIU SP, SP, -24
9D00D7F0  AFBF0014   SW RA, 20(SP)
9D00D7F4  AFB00010   SW S0, 16(SP)
9D00D7F8  00808021   ADDU S0, A0, ZERO
3313:                		/* This call is required specifically for the TriCore port.  It must be
3314:                		above the vPortFree() calls.  The call is also used by ports/demos that
3315:                		want to allocate and clean RAM statically. */
3316:                		portCLEAN_UP_TCB( pxTCB );
3317:                
3318:                		/* Free up the memory allocated by the scheduler for the task.  It is up
3319:                		to the task to free any memory allocated at the application level. */
3320:                		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3321:                		{
3322:                			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3323:                		}
3324:                		#endif /* configUSE_NEWLIB_REENTRANT */
3325:                
3326:                		#if( portUSING_MPU_WRAPPERS == 1 )
3327:                		{
3328:                			/* Only free the stack if it was allocated dynamically in the first
3329:                			place. */
3330:                			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
3331:                			{
3332:                				vPortFreeAligned( pxTCB->pxStack );
3333:                			}
3334:                		}
3335:                		#else
3336:                		{
3337:                			vPortFreeAligned( pxTCB->pxStack );
9D00D7FC  0F403760   JAL vPortFree
9D00D800  8C840030   LW A0, 48(A0)
3338:                		}
3339:                		#endif
3340:                
3341:                		vPortFree( pxTCB );
9D00D804  0F403760   JAL vPortFree
9D00D808  02002021   ADDU A0, S0, ZERO
3342:                	}
9D00D80C  8FBF0014   LW RA, 20(SP)
9D00D810  8FB00010   LW S0, 16(SP)
9D00D814  03E00008   JR RA
9D00D818  27BD0018   ADDIU SP, SP, 24
3343:                
3344:                #endif /* INCLUDE_vTaskDelete */
3345:                /*-----------------------------------------------------------*/
3346:                
3347:                static void prvResetNextTaskUnblockTime( void )
3348:                {
3349:                TCB_t *pxTCB;
3350:                
3351:                	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
9D00D59C  8F828108   LW V0, -32504(GP)
9D00D5A0  8C420000   LW V0, 0(V0)
9D00D5A4  14400004   BNE V0, ZERO, 0x9D00D5B8
9D00D5A8  2402FFFF   ADDIU V0, ZERO, -1
3352:                	{
3353:                		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3354:                		the maximum possible value so it is	extremely unlikely that the
3355:                		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3356:                		there is an item in the delayed list. */
3357:                		xNextTaskUnblockTime = portMAX_DELAY;
9D00D5AC  AF828060   SW V0, -32672(GP)
9D00D5B0  03E00008   JR RA
9D00D5B4  00000000   NOP
3358:                	}
3359:                	else
3360:                	{
3361:                		/* The new current delayed list is not empty, get the value of
3362:                		the item at the head of the delayed list.  This is the time at
3363:                		which the task at the head of the delayed list should be removed
3364:                		from the Blocked state. */
3365:                		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
9D00D5B8  8F828108   LW V0, -32504(GP)
9D00D5BC  8C42000C   LW V0, 12(V0)
3366:                		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
9D00D5C0  8C42000C   LW V0, 12(V0)
9D00D5C4  8C420004   LW V0, 4(V0)
9D00D5C8  AF828060   SW V0, -32672(GP)
9D00D5CC  03E00008   JR RA
9D00D5D0  00000000   NOP
3367:                	}
3368:                }
3369:                /*-----------------------------------------------------------*/
3370:                
3371:                #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3372:                
3373:                	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3374:                	{
3375:                	TaskHandle_t xReturn;
3376:                
3377:                		/* A critical section is not required as this is not called from
3378:                		an interrupt and the current TCB will always be the same for any
3379:                		individual execution thread. */
3380:                		xReturn = pxCurrentTCB;
00000000  00000000   NOP
3381:                
3382:                		return xReturn;
3383:                	}
00000004  00000000   NOP
3384:                
3385:                #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3386:                /*-----------------------------------------------------------*/
3387:                
3388:                #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3389:                
3390:                	BaseType_t xTaskGetSchedulerState( void )
3391:                	{
3392:                	BaseType_t xReturn;
3393:                
3394:                		if( xSchedulerRunning == pdFALSE )
3395:                		{
3396:                			xReturn = taskSCHEDULER_NOT_STARTED;
3397:                		}
3398:                		else
3399:                		{
3400:                			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3401:                			{
3402:                				xReturn = taskSCHEDULER_RUNNING;
3403:                			}
3404:                			else
3405:                			{
3406:                				xReturn = taskSCHEDULER_SUSPENDED;
3407:                			}
3408:                		}
3409:                
3410:                		return xReturn;
3411:                	}
3412:                
3413:                #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3414:                /*-----------------------------------------------------------*/
3415:                
3416:                #if ( configUSE_MUTEXES == 1 )
3417:                
3418:                	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3419:                	{
9D009028  27BDFFE0   ADDIU SP, SP, -32
9D00902C  AFBF001C   SW RA, 28(SP)
9D009030  AFB10018   SW S1, 24(SP)
9D009034  AFB00014   SW S0, 20(SP)
3420:                	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3421:                
3422:                		/* If the mutex was given back by an interrupt while the queue was
3423:                		locked then the mutex holder might now be NULL. */
3424:                		if( pxMutexHolder != NULL )
9D009038  10800041   BEQ A0, ZERO, 0x9D009140
9D00903C  00808021   ADDU S0, A0, ZERO
3425:                		{
3426:                			/* If the holder of the mutex has a priority below the priority of
3427:                			the task attempting to obtain the mutex then it will temporarily
3428:                			inherit the priority of the task attempting to obtain the mutex. */
3429:                			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
9D009040  8C82002C   LW V0, 44(A0)
9D009044  8F838088   LW V1, -32632(GP)
9D009048  8C63002C   LW V1, 44(V1)
9D00904C  0043182B   SLTU V1, V0, V1
9D009050  5060003C   BEQL V1, ZERO, 0x9D009144
9D009054  8FBF001C   LW RA, 28(SP)
3430:                			{
3431:                				/* Adjust the mutex holder state to account for its new
3432:                				priority.  Only reset the event list item value if the value is
3433:                				not	being used for anything else. */
3434:                				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
9D009058  8C830018   LW V1, 24(A0)
9D00905C  04600007   BLTZ V1, 0x9D00907C
9D009060  00021880   SLL V1, V0, 2
3435:                				{
3436:                					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D009064  8F838088   LW V1, -32632(GP)
9D009068  8C63002C   LW V1, 44(V1)
9D00906C  24040005   ADDIU A0, ZERO, 5
9D009070  00831823   SUBU V1, A0, V1
9D009074  AE030018   SW V1, 24(S0)
3437:                				}
3438:                				else
3439:                				{
3440:                					mtCOVERAGE_TEST_MARKER();
3441:                				}
3442:                
3443:                				/* If the task being modified is in the ready state it will need
3444:                				to be moved into a new list. */
3445:                				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
9D009078  00021880   SLL V1, V0, 2
9D00907C  00021100   SLL V0, V0, 4
9D009080  00621021   ADDU V0, V1, V0
9D009084  3C03A000   LUI V1, -24576
9D009088  24630BC0   ADDIU V1, V1, 3008
9D00908C  00621021   ADDU V0, V1, V0
9D009090  8E030014   LW V1, 20(S0)
9D009094  14620027   BNE V1, V0, 0x9D009134
9D009098  26110004   ADDIU S1, S0, 4
3446:                				{
3447:                					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
9D00909C  0F40348C   JAL uxListRemove
9D0090A0  02202021   ADDU A0, S1, ZERO
9D0090A4  14400011   BNE V0, ZERO, 0x9D0090EC
9D0090A8  00000000   NOP
3448:                					{
3449:                						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
9D0090AC  8E02002C   LW V0, 44(S0)
9D0090B0  00022080   SLL A0, V0, 2
9D0090B4  00021900   SLL V1, V0, 4
9D0090B8  00831821   ADDU V1, A0, V1
9D0090BC  3C04A000   LUI A0, -24576
9D0090C0  24840BC0   ADDIU A0, A0, 3008
9D0090C4  00641821   ADDU V1, V1, A0
9D0090C8  8C630000   LW V1, 0(V1)
9D0090CC  14600007   BNE V1, ZERO, 0x9D0090EC
9D0090D0  00000000   NOP
9D0090D4  8F838078   LW V1, -32648(GP)
9D0090D8  24040001   ADDIU A0, ZERO, 1
9D0090DC  00441004   SLLV V0, A0, V0
9D0090E0  00021027   NOR V0, ZERO, V0
9D0090E4  00431024   AND V0, V0, V1
9D0090E8  AF828078   SW V0, -32648(GP)
3450:                					}
3451:                					else
3452:                					{
3453:                						mtCOVERAGE_TEST_MARKER();
3454:                					}
3455:                
3456:                					/* Inherit the priority before being moved into the new list. */
3457:                					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
9D0090EC  8F828088   LW V0, -32632(GP)
9D0090F0  8C42002C   LW V0, 44(V0)
9D0090F4  AE02002C   SW V0, 44(S0)
3458:                					prvAddTaskToReadyList( pxTCB );
9D0090F8  8F848078   LW A0, -32648(GP)
9D0090FC  24030001   ADDIU V1, ZERO, 1
9D009100  00431804   SLLV V1, V1, V0
9D009104  00641825   OR V1, V1, A0
9D009108  AF838078   SW V1, -32648(GP)
9D00910C  00021880   SLL V1, V0, 2
9D009110  00021100   SLL V0, V0, 4
9D009114  00621021   ADDU V0, V1, V0
9D009118  3C04A000   LUI A0, -24576
9D00911C  24840BC0   ADDIU A0, A0, 3008
9D009120  00822021   ADDU A0, A0, V0
9D009124  0F4035EF   JAL vListInsertEnd
9D009128  02202821   ADDU A1, S1, ZERO
9D00912C  0B402451   J 0x9D009144
9D009130  8FBF001C   LW RA, 28(SP)
3459:                				}
3460:                				else
3461:                				{
3462:                					/* Just inherit the priority. */
3463:                					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
9D009134  8F828088   LW V0, -32632(GP)
9D009138  8C42002C   LW V0, 44(V0)
9D00913C  AE02002C   SW V0, 44(S0)
3464:                				}
3465:                
3466:                				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3467:                			}
3468:                			else
3469:                			{
3470:                				mtCOVERAGE_TEST_MARKER();
3471:                			}
3472:                		}
3473:                		else
3474:                		{
3475:                			mtCOVERAGE_TEST_MARKER();
3476:                		}
3477:                	}
9D009140  8FBF001C   LW RA, 28(SP)
9D009144  8FB10018   LW S1, 24(SP)
9D009148  8FB00014   LW S0, 20(SP)
9D00914C  03E00008   JR RA
9D009150  27BD0020   ADDIU SP, SP, 32
3478:                
3479:                #endif /* configUSE_MUTEXES */
3480:                /*-----------------------------------------------------------*/
3481:                
3482:                #if ( configUSE_MUTEXES == 1 )
3483:                
3484:                	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3485:                	{
9D009D34  27BDFFE0   ADDIU SP, SP, -32
9D009D38  AFBF001C   SW RA, 28(SP)
9D009D3C  AFB10018   SW S1, 24(SP)
9D009D40  AFB00014   SW S0, 20(SP)
3486:                	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3487:                	BaseType_t xReturn = pdFALSE;
3488:                
3489:                		if( pxMutexHolder != NULL )
9D009D44  10800033   BEQ A0, ZERO, 0x9D009E14
9D009D48  00808021   ADDU S0, A0, ZERO
3490:                		{
3491:                			/* A task can only have an inherited priority if it holds the mutex.
3492:                			If the mutex is held by a task then it cannot be given from an
3493:                			interrupt, and if a mutex is given by the holding task then it must
3494:                			be the running state task. */
3495:                			configASSERT( pxTCB == pxCurrentTCB );
3496:                
3497:                			configASSERT( pxTCB->uxMutexesHeld );
3498:                			( pxTCB->uxMutexesHeld )--;
9D009D4C  8C83004C   LW V1, 76(A0)
9D009D50  2463FFFF   ADDIU V1, V1, -1
9D009D54  AC83004C   SW V1, 76(A0)
3499:                
3500:                			/* Has the holder of the mutex inherited the priority of another
3501:                			task? */
3502:                			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
9D009D58  8C84002C   LW A0, 44(A0)
9D009D5C  8E020048   LW V0, 72(S0)
9D009D60  1082002D   BEQ A0, V0, 0x9D009E18
9D009D64  00001021   ADDU V0, ZERO, ZERO
3503:                			{
3504:                				/* Only disinherit if no other mutexes are held. */
3505:                				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
9D009D68  1460002C   BNE V1, ZERO, 0x9D009E1C
9D009D6C  8FBF001C   LW RA, 28(SP)
3506:                				{
3507:                					/* A task can only have an inherited priority if it holds
3508:                					the mutex.  If the mutex is held by a task then it cannot be
3509:                					given from an interrupt, and if a mutex is given by the
3510:                					holding	task then it must be the running state task.  Remove
3511:                					the	holding task from the ready	list. */
3512:                					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
9D009D70  26110004   ADDIU S1, S0, 4
9D009D74  0F40348C   JAL uxListRemove
9D009D78  02202021   ADDU A0, S1, ZERO
9D009D7C  54400012   BNEL V0, ZERO, 0x9D009DC8
9D009D80  8E020048   LW V0, 72(S0)
3513:                					{
3514:                						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
9D009D84  8E02002C   LW V0, 44(S0)
9D009D88  00022080   SLL A0, V0, 2
9D009D8C  00021900   SLL V1, V0, 4
9D009D90  00831821   ADDU V1, A0, V1
9D009D94  3C04A000   LUI A0, -24576
9D009D98  24840BC0   ADDIU A0, A0, 3008
9D009D9C  00641821   ADDU V1, V1, A0
9D009DA0  8C630000   LW V1, 0(V1)
9D009DA4  54600008   BNEL V1, ZERO, 0x9D009DC8
9D009DA8  8E020048   LW V0, 72(S0)
9D009DAC  8F838078   LW V1, -32648(GP)
9D009DB0  24040001   ADDIU A0, ZERO, 1
9D009DB4  00441004   SLLV V0, A0, V0
9D009DB8  00021027   NOR V0, ZERO, V0
9D009DBC  00431024   AND V0, V0, V1
9D009DC0  AF828078   SW V0, -32648(GP)
3515:                					}
3516:                					else
3517:                					{
3518:                						mtCOVERAGE_TEST_MARKER();
3519:                					}
3520:                
3521:                					/* Disinherit the priority before adding the task into the
3522:                					new	ready list. */
3523:                					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3524:                					pxTCB->uxPriority = pxTCB->uxBasePriority;
9D009DC4  8E020048   LW V0, 72(S0)
9D009DC8  AE02002C   SW V0, 44(S0)
3525:                
3526:                					/* Reset the event list item value.  It cannot be in use for
3527:                					any other purpose if this task is running, and it must be
3528:                					running to give back the mutex. */
3529:                					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D009DCC  24030005   ADDIU V1, ZERO, 5
9D009DD0  00621823   SUBU V1, V1, V0
9D009DD4  AE030018   SW V1, 24(S0)
3530:                					prvAddTaskToReadyList( pxTCB );
9D009DD8  8F848078   LW A0, -32648(GP)
9D009DDC  24030001   ADDIU V1, ZERO, 1
9D009DE0  00431804   SLLV V1, V1, V0
9D009DE4  00641825   OR V1, V1, A0
9D009DE8  AF838078   SW V1, -32648(GP)
9D009DEC  00021880   SLL V1, V0, 2
9D009DF0  00021100   SLL V0, V0, 4
9D009DF4  00621021   ADDU V0, V1, V0
9D009DF8  3C04A000   LUI A0, -24576
9D009DFC  24840BC0   ADDIU A0, A0, 3008
9D009E00  00822021   ADDU A0, A0, V0
9D009E04  0F4035EF   JAL vListInsertEnd
9D009E08  02202821   ADDU A1, S1, ZERO
9D009E0C  0B402786   J 0x9D009E18
9D009E10  24020001   ADDIU V0, ZERO, 1
9D009E14  00001021   ADDU V0, ZERO, ZERO
3531:                
3532:                					/* Return true to indicate that a context switch is required.
3533:                					This is only actually required in the corner case whereby
3534:                					multiple mutexes were held and the mutexes were given back
3535:                					in an order different to that in which they were taken.
3536:                					If a context switch did not occur when the first mutex was
3537:                					returned, even if a task was waiting on it, then a context
3538:                					switch should occur when the last mutex is returned whether
3539:                					a task is waiting on it or not. */
3540:                					xReturn = pdTRUE;
3541:                				}
3542:                				else
3543:                				{
3544:                					mtCOVERAGE_TEST_MARKER();
3545:                				}
3546:                			}
3547:                			else
3548:                			{
3549:                				mtCOVERAGE_TEST_MARKER();
3550:                			}
3551:                		}
3552:                		else
3553:                		{
3554:                			mtCOVERAGE_TEST_MARKER();
3555:                		}
3556:                
3557:                		return xReturn;
3558:                	}
9D009E18  8FBF001C   LW RA, 28(SP)
9D009E1C  8FB10018   LW S1, 24(SP)
9D009E20  8FB00014   LW S0, 20(SP)
9D009E24  03E00008   JR RA
9D009E28  27BD0020   ADDIU SP, SP, 32
3559:                
3560:                #endif /* configUSE_MUTEXES */
3561:                /*-----------------------------------------------------------*/
3562:                
3563:                #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3564:                
3565:                	void vTaskEnterCritical( void )
3566:                	{
9D00CE78  27BDFFF8   ADDIU SP, SP, -8
9D00CE7C  AFBF0004   SW RA, 4(SP)
3567:                		portDISABLE_INTERRUPTS();
9D00CE80  40036000   MFC0 V1, Status
9D00CE84  3C02FFFF   LUI V0, -1
9D00CE88  244203FF   ADDIU V0, V0, 1023
9D00CE8C  00621024   AND V0, V1, V0
9D00CE90  34420C00   ORI V0, V0, 3072
9D00CE94  40826000   MTC0 V0, Status
9D00CE98  000000C0   EHB
3568:                
3569:                		if( xSchedulerRunning != pdFALSE )
9D00CE9C  8F828074   LW V0, -32652(GP)
9D00CEA0  10400007   BEQ V0, ZERO, 0x9D00CEC0
9D00CEA4  8FBF0004   LW RA, 4(SP)
3570:                		{
3571:                			( pxCurrentTCB->uxCriticalNesting )++;
9D00CEA8  8F828088   LW V0, -32632(GP)
9D00CEAC  8C430044   LW V1, 68(V0)
9D00CEB0  24630001   ADDIU V1, V1, 1
9D00CEB4  AC430044   SW V1, 68(V0)
3572:                
3573:                			/* This is not the interrupt safe version of the enter critical
3574:                			function so	assert() if it is being called from an interrupt
3575:                			context.  Only API functions that end in "FromISR" can be used in an
3576:                			interrupt.  Only assert if the critical nesting count is 1 to
3577:                			protect against recursive calls if the assert function also uses a
3578:                			critical section. */
3579:                			if( pxCurrentTCB->uxCriticalNesting == 1 )
9D00CEB8  8F828088   LW V0, -32632(GP)
3580:                			{
3581:                				portASSERT_IF_IN_ISR();
3582:                			}
3583:                		}
3584:                		else
3585:                		{
3586:                			mtCOVERAGE_TEST_MARKER();
3587:                		}
3588:                	}
9D00CEBC  8FBF0004   LW RA, 4(SP)
9D00CEC0  03E00008   JR RA
9D00CEC4  27BD0008   ADDIU SP, SP, 8
3589:                
3590:                #endif /* portCRITICAL_NESTING_IN_TCB */
3591:                /*-----------------------------------------------------------*/
3592:                
3593:                #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3594:                
3595:                	void vTaskExitCritical( void )
3596:                	{
9D00C544  27BDFFF8   ADDIU SP, SP, -8
9D00C548  AFBF0004   SW RA, 4(SP)
3597:                		if( xSchedulerRunning != pdFALSE )
9D00C54C  8F828074   LW V0, -32652(GP)
9D00C550  50400014   BEQL V0, ZERO, 0x9D00C5A4
9D00C554  8FBF0004   LW RA, 4(SP)
3598:                		{
3599:                			if( pxCurrentTCB->uxCriticalNesting > 0U )
9D00C558  8F828088   LW V0, -32632(GP)
9D00C55C  8C420044   LW V0, 68(V0)
9D00C560  10400010   BEQ V0, ZERO, 0x9D00C5A4
9D00C564  8FBF0004   LW RA, 4(SP)
3600:                			{
3601:                				( pxCurrentTCB->uxCriticalNesting )--;
9D00C568  8F828088   LW V0, -32632(GP)
9D00C56C  8C430044   LW V1, 68(V0)
9D00C570  2463FFFF   ADDIU V1, V1, -1
9D00C574  AC430044   SW V1, 68(V0)
3602:                
3603:                				if( pxCurrentTCB->uxCriticalNesting == 0U )
9D00C578  8F828088   LW V0, -32632(GP)
9D00C57C  8C420044   LW V0, 68(V0)
9D00C580  14400008   BNE V0, ZERO, 0x9D00C5A4
9D00C584  8FBF0004   LW RA, 4(SP)
3604:                				{
3605:                					portENABLE_INTERRUPTS();
9D00C588  40036000   MFC0 V1, Status
9D00C58C  3C02FFFF   LUI V0, -1
9D00C590  244203FF   ADDIU V0, V0, 1023
9D00C594  00621024   AND V0, V1, V0
9D00C598  40826000   MTC0 V0, Status
9D00C59C  000000C0   EHB
3606:                				}
3607:                				else
3608:                				{
3609:                					mtCOVERAGE_TEST_MARKER();
3610:                				}
3611:                			}
3612:                			else
3613:                			{
3614:                				mtCOVERAGE_TEST_MARKER();
3615:                			}
3616:                		}
3617:                		else
3618:                		{
3619:                			mtCOVERAGE_TEST_MARKER();
3620:                		}
3621:                	}
9D00C5A0  8FBF0004   LW RA, 4(SP)
9D00C5A4  03E00008   JR RA
9D00C5A8  27BD0008   ADDIU SP, SP, 8
3622:                
3623:                #endif /* portCRITICAL_NESTING_IN_TCB */
3624:                /*-----------------------------------------------------------*/
3625:                
3626:                #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3627:                
3628:                	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3629:                	{
3630:                	size_t x;
3631:                
3632:                		/* Start by copying the entire string. */
3633:                		strcpy( pcBuffer, pcTaskName );
3634:                
3635:                		/* Pad the end of the string with spaces to ensure columns line up when
3636:                		printed out. */
3637:                		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3638:                		{
3639:                			pcBuffer[ x ] = ' ';
3640:                		}
3641:                
3642:                		/* Terminate. */
3643:                		pcBuffer[ x ] = 0x00;
3644:                
3645:                		/* Return the new end of string. */
3646:                		return &( pcBuffer[ x ] );
3647:                	}
3648:                
3649:                #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3650:                /*-----------------------------------------------------------*/
3651:                
3652:                #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3653:                
3654:                	void vTaskList( char * pcWriteBuffer )
3655:                	{
3656:                	TaskStatus_t *pxTaskStatusArray;
3657:                	volatile UBaseType_t uxArraySize, x;
3658:                	char cStatus;
3659:                
3660:                		/*
3661:                		 * PLEASE NOTE:
3662:                		 *
3663:                		 * This function is provided for convenience only, and is used by many
3664:                		 * of the demo applications.  Do not consider it to be part of the
3665:                		 * scheduler.
3666:                		 *
3667:                		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3668:                		 * uxTaskGetSystemState() output into a human readable table that
3669:                		 * displays task names, states and stack usage.
3670:                		 *
3671:                		 * vTaskList() has a dependency on the sprintf() C library function that
3672:                		 * might bloat the code size, use a lot of stack, and provide different
3673:                		 * results on different platforms.  An alternative, tiny, third party,
3674:                		 * and limited functionality implementation of sprintf() is provided in
3675:                		 * many of the FreeRTOS/Demo sub-directories in a file called
3676:                		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3677:                		 * snprintf() implementation!).
3678:                		 *
3679:                		 * It is recommended that production systems call uxTaskGetSystemState()
3680:                		 * directly to get access to raw stats data, rather than indirectly
3681:                		 * through a call to vTaskList().
3682:                		 */
3683:                
3684:                
3685:                		/* Make sure the write buffer does not contain a string. */
3686:                		*pcWriteBuffer = 0x00;
3687:                
3688:                		/* Take a snapshot of the number of tasks in case it changes while this
3689:                		function is executing. */
3690:                		uxArraySize = uxCurrentNumberOfTasks;
3691:                
3692:                		/* Allocate an array index for each task. */
3693:                		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3694:                
3695:                		if( pxTaskStatusArray != NULL )
3696:                		{
3697:                			/* Generate the (binary) data. */
3698:                			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3699:                
3700:                			/* Create a human readable table from the binary data. */
3701:                			for( x = 0; x < uxArraySize; x++ )
3702:                			{
3703:                				switch( pxTaskStatusArray[ x ].eCurrentState )
3704:                				{
3705:                					case eReady:		cStatus = tskREADY_CHAR;
3706:                										break;
3707:                
3708:                					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3709:                										break;
3710:                
3711:                					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3712:                										break;
3713:                
3714:                					case eDeleted:		cStatus = tskDELETED_CHAR;
3715:                										break;
3716:                
3717:                					default:			/* Should not get here, but it is included
3718:                										to prevent static checking errors. */
3719:                										cStatus = 0x00;
3720:                										break;
3721:                				}
3722:                
3723:                				/* Write the task name to the string, padding with spaces so it
3724:                				can be printed in tabular form more easily. */
3725:                				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3726:                
3727:                				/* Write the rest of the string. */
3728:                				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
3729:                				pcWriteBuffer += strlen( pcWriteBuffer );
3730:                			}
3731:                
3732:                			/* Free the array again. */
3733:                			vPortFree( pxTaskStatusArray );
3734:                		}
3735:                		else
3736:                		{
3737:                			mtCOVERAGE_TEST_MARKER();
3738:                		}
3739:                	}
3740:                
3741:                #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
3742:                /*----------------------------------------------------------*/
3743:                
3744:                #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3745:                
3746:                	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3747:                	{
3748:                	TaskStatus_t *pxTaskStatusArray;
3749:                	volatile UBaseType_t uxArraySize, x;
3750:                	uint32_t ulTotalTime, ulStatsAsPercentage;
3751:                
3752:                		#if( configUSE_TRACE_FACILITY != 1 )
3753:                		{
3754:                			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
3755:                		}
3756:                		#endif
3757:                
3758:                		/*
3759:                		 * PLEASE NOTE:
3760:                		 *
3761:                		 * This function is provided for convenience only, and is used by many
3762:                		 * of the demo applications.  Do not consider it to be part of the
3763:                		 * scheduler.
3764:                		 *
3765:                		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3766:                		 * of the uxTaskGetSystemState() output into a human readable table that
3767:                		 * displays the amount of time each task has spent in the Running state
3768:                		 * in both absolute and percentage terms.
3769:                		 *
3770:                		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3771:                		 * function that might bloat the code size, use a lot of stack, and
3772:                		 * provide different results on different platforms.  An alternative,
3773:                		 * tiny, third party, and limited functionality implementation of
3774:                		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3775:                		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3776:                		 * a full snprintf() implementation!).
3777:                		 *
3778:                		 * It is recommended that production systems call uxTaskGetSystemState()
3779:                		 * directly to get access to raw stats data, rather than indirectly
3780:                		 * through a call to vTaskGetRunTimeStats().
3781:                		 */
3782:                
3783:                		/* Make sure the write buffer does not contain a string. */
3784:                		*pcWriteBuffer = 0x00;
3785:                
3786:                		/* Take a snapshot of the number of tasks in case it changes while this
3787:                		function is executing. */
3788:                		uxArraySize = uxCurrentNumberOfTasks;
3789:                
3790:                		/* Allocate an array index for each task. */
3791:                		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3792:                
3793:                		if( pxTaskStatusArray != NULL )
3794:                		{
3795:                			/* Generate the (binary) data. */
3796:                			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3797:                
3798:                			/* For percentage calculations. */
3799:                			ulTotalTime /= 100UL;
3800:                
3801:                			/* Avoid divide by zero errors. */
3802:                			if( ulTotalTime > 0 )
3803:                			{
3804:                				/* Create a human readable table from the binary data. */
3805:                				for( x = 0; x < uxArraySize; x++ )
3806:                				{
3807:                					/* What percentage of the total run time has the task used?
3808:                					This will always be rounded down to the nearest integer.
3809:                					ulTotalRunTimeDiv100 has already been divided by 100. */
3810:                					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3811:                
3812:                					/* Write the task name to the string, padding with
3813:                					spaces so it can be printed in tabular form more
3814:                					easily. */
3815:                					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3816:                
3817:                					if( ulStatsAsPercentage > 0UL )
3818:                					{
3819:                						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3820:                						{
3821:                							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
3822:                						}
3823:                						#else
3824:                						{
3825:                							/* sizeof( int ) == sizeof( long ) so a smaller
3826:                							printf() library can be used. */
3827:                							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
3828:                						}
3829:                						#endif
3830:                					}
3831:                					else
3832:                					{
3833:                						/* If the percentage is zero here then the task has
3834:                						consumed less than 1% of the total run time. */
3835:                						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3836:                						{
3837:                							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
3838:                						}
3839:                						#else
3840:                						{
3841:                							/* sizeof( int ) == sizeof( long ) so a smaller
3842:                							printf() library can be used. */
3843:                							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
3844:                						}
3845:                						#endif
3846:                					}
3847:                
3848:                					pcWriteBuffer += strlen( pcWriteBuffer );
3849:                				}
3850:                			}
3851:                			else
3852:                			{
3853:                				mtCOVERAGE_TEST_MARKER();
3854:                			}
3855:                
3856:                			/* Free the array again. */
3857:                			vPortFree( pxTaskStatusArray );
3858:                		}
3859:                		else
3860:                		{
3861:                			mtCOVERAGE_TEST_MARKER();
3862:                		}
3863:                	}
3864:                
3865:                #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
3866:                /*-----------------------------------------------------------*/
3867:                
3868:                TickType_t uxTaskResetEventItemValue( void )
3869:                {
3870:                TickType_t uxReturn;
3871:                
3872:                	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
00000000  00000000   NOP
3873:                
3874:                	/* Reset the event list item to its normal value - so it can be used with
3875:                	queues and semaphores. */
3876:                	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00000008  00000000   NOP
3877:                
3878:                	return uxReturn;
3879:                }
0000001C  00000000   NOP
3880:                /*-----------------------------------------------------------*/
3881:                
3882:                #if ( configUSE_MUTEXES == 1 )
3883:                
3884:                	void *pvTaskIncrementMutexHeldCount( void )
3885:                	{
3886:                		/* If xSemaphoreCreateMutex() is called before any tasks have been created
3887:                		then pxCurrentTCB will be NULL. */
3888:                		if( pxCurrentTCB != NULL )
9D00D998  8F828088   LW V0, -32632(GP)
9D00D99C  10400005   BEQ V0, ZERO, 0x9D00D9B4
9D00D9A0  00000000   NOP
3889:                		{
3890:                			( pxCurrentTCB->uxMutexesHeld )++;
9D00D9A4  8F828088   LW V0, -32632(GP)
9D00D9A8  8C43004C   LW V1, 76(V0)
9D00D9AC  24630001   ADDIU V1, V1, 1
9D00D9B0  AC43004C   SW V1, 76(V0)
3891:                		}
3892:                
3893:                		return pxCurrentTCB;
9D00D9B4  8F828088   LW V0, -32632(GP)
3894:                	}
9D00D9B8  03E00008   JR RA
9D00D9BC  00000000   NOP
3895:                
3896:                #endif /* configUSE_MUTEXES */
3897:                /*-----------------------------------------------------------*/
3898:                
3899:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
3900:                
3901:                	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
3902:                	{
00000000  00000000   NOP
3903:                	TickType_t xTimeToWake;
3904:                	uint32_t ulReturn;
3905:                
3906:                		taskENTER_CRITICAL();
00000014  00000000   NOP
3907:                		{
3908:                			/* Only block if the notification count is not already non-zero. */
3909:                			if( pxCurrentTCB->ulNotifiedValue == 0UL )
0000001C  00000000   NOP
3910:                			{
3911:                				/* Mark this task as waiting for a notification. */
3912:                				pxCurrentTCB->eNotifyState = eWaitingNotification;
0000002C  00000000   NOP
3913:                
3914:                				if( xTicksToWait > ( TickType_t ) 0 )
00000038  00000000   NOP
3915:                				{
3916:                					/* The task is going to block.  First it must be removed
3917:                					from the ready list. */
3918:                					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00000040  00000000   NOP
3919:                					{
3920:                						/* The current task must be in a ready list, so there is
3921:                						no need to check, and the port reset macro can be called
3922:                						directly. */
3923:                						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
00000054  00000000   NOP
3924:                					}
3925:                					else
3926:                					{
3927:                						mtCOVERAGE_TEST_MARKER();
3928:                					}
3929:                
3930:                					#if ( INCLUDE_vTaskSuspend == 1 )
3931:                					{
3932:                						if( xTicksToWait == portMAX_DELAY )
00000074  00000000   NOP
3933:                						{
3934:                							/* Add the task to the suspended task list instead
3935:                							of a delayed task list to ensure the task is not
3936:                							woken by a timing event.  It will block
3937:                							indefinitely. */
3938:                							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
00000080  00000000   NOP
3939:                						}
3940:                						else
3941:                						{
3942:                							/* Calculate the time at which the task should be
3943:                							woken if no notification events occur.  This may
3944:                							overflow but this doesn't matter, the scheduler will
3945:                							handle it. */
3946:                							xTimeToWake = xTickCount + xTicksToWait;
0000009C  00000000   NOP
3947:                							prvAddCurrentTaskToDelayedList( xTimeToWake );
000000A0  00000000   NOP
3948:                						}
3949:                					}
3950:                					#else /* INCLUDE_vTaskSuspend */
3951:                					{
3952:                							/* Calculate the time at which the task should be
3953:                							woken if the event does not occur.  This may
3954:                							overflow but this doesn't matter, the scheduler will
3955:                							handle it. */
3956:                							xTimeToWake = xTickCount + xTicksToWait;
3957:                							prvAddCurrentTaskToDelayedList( xTimeToWake );
3958:                					}
3959:                					#endif /* INCLUDE_vTaskSuspend */
3960:                
3961:                					traceTASK_NOTIFY_TAKE_BLOCK();
3962:                
3963:                					/* All ports are written to allow a yield in a critical
3964:                					section (some will yield immediately, others wait until the
3965:                					critical section exits) - but it is not something that
3966:                					application code should ever do. */
3967:                					portYIELD_WITHIN_API();
000000A8  00000000   NOP
3968:                				}
3969:                				else
3970:                				{
3971:                					mtCOVERAGE_TEST_MARKER();
3972:                				}
3973:                			}
3974:                			else
3975:                			{
3976:                				mtCOVERAGE_TEST_MARKER();
3977:                			}
3978:                		}
3979:                		taskEXIT_CRITICAL();
000000B8  00000000   NOP
3980:                
3981:                		taskENTER_CRITICAL();
000000C0  00000000   NOP
3982:                		{
3983:                			traceTASK_NOTIFY_TAKE();
3984:                			ulReturn = pxCurrentTCB->ulNotifiedValue;
000000C8  00000000   NOP
3985:                
3986:                			if( ulReturn != 0UL )
000000D0  00000000   NOP
3987:                			{
3988:                				if( xClearCountOnExit != pdFALSE )
000000D8  00000000   NOP
3989:                				{
3990:                					pxCurrentTCB->ulNotifiedValue = 0UL;
000000E0  00000000   NOP
3991:                				}
3992:                				else
3993:                				{
3994:                					( pxCurrentTCB->ulNotifiedValue )--;
000000F0  00000000   NOP
3995:                				}
3996:                			}
3997:                			else
3998:                			{
3999:                				mtCOVERAGE_TEST_MARKER();
4000:                			}
4001:                
4002:                			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
00000100  00000000   NOP
4003:                		}
4004:                		taskEXIT_CRITICAL();
00000108  00000000   NOP
4005:                
4006:                		return ulReturn;
4007:                	}
00000110  00000000   NOP
4008:                
4009:                #endif /* configUSE_TASK_NOTIFICATIONS */
4010:                /*-----------------------------------------------------------*/
4011:                
4012:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4013:                
4014:                	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
4015:                	{
00000000  00000000   NOP
4016:                	TickType_t xTimeToWake;
4017:                	BaseType_t xReturn;
4018:                
4019:                		taskENTER_CRITICAL();
00000024  00000000   NOP
4020:                		{
4021:                			/* Only block if a notification is not already pending. */
4022:                			if( pxCurrentTCB->eNotifyState != eNotified )
0000002C  00000000   NOP
4023:                			{
4024:                				/* Clear bits in the task's notification value as bits may get
4025:                				set	by the notifying task or interrupt.  This can be used to
4026:                				clear the value to zero. */
4027:                				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00000040  00000000   NOP
4028:                
4029:                				/* Mark this task as waiting for a notification. */
4030:                				pxCurrentTCB->eNotifyState = eWaitingNotification;
00000054  00000000   NOP
4031:                
4032:                				if( xTicksToWait > ( TickType_t ) 0 )
00000060  00000000   NOP
4033:                				{
4034:                					/* The task is going to block.  First it must be removed
4035:                					from the	ready list. */
4036:                					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00000068  00000000   NOP
4037:                					{
4038:                						/* The current task must be in a ready list, so there is
4039:                						no need to check, and the port reset macro can be called
4040:                						directly. */
4041:                						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
0000007C  00000000   NOP
4042:                					}
4043:                					else
4044:                					{
4045:                						mtCOVERAGE_TEST_MARKER();
4046:                					}
4047:                
4048:                					#if ( INCLUDE_vTaskSuspend == 1 )
4049:                					{
4050:                						if( xTicksToWait == portMAX_DELAY )
0000009C  00000000   NOP
4051:                						{
4052:                							/* Add the task to the suspended task list instead
4053:                							of a delayed task list to ensure the task is not
4054:                							woken by a timing event.  It will block
4055:                							indefinitely. */
4056:                							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000000A8  00000000   NOP
4057:                						}
4058:                						else
4059:                						{
4060:                							/* Calculate the time at which the task should be
4061:                							woken if no notification events occur.  This may
4062:                							overflow but this doesn't matter, the scheduler will
4063:                							handle it. */
4064:                							xTimeToWake = xTickCount + xTicksToWait;
000000C4  00000000   NOP
4065:                							prvAddCurrentTaskToDelayedList( xTimeToWake );
000000C8  00000000   NOP
4066:                						}
4067:                					}
4068:                					#else /* INCLUDE_vTaskSuspend */
4069:                					{
4070:                							/* Calculate the time at which the task should be
4071:                							woken if the event does not occur.  This may
4072:                							overflow but this doesn't matter, the scheduler will
4073:                							handle it. */
4074:                							xTimeToWake = xTickCount + xTicksToWait;
4075:                							prvAddCurrentTaskToDelayedList( xTimeToWake );
4076:                					}
4077:                					#endif /* INCLUDE_vTaskSuspend */
4078:                
4079:                					traceTASK_NOTIFY_WAIT_BLOCK();
4080:                
4081:                					/* All ports are written to allow a yield in a critical
4082:                					section (some will yield immediately, others wait until the
4083:                					critical section exits) - but it is not something that
4084:                					application code should ever do. */
4085:                					portYIELD_WITHIN_API();
000000D0  00000000   NOP
4086:                				}
4087:                				else
4088:                				{
4089:                					mtCOVERAGE_TEST_MARKER();
4090:                				}
4091:                			}
4092:                			else
4093:                			{
4094:                				mtCOVERAGE_TEST_MARKER();
4095:                			}
4096:                		}
4097:                		taskEXIT_CRITICAL();
000000E0  00000000   NOP
4098:                
4099:                		taskENTER_CRITICAL();
000000E8  00000000   NOP
4100:                		{
4101:                			traceTASK_NOTIFY_WAIT();
4102:                
4103:                			if( pulNotificationValue != NULL )
000000F0  00000000   NOP
4104:                			{
4105:                				/* Output the current notification value, which may or may not
4106:                				have changed. */
4107:                				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000000F8  00000000   NOP
4108:                			}
4109:                
4110:                			/* If eNotifyValue is set then either the task never entered the
4111:                			blocked state (because a notification was already pending) or the
4112:                			task unblocked because of a notification.  Otherwise the task
4113:                			unblocked because of a timeout. */
4114:                			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
00000104  00000000   NOP
4115:                			{
4116:                				/* A notification was not received. */
4117:                				xReturn = pdFALSE;
4118:                			}
4119:                			else
4120:                			{
4121:                				/* A notification was already pending or a notification was
4122:                				received while the task was waiting. */
4123:                				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
00000118  00000000   NOP
4124:                				xReturn = pdTRUE;
4125:                			}
4126:                
4127:                			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
00000130  00000000   NOP
4128:                		}
4129:                		taskEXIT_CRITICAL();
00000138  00000000   NOP
4130:                
4131:                		return xReturn;
4132:                	}
00000140  00000000   NOP
4133:                
4134:                #endif /* configUSE_TASK_NOTIFICATIONS */
4135:                /*-----------------------------------------------------------*/
4136:                
4137:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4138:                
4139:                	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
4140:                	{
00000000  00000000   NOP
4141:                	TCB_t * pxTCB;
4142:                	eNotifyValue eOriginalNotifyState;
4143:                	BaseType_t xReturn = pdPASS;
4144:                
4145:                		configASSERT( xTaskToNotify );
4146:                		pxTCB = ( TCB_t * ) xTaskToNotify;
4147:                
4148:                		taskENTER_CRITICAL();
00000024  00000000   NOP
4149:                		{
4150:                			if( pulPreviousNotificationValue != NULL )
0000002C  00000000   NOP
4151:                			{
4152:                				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
00000034  00000000   NOP
4153:                			}
4154:                
4155:                			eOriginalNotifyState = pxTCB->eNotifyState;
0000003C  00000000   NOP
4156:                
4157:                			pxTCB->eNotifyState = eNotified;
00000040  00000000   NOP
4158:                
4159:                			switch( eAction )
00000048  00000000   NOP
4160:                			{
4161:                				case eSetBits	:
4162:                					pxTCB->ulNotifiedValue |= ulValue;
00000084  00000000   NOP
4163:                					break;
00000090  00000000   NOP
4164:                
4165:                				case eIncrement	:
4166:                					( pxTCB->ulNotifiedValue )++;
00000098  00000000   NOP
4167:                					break;
000000A4  00000000   NOP
4168:                
4169:                				case eSetValueWithOverwrite	:
4170:                					pxTCB->ulNotifiedValue = ulValue;
000000AC  00000000   NOP
4171:                					break;
000000B0  00000000   NOP
4172:                
4173:                				case eSetValueWithoutOverwrite :
4174:                					if( eOriginalNotifyState != eNotified )
000000B8  00000000   NOP
4175:                					{
4176:                						pxTCB->ulNotifiedValue = ulValue;
000000C0  00000000   NOP
4177:                					}
4178:                					else
4179:                					{
4180:                						/* The value could not be written to the task. */
4181:                						xReturn = pdFAIL;
4182:                					}
4183:                					break;
4184:                
4185:                				case eNoAction:
4186:                					/* The task is being notified without its notify value being
4187:                					updated. */
4188:                					break;
4189:                			}
4190:                
4191:                			traceTASK_NOTIFY();
4192:                
4193:                			/* If the task is in the blocked state specifically to wait for a
4194:                			notification then unblock it now. */
4195:                			if( eOriginalNotifyState == eWaitingNotification )
000000C8  00000000   NOP
4196:                			{
4197:                				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000000D4  00000000   NOP
4198:                				prvAddTaskToReadyList( pxTCB );
000000E0  00000000   NOP
4199:                
4200:                				/* The task should not have been on an event list. */
4201:                				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4202:                
4203:                				#if( configUSE_TICKLESS_IDLE != 0 )
4204:                				{
4205:                					/* If a task is blocked waiting for a notification then
4206:                					xNextTaskUnblockTime might be set to the blocked task's time
4207:                					out time.  If the task is unblocked for a reason other than
4208:                					a timeout xNextTaskUnblockTime is normally left unchanged,
4209:                					because it will automatically get reset to a new value when
4210:                					the tick count equals xNextTaskUnblockTime.  However if
4211:                					tickless idling is used it might be more important to enter
4212:                					sleep mode at the earliest possible time - so reset
4213:                					xNextTaskUnblockTime here to ensure it is updated at the
4214:                					earliest possible time. */
4215:                					prvResetNextTaskUnblockTime();
4216:                				}
4217:                				#endif
4218:                
4219:                				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00000118  00000000   NOP
4220:                				{
4221:                					/* The notified task has a priority above the currently
4222:                					executing task so a yield is required. */
4223:                					taskYIELD_IF_USING_PREEMPTION();
00000130  00000000   NOP
4224:                				}
4225:                				else
4226:                				{
4227:                					mtCOVERAGE_TEST_MARKER();
4228:                				}
4229:                			}
4230:                			else
4231:                			{
4232:                				mtCOVERAGE_TEST_MARKER();
4233:                			}
4234:                		}
4235:                		taskEXIT_CRITICAL();
00000140  00000000   NOP
4236:                
4237:                		return xReturn;
4238:                	}
00000148  00000000   NOP
4239:                
4240:                #endif /* configUSE_TASK_NOTIFICATIONS */
4241:                /*-----------------------------------------------------------*/
4242:                
4243:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4244:                
4245:                	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
4246:                	{
00000000  00000000   NOP
4247:                	TCB_t * pxTCB;
4248:                	eNotifyValue eOriginalNotifyState;
4249:                	BaseType_t xReturn = pdPASS;
4250:                	UBaseType_t uxSavedInterruptStatus;
4251:                
4252:                		configASSERT( xTaskToNotify );
4253:                
4254:                		/* RTOS ports that support interrupt nesting have the concept of a
4255:                		maximum	system call (or maximum API call) interrupt priority.
4256:                		Interrupts that are	above the maximum system call priority are keep
4257:                		permanently enabled, even when the RTOS kernel is in a critical section,
4258:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4259:                		is defined in FreeRTOSConfig.h then
4260:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4261:                		failure if a FreeRTOS API function is called from an interrupt that has
4262:                		been assigned a priority above the configured maximum system call
4263:                		priority.  Only FreeRTOS functions that end in FromISR can be called
4264:                		from interrupts	that have been assigned a priority at or (logically)
4265:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
4266:                		separate interrupt safe API to ensure interrupt entry is as fast and as
4267:                		simple as possible.  More information (albeit Cortex-M specific) is
4268:                		provided on the following link:
4269:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4270:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4271:                
4272:                		pxTCB = ( TCB_t * ) xTaskToNotify;
4273:                
4274:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000028  00000000   NOP
4275:                		{
4276:                			if( pulPreviousNotificationValue != NULL )
00000030  00000000   NOP
4277:                			{
4278:                				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
00000038  00000000   NOP
4279:                			}
4280:                
4281:                			eOriginalNotifyState = pxTCB->eNotifyState;
00000040  00000000   NOP
4282:                			pxTCB->eNotifyState = eNotified;
00000044  00000000   NOP
4283:                
4284:                			switch( eAction )
0000004C  00000000   NOP
4285:                			{
4286:                				case eSetBits	:
4287:                					pxTCB->ulNotifiedValue |= ulValue;
00000088  00000000   NOP
4288:                					break;
00000094  00000000   NOP
4289:                
4290:                				case eIncrement	:
4291:                					( pxTCB->ulNotifiedValue )++;
0000009C  00000000   NOP
4292:                					break;
000000A8  00000000   NOP
4293:                
4294:                				case eSetValueWithOverwrite	:
4295:                					pxTCB->ulNotifiedValue = ulValue;
000000B0  00000000   NOP
4296:                					break;
000000B4  00000000   NOP
4297:                
4298:                				case eSetValueWithoutOverwrite :
4299:                					if( eOriginalNotifyState != eNotified )
000000BC  00000000   NOP
4300:                					{
4301:                						pxTCB->ulNotifiedValue = ulValue;
000000C4  00000000   NOP
4302:                					}
4303:                					else
4304:                					{
4305:                						/* The value could not be written to the task. */
4306:                						xReturn = pdFAIL;
4307:                					}
4308:                					break;
4309:                
4310:                				case eNoAction :
4311:                					/* The task is being notified without its notify value being
4312:                					updated. */
4313:                					break;
4314:                			}
4315:                
4316:                			traceTASK_NOTIFY_FROM_ISR();
4317:                
4318:                			/* If the task is in the blocked state specifically to wait for a
4319:                			notification then unblock it now. */
4320:                			if( eOriginalNotifyState == eWaitingNotification )
000000CC  00000000   NOP
4321:                			{
4322:                				/* The task should not have been on an event list. */
4323:                				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4324:                
4325:                				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000000D8  00000000   NOP
4326:                				{
4327:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000000E4  00000000   NOP
4328:                					prvAddTaskToReadyList( pxTCB );
000000F0  00000000   NOP
4329:                				}
4330:                				else
4331:                				{
4332:                					/* The delayed and ready lists cannot be accessed, so hold
4333:                					this task pending until the scheduler is resumed. */
4334:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00000130  00000000   NOP
4335:                				}
4336:                
4337:                				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000013C  00000000   NOP
4338:                				{
4339:                					/* The notified task has a priority above the currently
4340:                					executing task so a yield is required. */
4341:                					if( pxHigherPriorityTaskWoken != NULL )
00000154  00000000   NOP
4342:                					{
4343:                						*pxHigherPriorityTaskWoken = pdTRUE;
00000160  00000000   NOP
4344:                					}
4345:                				}
4346:                				else
4347:                				{
4348:                					mtCOVERAGE_TEST_MARKER();
4349:                				}
4350:                			}
4351:                		}
4352:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000016C  00000000   NOP
4353:                
4354:                		return xReturn;
4355:                	}
00000174  00000000   NOP
4356:                
4357:                #endif /* configUSE_TASK_NOTIFICATIONS */
4358:                /*-----------------------------------------------------------*/
4359:                
4360:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4361:                
4362:                	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4363:                	{
00000000  00000000   NOP
4364:                	TCB_t * pxTCB;
4365:                	eNotifyValue eOriginalNotifyState;
4366:                	UBaseType_t uxSavedInterruptStatus;
4367:                
4368:                		configASSERT( xTaskToNotify );
4369:                
4370:                		/* RTOS ports that support interrupt nesting have the concept of a
4371:                		maximum	system call (or maximum API call) interrupt priority.
4372:                		Interrupts that are	above the maximum system call priority are keep
4373:                		permanently enabled, even when the RTOS kernel is in a critical section,
4374:                		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4375:                		is defined in FreeRTOSConfig.h then
4376:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4377:                		failure if a FreeRTOS API function is called from an interrupt that has
4378:                		been assigned a priority above the configured maximum system call
4379:                		priority.  Only FreeRTOS functions that end in FromISR can be called
4380:                		from interrupts	that have been assigned a priority at or (logically)
4381:                		below the maximum system call interrupt priority.  FreeRTOS maintains a
4382:                		separate interrupt safe API to ensure interrupt entry is as fast and as
4383:                		simple as possible.  More information (albeit Cortex-M specific) is
4384:                		provided on the following link:
4385:                		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4386:                		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4387:                
4388:                		pxTCB = ( TCB_t * ) xTaskToNotify;
4389:                
4390:                		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0000001C  00000000   NOP
4391:                		{
4392:                			eOriginalNotifyState = pxTCB->eNotifyState;
00000028  00000000   NOP
4393:                			pxTCB->eNotifyState = eNotified;
0000002C  00000000   NOP
4394:                
4395:                			/* 'Giving' is equivalent to incrementing a count in a counting
4396:                			semaphore. */
4397:                			( pxTCB->ulNotifiedValue )++;
00000034  00000000   NOP
4398:                
4399:                			traceTASK_NOTIFY_GIVE_FROM_ISR();
4400:                
4401:                			/* If the task is in the blocked state specifically to wait for a
4402:                			notification then unblock it now. */
4403:                			if( eOriginalNotifyState == eWaitingNotification )
00000040  00000000   NOP
4404:                			{
4405:                				/* The task should not have been on an event list. */
4406:                				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4407:                
4408:                				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0000004C  00000000   NOP
4409:                				{
4410:                					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
00000058  00000000   NOP
4411:                					prvAddTaskToReadyList( pxTCB );
00000064  00000000   NOP
4412:                				}
4413:                				else
4414:                				{
4415:                					/* The delayed and ready lists cannot be accessed, so hold
4416:                					this task pending until the scheduler is resumed. */
4417:                					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000000A4  00000000   NOP
4418:                				}
4419:                
4420:                				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000000B0  00000000   NOP
4421:                				{
4422:                					/* The notified task has a priority above the currently
4423:                					executing task so a yield is required. */
4424:                					if( pxHigherPriorityTaskWoken != NULL )
000000C8  00000000   NOP
4425:                					{
4426:                						*pxHigherPriorityTaskWoken = pdTRUE;
000000D0  00000000   NOP
4427:                					}
4428:                				}
4429:                				else
4430:                				{
4431:                					mtCOVERAGE_TEST_MARKER();
4432:                				}
4433:                			}
4434:                		}
4435:                		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000000D4  00000000   NOP
4436:                	}
000000DC  00000000   NOP
4437:                
4438:                #endif /* configUSE_TASK_NOTIFICATIONS */
4439:                
4440:                /*-----------------------------------------------------------*/
4441:                
4442:                #if( configUSE_TASK_NOTIFICATIONS == 1 )
4443:                
4444:                	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4445:                	{
00000000  00000000   NOP
4446:                	TCB_t *pxTCB;
4447:                	BaseType_t xReturn;
4448:                
4449:                		pxTCB = ( TCB_t * ) xTask;
4450:                
4451:                		/* If null is passed in here then it is the calling task that is having
4452:                		its notification state cleared. */
4453:                		pxTCB = prvGetTCBFromHandle( pxTCB );
00000010  00000000   NOP
4454:                
4455:                		taskENTER_CRITICAL();
0000001C  00000000   NOP
4456:                		{
4457:                			if( pxTCB->eNotifyState == eNotified )
00000024  00000000   NOP
4458:                			{
4459:                				pxTCB->eNotifyState = eNotWaitingNotification;
00000034  00000000   NOP
4460:                				xReturn = pdPASS;
00000038  00000000   NOP
4461:                			}
4462:                			else
4463:                			{
4464:                				xReturn = pdFAIL;
4465:                			}
4466:                		}
4467:                		taskEXIT_CRITICAL();
0000003C  00000000   NOP
4468:                
4469:                		return xReturn;
4470:                	}
00000044  00000000   NOP
4471:                
4472:                #endif /* configUSE_TASK_NOTIFICATIONS */
4473:                
4474:                #ifdef FREERTOS_MODULE_TEST
4475:                	#include "tasks_test_access_functions.h"
4476:                #endif
4477:                
---  c:/microchip/harmony/v1_08_01/third_party/rtos/freertos/source/queue.c  ----------------------------
1:                   /*
2:                       FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  #include <stdlib.h>
71:                  #include <string.h>
72:                  
73:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                  all the API functions to use the MPU wrappers.  That should only be done when
75:                  task.h is included from an application file. */
76:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                  
78:                  #include "FreeRTOS.h"
79:                  #include "task.h"
80:                  #include "queue.h"
81:                  
82:                  #if ( configUSE_CO_ROUTINES == 1 )
83:                  	#include "croutine.h"
84:                  #endif
85:                  
86:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
87:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
88:                  header files above, but not in this file, in order to generate the correct
89:                  privileged Vs unprivileged linkage and placement. */
90:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
91:                  
92:                  
93:                  /* Constants used with the xRxLock and xTxLock structure members. */
94:                  #define queueUNLOCKED					( ( BaseType_t ) -1 )
95:                  #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
96:                  
97:                  /* When the Queue_t structure is used to represent a base queue its pcHead and
98:                  pcTail members are used as pointers into the queue storage area.  When the
99:                  Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
100:                 not necessary, and the pcHead pointer is set to NULL to indicate that the
101:                 pcTail pointer actually points to the mutex holder (if any).  Map alternative
102:                 names to the pcHead and pcTail structure members to ensure the readability of
103:                 the code is maintained despite this dual use of two structure members.  An
104:                 alternative implementation would be to use a union, but use of a union is
105:                 against the coding standard (although an exception to the standard has been
106:                 permitted where the dual use also significantly changes the type of the
107:                 structure member). */
108:                 #define pxMutexHolder					pcTail
109:                 #define uxQueueType						pcHead
110:                 #define queueQUEUE_IS_MUTEX				NULL
111:                 
112:                 /* Semaphores do not actually store or copy data, so have an item size of
113:                 zero. */
114:                 #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
115:                 #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
116:                 
117:                 #if( configUSE_PREEMPTION == 0 )
118:                 	/* If the cooperative scheduler is being used then a yield should not be
119:                 	performed just because a higher priority task has been woken. */
120:                 	#define queueYIELD_IF_USING_PREEMPTION()
121:                 #else
122:                 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
123:                 #endif
124:                 
125:                 /*
126:                  * Definition of the queue used by the scheduler.
127:                  * Items are queued by copy, not reference.  See the following link for the
128:                  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
129:                  */
130:                 typedef struct QueueDefinition
131:                 {
132:                 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
133:                 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
134:                 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
135:                 
136:                 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
137:                 	{
138:                 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
139:                 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
140:                 	} u;
141:                 
142:                 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
143:                 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
144:                 
145:                 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
146:                 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
147:                 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
148:                 
149:                 	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
150:                 	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
151:                 
152:                 	#if ( configUSE_TRACE_FACILITY == 1 )
153:                 		UBaseType_t uxQueueNumber;
154:                 		uint8_t ucQueueType;
155:                 	#endif
156:                 
157:                 	#if ( configUSE_QUEUE_SETS == 1 )
158:                 		struct QueueDefinition *pxQueueSetContainer;
159:                 	#endif
160:                 
161:                 } xQUEUE;
162:                 
163:                 /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
164:                 name below to enable the use of older kernel aware debuggers. */
165:                 typedef xQUEUE Queue_t;
166:                 
167:                 /*-----------------------------------------------------------*/
168:                 
169:                 /*
170:                  * The queue registry is just a means for kernel aware debuggers to locate
171:                  * queue structures.  It has no other purpose so is an optional component.
172:                  */
173:                 #if ( configQUEUE_REGISTRY_SIZE > 0 )
174:                 
175:                 	/* The type stored within the queue registry array.  This allows a name
176:                 	to be assigned to each queue making kernel aware debugging a little
177:                 	more user friendly. */
178:                 	typedef struct QUEUE_REGISTRY_ITEM
179:                 	{
180:                 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
181:                 		QueueHandle_t xHandle;
182:                 	} xQueueRegistryItem;
183:                 
184:                 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
185:                 	new xQueueRegistryItem name below to enable the use of older kernel aware
186:                 	debuggers. */
187:                 	typedef xQueueRegistryItem QueueRegistryItem_t;
188:                 
189:                 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
190:                 	The pcQueueName member of a structure being NULL is indicative of the
191:                 	array position being vacant. */
192:                 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
193:                 
194:                 #endif /* configQUEUE_REGISTRY_SIZE */
195:                 
196:                 /*
197:                  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
198:                  * prevent an ISR from adding or removing items to the queue, but does prevent
199:                  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
200:                  * queue is locked it will instead increment the appropriate queue lock count
201:                  * to indicate that a task may require unblocking.  When the queue in unlocked
202:                  * these lock counts are inspected, and the appropriate action taken.
203:                  */
204:                 static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
205:                 
206:                 /*
207:                  * Uses a critical section to determine if there is any data in a queue.
208:                  *
209:                  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
210:                  */
211:                 static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
212:                 
213:                 /*
214:                  * Uses a critical section to determine if there is any space in a queue.
215:                  *
216:                  * @return pdTRUE if there is no space, otherwise pdFALSE;
217:                  */
218:                 static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
219:                 
220:                 /*
221:                  * Copies an item into the queue, either at the front of the queue or the
222:                  * back of the queue.
223:                  */
224:                 static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
225:                 
226:                 /*
227:                  * Copies an item out of a queue.
228:                  */
229:                 static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
230:                 
231:                 #if ( configUSE_QUEUE_SETS == 1 )
232:                 	/*
233:                 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
234:                 	 * the queue set that the queue contains data.
235:                 	 */
236:                 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
237:                 #endif
238:                 
239:                 /*-----------------------------------------------------------*/
240:                 
241:                 /*
242:                  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
243:                  * accessing the queue event lists.
244:                  */
245:                 #define prvLockQueue( pxQueue )								\
246:                 	taskENTER_CRITICAL();									\
247:                 	{														\
248:                 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
249:                 		{													\
250:                 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
251:                 		}													\
252:                 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
253:                 		{													\
254:                 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
255:                 		}													\
256:                 	}														\
257:                 	taskEXIT_CRITICAL()
258:                 /*-----------------------------------------------------------*/
259:                 
260:                 BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
261:                 {
9D00A788  27BDFFE0   ADDIU SP, SP, -32
9D00A78C  AFBF001C   SW RA, 28(SP)
9D00A790  AFB10018   SW S1, 24(SP)
9D00A794  AFB00014   SW S0, 20(SP)
9D00A798  00808021   ADDU S0, A0, ZERO
262:                 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
263:                 
264:                 	configASSERT( pxQueue );
265:                 
266:                 	taskENTER_CRITICAL();
9D00A79C  0F40339E   JAL vTaskEnterCritical
9D00A7A0  00A08821   ADDU S1, A1, ZERO
267:                 	{
268:                 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
9D00A7A4  8E020000   LW V0, 0(S0)
9D00A7A8  8E030040   LW V1, 64(S0)
9D00A7AC  8E04003C   LW A0, 60(S0)
9D00A7B0  70642002   MUL A0, V1, A0
9D00A7B4  00442821   ADDU A1, V0, A0
9D00A7B8  AE050004   SW A1, 4(S0)
269:                 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
9D00A7BC  AE000038   SW ZERO, 56(S0)
270:                 		pxQueue->pcWriteTo = pxQueue->pcHead;
9D00A7C0  AE020008   SW V0, 8(S0)
271:                 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
9D00A7C4  00831823   SUBU V1, A0, V1
9D00A7C8  00431021   ADDU V0, V0, V1
9D00A7CC  AE02000C   SW V0, 12(S0)
272:                 		pxQueue->xRxLock = queueUNLOCKED;
9D00A7D0  2402FFFF   ADDIU V0, ZERO, -1
9D00A7D4  AE020044   SW V0, 68(S0)
273:                 		pxQueue->xTxLock = queueUNLOCKED;
9D00A7D8  AE020048   SW V0, 72(S0)
274:                 
275:                 		if( xNewQueue == pdFALSE )
9D00A7DC  1620000F   BNE S1, ZERO, 0x9D00A81C
9D00A7E0  00000000   NOP
276:                 		{
277:                 			/* If there are tasks blocked waiting to read from the queue, then
278:                 			the tasks will remain blocked as after this function exits the queue
279:                 			will still be empty.  If there are tasks blocked waiting to write to
280:                 			the queue, then one should be unblocked as after this function exits
281:                 			it will be possible to write to it. */
282:                 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D00A7E4  8E020010   LW V0, 16(S0)
9D00A7E8  10400010   BEQ V0, ZERO, 0x9D00A82C
9D00A7EC  00000000   NOP
283:                 			{
284:                 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
9D00A7F0  0F402AA3   JAL xTaskRemoveFromEventList
9D00A7F4  26040010   ADDIU A0, S0, 16
9D00A7F8  24030001   ADDIU V1, ZERO, 1
9D00A7FC  1443000B   BNE V0, V1, 0x9D00A82C
9D00A800  00000000   NOP
285:                 				{
286:                 					queueYIELD_IF_USING_PREEMPTION();
9D00A804  40026800   MFC0 V0, Cause
9D00A808  34420100   ORI V0, V0, 256
9D00A80C  40826800   MTC0 V0, Cause
9D00A810  000000C0   EHB
9D00A814  0B402A0B   J 0x9D00A82C
9D00A818  00000000   NOP
287:                 				}
288:                 				else
289:                 				{
290:                 					mtCOVERAGE_TEST_MARKER();
291:                 				}
292:                 			}
293:                 			else
294:                 			{
295:                 				mtCOVERAGE_TEST_MARKER();
296:                 			}
297:                 		}
298:                 		else
299:                 		{
300:                 			/* Ensure the event queues start in the correct state. */
301:                 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
9D00A81C  0F403689   JAL vListInitialise
9D00A820  26040010   ADDIU A0, S0, 16
302:                 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
9D00A824  0F403689   JAL vListInitialise
9D00A828  26040024   ADDIU A0, S0, 36
303:                 		}
304:                 	}
305:                 	taskEXIT_CRITICAL();
9D00A82C  0F403151   JAL vTaskExitCritical
9D00A830  00000000   NOP
306:                 
307:                 	/* A value is returned for calling semantic consistency with previous
308:                 	versions. */
309:                 	return pdPASS;
310:                 }
9D00A834  24020001   ADDIU V0, ZERO, 1
9D00A838  8FBF001C   LW RA, 28(SP)
9D00A83C  8FB10018   LW S1, 24(SP)
9D00A840  8FB00014   LW S0, 20(SP)
9D00A844  03E00008   JR RA
9D00A848  27BD0020   ADDIU SP, SP, 32
311:                 /*-----------------------------------------------------------*/
312:                 
313:                 QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
314:                 {
9D00B6D0  27BDFFE0   ADDIU SP, SP, -32
9D00B6D4  AFBF001C   SW RA, 28(SP)
9D00B6D8  AFB20018   SW S2, 24(SP)
9D00B6DC  AFB10014   SW S1, 20(SP)
9D00B6E0  AFB00010   SW S0, 16(SP)
9D00B6E4  00809021   ADDU S2, A0, ZERO
315:                 Queue_t *pxNewQueue;
316:                 size_t xQueueSizeInBytes;
317:                 QueueHandle_t xReturn = NULL;
318:                 
319:                 	/* Remove compiler warnings about unused parameters should
320:                 	configUSE_TRACE_FACILITY not be set to 1. */
321:                 	( void ) ucQueueType;
322:                 
323:                 	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
324:                 
325:                 	if( uxItemSize == ( UBaseType_t ) 0 )
9D00B6E8  10A00013   BEQ A1, ZERO, 0x9D00B738
9D00B6EC  00A08821   ADDU S1, A1, ZERO
326:                 	{
327:                 		/* There is not going to be a queue storage area. */
328:                 		xQueueSizeInBytes = ( size_t ) 0;
329:                 	}
330:                 	else
331:                 	{
332:                 		/* The queue is one byte longer than asked for to make wrap checking
333:                 		easier/faster. */
334:                 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D00B6F0  70A42002   MUL A0, A1, A0
335:                 	}
336:                 
337:                 	/* Allocate the new queue structure and storage area. */
338:                 	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
9D00B6F4  0F402A73   JAL pvPortMalloc
9D00B6F8  2484004D   ADDIU A0, A0, 77
9D00B738  0F402A73   JAL pvPortMalloc
9D00B73C  2404004C   ADDIU A0, ZERO, 76
339:                 
340:                 	if( pxNewQueue != NULL )
9D00B6FC  14400005   BNE V0, ZERO, 0x9D00B714
9D00B700  00408021   ADDU S0, V0, ZERO
9D00B740  1440FFF2   BNE V0, ZERO, 0x9D00B70C
9D00B744  00408021   ADDU S0, V0, ZERO
341:                 	{
342:                 		if( uxItemSize == ( UBaseType_t ) 0 )
343:                 		{
344:                 			/* No RAM was allocated for the queue storage area, but PC head
345:                 			cannot be set to NULL because NULL is used as a key to say the queue
346:                 			is used as a mutex.  Therefore just set pcHead to point to the queue
347:                 			as a benign value that is known to be within the memory map. */
348:                 			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
349:                 		}
350:                 		else
351:                 		{
352:                 			/* Jump past the queue structure to find the location of the queue
353:                 			storage area. */
354:                 			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
9D00B714  2442004C   ADDIU V0, V0, 76
9D00B718  AE020000   SW V0, 0(S0)
355:                 		}
356:                 
357:                 		/* Initialise the queue members as described above where the queue type
358:                 		is defined. */
359:                 		pxNewQueue->uxLength = uxQueueLength;
9D00B71C  AE12003C   SW S2, 60(S0)
360:                 		pxNewQueue->uxItemSize = uxItemSize;
9D00B720  AE110040   SW S1, 64(S0)
361:                 		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
9D00B724  02002021   ADDU A0, S0, ZERO
9D00B728  0F4029E2   JAL xQueueGenericReset
9D00B72C  24050001   ADDIU A1, ZERO, 1
9D00B730  0B402DD3   J 0x9D00B74C
9D00B734  02001021   ADDU V0, S0, ZERO
362:                 
363:                 		#if ( configUSE_TRACE_FACILITY == 1 )
364:                 		{
365:                 			pxNewQueue->ucQueueType = ucQueueType;
366:                 		}
367:                 		#endif /* configUSE_TRACE_FACILITY */
368:                 
369:                 		#if( configUSE_QUEUE_SETS == 1 )
370:                 		{
371:                 			pxNewQueue->pxQueueSetContainer = NULL;
372:                 		}
373:                 		#endif /* configUSE_QUEUE_SETS */
374:                 
375:                 		traceQUEUE_CREATE( pxNewQueue );
376:                 		xReturn = pxNewQueue;
377:                 	}
378:                 	else
379:                 	{
380:                 		mtCOVERAGE_TEST_MARKER();
381:                 	}
382:                 
383:                 	configASSERT( xReturn );
384:                 
385:                 	return xReturn;
386:                 }
9D00B704  0B402DD3   J 0x9D00B74C
9D00B708  02001021   ADDU V0, S0, ZERO
9D00B70C  0B402DC7   J 0x9D00B71C
9D00B710  AE100000   SW S0, 0(S0)
9D00B748  02001021   ADDU V0, S0, ZERO
9D00B74C  8FBF001C   LW RA, 28(SP)
9D00B750  8FB20018   LW S2, 24(SP)
9D00B754  8FB10014   LW S1, 20(SP)
9D00B758  8FB00010   LW S0, 16(SP)
9D00B75C  03E00008   JR RA
9D00B760  27BD0020   ADDIU SP, SP, 32
387:                 /*-----------------------------------------------------------*/
388:                 
389:                 #if ( configUSE_MUTEXES == 1 )
390:                 
391:                 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
392:                 	{
9D00BDF4  27BDFFE8   ADDIU SP, SP, -24
9D00BDF8  AFBF0014   SW RA, 20(SP)
9D00BDFC  AFB00010   SW S0, 16(SP)
393:                 	Queue_t *pxNewQueue;
394:                 
395:                 		/* Prevent compiler warnings about unused parameters if
396:                 		configUSE_TRACE_FACILITY does not equal 1. */
397:                 		( void ) ucQueueType;
398:                 
399:                 		/* Allocate the new queue structure. */
400:                 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
9D00BE00  0F402A73   JAL pvPortMalloc
9D00BE04  2404004C   ADDIU A0, ZERO, 76
401:                 		if( pxNewQueue != NULL )
9D00BE08  10400015   BEQ V0, ZERO, 0x9D00BE60
9D00BE0C  00408021   ADDU S0, V0, ZERO
402:                 		{
403:                 			/* Information required for priority inheritance. */
404:                 			pxNewQueue->pxMutexHolder = NULL;
9D00BE10  AC400004   SW ZERO, 4(V0)
405:                 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
9D00BE14  AC400000   SW ZERO, 0(V0)
406:                 
407:                 			/* Queues used as a mutex no data is actually copied into or out
408:                 			of the queue. */
409:                 			pxNewQueue->pcWriteTo = NULL;
9D00BE18  AC400008   SW ZERO, 8(V0)
410:                 			pxNewQueue->u.pcReadFrom = NULL;
9D00BE1C  AC40000C   SW ZERO, 12(V0)
411:                 
412:                 			/* Each mutex has a length of 1 (like a binary semaphore) and
413:                 			an item size of 0 as nothing is actually copied into or out
414:                 			of the mutex. */
415:                 			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
9D00BE20  AC400038   SW ZERO, 56(V0)
416:                 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
9D00BE24  24020001   ADDIU V0, ZERO, 1
9D00BE28  AE02003C   SW V0, 60(S0)
417:                 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
9D00BE2C  AE000040   SW ZERO, 64(S0)
418:                 			pxNewQueue->xRxLock = queueUNLOCKED;
9D00BE30  2402FFFF   ADDIU V0, ZERO, -1
9D00BE34  AE020044   SW V0, 68(S0)
419:                 			pxNewQueue->xTxLock = queueUNLOCKED;
9D00BE38  AE020048   SW V0, 72(S0)
420:                 
421:                 			#if ( configUSE_TRACE_FACILITY == 1 )
422:                 			{
423:                 				pxNewQueue->ucQueueType = ucQueueType;
424:                 			}
425:                 			#endif
426:                 
427:                 			#if ( configUSE_QUEUE_SETS == 1 )
428:                 			{
429:                 				pxNewQueue->pxQueueSetContainer = NULL;
430:                 			}
431:                 			#endif
432:                 
433:                 			/* Ensure the event queues start with the correct state. */
434:                 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
9D00BE3C  0F403689   JAL vListInitialise
9D00BE40  26040010   ADDIU A0, S0, 16
435:                 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
9D00BE44  0F403689   JAL vListInitialise
9D00BE48  26040024   ADDIU A0, S0, 36
436:                 
437:                 			traceCREATE_MUTEX( pxNewQueue );
438:                 
439:                 			/* Start with the semaphore in the expected state. */
440:                 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
9D00BE4C  02002021   ADDU A0, S0, ZERO
9D00BE50  00002821   ADDU A1, ZERO, ZERO
9D00BE54  00003021   ADDU A2, ZERO, ZERO
9D00BE58  0F40199A   JAL xQueueGenericSend
9D00BE5C  00003821   ADDU A3, ZERO, ZERO
441:                 		}
442:                 		else
443:                 		{
444:                 			traceCREATE_MUTEX_FAILED();
445:                 		}
446:                 
447:                 		return pxNewQueue;
448:                 	}
9D00BE60  02001021   ADDU V0, S0, ZERO
9D00BE64  8FBF0014   LW RA, 20(SP)
9D00BE68  8FB00010   LW S0, 16(SP)
9D00BE6C  03E00008   JR RA
9D00BE70  27BD0018   ADDIU SP, SP, 24
449:                 
450:                 #endif /* configUSE_MUTEXES */
451:                 /*-----------------------------------------------------------*/
452:                 
453:                 #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
454:                 
455:                 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
456:                 	{
457:                 	void *pxReturn;
458:                 
459:                 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
460:                 		be called directly.  Note:  This is a good way of determining if the
461:                 		calling task is the mutex holder, but not a good way of determining the
462:                 		identity of the mutex holder, as the holder may change between the
463:                 		following critical section exiting and the function returning. */
464:                 		taskENTER_CRITICAL();
465:                 		{
466:                 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
467:                 			{
468:                 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
469:                 			}
470:                 			else
471:                 			{
472:                 				pxReturn = NULL;
473:                 			}
474:                 		}
475:                 		taskEXIT_CRITICAL();
476:                 
477:                 		return pxReturn;
478:                 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
479:                 
480:                 #endif
481:                 /*-----------------------------------------------------------*/
482:                 
483:                 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
484:                 
485:                 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
486:                 	{
487:                 	BaseType_t xReturn;
488:                 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
489:                 
490:                 		configASSERT( pxMutex );
491:                 
492:                 		/* If this is the task that holds the mutex then pxMutexHolder will not
493:                 		change outside of this task.  If this task does not hold the mutex then
494:                 		pxMutexHolder can never coincidentally equal the tasks handle, and as
495:                 		this is the only condition we are interested in it does not matter if
496:                 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
497:                 		mutual exclusion is required to test the pxMutexHolder variable. */
498:                 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
499:                 		{
500:                 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
501:                 
502:                 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
503:                 			the task handle, therefore no underflow check is required.  Also,
504:                 			uxRecursiveCallCount is only modified by the mutex holder, and as
505:                 			there can only be one, no mutual exclusion is required to modify the
506:                 			uxRecursiveCallCount member. */
507:                 			( pxMutex->u.uxRecursiveCallCount )--;
508:                 
509:                 			/* Have we unwound the call count? */
510:                 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
511:                 			{
512:                 				/* Return the mutex.  This will automatically unblock any other
513:                 				task that might be waiting to access the mutex. */
514:                 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
515:                 			}
516:                 			else
517:                 			{
518:                 				mtCOVERAGE_TEST_MARKER();
519:                 			}
520:                 
521:                 			xReturn = pdPASS;
522:                 		}
523:                 		else
524:                 		{
525:                 			/* The mutex cannot be given because the calling task is not the
526:                 			holder. */
527:                 			xReturn = pdFAIL;
528:                 
529:                 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
530:                 		}
531:                 
532:                 		return xReturn;
533:                 	}
534:                 
535:                 #endif /* configUSE_RECURSIVE_MUTEXES */
536:                 /*-----------------------------------------------------------*/
537:                 
538:                 #if ( configUSE_RECURSIVE_MUTEXES == 1 )
539:                 
540:                 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
541:                 	{
542:                 	BaseType_t xReturn;
543:                 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
544:                 
545:                 		configASSERT( pxMutex );
546:                 
547:                 		/* Comments regarding mutual exclusion as per those within
548:                 		xQueueGiveMutexRecursive(). */
549:                 
550:                 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
551:                 
552:                 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
553:                 		{
554:                 			( pxMutex->u.uxRecursiveCallCount )++;
555:                 			xReturn = pdPASS;
556:                 		}
557:                 		else
558:                 		{
559:                 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
560:                 
561:                 			/* pdPASS will only be returned if the mutex was successfully
562:                 			obtained.  The calling task may have entered the Blocked state
563:                 			before reaching here. */
564:                 			if( xReturn == pdPASS )
565:                 			{
566:                 				( pxMutex->u.uxRecursiveCallCount )++;
567:                 			}
568:                 			else
569:                 			{
570:                 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
571:                 			}
572:                 		}
573:                 
574:                 		return xReturn;
575:                 	}
576:                 
577:                 #endif /* configUSE_RECURSIVE_MUTEXES */
578:                 /*-----------------------------------------------------------*/
579:                 
580:                 #if ( configUSE_COUNTING_SEMAPHORES == 1 )
581:                 
582:                 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
583:                 	{
9D00D608  27BDFFE8   ADDIU SP, SP, -24
9D00D60C  AFBF0014   SW RA, 20(SP)
9D00D610  AFB00010   SW S0, 16(SP)
9D00D614  00A08021   ADDU S0, A1, ZERO
584:                 	QueueHandle_t xHandle;
585:                 
586:                 		configASSERT( uxMaxCount != 0 );
587:                 		configASSERT( uxInitialCount <= uxMaxCount );
588:                 
589:                 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
9D00D618  00002821   ADDU A1, ZERO, ZERO
9D00D61C  0F402DB4   JAL xQueueGenericCreate
9D00D620  24060002   ADDIU A2, ZERO, 2
590:                 
591:                 		if( xHandle != NULL )
9D00D624  54400001   BNEL V0, ZERO, 0x9D00D62C
9D00D628  AC500038   SW S0, 56(V0)
592:                 		{
593:                 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
594:                 
595:                 			traceCREATE_COUNTING_SEMAPHORE();
596:                 		}
597:                 		else
598:                 		{
599:                 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
600:                 		}
601:                 
602:                 		configASSERT( xHandle );
603:                 		return xHandle;
604:                 	}
9D00D62C  8FBF0014   LW RA, 20(SP)
9D00D630  8FB00010   LW S0, 16(SP)
9D00D634  03E00008   JR RA
9D00D638  27BD0018   ADDIU SP, SP, 24
605:                 
606:                 #endif /* configUSE_COUNTING_SEMAPHORES */
607:                 /*-----------------------------------------------------------*/
608:                 
609:                 BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
610:                 {
9D006668  27BDFFC0   ADDIU SP, SP, -64
9D00666C  AFBF003C   SW RA, 60(SP)
9D006670  AFBE0038   SW S8, 56(SP)
9D006674  AFB70034   SW S7, 52(SP)
9D006678  AFB60030   SW S6, 48(SP)
9D00667C  AFB5002C   SW S5, 44(SP)
9D006680  AFB40028   SW S4, 40(SP)
9D006684  AFB30024   SW S3, 36(SP)
9D006688  AFB20020   SW S2, 32(SP)
9D00668C  AFB1001C   SW S1, 28(SP)
9D006690  AFB00018   SW S0, 24(SP)
9D006694  00808021   ADDU S0, A0, ZERO
9D006698  00A0B021   ADDU S6, A1, ZERO
9D00669C  AFA60048   SW A2, 72(SP)
9D0066A0  00E09821   ADDU S3, A3, ZERO
611:                 BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
9D0066A4  00009021   ADDU S2, ZERO, ZERO
612:                 TimeOut_t xTimeOut;
613:                 Queue_t * const pxQueue = ( Queue_t * ) xQueue;
614:                 
615:                 	configASSERT( pxQueue );
616:                 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
617:                 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
618:                 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
619:                 	{
620:                 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
621:                 	}
622:                 	#endif
623:                 
624:                 
625:                 	/* This function relaxes the coding standard somewhat to allow return
626:                 	statements within the function itself.  This is done in the interest
627:                 	of execution time efficiency. */
628:                 	for( ;; )
629:                 	{
630:                 		taskENTER_CRITICAL();
9D0066B4  0F40339E   JAL vTaskEnterCritical
9D0066B8  00000000   NOP
631:                 		{
632:                 			/* Is there room on the queue now?  The running task must be the
633:                 			highest priority task wanting to access the queue.  If the head item
634:                 			in the queue is to be overwritten then it does not matter if the
635:                 			queue is full. */
636:                 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
9D0066A8  24140002   ADDIU S4, ZERO, 2
9D0066BC  8E030038   LW V1, 56(S0)
9D0066C0  8E02003C   LW V0, 60(S0)
9D0066C4  0062102B   SLTU V0, V1, V0
9D0066C8  14400004   BNE V0, ZERO, 0x9D0066DC
9D0066CC  02002021   ADDU A0, S0, ZERO
9D0066D0  1674001D   BNE S3, S4, 0x9D006748
9D0066D4  8FA20048   LW V0, 72(SP)
637:                 			{
638:                 				traceQUEUE_SEND( pxQueue );
639:                 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
9D0066D8  02002021   ADDU A0, S0, ZERO
9D0066DC  02C02821   ADDU A1, S6, ZERO
9D0066E0  0F4026CF   JAL prvCopyDataToQueue
9D0066E4  02603021   ADDU A2, S3, ZERO
640:                 
641:                 				#if ( configUSE_QUEUE_SETS == 1 )
642:                 				{
643:                 					if( pxQueue->pxQueueSetContainer != NULL )
644:                 					{
645:                 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
646:                 						{
647:                 							/* The queue is a member of a queue set, and posting
648:                 							to the queue set caused a higher priority task to
649:                 							unblock. A context switch is required. */
650:                 							queueYIELD_IF_USING_PREEMPTION();
651:                 						}
652:                 						else
653:                 						{
654:                 							mtCOVERAGE_TEST_MARKER();
655:                 						}
656:                 					}
657:                 					else
658:                 					{
659:                 						/* If there was a task waiting for data to arrive on the
660:                 						queue then unblock it now. */
661:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
662:                 						{
663:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
664:                 							{
665:                 								/* The unblocked task has a priority higher than
666:                 								our own so yield immediately.  Yes it is ok to
667:                 								do this from within the critical section - the
668:                 								kernel takes care of that. */
669:                 								queueYIELD_IF_USING_PREEMPTION();
670:                 							}
671:                 							else
672:                 							{
673:                 								mtCOVERAGE_TEST_MARKER();
674:                 							}
675:                 						}
676:                 						else if( xYieldRequired != pdFALSE )
677:                 						{
678:                 							/* This path is a special case that will only get
679:                 							executed if the task was holding multiple mutexes
680:                 							and the mutexes were given back in an order that is
681:                 							different to that in which they were taken. */
682:                 							queueYIELD_IF_USING_PREEMPTION();
683:                 						}
684:                 						else
685:                 						{
686:                 							mtCOVERAGE_TEST_MARKER();
687:                 						}
688:                 					}
689:                 				}
690:                 				#else /* configUSE_QUEUE_SETS */
691:                 				{
692:                 					/* If there was a task waiting for data to arrive on the
693:                 					queue then unblock it now. */
694:                 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D0066E8  8E030024   LW V1, 36(S0)
9D0066EC  1060000C   BEQ V1, ZERO, 0x9D006720
9D0066F0  00000000   NOP
695:                 					{
696:                 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
9D0066F4  0F402AA3   JAL xTaskRemoveFromEventList
9D0066F8  26040024   ADDIU A0, S0, 36
9D0066FC  24030001   ADDIU V1, ZERO, 1
9D006700  1443000D   BNE V0, V1, 0x9D006738
9D006704  00000000   NOP
697:                 						{
698:                 							/* The unblocked task has a priority higher than
699:                 							our own so yield immediately.  Yes it is ok to do
700:                 							this from within the critical section - the kernel
701:                 							takes care of that. */
702:                 							queueYIELD_IF_USING_PREEMPTION();
9D006708  40026800   MFC0 V0, Cause
9D00670C  34420100   ORI V0, V0, 256
9D006710  40826800   MTC0 V0, Cause
9D006714  000000C0   EHB
9D006718  0B4019CE   J 0x9D006738
9D00671C  00000000   NOP
703:                 						}
704:                 						else
705:                 						{
706:                 							mtCOVERAGE_TEST_MARKER();
707:                 						}
708:                 					}
709:                 					else if( xYieldRequired != pdFALSE )
9D006720  10400005   BEQ V0, ZERO, 0x9D006738
9D006724  00000000   NOP
710:                 					{
711:                 						/* This path is a special case that will only get
712:                 						executed if the task was holding multiple mutexes and
713:                 						the mutexes were given back in an order that is
714:                 						different to that in which they were taken. */
715:                 						queueYIELD_IF_USING_PREEMPTION();
9D006728  40026800   MFC0 V0, Cause
9D00672C  34420100   ORI V0, V0, 256
9D006730  40826800   MTC0 V0, Cause
9D006734  000000C0   EHB
716:                 					}
717:                 					else
718:                 					{
719:                 						mtCOVERAGE_TEST_MARKER();
720:                 					}
721:                 				}
722:                 				#endif /* configUSE_QUEUE_SETS */
723:                 
724:                 				taskEXIT_CRITICAL();
9D006738  0F403151   JAL vTaskExitCritical
9D00673C  00000000   NOP
725:                 				return pdPASS;
9D006740  0B401A10   J 0x9D006840
9D006744  24020001   ADDIU V0, ZERO, 1
726:                 			}
727:                 			else
728:                 			{
729:                 				if( xTicksToWait == ( TickType_t ) 0 )
9D006748  14400005   BNE V0, ZERO, 0x9D006760
9D00674C  00000000   NOP
730:                 				{
731:                 					/* The queue was full and no block time is specified (or
732:                 					the block time has expired) so leave now. */
733:                 					taskEXIT_CRITICAL();
9D006750  0F403151   JAL vTaskExitCritical
9D006754  00000000   NOP
734:                 
735:                 					/* Return to the original privilege level before exiting
736:                 					the function. */
737:                 					traceQUEUE_SEND_FAILED( pxQueue );
738:                 					return errQUEUE_FULL;
9D006758  0B401A10   J 0x9D006840
9D00675C  00001021   ADDU V0, ZERO, ZERO
739:                 				}
740:                 				else if( xEntryTimeSet == pdFALSE )
9D006760  16400004   BNE S2, ZERO, 0x9D006774
9D006764  00000000   NOP
741:                 				{
742:                 					/* The queue was full and a block time was specified so
743:                 					configure the timeout structure. */
744:                 					vTaskSetTimeOutState( &xTimeOut );
9D006768  0F40373B   JAL vTaskSetTimeOutState
9D00676C  27A40010   ADDIU A0, SP, 16
745:                 					xEntryTimeSet = pdTRUE;
9D006770  24120001   ADDIU S2, ZERO, 1
746:                 				}
747:                 				else
748:                 				{
749:                 					/* Entry time was already set. */
750:                 					mtCOVERAGE_TEST_MARKER();
751:                 				}
752:                 			}
753:                 		}
754:                 		taskEXIT_CRITICAL();
9D006774  0F403151   JAL vTaskExitCritical
9D006778  00000000   NOP
755:                 
756:                 		/* Interrupts and other tasks can send to and receive from the queue
757:                 		now the critical section has been exited. */
758:                 
759:                 		vTaskSuspendAll();
9D00677C  0F403736   JAL vTaskSuspendAll
9D006780  00000000   NOP
760:                 		prvLockQueue( pxQueue );
9D0066AC  2411FFFF   ADDIU S1, ZERO, -1
9D006784  0F40339E   JAL vTaskEnterCritical
9D006788  00000000   NOP
9D00678C  8E020044   LW V0, 68(S0)
9D006790  50510001   BEQL V0, S1, 0x9D006798
9D006794  AE000044   SW ZERO, 68(S0)
9D006798  8E020048   LW V0, 72(S0)
9D00679C  50510001   BEQL V0, S1, 0x9D0067A4
9D0067A0  AE000048   SW ZERO, 72(S0)
9D0067A4  0F403151   JAL vTaskExitCritical
9D0067A8  00000000   NOP
761:                 
762:                 		/* Update the timeout state to see if it has expired yet. */
763:                 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
9D0067AC  27A40010   ADDIU A0, SP, 16
9D0067B0  0F402C59   JAL xTaskCheckForTimeOut
9D0067B4  27A50048   ADDIU A1, SP, 72
9D0067B8  1440001C   BNE V0, ZERO, 0x9D00682C
9D0067BC  00000000   NOP
764:                 		{
765:                 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
9D0067D4  17D7000F   BNE S8, S7, 0x9D006814
9D0067D8  02A02021   ADDU A0, S5, ZERO
766:                 			{
767:                 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
768:                 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
9D0066B0  24950010   ADDIU S5, A0, 16
9D0067DC  0F402DD9   JAL vTaskPlaceOnEventList
9D0067E0  8FA50048   LW A1, 72(SP)
769:                 
770:                 				/* Unlocking the queue means queue events can effect the
771:                 				event list.  It is possible	that interrupts occurring now
772:                 				remove this task from the event	list again - but as the
773:                 				scheduler is suspended the task will go onto the pending
774:                 				ready last instead of the actual ready list. */
775:                 				prvUnlockQueue( pxQueue );
9D0067E4  0F40264D   JAL prvUnlockQueue
9D0067E8  02002021   ADDU A0, S0, ZERO
776:                 
777:                 				/* Resuming the scheduler will move tasks from the pending
778:                 				ready list into the ready list - so it is feasible that this
779:                 				task is already in a ready list before it yields - in which
780:                 				case the yield will not cause a context switch unless there
781:                 				is also a higher priority task in the pending ready list. */
782:                 				if( xTaskResumeAll() == pdFALSE )
9D0067EC  0F402184   JAL xTaskResumeAll
9D0067F0  00000000   NOP
9D0067F4  1440FFAF   BNE V0, ZERO, 0x9D0066B4
9D0067F8  00000000   NOP
783:                 				{
784:                 					portYIELD_WITHIN_API();
9D0067FC  40026800   MFC0 V0, Cause
9D006800  34420100   ORI V0, V0, 256
9D006804  40826800   MTC0 V0, Cause
9D006808  000000C0   EHB
9D00680C  0B4019AD   J 0x9D0066B4
9D006810  00000000   NOP
785:                 				}
786:                 			}
787:                 			else
788:                 			{
789:                 				/* Try again. */
790:                 				prvUnlockQueue( pxQueue );
9D006814  0F40264D   JAL prvUnlockQueue
9D006818  02002021   ADDU A0, S0, ZERO
791:                 				( void ) xTaskResumeAll();
9D00681C  0F402184   JAL xTaskResumeAll
9D006820  00000000   NOP
9D006824  0B4019AD   J 0x9D0066B4
9D006828  00000000   NOP
792:                 			}
793:                 		}
794:                 		else
795:                 		{
796:                 			/* The timeout has expired. */
797:                 			prvUnlockQueue( pxQueue );
9D00682C  0F40264D   JAL prvUnlockQueue
9D006830  02002021   ADDU A0, S0, ZERO
798:                 			( void ) xTaskResumeAll();
9D006834  0F402184   JAL xTaskResumeAll
9D006838  00000000   NOP
799:                 
800:                 			/* Return to the original privilege level before exiting the
801:                 			function. */
802:                 			traceQUEUE_SEND_FAILED( pxQueue );
803:                 			return errQUEUE_FULL;
9D00683C  00001021   ADDU V0, ZERO, ZERO
804:                 		}
805:                 	}
806:                 }
9D006840  8FBF003C   LW RA, 60(SP)
9D006844  8FBE0038   LW S8, 56(SP)
9D006848  8FB70034   LW S7, 52(SP)
9D00684C  8FB60030   LW S6, 48(SP)
9D006850  8FB5002C   LW S5, 44(SP)
9D006854  8FB40028   LW S4, 40(SP)
9D006858  8FB30024   LW S3, 36(SP)
9D00685C  8FB20020   LW S2, 32(SP)
9D006860  8FB1001C   LW S1, 28(SP)
9D006864  8FB00018   LW S0, 24(SP)
9D006868  03E00008   JR RA
9D00686C  27BD0040   ADDIU SP, SP, 64
807:                 /*-----------------------------------------------------------*/
808:                 
809:                 #if ( configUSE_ALTERNATIVE_API == 1 )
810:                 
811:                 	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition )
812:                 	{
813:                 	BaseType_t xEntryTimeSet = pdFALSE;
814:                 	TimeOut_t xTimeOut;
815:                 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
816:                 
817:                 		configASSERT( pxQueue );
818:                 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
819:                 
820:                 		for( ;; )
821:                 		{
822:                 			taskENTER_CRITICAL();
823:                 			{
824:                 				/* Is there room on the queue now?  To be running we must be
825:                 				the highest priority task wanting to access the queue. */
826:                 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
827:                 				{
828:                 					traceQUEUE_SEND( pxQueue );
829:                 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
830:                 
831:                 					/* If there was a task waiting for data to arrive on the
832:                 					queue then unblock it now. */
833:                 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
834:                 					{
835:                 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
836:                 						{
837:                 							/* The unblocked task has a priority higher than
838:                 							our own so yield immediately. */
839:                 							portYIELD_WITHIN_API();
840:                 						}
841:                 						else
842:                 						{
843:                 							mtCOVERAGE_TEST_MARKER();
844:                 						}
845:                 					}
846:                 					else
847:                 					{
848:                 						mtCOVERAGE_TEST_MARKER();
849:                 					}
850:                 
851:                 					taskEXIT_CRITICAL();
852:                 					return pdPASS;
853:                 				}
854:                 				else
855:                 				{
856:                 					if( xTicksToWait == ( TickType_t ) 0 )
857:                 					{
858:                 						taskEXIT_CRITICAL();
859:                 						return errQUEUE_FULL;
860:                 					}
861:                 					else if( xEntryTimeSet == pdFALSE )
862:                 					{
863:                 						vTaskSetTimeOutState( &xTimeOut );
864:                 						xEntryTimeSet = pdTRUE;
865:                 					}
866:                 				}
867:                 			}
868:                 			taskEXIT_CRITICAL();
869:                 
870:                 			taskENTER_CRITICAL();
871:                 			{
872:                 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
873:                 				{
874:                 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
875:                 					{
876:                 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
877:                 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
878:                 						portYIELD_WITHIN_API();
879:                 					}
880:                 					else
881:                 					{
882:                 						mtCOVERAGE_TEST_MARKER();
883:                 					}
884:                 				}
885:                 				else
886:                 				{
887:                 					taskEXIT_CRITICAL();
888:                 					traceQUEUE_SEND_FAILED( pxQueue );
889:                 					return errQUEUE_FULL;
890:                 				}
891:                 			}
892:                 			taskEXIT_CRITICAL();
893:                 		}
894:                 	}
895:                 
896:                 #endif /* configUSE_ALTERNATIVE_API */
897:                 /*-----------------------------------------------------------*/
898:                 
899:                 #if ( configUSE_ALTERNATIVE_API == 1 )
900:                 
901:                 	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking )
902:                 	{
903:                 	BaseType_t xEntryTimeSet = pdFALSE;
904:                 	TimeOut_t xTimeOut;
905:                 	int8_t *pcOriginalReadPosition;
906:                 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
907:                 
908:                 		configASSERT( pxQueue );
909:                 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
910:                 
911:                 		for( ;; )
912:                 		{
913:                 			taskENTER_CRITICAL();
914:                 			{
915:                 				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
916:                 				{
917:                 					/* Remember our read position in case we are just peeking. */
918:                 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
919:                 
920:                 					prvCopyDataFromQueue( pxQueue, pvBuffer );
921:                 
922:                 					if( xJustPeeking == pdFALSE )
923:                 					{
924:                 						traceQUEUE_RECEIVE( pxQueue );
925:                 
926:                 						/* Data is actually being removed (not just peeked). */
927:                 						--( pxQueue->uxMessagesWaiting );
928:                 
929:                 						#if ( configUSE_MUTEXES == 1 )
930:                 						{
931:                 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
932:                 							{
933:                 								/* Record the information required to implement
934:                 								priority inheritance should it become necessary. */
935:                 								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
936:                 							}
937:                 							else
938:                 							{
939:                 								mtCOVERAGE_TEST_MARKER();
940:                 							}
941:                 						}
942:                 						#endif
943:                 
944:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
945:                 						{
946:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
947:                 							{
948:                 								portYIELD_WITHIN_API();
949:                 							}
950:                 							else
951:                 							{
952:                 								mtCOVERAGE_TEST_MARKER();
953:                 							}
954:                 						}
955:                 					}
956:                 					else
957:                 					{
958:                 						traceQUEUE_PEEK( pxQueue );
959:                 
960:                 						/* The data is not being removed, so reset our read
961:                 						pointer. */
962:                 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
963:                 
964:                 						/* The data is being left in the queue, so see if there are
965:                 						any other tasks waiting for the data. */
966:                 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
967:                 						{
968:                 							/* Tasks that are removed from the event list will get added to
969:                 							the pending ready list as the scheduler is still suspended. */
970:                 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
971:                 							{
972:                 								/* The task waiting has a higher priority than this task. */
973:                 								portYIELD_WITHIN_API();
974:                 							}
975:                 							else
976:                 							{
977:                 								mtCOVERAGE_TEST_MARKER();
978:                 							}
979:                 						}
980:                 						else
981:                 						{
982:                 							mtCOVERAGE_TEST_MARKER();
983:                 						}
984:                 					}
985:                 
986:                 					taskEXIT_CRITICAL();
987:                 					return pdPASS;
988:                 				}
989:                 				else
990:                 				{
991:                 					if( xTicksToWait == ( TickType_t ) 0 )
992:                 					{
993:                 						taskEXIT_CRITICAL();
994:                 						traceQUEUE_RECEIVE_FAILED( pxQueue );
995:                 						return errQUEUE_EMPTY;
996:                 					}
997:                 					else if( xEntryTimeSet == pdFALSE )
998:                 					{
999:                 						vTaskSetTimeOutState( &xTimeOut );
1000:                						xEntryTimeSet = pdTRUE;
1001:                					}
1002:                				}
1003:                			}
1004:                			taskEXIT_CRITICAL();
1005:                
1006:                			taskENTER_CRITICAL();
1007:                			{
1008:                				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1009:                				{
1010:                					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1011:                					{
1012:                						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1013:                
1014:                						#if ( configUSE_MUTEXES == 1 )
1015:                						{
1016:                							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1017:                							{
1018:                								taskENTER_CRITICAL();
1019:                								{
1020:                									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1021:                								}
1022:                								taskEXIT_CRITICAL();
1023:                							}
1024:                							else
1025:                							{
1026:                								mtCOVERAGE_TEST_MARKER();
1027:                							}
1028:                						}
1029:                						#endif
1030:                
1031:                						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1032:                						portYIELD_WITHIN_API();
1033:                					}
1034:                					else
1035:                					{
1036:                						mtCOVERAGE_TEST_MARKER();
1037:                					}
1038:                				}
1039:                				else
1040:                				{
1041:                					taskEXIT_CRITICAL();
1042:                					traceQUEUE_RECEIVE_FAILED( pxQueue );
1043:                					return errQUEUE_EMPTY;
1044:                				}
1045:                			}
1046:                			taskEXIT_CRITICAL();
1047:                		}
1048:                	}
1049:                
1050:                
1051:                #endif /* configUSE_ALTERNATIVE_API */
1052:                /*-----------------------------------------------------------*/
1053:                
1054:                BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
1055:                {
9D009E2C  27BDFFD0   ADDIU SP, SP, -48
9D009E30  AFBF002C   SW RA, 44(SP)
9D009E34  AFB50028   SW S5, 40(SP)
9D009E38  AFB40024   SW S4, 36(SP)
9D009E3C  AFB30020   SW S3, 32(SP)
9D009E40  AFB2001C   SW S2, 28(SP)
9D009E44  AFB10018   SW S1, 24(SP)
9D009E48  AFB00014   SW S0, 20(SP)
9D009E4C  00808021   ADDU S0, A0, ZERO
9D009E50  00A0A021   ADDU S4, A1, ZERO
9D009E54  00C0A821   ADDU S5, A2, ZERO
1056:                BaseType_t xReturn;
1057:                UBaseType_t uxSavedInterruptStatus;
1058:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1059:                
1060:                	configASSERT( pxQueue );
1061:                	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1062:                	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
1063:                
1064:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1065:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1066:                	above the maximum system call priority are kept permanently enabled, even
1067:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1068:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1069:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1070:                	failure if a FreeRTOS API function is called from an interrupt that has been
1071:                	assigned a priority above the configured maximum system call priority.
1072:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1073:                	that have been assigned a priority at or (logically) below the maximum
1074:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1075:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1076:                	More information (albeit Cortex-M specific) is provided on the following
1077:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1078:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1079:                
1080:                	/* Similar to xQueueGenericSend, except without blocking if there is no room
1081:                	in the queue.  Also don't directly wake a task that was blocked on a queue
1082:                	read, instead return a flag to say whether a context switch is required or
1083:                	not (i.e. has a task with a higher priority than us been woken by this
1084:                	post). */
1085:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
9D009E58  0F40351D   JAL uxPortSetInterruptMaskFromISR
9D009E5C  00E09021   ADDU S2, A3, ZERO
9D009E60  00409821   ADDU S3, V0, ZERO
1086:                	{
1087:                		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
9D009E64  8E030038   LW V1, 56(S0)
9D009E68  8E02003C   LW V0, 60(S0)
9D009E6C  0062102B   SLTU V0, V1, V0
9D009E70  14400003   BNE V0, ZERO, 0x9D009E80
9D009E74  24020002   ADDIU V0, ZERO, 2
9D009E78  1642001A   BNE S2, V0, 0x9D009EE4
9D009E7C  00008821   ADDU S1, ZERO, ZERO
1088:                		{
1089:                			traceQUEUE_SEND_FROM_ISR( pxQueue );
1090:                
1091:                			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1092:                			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1093:                			in a task disinheriting a priority and prvCopyDataToQueue() can be
1094:                			called here even though the disinherit function does not check if
1095:                			the scheduler is suspended before accessing the ready lists. */
1096:                			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
9D009E80  02002021   ADDU A0, S0, ZERO
9D009E84  02802821   ADDU A1, S4, ZERO
9D009E88  0F4026CF   JAL prvCopyDataToQueue
9D009E8C  02403021   ADDU A2, S2, ZERO
1097:                
1098:                			/* The event list is not altered if the queue is locked.  This will
1099:                			be done when the queue is unlocked later. */
1100:                			if( pxQueue->xTxLock == queueUNLOCKED )
9D009E90  8E030048   LW V1, 72(S0)
9D009E94  2402FFFF   ADDIU V0, ZERO, -1
9D009E98  1462000C   BNE V1, V0, 0x9D009ECC
9D009E9C  00000000   NOP
1101:                			{
1102:                				#if ( configUSE_QUEUE_SETS == 1 )
1103:                				{
1104:                					if( pxQueue->pxQueueSetContainer != NULL )
1105:                					{
1106:                						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
1107:                						{
1108:                							/* The queue is a member of a queue set, and posting
1109:                							to the queue set caused a higher priority task to
1110:                							unblock.  A context switch is required. */
1111:                							if( pxHigherPriorityTaskWoken != NULL )
1112:                							{
1113:                								*pxHigherPriorityTaskWoken = pdTRUE;
1114:                							}
1115:                							else
1116:                							{
1117:                								mtCOVERAGE_TEST_MARKER();
1118:                							}
1119:                						}
1120:                						else
1121:                						{
1122:                							mtCOVERAGE_TEST_MARKER();
1123:                						}
1124:                					}
1125:                					else
1126:                					{
1127:                						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1128:                						{
1129:                							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1130:                							{
1131:                								/* The task waiting has a higher priority so
1132:                								record that a context switch is required. */
1133:                								if( pxHigherPriorityTaskWoken != NULL )
1134:                								{
1135:                									*pxHigherPriorityTaskWoken = pdTRUE;
1136:                								}
1137:                								else
1138:                								{
1139:                									mtCOVERAGE_TEST_MARKER();
1140:                								}
1141:                							}
1142:                							else
1143:                							{
1144:                								mtCOVERAGE_TEST_MARKER();
1145:                							}
1146:                						}
1147:                						else
1148:                						{
1149:                							mtCOVERAGE_TEST_MARKER();
1150:                						}
1151:                					}
1152:                				}
1153:                				#else /* configUSE_QUEUE_SETS */
1154:                				{
1155:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D009EA0  8E020024   LW V0, 36(S0)
9D009EA4  1040000F   BEQ V0, ZERO, 0x9D009EE4
9D009EA8  24110001   ADDIU S1, ZERO, 1
1156:                					{
1157:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D009EAC  0F402AA3   JAL xTaskRemoveFromEventList
9D009EB0  26040024   ADDIU A0, S0, 36
9D009EB4  1040000B   BEQ V0, ZERO, 0x9D009EE4
9D009EB8  00000000   NOP
1158:                						{
1159:                							/* The task waiting has a higher priority so record that a
1160:                							context	switch is required. */
1161:                							if( pxHigherPriorityTaskWoken != NULL )
9D009EBC  12A00008   BEQ S5, ZERO, 0x9D009EE0
9D009EC0  24020001   ADDIU V0, ZERO, 1
9D009EC4  0B4027B9   J 0x9D009EE4
9D009EC8  AEA20000   SW V0, 0(S5)
1162:                							{
1163:                								*pxHigherPriorityTaskWoken = pdTRUE;
1164:                							}
1165:                							else
1166:                							{
1167:                								mtCOVERAGE_TEST_MARKER();
1168:                							}
1169:                						}
1170:                						else
1171:                						{
1172:                							mtCOVERAGE_TEST_MARKER();
1173:                						}
1174:                					}
1175:                					else
1176:                					{
1177:                						mtCOVERAGE_TEST_MARKER();
1178:                					}
1179:                				}
1180:                				#endif /* configUSE_QUEUE_SETS */
1181:                			}
1182:                			else
1183:                			{
1184:                				/* Increment the lock count so the task that unlocks the queue
1185:                				knows that data was posted while it was locked. */
1186:                				++( pxQueue->xTxLock );
9D009ECC  8E020048   LW V0, 72(S0)
9D009ED0  24420001   ADDIU V0, V0, 1
9D009ED4  AE020048   SW V0, 72(S0)
1187:                			}
1188:                
1189:                			xReturn = pdPASS;
9D009ED8  0B4027B9   J 0x9D009EE4
9D009EDC  24110001   ADDIU S1, ZERO, 1
9D009EE0  24110001   ADDIU S1, ZERO, 1
1190:                		}
1191:                		else
1192:                		{
1193:                			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1194:                			xReturn = errQUEUE_FULL;
1195:                		}
1196:                	}
1197:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
9D009EE4  0F4036A7   JAL vPortClearInterruptMaskFromISR
9D009EE8  02602021   ADDU A0, S3, ZERO
1198:                
1199:                	return xReturn;
1200:                }
9D009EEC  02201021   ADDU V0, S1, ZERO
9D009EF0  8FBF002C   LW RA, 44(SP)
9D009EF4  8FB50028   LW S5, 40(SP)
9D009EF8  8FB40024   LW S4, 36(SP)
9D009EFC  8FB30020   LW S3, 32(SP)
9D009F00  8FB2001C   LW S2, 28(SP)
9D009F04  8FB10018   LW S1, 24(SP)
9D009F08  8FB00014   LW S0, 20(SP)
9D009F0C  03E00008   JR RA
9D009F10  27BD0030   ADDIU SP, SP, 48
1201:                /*-----------------------------------------------------------*/
1202:                
1203:                BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1204:                {
00000000  00000000   NOP
1205:                BaseType_t xReturn;
1206:                UBaseType_t uxSavedInterruptStatus;
1207:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1208:                
1209:                	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1210:                	item size is 0.  Don't directly wake a task that was blocked on a queue
1211:                	read, instead return a flag to say whether a context switch is required or
1212:                	not (i.e. has a task with a higher priority than us been woken by this
1213:                	post). */
1214:                
1215:                	configASSERT( pxQueue );
1216:                
1217:                	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1218:                	if the item size is not 0. */
1219:                	configASSERT( pxQueue->uxItemSize == 0 );
1220:                
1221:                	/* Normally a mutex would not be given from an interrupt, especially if
1222:                	there is a mutex holder, as priority inheritance makes no sense for an
1223:                	interrupts, only tasks. */
1224:                	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
1225:                
1226:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1227:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1228:                	above the maximum system call priority are kept permanently enabled, even
1229:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1230:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1231:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1232:                	failure if a FreeRTOS API function is called from an interrupt that has been
1233:                	assigned a priority above the configured maximum system call priority.
1234:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1235:                	that have been assigned a priority at or (logically) below the maximum
1236:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1237:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1238:                	More information (albeit Cortex-M specific) is provided on the following
1239:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1240:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1241:                
1242:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0000001C  00000000   NOP
1243:                	{
1244:                		/* When the queue is used to implement a semaphore no data is ever
1245:                		moved through the queue but it is still valid to see if the queue 'has
1246:                		space'. */
1247:                		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
00000028  00000000   NOP
1248:                		{
1249:                			traceQUEUE_SEND_FROM_ISR( pxQueue );
1250:                
1251:                			/* A task can only have an inherited priority if it is a mutex
1252:                			holder - and if there is a mutex holder then the mutex cannot be
1253:                			given from an ISR.  As this is the ISR version of the function it
1254:                			can be assumed there is no mutex holder and no need to determine if
1255:                			priority disinheritance is needed.  Simply increase the count of
1256:                			messages (semaphores) available. */
1257:                			++( pxQueue->uxMessagesWaiting );
0000003C  00000000   NOP
1258:                
1259:                			/* The event list is not altered if the queue is locked.  This will
1260:                			be done when the queue is unlocked later. */
1261:                			if( pxQueue->xTxLock == queueUNLOCKED )
00000048  00000000   NOP
1262:                			{
1263:                				#if ( configUSE_QUEUE_SETS == 1 )
1264:                				{
1265:                					if( pxQueue->pxQueueSetContainer != NULL )
1266:                					{
1267:                						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1268:                						{
1269:                							/* The semaphore is a member of a queue set, and
1270:                							posting	to the queue set caused a higher priority
1271:                							task to	unblock.  A context switch is required. */
1272:                							if( pxHigherPriorityTaskWoken != NULL )
1273:                							{
1274:                								*pxHigherPriorityTaskWoken = pdTRUE;
1275:                							}
1276:                							else
1277:                							{
1278:                								mtCOVERAGE_TEST_MARKER();
1279:                							}
1280:                						}
1281:                						else
1282:                						{
1283:                							mtCOVERAGE_TEST_MARKER();
1284:                						}
1285:                					}
1286:                					else
1287:                					{
1288:                						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1289:                						{
1290:                							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1291:                							{
1292:                								/* The task waiting has a higher priority so
1293:                								record that a context switch is required. */
1294:                								if( pxHigherPriorityTaskWoken != NULL )
1295:                								{
1296:                									*pxHigherPriorityTaskWoken = pdTRUE;
1297:                								}
1298:                								else
1299:                								{
1300:                									mtCOVERAGE_TEST_MARKER();
1301:                								}
1302:                							}
1303:                							else
1304:                							{
1305:                								mtCOVERAGE_TEST_MARKER();
1306:                							}
1307:                						}
1308:                						else
1309:                						{
1310:                							mtCOVERAGE_TEST_MARKER();
1311:                						}
1312:                					}
1313:                				}
1314:                				#else /* configUSE_QUEUE_SETS */
1315:                				{
1316:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00000058  00000000   NOP
1317:                					{
1318:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00000064  00000000   NOP
1319:                						{
1320:                							/* The task waiting has a higher priority so record that a
1321:                							context	switch is required. */
1322:                							if( pxHigherPriorityTaskWoken != NULL )
00000074  00000000   NOP
1323:                							{
1324:                								*pxHigherPriorityTaskWoken = pdTRUE;
1325:                							}
1326:                							else
1327:                							{
1328:                								mtCOVERAGE_TEST_MARKER();
1329:                							}
1330:                						}
1331:                						else
1332:                						{
1333:                							mtCOVERAGE_TEST_MARKER();
1334:                						}
1335:                					}
1336:                					else
1337:                					{
1338:                						mtCOVERAGE_TEST_MARKER();
1339:                					}
1340:                				}
1341:                				#endif /* configUSE_QUEUE_SETS */
1342:                			}
1343:                			else
1344:                			{
1345:                				/* Increment the lock count so the task that unlocks the queue
1346:                				knows that data was posted while it was locked. */
1347:                				++( pxQueue->xTxLock );
00000084  00000000   NOP
1348:                			}
1349:                
1350:                			xReturn = pdPASS;
00000090  00000000   NOP
1351:                		}
1352:                		else
1353:                		{
1354:                			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1355:                			xReturn = errQUEUE_FULL;
1356:                		}
1357:                	}
1358:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000009C  00000000   NOP
1359:                
1360:                	return xReturn;
1361:                }
000000A4  00000000   NOP
1362:                /*-----------------------------------------------------------*/
1363:                
1364:                BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
1365:                {
9D005974  27BDFFC8   ADDIU SP, SP, -56
9D005978  AFBF0034   SW RA, 52(SP)
9D00597C  AFB60030   SW S6, 48(SP)
9D005980  AFB5002C   SW S5, 44(SP)
9D005984  AFB40028   SW S4, 40(SP)
9D005988  AFB30024   SW S3, 36(SP)
9D00598C  AFB20020   SW S2, 32(SP)
9D005990  AFB1001C   SW S1, 28(SP)
9D005994  AFB00018   SW S0, 24(SP)
9D005998  00808021   ADDU S0, A0, ZERO
9D00599C  00A0A821   ADDU S5, A1, ZERO
9D0059A0  AFA60040   SW A2, 64(SP)
9D0059A4  00E0A021   ADDU S4, A3, ZERO
1366:                BaseType_t xEntryTimeSet = pdFALSE;
9D0059A8  00009021   ADDU S2, ZERO, ZERO
1367:                TimeOut_t xTimeOut;
1368:                int8_t *pcOriginalReadPosition;
1369:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1370:                
1371:                	configASSERT( pxQueue );
1372:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1373:                	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1374:                	{
1375:                		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1376:                	}
1377:                	#endif
1378:                
1379:                	/* This function relaxes the coding standard somewhat to allow return
1380:                	statements within the function itself.  This is done in the interest
1381:                	of execution time efficiency. */
1382:                
1383:                	for( ;; )
1384:                	{
1385:                		taskENTER_CRITICAL();
9D0059B4  0F40339E   JAL vTaskEnterCritical
9D0059B8  00000000   NOP
1386:                		{
1387:                			/* Is there data in the queue now?  To be running the calling task
1388:                			must be	the highest priority task wanting to access the queue. */
1389:                			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
9D0059BC  8E020038   LW V0, 56(S0)
9D0059C0  1040002D   BEQ V0, ZERO, 0x9D005A78
9D0059C4  8FA20040   LW V0, 64(SP)
1390:                			{
1391:                				/* Remember the read position in case the queue is only being
1392:                				peeked. */
1393:                				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
9D0059C8  8E11000C   LW S1, 12(S0)
1394:                
1395:                				prvCopyDataFromQueue( pxQueue, pvBuffer );
9D0059CC  02002021   ADDU A0, S0, ZERO
9D0059D0  0F40338A   JAL prvCopyDataFromQueue
9D0059D4  02A02821   ADDU A1, S5, ZERO
1396:                
1397:                				if( xJustPeeking == pdFALSE )
9D0059D8  56800018   BNEL S4, ZERO, 0x9D005A3C
9D0059DC  AE11000C   SW S1, 12(S0)
1398:                				{
1399:                					traceQUEUE_RECEIVE( pxQueue );
1400:                
1401:                					/* Actually removing data, not just peeking. */
1402:                					--( pxQueue->uxMessagesWaiting );
9D0059E0  8E020038   LW V0, 56(S0)
9D0059E4  2442FFFF   ADDIU V0, V0, -1
9D0059E8  AE020038   SW V0, 56(S0)
1403:                
1404:                					#if ( configUSE_MUTEXES == 1 )
1405:                					{
1406:                						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9D0059EC  8E020000   LW V0, 0(S0)
9D0059F0  54400005   BNEL V0, ZERO, 0x9D005A08
9D0059F4  8E020010   LW V0, 16(S0)
1407:                						{
1408:                							/* Record the information required to implement
1409:                							priority inheritance should it become necessary. */
1410:                							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
9D0059F8  0F403666   JAL pvTaskIncrementMutexHeldCount
9D0059FC  00000000   NOP
9D005A00  AE020004   SW V0, 4(S0)
1411:                						}
1412:                						else
1413:                						{
1414:                							mtCOVERAGE_TEST_MARKER();
1415:                						}
1416:                					}
1417:                					#endif /* configUSE_MUTEXES */
1418:                
1419:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D005A04  8E020010   LW V0, 16(S0)
9D005A08  10400017   BEQ V0, ZERO, 0x9D005A68
9D005A0C  00000000   NOP
1420:                					{
1421:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
9D005A10  0F402AA3   JAL xTaskRemoveFromEventList
9D005A14  26040010   ADDIU A0, S0, 16
9D005A18  24030001   ADDIU V1, ZERO, 1
9D005A1C  14430012   BNE V0, V1, 0x9D005A68
9D005A20  00000000   NOP
1422:                						{
1423:                							queueYIELD_IF_USING_PREEMPTION();
9D005A24  40026800   MFC0 V0, Cause
9D005A28  34420100   ORI V0, V0, 256
9D005A2C  40826800   MTC0 V0, Cause
9D005A30  000000C0   EHB
9D005A34  0B40169A   J 0x9D005A68
9D005A38  00000000   NOP
1424:                						}
1425:                						else
1426:                						{
1427:                							mtCOVERAGE_TEST_MARKER();
1428:                						}
1429:                					}
1430:                					else
1431:                					{
1432:                						mtCOVERAGE_TEST_MARKER();
1433:                					}
1434:                				}
1435:                				else
1436:                				{
1437:                					traceQUEUE_PEEK( pxQueue );
1438:                
1439:                					/* The data is not being removed, so reset the read
1440:                					pointer. */
1441:                					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1442:                
1443:                					/* The data is being left in the queue, so see if there are
1444:                					any other tasks waiting for the data. */
1445:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D005A3C  8E020024   LW V0, 36(S0)
9D005A40  10400009   BEQ V0, ZERO, 0x9D005A68
9D005A44  00000000   NOP
1446:                					{
1447:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D005A48  0F402AA3   JAL xTaskRemoveFromEventList
9D005A4C  26040024   ADDIU A0, S0, 36
9D005A50  10400005   BEQ V0, ZERO, 0x9D005A68
9D005A54  00000000   NOP
1448:                						{
1449:                							/* The task waiting has a higher priority than this task. */
1450:                							queueYIELD_IF_USING_PREEMPTION();
9D005A58  40026800   MFC0 V0, Cause
9D005A5C  34420100   ORI V0, V0, 256
9D005A60  40826800   MTC0 V0, Cause
9D005A64  000000C0   EHB
1451:                						}
1452:                						else
1453:                						{
1454:                							mtCOVERAGE_TEST_MARKER();
1455:                						}
1456:                					}
1457:                					else
1458:                					{
1459:                						mtCOVERAGE_TEST_MARKER();
1460:                					}
1461:                				}
1462:                
1463:                				taskEXIT_CRITICAL();
9D005A68  0F403151   JAL vTaskExitCritical
9D005A6C  00000000   NOP
1464:                				return pdPASS;
9D005A70  0B4016E6   J 0x9D005B98
9D005A74  24020001   ADDIU V0, ZERO, 1
1465:                			}
1466:                			else
1467:                			{
1468:                				if( xTicksToWait == ( TickType_t ) 0 )
9D005A78  14400005   BNE V0, ZERO, 0x9D005A90
9D005A7C  00000000   NOP
1469:                				{
1470:                					/* The queue was empty and no block time is specified (or
1471:                					the block time has expired) so leave now. */
1472:                					taskEXIT_CRITICAL();
9D005A80  0F403151   JAL vTaskExitCritical
9D005A84  00000000   NOP
1473:                					traceQUEUE_RECEIVE_FAILED( pxQueue );
1474:                					return errQUEUE_EMPTY;
9D005A88  0B4016E6   J 0x9D005B98
9D005A8C  00001021   ADDU V0, ZERO, ZERO
1475:                				}
1476:                				else if( xEntryTimeSet == pdFALSE )
9D005A90  16400004   BNE S2, ZERO, 0x9D005AA4
9D005A94  00000000   NOP
1477:                				{
1478:                					/* The queue was empty and a block time was specified so
1479:                					configure the timeout structure. */
1480:                					vTaskSetTimeOutState( &xTimeOut );
9D005A98  0F40373B   JAL vTaskSetTimeOutState
9D005A9C  27A40010   ADDIU A0, SP, 16
1481:                					xEntryTimeSet = pdTRUE;
9D005AA0  24120001   ADDIU S2, ZERO, 1
1482:                				}
1483:                				else
1484:                				{
1485:                					/* Entry time was already set. */
1486:                					mtCOVERAGE_TEST_MARKER();
1487:                				}
1488:                			}
1489:                		}
1490:                		taskEXIT_CRITICAL();
9D005AA4  0F403151   JAL vTaskExitCritical
9D005AA8  00000000   NOP
1491:                
1492:                		/* Interrupts and other tasks can send to and receive from the queue
1493:                		now the critical section has been exited. */
1494:                
1495:                		vTaskSuspendAll();
9D005AAC  0F403736   JAL vTaskSuspendAll
9D005AB0  00000000   NOP
1496:                		prvLockQueue( pxQueue );
9D0059AC  2411FFFF   ADDIU S1, ZERO, -1
9D005AB4  0F40339E   JAL vTaskEnterCritical
9D005AB8  00000000   NOP
9D005ABC  8E020044   LW V0, 68(S0)
9D005AC0  50510001   BEQL V0, S1, 0x9D005AC8
9D005AC4  AE000044   SW ZERO, 68(S0)
9D005AC8  8E020048   LW V0, 72(S0)
9D005ACC  50510001   BEQL V0, S1, 0x9D005AD4
9D005AD0  AE000048   SW ZERO, 72(S0)
9D005AD4  0F403151   JAL vTaskExitCritical
9D005AD8  00000000   NOP
1497:                
1498:                		/* Update the timeout state to see if it has expired yet. */
1499:                		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
9D005ADC  27A40010   ADDIU A0, SP, 16
9D005AE0  0F402C59   JAL xTaskCheckForTimeOut
9D005AE4  27A50040   ADDIU A1, SP, 64
9D005AE8  14400026   BNE V0, ZERO, 0x9D005B84
9D005AEC  00000000   NOP
1500:                		{
1501:                			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
9D005B04  16C00019   BNE S6, ZERO, 0x9D005B6C
9D005B08  00000000   NOP
1502:                			{
1503:                				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1504:                
1505:                				#if ( configUSE_MUTEXES == 1 )
1506:                				{
1507:                					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9D005B0C  8E020000   LW V0, 0(S0)
9D005B10  54400008   BNEL V0, ZERO, 0x9D005B34
9D005B14  02602021   ADDU A0, S3, ZERO
1508:                					{
1509:                						taskENTER_CRITICAL();
9D005B18  0F40339E   JAL vTaskEnterCritical
9D005B1C  00000000   NOP
1510:                						{
1511:                							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
9D005B20  0F40240A   JAL vTaskPriorityInherit
9D005B24  8E040004   LW A0, 4(S0)
1512:                						}
1513:                						taskEXIT_CRITICAL();
9D005B28  0F403151   JAL vTaskExitCritical
9D005B2C  00000000   NOP
1514:                					}
1515:                					else
1516:                					{
1517:                						mtCOVERAGE_TEST_MARKER();
1518:                					}
1519:                				}
1520:                				#endif
1521:                
1522:                				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
9D0059B0  24930024   ADDIU S3, A0, 36
9D005B30  02602021   ADDU A0, S3, ZERO
9D005B34  0F402DD9   JAL vTaskPlaceOnEventList
9D005B38  8FA50040   LW A1, 64(SP)
1523:                				prvUnlockQueue( pxQueue );
9D005B3C  0F40264D   JAL prvUnlockQueue
9D005B40  02002021   ADDU A0, S0, ZERO
1524:                				if( xTaskResumeAll() == pdFALSE )
9D005B44  0F402184   JAL xTaskResumeAll
9D005B48  00000000   NOP
9D005B4C  1440FF99   BNE V0, ZERO, 0x9D0059B4
9D005B50  00000000   NOP
1525:                				{
1526:                					portYIELD_WITHIN_API();
9D005B54  40026800   MFC0 V0, Cause
9D005B58  34420100   ORI V0, V0, 256
9D005B5C  40826800   MTC0 V0, Cause
9D005B60  000000C0   EHB
9D005B64  0B40166D   J 0x9D0059B4
9D005B68  00000000   NOP
1527:                				}
1528:                				else
1529:                				{
1530:                					mtCOVERAGE_TEST_MARKER();
1531:                				}
1532:                			}
1533:                			else
1534:                			{
1535:                				/* Try again. */
1536:                				prvUnlockQueue( pxQueue );
9D005B6C  0F40264D   JAL prvUnlockQueue
9D005B70  02002021   ADDU A0, S0, ZERO
1537:                				( void ) xTaskResumeAll();
9D005B74  0F402184   JAL xTaskResumeAll
9D005B78  00000000   NOP
9D005B7C  0B40166D   J 0x9D0059B4
9D005B80  00000000   NOP
1538:                			}
1539:                		}
1540:                		else
1541:                		{
1542:                			prvUnlockQueue( pxQueue );
9D005B84  0F40264D   JAL prvUnlockQueue
9D005B88  02002021   ADDU A0, S0, ZERO
1543:                			( void ) xTaskResumeAll();
9D005B8C  0F402184   JAL xTaskResumeAll
9D005B90  00000000   NOP
1544:                			traceQUEUE_RECEIVE_FAILED( pxQueue );
1545:                			return errQUEUE_EMPTY;
9D005B94  00001021   ADDU V0, ZERO, ZERO
1546:                		}
1547:                	}
1548:                }
9D005B98  8FBF0034   LW RA, 52(SP)
9D005B9C  8FB60030   LW S6, 48(SP)
9D005BA0  8FB5002C   LW S5, 44(SP)
9D005BA4  8FB40028   LW S4, 40(SP)
9D005BA8  8FB30024   LW S3, 36(SP)
9D005BAC  8FB20020   LW S2, 32(SP)
9D005BB0  8FB1001C   LW S1, 28(SP)
9D005BB4  8FB00018   LW S0, 24(SP)
9D005BB8  03E00008   JR RA
9D005BBC  27BD0038   ADDIU SP, SP, 56
1549:                /*-----------------------------------------------------------*/
1550:                
1551:                BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
1552:                {
00000000  00000000   NOP
1553:                BaseType_t xReturn;
1554:                UBaseType_t uxSavedInterruptStatus;
1555:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1556:                
1557:                	configASSERT( pxQueue );
1558:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1559:                
1560:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1561:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1562:                	above the maximum system call priority are kept permanently enabled, even
1563:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1564:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1565:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1566:                	failure if a FreeRTOS API function is called from an interrupt that has been
1567:                	assigned a priority above the configured maximum system call priority.
1568:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1569:                	that have been assigned a priority at or (logically) below the maximum
1570:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1571:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1572:                	More information (albeit Cortex-M specific) is provided on the following
1573:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1574:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1575:                
1576:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000024  00000000   NOP
1577:                	{
1578:                		/* Cannot block in an ISR, so check there is data available. */
1579:                		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
00000030  00000000   NOP
1580:                		{
1581:                			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1582:                
1583:                			prvCopyDataFromQueue( pxQueue, pvBuffer );
0000003C  00000000   NOP
1584:                			--( pxQueue->uxMessagesWaiting );
00000048  00000000   NOP
1585:                
1586:                			/* If the queue is locked the event list will not be modified.
1587:                			Instead update the lock count so the task that unlocks the queue
1588:                			will know that an ISR has removed data while the queue was
1589:                			locked. */
1590:                			if( pxQueue->xRxLock == queueUNLOCKED )
00000054  00000000   NOP
1591:                			{
1592:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00000064  00000000   NOP
1593:                				{
1594:                					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00000070  00000000   NOP
1595:                					{
1596:                						/* The task waiting has a higher priority than us so
1597:                						force a context switch. */
1598:                						if( pxHigherPriorityTaskWoken != NULL )
00000080  00000000   NOP
1599:                						{
1600:                							*pxHigherPriorityTaskWoken = pdTRUE;
1601:                						}
1602:                						else
1603:                						{
1604:                							mtCOVERAGE_TEST_MARKER();
1605:                						}
1606:                					}
1607:                					else
1608:                					{
1609:                						mtCOVERAGE_TEST_MARKER();
1610:                					}
1611:                				}
1612:                				else
1613:                				{
1614:                					mtCOVERAGE_TEST_MARKER();
1615:                				}
1616:                			}
1617:                			else
1618:                			{
1619:                				/* Increment the lock count so the task that unlocks the queue
1620:                				knows that data was removed while it was locked. */
1621:                				++( pxQueue->xRxLock );
00000090  00000000   NOP
1622:                			}
1623:                
1624:                			xReturn = pdPASS;
0000009C  00000000   NOP
1625:                		}
1626:                		else
1627:                		{
1628:                			xReturn = pdFAIL;
1629:                			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1630:                		}
1631:                	}
1632:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000000A8  00000000   NOP
1633:                
1634:                	return xReturn;
1635:                }
000000B0  00000000   NOP
1636:                /*-----------------------------------------------------------*/
1637:                
1638:                BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1639:                {
00000000  00000000   NOP
1640:                BaseType_t xReturn;
1641:                UBaseType_t uxSavedInterruptStatus;
1642:                int8_t *pcOriginalReadPosition;
1643:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1644:                
1645:                	configASSERT( pxQueue );
1646:                	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1647:                	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1648:                
1649:                	/* RTOS ports that support interrupt nesting have the concept of a maximum
1650:                	system call (or maximum API call) interrupt priority.  Interrupts that are
1651:                	above the maximum system call priority are kept permanently enabled, even
1652:                	when the RTOS kernel is in a critical section, but cannot make any calls to
1653:                	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1654:                	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1655:                	failure if a FreeRTOS API function is called from an interrupt that has been
1656:                	assigned a priority above the configured maximum system call priority.
1657:                	Only FreeRTOS functions that end in FromISR can be called from interrupts
1658:                	that have been assigned a priority at or (logically) below the maximum
1659:                	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1660:                	safe API to ensure interrupt entry is as fast and as simple as possible.
1661:                	More information (albeit Cortex-M specific) is provided on the following
1662:                	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1663:                	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1664:                
1665:                	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0000001C  00000000   NOP
1666:                	{
1667:                		/* Cannot block in an ISR, so check there is data available. */
1668:                		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
00000028  00000000   NOP
1669:                		{
1670:                			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1671:                
1672:                			/* Remember the read position so it can be reset as nothing is
1673:                			actually being removed from the queue. */
1674:                			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
00000034  00000000   NOP
1675:                			prvCopyDataFromQueue( pxQueue, pvBuffer );
00000038  00000000   NOP
1676:                			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00000044  00000000   NOP
1677:                
1678:                			xReturn = pdPASS;
00000048  00000000   NOP
1679:                		}
1680:                		else
1681:                		{
1682:                			xReturn = pdFAIL;
1683:                			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1684:                		}
1685:                	}
1686:                	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000004C  00000000   NOP
1687:                
1688:                	return xReturn;
1689:                }
00000054  00000000   NOP
1690:                /*-----------------------------------------------------------*/
1691:                
1692:                UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1693:                {
00000000  00000000   NOP
1694:                UBaseType_t uxReturn;
1695:                
1696:                	configASSERT( xQueue );
1697:                
1698:                	taskENTER_CRITICAL();
0000000C  00000000   NOP
1699:                	{
1700:                		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
00000014  00000000   NOP
1701:                	}
1702:                	taskEXIT_CRITICAL();
00000018  00000000   NOP
1703:                
1704:                	return uxReturn;
1705:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00000020  00000000   NOP
1706:                /*-----------------------------------------------------------*/
1707:                
1708:                UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1709:                {
00000000  00000000   NOP
1710:                UBaseType_t uxReturn;
1711:                Queue_t *pxQueue;
1712:                
1713:                	pxQueue = ( Queue_t * ) xQueue;
1714:                	configASSERT( pxQueue );
1715:                
1716:                	taskENTER_CRITICAL();
0000000C  00000000   NOP
1717:                	{
1718:                		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
00000014  00000000   NOP
1719:                	}
1720:                	taskEXIT_CRITICAL();
0000001C  00000000   NOP
1721:                
1722:                	return uxReturn;
1723:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00000024  00000000   NOP
1724:                /*-----------------------------------------------------------*/
1725:                
1726:                UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1727:                {
1728:                UBaseType_t uxReturn;
1729:                
1730:                	configASSERT( xQueue );
1731:                
1732:                	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
00000000  00000000   NOP
1733:                
1734:                	return uxReturn;
1735:                } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00000004  00000000   NOP
1736:                /*-----------------------------------------------------------*/
1737:                
1738:                void vQueueDelete( QueueHandle_t xQueue )
1739:                {
00000000  00000000   NOP
1740:                Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1741:                
1742:                	configASSERT( pxQueue );
1743:                
1744:                	traceQUEUE_DELETE( pxQueue );
1745:                	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1746:                	{
1747:                		vQueueUnregisterQueue( pxQueue );
1748:                	}
1749:                	#endif
1750:                	vPortFree( pxQueue );
00000008  00000000   NOP
1751:                }
00000010  00000000   NOP
1752:                /*-----------------------------------------------------------*/
1753:                
1754:                #if ( configUSE_TRACE_FACILITY == 1 )
1755:                
1756:                	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1757:                	{
1758:                		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1759:                	}
1760:                
1761:                #endif /* configUSE_TRACE_FACILITY */
1762:                /*-----------------------------------------------------------*/
1763:                
1764:                #if ( configUSE_TRACE_FACILITY == 1 )
1765:                
1766:                	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1767:                	{
1768:                		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1769:                	}
1770:                
1771:                #endif /* configUSE_TRACE_FACILITY */
1772:                /*-----------------------------------------------------------*/
1773:                
1774:                #if ( configUSE_TRACE_FACILITY == 1 )
1775:                
1776:                	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1777:                	{
1778:                		return ( ( Queue_t * ) xQueue )->ucQueueType;
1779:                	}
1780:                
1781:                #endif /* configUSE_TRACE_FACILITY */
1782:                /*-----------------------------------------------------------*/
1783:                
1784:                static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
1785:                {
9D009B3C  27BDFFE0   ADDIU SP, SP, -32
9D009B40  AFBF001C   SW RA, 28(SP)
9D009B44  AFB10018   SW S1, 24(SP)
9D009B48  AFB00014   SW S0, 20(SP)
9D009B4C  00C08821   ADDU S1, A2, ZERO
1786:                BaseType_t xReturn = pdFALSE;
9D009C14  00001021   ADDU V0, ZERO, ZERO
1787:                
1788:                	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
9D009B50  8C860040   LW A2, 64(A0)
9D009B54  14C00008   BNE A2, ZERO, 0x9D009B78
9D009B58  00808021   ADDU S0, A0, ZERO
1789:                	{
1790:                		#if ( configUSE_MUTEXES == 1 )
1791:                		{
1792:                			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
9D009B5C  8C830000   LW V1, 0(A0)
9D009B60  1460002D   BNE V1, ZERO, 0x9D009C18
9D009B64  00001021   ADDU V0, ZERO, ZERO
1793:                			{
1794:                				/* The mutex is no longer being held. */
1795:                				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
9D009B68  0F40274D   JAL xTaskPriorityDisinherit
9D009B6C  8C840004   LW A0, 4(A0)
9D009B70  0B402706   J 0x9D009C18
9D009B74  AE000004   SW ZERO, 4(S0)
1796:                				pxQueue->pxMutexHolder = NULL;
1797:                			}
1798:                			else
1799:                			{
1800:                				mtCOVERAGE_TEST_MARKER();
1801:                			}
1802:                		}
1803:                		#endif /* configUSE_MUTEXES */
1804:                	}
1805:                	else if( xPosition == queueSEND_TO_BACK )
9D009B78  1620000F   BNE S1, ZERO, 0x9D009BB8
9D009B7C  00000000   NOP
1806:                	{
1807:                		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
9D009B80  0F40207B   JAL 0x9D0081EC
9D009B84  8C840008   LW A0, 8(A0)
1808:                		pxQueue->pcWriteTo += pxQueue->uxItemSize;
9D009B88  8E030008   LW V1, 8(S0)
9D009B8C  8E020040   LW V0, 64(S0)
9D009B90  00621021   ADDU V0, V1, V0
9D009B94  AE020008   SW V0, 8(S0)
1809:                		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
9D009B98  8E030004   LW V1, 4(S0)
9D009B9C  0043182B   SLTU V1, V0, V1
9D009BA0  1460001D   BNE V1, ZERO, 0x9D009C18
9D009BA4  00001021   ADDU V0, ZERO, ZERO
1810:                		{
1811:                			pxQueue->pcWriteTo = pxQueue->pcHead;
9D009BA8  8E020000   LW V0, 0(S0)
9D009BAC  AE020008   SW V0, 8(S0)
9D009BB0  0B402706   J 0x9D009C18
9D009BB4  00001021   ADDU V0, ZERO, ZERO
1812:                		}
1813:                		else
1814:                		{
1815:                			mtCOVERAGE_TEST_MARKER();
1816:                		}
1817:                	}
1818:                	else
1819:                	{
1820:                		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
9D009BB8  0F40207B   JAL 0x9D0081EC
9D009BBC  8C84000C   LW A0, 12(A0)
1821:                		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
9D009BC0  8E030040   LW V1, 64(S0)
9D009BC4  00031823   SUBU V1, ZERO, V1
9D009BC8  8E02000C   LW V0, 12(S0)
9D009BCC  00431021   ADDU V0, V0, V1
9D009BD0  AE02000C   SW V0, 12(S0)
1822:                		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
9D009BD4  8E040000   LW A0, 0(S0)
9D009BD8  0044102B   SLTU V0, V0, A0
9D009BDC  50400005   BEQL V0, ZERO, 0x9D009BF4
9D009BE0  24030002   ADDIU V1, ZERO, 2
1823:                		{
1824:                			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
9D009BE4  8E020004   LW V0, 4(S0)
9D009BE8  00431821   ADDU V1, V0, V1
9D009BEC  AE03000C   SW V1, 12(S0)
1825:                		}
1826:                		else
1827:                		{
1828:                			mtCOVERAGE_TEST_MARKER();
1829:                		}
1830:                
1831:                		if( xPosition == queueOVERWRITE )
9D009BF0  24030002   ADDIU V1, ZERO, 2
9D009BF4  16230008   BNE S1, V1, 0x9D009C18
9D009BF8  00001021   ADDU V0, ZERO, ZERO
1832:                		{
1833:                			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
9D009BFC  8E030038   LW V1, 56(S0)
9D009C00  10600005   BEQ V1, ZERO, 0x9D009C18
9D009C04  00000000   NOP
1834:                			{
1835:                				/* An item is not being added but overwritten, so subtract
1836:                				one from the recorded number of items in the queue so when
1837:                				one is added again below the number of recorded items remains
1838:                				correct. */
1839:                				--( pxQueue->uxMessagesWaiting );
9D009C08  8E020038   LW V0, 56(S0)
9D009C0C  2442FFFF   ADDIU V0, V0, -1
9D009C10  AE020038   SW V0, 56(S0)
1840:                			}
1841:                			else
1842:                			{
1843:                				mtCOVERAGE_TEST_MARKER();
1844:                			}
1845:                		}
1846:                		else
1847:                		{
1848:                			mtCOVERAGE_TEST_MARKER();
1849:                		}
1850:                	}
1851:                
1852:                	++( pxQueue->uxMessagesWaiting );
9D009C18  8E030038   LW V1, 56(S0)
9D009C1C  24630001   ADDIU V1, V1, 1
9D009C20  AE030038   SW V1, 56(S0)
1853:                
1854:                	return xReturn;
1855:                }
9D009C24  8FBF001C   LW RA, 28(SP)
1856:                /*-----------------------------------------------------------*/
1857:                
1858:                static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1859:                {
9D00CE34  27BDFFE8   ADDIU SP, SP, -24
9D00CE38  AFBF0014   SW RA, 20(SP)
1860:                	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
9D00CE28  8C860040   LW A2, 64(A0)
9D00CE2C  10C00010   BEQ A2, ZERO, 0x9D00CE70
9D00CE30  00801021   ADDU V0, A0, ZERO
1861:                	{
1862:                		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
9D00CE3C  8C83000C   LW V1, 12(A0)
9D00CE40  00661821   ADDU V1, V1, A2
9D00CE44  AC83000C   SW V1, 12(A0)
1863:                		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
9D00CE48  8C840004   LW A0, 4(A0)
9D00CE4C  0064182B   SLTU V1, V1, A0
9D00CE50  14600003   BNE V1, ZERO, 0x9D00CE60
9D00CE54  00A02021   ADDU A0, A1, ZERO
1864:                		{
1865:                			pxQueue->u.pcReadFrom = pxQueue->pcHead;
9D00CE58  8C430000   LW V1, 0(V0)
9D00CE5C  AC43000C   SW V1, 12(V0)
1866:                		}
1867:                		else
1868:                		{
1869:                			mtCOVERAGE_TEST_MARKER();
1870:                		}
1871:                		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
9D00CE60  0F40207B   JAL 0x9D0081EC
9D00CE64  8C45000C   LW A1, 12(V0)
1872:                	}
1873:                }
9D00CE68  8FBF0014   LW RA, 20(SP)
9D00CE6C  27BD0018   ADDIU SP, SP, 24
9D00CE70  03E00008   JR RA
9D00CE74  00000000   NOP
1874:                /*-----------------------------------------------------------*/
1875:                
1876:                static void prvUnlockQueue( Queue_t * const pxQueue )
1877:                {
9D009934  27BDFFE0   ADDIU SP, SP, -32
9D009938  AFBF001C   SW RA, 28(SP)
9D00993C  AFB10018   SW S1, 24(SP)
9D009940  AFB00014   SW S0, 20(SP)
1878:                	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1879:                
1880:                	/* The lock counts contains the number of extra data items placed or
1881:                	removed from the queue while the queue was locked.  When a queue is
1882:                	locked items can be added or removed, but the event lists cannot be
1883:                	updated. */
1884:                	taskENTER_CRITICAL();
9D009944  0F40339E   JAL vTaskEnterCritical
9D009948  00808021   ADDU S0, A0, ZERO
1885:                	{
1886:                		/* See if data was added to the queue while it was locked. */
1887:                		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
9D00994C  8E020048   LW V0, 72(S0)
9D009950  18400015   BLEZ V0, 0x9D0099A8
9D009954  2402FFFF   ADDIU V0, ZERO, -1
9D009998  8E020048   LW V0, 72(S0)
9D00999C  5C40FFF3   BGTZL V0, 0x9D00996C
9D0099A0  8E020024   LW V0, 36(S0)
1888:                		{
1889:                			/* Data was posted while the queue was locked.  Are any tasks
1890:                			blocked waiting for data to become available? */
1891:                			#if ( configUSE_QUEUE_SETS == 1 )
1892:                			{
1893:                				if( pxQueue->pxQueueSetContainer != NULL )
1894:                				{
1895:                					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1896:                					{
1897:                						/* The queue is a member of a queue set, and posting to
1898:                						the queue set caused a higher priority task to unblock.
1899:                						A context switch is required. */
1900:                						vTaskMissedYield();
1901:                					}
1902:                					else
1903:                					{
1904:                						mtCOVERAGE_TEST_MARKER();
1905:                					}
1906:                				}
1907:                				else
1908:                				{
1909:                					/* Tasks that are removed from the event list will get added to
1910:                					the pending ready list as the scheduler is still suspended. */
1911:                					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1912:                					{
1913:                						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1914:                						{
1915:                							/* The task waiting has a higher priority so record that a
1916:                							context	switch is required. */
1917:                							vTaskMissedYield();
1918:                						}
1919:                						else
1920:                						{
1921:                							mtCOVERAGE_TEST_MARKER();
1922:                						}
1923:                					}
1924:                					else
1925:                					{
1926:                						break;
1927:                					}
1928:                				}
1929:                			}
1930:                			#else /* configUSE_QUEUE_SETS */
1931:                			{
1932:                				/* Tasks that are removed from the event list will get added to
1933:                				the pending ready list as the scheduler is still suspended. */
1934:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
9D009958  8E020024   LW V0, 36(S0)
9D00995C  10400012   BEQ V0, ZERO, 0x9D0099A8
9D009960  2402FFFF   ADDIU V0, ZERO, -1
9D00996C  1040000E   BEQ V0, ZERO, 0x9D0099A8
9D009970  2402FFFF   ADDIU V0, ZERO, -1
1935:                				{
1936:                					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
9D009964  0B40265D   J 0x9D009974
9D009968  26110024   ADDIU S1, S0, 36
9D009974  0F402AA3   JAL xTaskRemoveFromEventList
9D009978  02202021   ADDU A0, S1, ZERO
9D00997C  10400003   BEQ V0, ZERO, 0x9D00998C
9D009980  00000000   NOP
1937:                					{
1938:                						/* The task waiting has a higher priority so record that a
1939:                						context	switch is required. */
1940:                						vTaskMissedYield();
9D009984  0F403740   JAL vTaskMissedYield
9D009988  00000000   NOP
1941:                					}
1942:                					else
1943:                					{
1944:                						mtCOVERAGE_TEST_MARKER();
1945:                					}
1946:                				}
1947:                				else
1948:                				{
1949:                					break;
1950:                				}
1951:                			}
1952:                			#endif /* configUSE_QUEUE_SETS */
1953:                
1954:                			--( pxQueue->xTxLock );
9D00998C  8E020048   LW V0, 72(S0)
9D009990  2442FFFF   ADDIU V0, V0, -1
9D009994  AE020048   SW V0, 72(S0)
1955:                		}
1956:                
1957:                		pxQueue->xTxLock = queueUNLOCKED;
9D0099A4  2402FFFF   ADDIU V0, ZERO, -1
9D0099A8  AE020048   SW V0, 72(S0)
1958:                	}
1959:                	taskEXIT_CRITICAL();
9D0099AC  0F403151   JAL vTaskExitCritical
9D0099B0  00000000   NOP
1960:                
1961:                	/* Do the same for the Rx lock. */
1962:                	taskENTER_CRITICAL();
9D0099B4  0F40339E   JAL vTaskEnterCritical
9D0099B8  00000000   NOP
1963:                	{
1964:                		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
9D0099BC  8E020044   LW V0, 68(S0)
9D0099C0  18400015   BLEZ V0, 0x9D009A18
9D0099C4  2402FFFF   ADDIU V0, ZERO, -1
9D009A08  8E020044   LW V0, 68(S0)
9D009A0C  5C40FFF3   BGTZL V0, 0x9D0099DC
9D009A10  8E020010   LW V0, 16(S0)
1965:                		{
1966:                			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
9D0099C8  8E020010   LW V0, 16(S0)
9D0099CC  10400011   BEQ V0, ZERO, 0x9D009A14
9D0099D0  26110010   ADDIU S1, S0, 16
9D0099D4  0B402679   J 0x9D0099E4
9D0099D8  00000000   NOP
9D0099DC  1040000E   BEQ V0, ZERO, 0x9D009A18
9D0099E0  2402FFFF   ADDIU V0, ZERO, -1
1967:                			{
1968:                				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
9D0099E4  0F402AA3   JAL xTaskRemoveFromEventList
9D0099E8  02202021   ADDU A0, S1, ZERO
9D0099EC  10400003   BEQ V0, ZERO, 0x9D0099FC
9D0099F0  00000000   NOP
1969:                				{
1970:                					vTaskMissedYield();
9D0099F4  0F403740   JAL vTaskMissedYield
9D0099F8  00000000   NOP
1971:                				}
1972:                				else
1973:                				{
1974:                					mtCOVERAGE_TEST_MARKER();
1975:                				}
1976:                
1977:                				--( pxQueue->xRxLock );
9D0099FC  8E020044   LW V0, 68(S0)
9D009A00  2442FFFF   ADDIU V0, V0, -1
9D009A04  AE020044   SW V0, 68(S0)
1978:                			}
1979:                			else
1980:                			{
1981:                				break;
1982:                			}
1983:                		}
1984:                
1985:                		pxQueue->xRxLock = queueUNLOCKED;
9D009A14  2402FFFF   ADDIU V0, ZERO, -1
9D009A18  AE020044   SW V0, 68(S0)
1986:                	}
1987:                	taskEXIT_CRITICAL();
9D009A1C  0F403151   JAL vTaskExitCritical
9D009A20  00000000   NOP
1988:                }
9D009A24  8FBF001C   LW RA, 28(SP)
9D009A28  8FB10018   LW S1, 24(SP)
9D009A2C  8FB00014   LW S0, 20(SP)
9D009A30  03E00008   JR RA
9D009A34  27BD0020   ADDIU SP, SP, 32
1989:                /*-----------------------------------------------------------*/
1990:                
1991:                static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1992:                {
1993:                BaseType_t xReturn;
1994:                
1995:                	taskENTER_CRITICAL();
9D005AF0  0F40339E   JAL vTaskEnterCritical
1996:                	{
1997:                		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
9D005AF8  8E160038   LW S6, 56(S0)
1998:                		{
1999:                			xReturn = pdTRUE;
2000:                		}
2001:                		else
2002:                		{
2003:                			xReturn = pdFALSE;
2004:                		}
2005:                	}
2006:                	taskEXIT_CRITICAL();
9D005AFC  0F403151   JAL vTaskExitCritical
9D005B00  00000000   NOP
2007:                
2008:                	return xReturn;
2009:                }
2010:                /*-----------------------------------------------------------*/
2011:                
2012:                BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2013:                {
2014:                BaseType_t xReturn;
2015:                
2016:                	configASSERT( xQueue );
2017:                	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
00000000  00000000   NOP
2018:                	{
2019:                		xReturn = pdTRUE;
2020:                	}
2021:                	else
2022:                	{
2023:                		xReturn = pdFALSE;
2024:                	}
2025:                
2026:                	return xReturn;
2027:                } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00000004  00000000   NOP
2028:                /*-----------------------------------------------------------*/
2029:                
2030:                static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2031:                {
2032:                BaseType_t xReturn;
2033:                
2034:                	taskENTER_CRITICAL();
9D0067C0  0F40339E   JAL vTaskEnterCritical
2035:                	{
2036:                		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
9D0067C8  8E1E0038   LW S8, 56(S0)
2037:                		{
2038:                			xReturn = pdTRUE;
2039:                		}
2040:                		else
2041:                		{
2042:                			xReturn = pdFALSE;
2043:                		}
2044:                	}
2045:                	taskEXIT_CRITICAL();
9D0067CC  0F403151   JAL vTaskExitCritical
9D0067D0  8E17003C   LW S7, 60(S0)
2046:                
2047:                	return xReturn;
2048:                }
2049:                /*-----------------------------------------------------------*/
2050:                
2051:                BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2052:                {
2053:                BaseType_t xReturn;
2054:                
2055:                	configASSERT( xQueue );
2056:                	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
00000000  00000000   NOP
2057:                	{
2058:                		xReturn = pdTRUE;
2059:                	}
2060:                	else
2061:                	{
2062:                		xReturn = pdFALSE;
2063:                	}
2064:                
2065:                	return xReturn;
2066:                } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
0000000C  00000000   NOP
2067:                /*-----------------------------------------------------------*/
2068:                
2069:                #if ( configUSE_CO_ROUTINES == 1 )
2070:                
2071:                	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
2072:                	{
2073:                	BaseType_t xReturn;
2074:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2075:                
2076:                		/* If the queue is already full we may have to block.  A critical section
2077:                		is required to prevent an interrupt removing something from the queue
2078:                		between the check to see if the queue is full and blocking on the queue. */
2079:                		portDISABLE_INTERRUPTS();
2080:                		{
2081:                			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2082:                			{
2083:                				/* The queue is full - do we want to block or just leave without
2084:                				posting? */
2085:                				if( xTicksToWait > ( TickType_t ) 0 )
2086:                				{
2087:                					/* As this is called from a coroutine we cannot block directly, but
2088:                					return indicating that we need to block. */
2089:                					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2090:                					portENABLE_INTERRUPTS();
2091:                					return errQUEUE_BLOCKED;
2092:                				}
2093:                				else
2094:                				{
2095:                					portENABLE_INTERRUPTS();
2096:                					return errQUEUE_FULL;
2097:                				}
2098:                			}
2099:                		}
2100:                		portENABLE_INTERRUPTS();
2101:                
2102:                		portDISABLE_INTERRUPTS();
2103:                		{
2104:                			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2105:                			{
2106:                				/* There is room in the queue, copy the data into the queue. */
2107:                				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2108:                				xReturn = pdPASS;
2109:                
2110:                				/* Were any co-routines waiting for data to become available? */
2111:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2112:                				{
2113:                					/* In this instance the co-routine could be placed directly
2114:                					into the ready list as we are within a critical section.
2115:                					Instead the same pending ready list mechanism is used as if
2116:                					the event were caused from within an interrupt. */
2117:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2118:                					{
2119:                						/* The co-routine waiting has a higher priority so record
2120:                						that a yield might be appropriate. */
2121:                						xReturn = errQUEUE_YIELD;
2122:                					}
2123:                					else
2124:                					{
2125:                						mtCOVERAGE_TEST_MARKER();
2126:                					}
2127:                				}
2128:                				else
2129:                				{
2130:                					mtCOVERAGE_TEST_MARKER();
2131:                				}
2132:                			}
2133:                			else
2134:                			{
2135:                				xReturn = errQUEUE_FULL;
2136:                			}
2137:                		}
2138:                		portENABLE_INTERRUPTS();
2139:                
2140:                		return xReturn;
2141:                	}
2142:                
2143:                #endif /* configUSE_CO_ROUTINES */
2144:                /*-----------------------------------------------------------*/
2145:                
2146:                #if ( configUSE_CO_ROUTINES == 1 )
2147:                
2148:                	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2149:                	{
2150:                	BaseType_t xReturn;
2151:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2152:                
2153:                		/* If the queue is already empty we may have to block.  A critical section
2154:                		is required to prevent an interrupt adding something to the queue
2155:                		between the check to see if the queue is empty and blocking on the queue. */
2156:                		portDISABLE_INTERRUPTS();
2157:                		{
2158:                			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2159:                			{
2160:                				/* There are no messages in the queue, do we want to block or just
2161:                				leave with nothing? */
2162:                				if( xTicksToWait > ( TickType_t ) 0 )
2163:                				{
2164:                					/* As this is a co-routine we cannot block directly, but return
2165:                					indicating that we need to block. */
2166:                					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2167:                					portENABLE_INTERRUPTS();
2168:                					return errQUEUE_BLOCKED;
2169:                				}
2170:                				else
2171:                				{
2172:                					portENABLE_INTERRUPTS();
2173:                					return errQUEUE_FULL;
2174:                				}
2175:                			}
2176:                			else
2177:                			{
2178:                				mtCOVERAGE_TEST_MARKER();
2179:                			}
2180:                		}
2181:                		portENABLE_INTERRUPTS();
2182:                
2183:                		portDISABLE_INTERRUPTS();
2184:                		{
2185:                			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2186:                			{
2187:                				/* Data is available from the queue. */
2188:                				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2189:                				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2190:                				{
2191:                					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2192:                				}
2193:                				else
2194:                				{
2195:                					mtCOVERAGE_TEST_MARKER();
2196:                				}
2197:                				--( pxQueue->uxMessagesWaiting );
2198:                				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2199:                
2200:                				xReturn = pdPASS;
2201:                
2202:                				/* Were any co-routines waiting for space to become available? */
2203:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2204:                				{
2205:                					/* In this instance the co-routine could be placed directly
2206:                					into the ready list as we are within a critical section.
2207:                					Instead the same pending ready list mechanism is used as if
2208:                					the event were caused from within an interrupt. */
2209:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2210:                					{
2211:                						xReturn = errQUEUE_YIELD;
2212:                					}
2213:                					else
2214:                					{
2215:                						mtCOVERAGE_TEST_MARKER();
2216:                					}
2217:                				}
2218:                				else
2219:                				{
2220:                					mtCOVERAGE_TEST_MARKER();
2221:                				}
2222:                			}
2223:                			else
2224:                			{
2225:                				xReturn = pdFAIL;
2226:                			}
2227:                		}
2228:                		portENABLE_INTERRUPTS();
2229:                
2230:                		return xReturn;
2231:                	}
2232:                
2233:                #endif /* configUSE_CO_ROUTINES */
2234:                /*-----------------------------------------------------------*/
2235:                
2236:                #if ( configUSE_CO_ROUTINES == 1 )
2237:                
2238:                	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
2239:                	{
2240:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2241:                
2242:                		/* Cannot block within an ISR so if there is no space on the queue then
2243:                		exit without doing anything. */
2244:                		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2245:                		{
2246:                			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2247:                
2248:                			/* We only want to wake one co-routine per ISR, so check that a
2249:                			co-routine has not already been woken. */
2250:                			if( xCoRoutinePreviouslyWoken == pdFALSE )
2251:                			{
2252:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2253:                				{
2254:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2255:                					{
2256:                						return pdTRUE;
2257:                					}
2258:                					else
2259:                					{
2260:                						mtCOVERAGE_TEST_MARKER();
2261:                					}
2262:                				}
2263:                				else
2264:                				{
2265:                					mtCOVERAGE_TEST_MARKER();
2266:                				}
2267:                			}
2268:                			else
2269:                			{
2270:                				mtCOVERAGE_TEST_MARKER();
2271:                			}
2272:                		}
2273:                		else
2274:                		{
2275:                			mtCOVERAGE_TEST_MARKER();
2276:                		}
2277:                
2278:                		return xCoRoutinePreviouslyWoken;
2279:                	}
2280:                
2281:                #endif /* configUSE_CO_ROUTINES */
2282:                /*-----------------------------------------------------------*/
2283:                
2284:                #if ( configUSE_CO_ROUTINES == 1 )
2285:                
2286:                	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
2287:                	{
2288:                	BaseType_t xReturn;
2289:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2290:                
2291:                		/* We cannot block from an ISR, so check there is data available. If
2292:                		not then just leave without doing anything. */
2293:                		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2294:                		{
2295:                			/* Copy the data from the queue. */
2296:                			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2297:                			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2298:                			{
2299:                				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2300:                			}
2301:                			else
2302:                			{
2303:                				mtCOVERAGE_TEST_MARKER();
2304:                			}
2305:                			--( pxQueue->uxMessagesWaiting );
2306:                			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2307:                
2308:                			if( ( *pxCoRoutineWoken ) == pdFALSE )
2309:                			{
2310:                				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2311:                				{
2312:                					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2313:                					{
2314:                						*pxCoRoutineWoken = pdTRUE;
2315:                					}
2316:                					else
2317:                					{
2318:                						mtCOVERAGE_TEST_MARKER();
2319:                					}
2320:                				}
2321:                				else
2322:                				{
2323:                					mtCOVERAGE_TEST_MARKER();
2324:                				}
2325:                			}
2326:                			else
2327:                			{
2328:                				mtCOVERAGE_TEST_MARKER();
2329:                			}
2330:                
2331:                			xReturn = pdPASS;
2332:                		}
2333:                		else
2334:                		{
2335:                			xReturn = pdFAIL;
2336:                		}
2337:                
2338:                		return xReturn;
2339:                	}
2340:                
2341:                #endif /* configUSE_CO_ROUTINES */
2342:                /*-----------------------------------------------------------*/
2343:                
2344:                #if ( configQUEUE_REGISTRY_SIZE > 0 )
2345:                
2346:                	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2347:                	{
2348:                	UBaseType_t ux;
2349:                
2350:                		/* See if there is an empty space in the registry.  A NULL name denotes
2351:                		a free slot. */
2352:                		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2353:                		{
2354:                			if( xQueueRegistry[ ux ].pcQueueName == NULL )
2355:                			{
2356:                				/* Store the information on this queue. */
2357:                				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
2358:                				xQueueRegistry[ ux ].xHandle = xQueue;
2359:                
2360:                				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2361:                				break;
2362:                			}
2363:                			else
2364:                			{
2365:                				mtCOVERAGE_TEST_MARKER();
2366:                			}
2367:                		}
2368:                	}
2369:                
2370:                #endif /* configQUEUE_REGISTRY_SIZE */
2371:                /*-----------------------------------------------------------*/
2372:                
2373:                #if ( configQUEUE_REGISTRY_SIZE > 0 )
2374:                
2375:                	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2376:                	{
2377:                	UBaseType_t ux;
2378:                
2379:                		/* See if the handle of the queue being unregistered in actually in the
2380:                		registry. */
2381:                		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2382:                		{
2383:                			if( xQueueRegistry[ ux ].xHandle == xQueue )
2384:                			{
2385:                				/* Set the name to NULL to show that this slot if free again. */
2386:                				xQueueRegistry[ ux ].pcQueueName = NULL;
2387:                				break;
2388:                			}
2389:                			else
2390:                			{
2391:                				mtCOVERAGE_TEST_MARKER();
2392:                			}
2393:                		}
2394:                
2395:                	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2396:                
2397:                #endif /* configQUEUE_REGISTRY_SIZE */
2398:                /*-----------------------------------------------------------*/
2399:                
2400:                #if ( configUSE_TIMERS == 1 )
2401:                
2402:                	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
2403:                	{
2404:                	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2405:                
2406:                		/* This function should not be called by application code hence the
2407:                		'Restricted' in its name.  It is not part of the public API.  It is
2408:                		designed for use by kernel code, and has special calling requirements.
2409:                		It can result in vListInsert() being called on a list that can only
2410:                		possibly ever have one item in it, so the list will be fast, but even
2411:                		so it should be called with the scheduler locked and not from a critical
2412:                		section. */
2413:                
2414:                		/* Only do anything if there are no messages in the queue.  This function
2415:                		will not actually cause the task to block, just place it on a blocked
2416:                		list.  It will not block until the scheduler is unlocked - at which
2417:                		time a yield will be performed.  If an item is added to the queue while
2418:                		the queue is locked, and the calling task blocks on the queue, then the
2419:                		calling task will be immediately unblocked when the queue is unlocked. */
2420:                		prvLockQueue( pxQueue );
2421:                		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
2422:                		{
2423:                			/* There is nothing in the queue, block for the specified period. */
2424:                			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
2425:                		}
2426:                		else
2427:                		{
2428:                			mtCOVERAGE_TEST_MARKER();
2429:                		}
2430:                		prvUnlockQueue( pxQueue );
2431:                	}
2432:                
2433:                #endif /* configUSE_TIMERS */
2434:                /*-----------------------------------------------------------*/
2435:                
2436:                #if ( configUSE_QUEUE_SETS == 1 )
2437:                
2438:                	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2439:                	{
2440:                	QueueSetHandle_t pxQueue;
2441:                
2442:                		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
2443:                
2444:                		return pxQueue;
2445:                	}
2446:                
2447:                #endif /* configUSE_QUEUE_SETS */
2448:                /*-----------------------------------------------------------*/
2449:                
2450:                #if ( configUSE_QUEUE_SETS == 1 )
2451:                
2452:                	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2453:                	{
2454:                	BaseType_t xReturn;
2455:                
2456:                		taskENTER_CRITICAL();
2457:                		{
2458:                			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
2459:                			{
2460:                				/* Cannot add a queue/semaphore to more than one queue set. */
2461:                				xReturn = pdFAIL;
2462:                			}
2463:                			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
2464:                			{
2465:                				/* Cannot add a queue/semaphore to a queue set if there are already
2466:                				items in the queue/semaphore. */
2467:                				xReturn = pdFAIL;
2468:                			}
2469:                			else
2470:                			{
2471:                				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
2472:                				xReturn = pdPASS;
2473:                			}
2474:                		}
2475:                		taskEXIT_CRITICAL();
2476:                
2477:                		return xReturn;
2478:                	}
2479:                
2480:                #endif /* configUSE_QUEUE_SETS */
2481:                /*-----------------------------------------------------------*/
2482:                
2483:                #if ( configUSE_QUEUE_SETS == 1 )
2484:                
2485:                	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2486:                	{
2487:                	BaseType_t xReturn;
2488:                	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
2489:                
2490:                		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
2491:                		{
2492:                			/* The queue was not a member of the set. */
2493:                			xReturn = pdFAIL;
2494:                		}
2495:                		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
2496:                		{
2497:                			/* It is dangerous to remove a queue from a set when the queue is
2498:                			not empty because the queue set will still hold pending events for
2499:                			the queue. */
2500:                			xReturn = pdFAIL;
2501:                		}
2502:                		else
2503:                		{
2504:                			taskENTER_CRITICAL();
2505:                			{
2506:                				/* The queue is no longer contained in the set. */
2507:                				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
2508:                			}
2509:                			taskEXIT_CRITICAL();
2510:                			xReturn = pdPASS;
2511:                		}
2512:                
2513:                		return xReturn;
2514:                	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
2515:                
2516:                #endif /* configUSE_QUEUE_SETS */
2517:                /*-----------------------------------------------------------*/
2518:                
2519:                #if ( configUSE_QUEUE_SETS == 1 )
2520:                
2521:                	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
2522:                	{
2523:                	QueueSetMemberHandle_t xReturn = NULL;
2524:                
2525:                		( void ) xQueueGenericReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
2526:                		return xReturn;
2527:                	}
2528:                
2529:                #endif /* configUSE_QUEUE_SETS */
2530:                /*-----------------------------------------------------------*/
2531:                
2532:                #if ( configUSE_QUEUE_SETS == 1 )
2533:                
2534:                	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2535:                	{
2536:                	QueueSetMemberHandle_t xReturn = NULL;
2537:                
2538:                		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
2539:                		return xReturn;
2540:                	}
2541:                
2542:                #endif /* configUSE_QUEUE_SETS */
2543:                /*-----------------------------------------------------------*/
2544:                
2545:                #if ( configUSE_QUEUE_SETS == 1 )
2546:                
2547:                	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
2548:                	{
2549:                	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
2550:                	BaseType_t xReturn = pdFALSE;
2551:                
2552:                		/* This function must be called form a critical section. */
2553:                
2554:                		configASSERT( pxQueueSetContainer );
2555:                		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
2556:                
2557:                		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
2558:                		{
2559:                			traceQUEUE_SEND( pxQueueSetContainer );
2560:                
2561:                			/* The data copied is the handle of the queue that contains data. */
2562:                			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
2563:                
2564:                			if( pxQueueSetContainer->xTxLock == queueUNLOCKED )
2565:                			{
2566:                				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
2567:                				{
2568:                					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
2569:                					{
2570:                						/* The task waiting has a higher priority. */
2571:                						xReturn = pdTRUE;
2572:                					}
2573:                					else
2574:                					{
2575:                						mtCOVERAGE_TEST_MARKER();
2576:                					}
2577:                				}
2578:                				else
2579:                				{
2580:                					mtCOVERAGE_TEST_MARKER();
2581:                				}
2582:                			}
2583:                			else
2584:                			{
2585:                				( pxQueueSetContainer->xTxLock )++;
2586:                			}
2587:                		}
2588:                		else
2589:                		{
2590:                			mtCOVERAGE_TEST_MARKER();
2591:                		}
2592:                
2593:                		return xReturn;
2594:                	}
2595:                
2596:                #endif /* configUSE_QUEUE_SETS */
2597:                
2598:                
2599:                
2600:                
2601:                
2602:                
2603:                
2604:                
2605:                
2606:                
2607:                
2608:                
---  c:/microchip/harmony/v1_08_01/third_party/rtos/freertos/source/portable/mplab/pic32mx/port.c  ------
1:                   /*
2:                       FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /*-----------------------------------------------------------
71:                   * Implementation of functions defined in portable.h for the PIC32MX port.
72:                    *----------------------------------------------------------*/
73:                  
74:                  #ifndef __XC
75:                      #error This port is designed to work with XC32.  Please update your C compiler version.
76:                  #endif
77:                  
78:                  /* Scheduler include files. */
79:                  #include "FreeRTOS.h"
80:                  #include "task.h"
81:                  
82:                  /* Hardware specifics. */
83:                  #define portTIMER_PRESCALE	8
84:                  #define portPRESCALE_BITS	1
85:                  
86:                  /* Bits within various registers. */
87:                  #define portIE_BIT						( 0x00000001 )
88:                  #define portEXL_BIT						( 0x00000002 )
89:                  
90:                  /* Bits within the CAUSE register. */
91:                  #define portCORE_SW_0					( 0x00000100 )
92:                  #define portCORE_SW_1					( 0x00000200 )
93:                  
94:                  /* The EXL bit is set to ensure interrupts do not occur while the context of
95:                  the first task is being restored. */
96:                  #define portINITIAL_SR					( portIE_BIT | portEXL_BIT )
97:                  
98:                  /*
99:                  By default port.c generates its tick interrupt from TIMER1.  The user can
100:                 override this behaviour by:
101:                 	1: Providing their own implementation of vApplicationSetupTickTimerInterrupt(),
102:                 	   which is the function that configures the timer.  The function is defined
103:                 	   as a weak symbol in this file so if the same function name is used in the
104:                 	   application code then the version in the application code will be linked
105:                 	   into the application in preference to the version defined in this file.
106:                 	2: Define configTICK_INTERRUPT_VECTOR to the vector number of the timer used
107:                 	   to generate the tick interrupt.  For example, when timer 1 is used then
108:                 	   configTICK_INTERRUPT_VECTOR is set to _TIMER_1_VECTOR.
109:                 	   configTICK_INTERRUPT_VECTOR should be defined in FreeRTOSConfig.h.
110:                 	3: Define configCLEAR_TICK_TIMER_INTERRUPT() to clear the interrupt in the
111:                 	   timer used to generate the tick interrupt.  For example, when timer 1 is
112:                 	   used configCLEAR_TICK_TIMER_INTERRUPT() is defined to
113:                 	   IFS0CLR = _IFS0_T1IF_MASK.
114:                 */
115:                 #ifndef configTICK_INTERRUPT_VECTOR
116:                 	#define configTICK_INTERRUPT_VECTOR _TIMER_1_VECTOR
117:                 	#define configCLEAR_TICK_TIMER_INTERRUPT() IFS0CLR = _IFS0_T1IF_MASK
118:                 #else
119:                 	#ifndef configCLEAR_TICK_TIMER_INTERRUPT
120:                 		#error If configTICK_INTERRUPT_VECTOR is defined in application code then configCLEAR_TICK_TIMER_INTERRUPT must also be defined in application code.
121:                 	#endif
122:                 #endif
123:                 
124:                 /* Let the user override the pre-loading of the initial RA with the address of
125:                 prvTaskExitError() in case it messes up unwinding of the stack in the
126:                 debugger - in which case configTASK_RETURN_ADDRESS can be defined as 0 (NULL). */
127:                 #ifdef configTASK_RETURN_ADDRESS
128:                 	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
129:                 #else
130:                 	#define portTASK_RETURN_ADDRESS	prvTaskExitError
131:                 #endif
132:                 
133:                 /* Set configCHECK_FOR_STACK_OVERFLOW to 3 to add ISR stack checking to task
134:                 stack checking.  A problem in the ISR stack will trigger an assert, not call the
135:                 stack overflow hook function (because the stack overflow hook is specific to a
136:                 task stack, not the ISR stack). */
137:                 #if( configCHECK_FOR_STACK_OVERFLOW > 2 )
138:                 
139:                 	/* Don't use 0xa5 as the stack fill bytes as that is used by the kernerl for
140:                 	the task stacks, and so will legitimately appear in many positions within
141:                 	the ISR stack. */
142:                 	#define portISR_STACK_FILL_BYTE	0xee
143:                 
144:                 	static const uint8_t ucExpectedStackBytes[] = {
145:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
146:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
147:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
148:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE,		\
149:                 									portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE, portISR_STACK_FILL_BYTE };	\
150:                 
151:                 	#define portCHECK_ISR_STACK() configASSERT( ( memcmp( ( void * ) xISRStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) == 0 ) )
152:                 #else
153:                 	/* Define the function away. */
154:                 	#define portCHECK_ISR_STACK()
155:                 #endif /* configCHECK_FOR_STACK_OVERFLOW > 2 */
156:                 
157:                 /*-----------------------------------------------------------*/
158:                 
159:                 
160:                 /*
161:                  * Place the prototype here to ensure the interrupt vector is correctly installed.
162:                  * Note that because the interrupt is written in assembly, the IPL setting in the
163:                  * following line of code has no effect.  The interrupt priority is set by the
164:                  * call to ConfigIntTimer1() in vApplicationSetupTickTimerInterrupt().
165:                  */
166:                 extern void __attribute__( (interrupt(IPL1AUTO), vector( configTICK_INTERRUPT_VECTOR ))) vPortTickInterruptHandler( void );
167:                 
168:                 /*
169:                  * The software interrupt handler that performs the yield.  Note that, because
170:                  * the interrupt is written in assembly, the IPL setting in the following line of
171:                  * code has no effect.  The interrupt priority is set by the call to
172:                  * mConfigIntCoreSW0() in xPortStartScheduler().
173:                  */
174:                 void __attribute__( (interrupt(IPL1AUTO), vector(_CORE_SOFTWARE_0_VECTOR))) vPortYieldISR( void );
175:                 
176:                 /*
177:                  * Used to catch tasks that attempt to return from their implementing function.
178:                  */
179:                 static void prvTaskExitError( void );
180:                 
181:                 /*-----------------------------------------------------------*/
182:                 
183:                 /* Records the interrupt nesting depth.  This is initialised to one as it is
184:                 decremented to 0 when the first task starts. */
185:                 volatile UBaseType_t uxInterruptNesting = 0x01;
186:                 
187:                 /* Stores the task stack pointer when a switch is made to use the system stack. */
188:                 UBaseType_t uxSavedTaskStackPointer = 0;
189:                 
190:                 /* The stack used by interrupt service routines that cause a context switch. */
191:                 StackType_t xISRStack[ configISR_STACK_SIZE ] = { 0 };
192:                 
193:                 /* The top of stack value ensures there is enough space to store 6 registers on
194:                 the callers stack, as some functions seem to want to do this. */
195:                 const StackType_t * const xISRStackTop = &( xISRStack[ configISR_STACK_SIZE - 7 ] );
196:                 
197:                 /*-----------------------------------------------------------*/
198:                 
199:                 /*
200:                  * See header file for description.
201:                  */
202:                 StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
203:                 {
9D00CD2C  27BDFFF8   ADDIU SP, SP, -8
9D00CD30  AFBF0004   SW RA, 4(SP)
204:                 	/* Ensure byte alignment is maintained when leaving this function. */
205:                 	pxTopOfStack--;
206:                 
207:                 	*pxTopOfStack = (StackType_t) 0xDEADBEEF;
9D00CD34  3C02DEAD   LUI V0, -8531
9D00CD38  3442BEEF   ORI V0, V0, -16657
9D00CD3C  AC82FFFC   SW V0, -4(A0)
208:                 	pxTopOfStack--;
209:                 
210:                 	*pxTopOfStack = (StackType_t) 0x12345678;	/* Word to which the stack pointer will be left pointing after context restore. */
9D00CD40  3C021234   LUI V0, 4660
9D00CD44  24425678   ADDIU V0, V0, 22136
9D00CD48  AC82FFF8   SW V0, -8(A0)
211:                 	pxTopOfStack--;
212:                 
213:                 	*pxTopOfStack = (StackType_t) _CP0_GET_CAUSE();
9D00CD4C  40026800   MFC0 V0, Cause
9D00CD50  AC82FFF4   SW V0, -12(A0)
214:                 	pxTopOfStack--;
215:                 
216:                 	*pxTopOfStack = (StackType_t) portINITIAL_SR;/* CP0_STATUS */
9D00CD54  24020003   ADDIU V0, ZERO, 3
9D00CD58  AC82FFF0   SW V0, -16(A0)
217:                 	pxTopOfStack--;
218:                 
219:                 	*pxTopOfStack = (StackType_t) pxCode; 		/* CP0_EPC */
9D00CD5C  AC85FFEC   SW A1, -20(A0)
220:                 	pxTopOfStack--;
221:                 
222:                 	*pxTopOfStack = (StackType_t) portTASK_RETURN_ADDRESS;	/* ra */
9D00CD60  3C029D01   LUI V0, -25343
9D00CD64  2442D874   ADDIU V0, V0, -10124
9D00CD68  AC82FFE8   SW V0, -24(A0)
223:                 	pxTopOfStack -= 15;
224:                 
225:                 	*pxTopOfStack = (StackType_t) pvParameters; /* Parameters to pass in. */
9D00CD6C  AC86FFAC   SW A2, -84(A0)
226:                 	pxTopOfStack -= 15;
227:                 
228:                 	return pxTopOfStack;
229:                 }
9D00CD70  2482FF70   ADDIU V0, A0, -144
9D00CD74  8FBF0004   LW RA, 4(SP)
9D00CD78  03E00008   JR RA
9D00CD7C  27BD0008   ADDIU SP, SP, 8
230:                 /*-----------------------------------------------------------*/
231:                 
232:                 static void prvTaskExitError( void )
233:                 {
9D00D874  27BDFFF8   ADDIU SP, SP, -8
9D00D878  AFBF0004   SW RA, 4(SP)
234:                 	/* A function that implements a task must not exit or attempt to return to
235:                 	its caller as there is nothing to return to.  If a task wants to exit it
236:                 	should instead call vTaskDelete( NULL ).
237:                 
238:                 	Artificially force an assert() to be triggered if configASSERT() is
239:                 	defined, then stop here so application writers can catch the error. */
240:                 	configASSERT( uxSavedTaskStackPointer == 0UL );
241:                 	portDISABLE_INTERRUPTS();
9D00D87C  40026000   MFC0 V0, Status
242:                 	for( ;; );
243:                 }
244:                 /*-----------------------------------------------------------*/
245:                 
246:                 /*
247:                  * Setup a timer for a regular tick.  This function uses peripheral timer 1.
248:                  * The function is declared weak so an application writer can use a different
249:                  * timer by redefining this implementation.  If a different timer is used then
250:                  * configTICK_INTERRUPT_VECTOR must also be defined in FreeRTOSConfig.h to
251:                  * ensure the RTOS provided tick interrupt handler is installed on the correct
252:                  * vector number.  When Timer 1 is used the vector number is defined as
253:                  * _TIMER_1_VECTOR.
254:                  */
255:                 __attribute__(( weak )) void vApplicationSetupTickTimerInterrupt( void )
256:                 {
257:                 const uint32_t ulCompareMatch = ( (configPERIPHERAL_CLOCK_HZ / portTIMER_PRESCALE) / configTICK_RATE_HZ ) - 1;
258:                 
259:                 	T1CON = 0x0000;
9D00C408  3C02BF80   LUI V0, -16512
9D00C40C  AC400600   SW ZERO, 1536(V0)
260:                 	T1CONbits.TCKPS = portPRESCALE_BITS;
9D00C410  3C02BF80   LUI V0, -16512
9D00C414  94440600   LHU A0, 1536(V0)
9D00C418  24030001   ADDIU V1, ZERO, 1
9D00C41C  7C642904   INS A0, V1, 4, 2
9D00C420  A4440600   SH A0, 1536(V0)
261:                 	PR1 = ulCompareMatch;
9D00C424  34059C3F   ORI A1, ZERO, -25537
9D00C428  3C04BF80   LUI A0, -16512
9D00C42C  AC850620   SW A1, 1568(A0)
262:                 	IPC1bits.T1IP = configKERNEL_INTERRUPT_PRIORITY;
9D00C430  3C04BF88   LUI A0, -16504
9D00C434  8C8510A0   LW A1, 4256(A0)
9D00C438  7C652084   INS A1, V1, 2, 3
9D00C43C  AC8510A0   SW A1, 4256(A0)
263:                 
264:                 	/* Clear the interrupt as a starting condition. */
265:                 	IFS0bits.T1IF = 0;
9D00C440  3C04BF88   LUI A0, -16504
9D00C444  8C851030   LW A1, 4144(A0)
9D00C448  7C052104   INS A1, ZERO, 4, 1
9D00C44C  AC851030   SW A1, 4144(A0)
266:                 
267:                 	/* Enable the interrupt. */
268:                 	IEC0bits.T1IE = 1;
9D00C450  3C04BF88   LUI A0, -16504
9D00C454  8C851060   LW A1, 4192(A0)
9D00C458  7C652104   INS A1, V1, 4, 1
9D00C45C  AC851060   SW A1, 4192(A0)
269:                 
270:                 	/* Start the timer. */
271:                 	T1CONbits.TON = 1;
9D00C460  94440600   LHU A0, 1536(V0)
9D00C464  7C647BC4   INS A0, V1, 15, 1
9D00C468  A4440600   SH A0, 1536(V0)
9D00C46C  03E00008   JR RA
9D00C470  00000000   NOP
272:                 }
273:                 /*-----------------------------------------------------------*/
274:                 
275:                 void vPortEndScheduler(void)
276:                 {
00000000  00000000   NOP
277:                 	/* Not implemented in ports where there is nothing to return to.
278:                 	Artificially force an assert. */
279:                 	configASSERT( uxInterruptNesting == 1000UL );
280:                 }
281:                 /*-----------------------------------------------------------*/
282:                 
283:                 BaseType_t xPortStartScheduler( void )
284:                 {
9D00CAC8  27BDFFE8   ADDIU SP, SP, -24
9D00CACC  AFBF0014   SW RA, 20(SP)
285:                 extern void vPortStartFirstTask( void );
286:                 extern void *pxCurrentTCB;
287:                 
288:                 	#if ( configCHECK_FOR_STACK_OVERFLOW > 2 )
289:                 	{
290:                 		/* Fill the ISR stack to make it easy to asses how much is being used. */
291:                 		memset( ( void * ) xISRStack, portISR_STACK_FILL_BYTE, sizeof( xISRStack ) );
292:                 	}
293:                 	#endif /* configCHECK_FOR_STACK_OVERFLOW > 2 */
294:                 
295:                 	/* Clear the software interrupt flag. */
296:                 	IFS0CLR = _IFS0_CS0IF_MASK;
9D00CAD0  24020002   ADDIU V0, ZERO, 2
9D00CAD4  3C03BF88   LUI V1, -16504
9D00CAD8  AC621034   SW V0, 4148(V1)
297:                 
298:                 	/* Set software timer priority. */
299:                 	IPC0CLR = _IPC0_CS0IP_MASK;
9D00CADC  24041C00   ADDIU A0, ZERO, 7168
9D00CAE0  3C03BF88   LUI V1, -16504
9D00CAE4  AC641094   SW A0, 4244(V1)
300:                 	IPC0SET = ( configKERNEL_INTERRUPT_PRIORITY << _IPC0_CS0IP_POSITION );
9D00CAE8  24040400   ADDIU A0, ZERO, 1024
9D00CAEC  3C03BF88   LUI V1, -16504
9D00CAF0  AC641098   SW A0, 4248(V1)
301:                 
302:                 	/* Enable software interrupt. */
303:                 	IEC0CLR = _IEC0_CS0IE_MASK;
9D00CAF4  3C03BF88   LUI V1, -16504
9D00CAF8  AC621064   SW V0, 4196(V1)
304:                 	IEC0SET = 1 << _IEC0_CS0IE_POSITION;
9D00CAFC  3C03BF88   LUI V1, -16504
9D00CB00  AC621068   SW V0, 4200(V1)
305:                 
306:                 	/* Setup the timer to generate the tick.  Interrupts will have been
307:                 	disabled by the time we get here. */
308:                 	vApplicationSetupTickTimerInterrupt();
9D00CB04  0F403102   JAL vApplicationSetupTickTimerInterrupt
9D00CB08  00000000   NOP
309:                 
310:                 	/* Kick off the highest priority task that has been created so far.
311:                 	Its stack location is loaded into uxSavedTaskStackPointer. */
312:                 	uxSavedTaskStackPointer = *( UBaseType_t * ) pxCurrentTCB;
9D00CB0C  8F828088   LW V0, -32632(GP)
9D00CB10  8C420000   LW V0, 0(V0)
313:                 	vPortStartFirstTask();
9D00CB14  0F401169   JAL 0x9D0045A4
9D00CB18  AF828094   SW V0, -32620(GP)
314:                 
315:                 	/* Should never get here as the tasks will now be executing!  Call the task
316:                 	exit error function to prevent compiler warnings about a static function
317:                 	not being called in the case that the application writer overrides this
318:                 	functionality by defining configTASK_RETURN_ADDRESS. */
319:                 	prvTaskExitError();
9D00CB1C  0F40361D   JAL prvTaskExitError
9D00CB20  00000000   NOP
320:                 
321:                 	return pdFALSE;
322:                 }
323:                 /*-----------------------------------------------------------*/
324:                 
325:                 void vPortIncrementTick( void )
326:                 {
9D00CD80  27BDFFE8   ADDIU SP, SP, -24
9D00CD84  AFBF0014   SW RA, 20(SP)
327:                 UBaseType_t uxSavedStatus;
328:                 
329:                 	uxSavedStatus = uxPortSetInterruptMaskFromISR();
9D00CD88  0F40351D   JAL uxPortSetInterruptMaskFromISR
9D00CD8C  AFB00010   SW S0, 16(SP)
330:                 	{
331:                 		if( xTaskIncrementTick() != pdFALSE )
9D00CD90  0F401FB2   JAL xTaskIncrementTick
9D00CD94  00408021   ADDU S0, V0, ZERO
9D00CD98  10400005   BEQ V0, ZERO, vPortIncrementTick::vPortClearInterruptMaskFromISR
9D00CD9C  00000000   NOP
332:                 		{
333:                 			/* Pend a context switch. */
334:                 			_CP0_BIS_CAUSE( portCORE_SW_0 );
9D00CDA0  40026800   MFC0 V0, Cause
9D00CDA4  34420100   ORI V0, V0, 256
9D00CDA8  40826800   MTC0 V0, Cause
9D00CDAC  000000C0   EHB
335:                 		}
336:                 	}
337:                 	vPortClearInterruptMaskFromISR( uxSavedStatus );
338:                 
339:                 	/* Look for the ISR stack getting near or past its limit. */
340:                 	portCHECK_ISR_STACK();
341:                 
342:                 	/* Clear timer interrupt. */
343:                 	configCLEAR_TICK_TIMER_INTERRUPT();
9D00CDB8  24030010   ADDIU V1, ZERO, 16
9D00CDBC  3C02BF88   LUI V0, -16504
9D00CDC0  AC431034   SW V1, 4148(V0)
344:                 }
9D00CDC4  8FBF0014   LW RA, 20(SP)
9D00CDC8  8FB00010   LW S0, 16(SP)
9D00CDCC  03E00008   JR RA
9D00CDD0  27BD0018   ADDIU SP, SP, 24
345:                 /*-----------------------------------------------------------*/
346:                 
347:                 UBaseType_t uxPortSetInterruptMaskFromISR( void )
348:                 {
9D00D474  27BDFFF8   ADDIU SP, SP, -8
9D00D478  AFBF0004   SW RA, 4(SP)
349:                 UBaseType_t uxSavedStatusRegister;
350:                 
351:                 	__builtin_disable_interrupts();
9D00D47C  41626000   DI V0
9D00D480  000000C0   EHB
352:                 	uxSavedStatusRegister = _CP0_GET_STATUS() | 0x01;
9D00D484  40026000   MFC0 V0, Status
353:                 	/* This clears the IPL bits, then sets them to
354:                 	configMAX_SYSCALL_INTERRUPT_PRIORITY.  This function should not be called
355:                 	from an interrupt that has a priority above
356:                 	configMAX_SYSCALL_INTERRUPT_PRIORITY so, when used correctly, the action
357:                 	can only result in the IPL being unchanged or raised, and therefore never
358:                 	lowered. */
359:                 	_CP0_SET_STATUS( ( ( uxSavedStatusRegister & ( ~portALL_IPL_BITS ) ) ) | ( configMAX_SYSCALL_INTERRUPT_PRIORITY << portIPL_SHIFT ) );
9D00D488  3C03FFFF   LUI V1, -1
9D00D48C  246303FF   ADDIU V1, V1, 1023
9D00D490  00431824   AND V1, V0, V1
9D00D494  34630C01   ORI V1, V1, 3073
9D00D498  40836000   MTC0 V1, Status
9D00D49C  000000C0   EHB
360:                 
361:                 	return uxSavedStatusRegister;
362:                 }
9D00D4A0  34420001   ORI V0, V0, 1
9D00D4A4  8FBF0004   LW RA, 4(SP)
9D00D4A8  03E00008   JR RA
9D00D4AC  27BD0008   ADDIU SP, SP, 8
363:                 /*-----------------------------------------------------------*/
364:                 
365:                 void vPortClearInterruptMaskFromISR( UBaseType_t uxSavedStatusRegister )
366:                 {
9D00DA9C  27BDFFF8   ADDIU SP, SP, -8
9D00DAA0  AFBF0004   SW RA, 4(SP)
367:                 	_CP0_SET_STATUS( uxSavedStatusRegister );
9D00CDB0  40906000   MTC0 S0, Status
9D00DAA4  40846000   MTC0 A0, Status
9D00DAA8  000000C0   EHB
368:                 }
9D00DAAC  8FBF0004   LW RA, 4(SP)
9D00DAB0  03E00008   JR RA
9D00DAB4  27BD0008   ADDIU SP, SP, 8
369:                 /*-----------------------------------------------------------*/
370:                 
371:                 
372:                 
373:                 
374:                 
---  c:/microchip/harmony/v1_08_01/third_party/rtos/freertos/source/portable/memmang/heap_1.c  ----------
1:                   /*
2:                       FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  
71:                  /*
72:                   * The simplest possible implementation of pvPortMalloc().  Note that this
73:                   * implementation does NOT allow allocated memory to be freed again.
74:                   *
75:                   * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the
76:                   * memory management pages of http://www.FreeRTOS.org for more information.
77:                   */
78:                  #include <stdlib.h>
79:                  
80:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
81:                  all the API functions to use the MPU wrappers.  That should only be done when
82:                  task.h is included from an application file. */
83:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
84:                  
85:                  #include "FreeRTOS.h"
86:                  #include "task.h"
87:                  
88:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
89:                  
90:                  /* A few bytes might be lost to byte aligning the heap start address. */
91:                  #define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
92:                  
93:                  /* Allocate the memory for the heap. */
94:                  static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
95:                  static size_t xNextFreeByte = ( size_t ) 0;
96:                  
97:                  /*-----------------------------------------------------------*/
98:                  
99:                  void *pvPortMalloc( size_t xWantedSize )
100:                 {
9D00A9CC  27BDFFE0   ADDIU SP, SP, -32
9D00A9D0  AFBF001C   SW RA, 28(SP)
9D00A9D4  AFB10018   SW S1, 24(SP)
9D00A9D8  AFB00014   SW S0, 20(SP)
101:                 void *pvReturn = NULL;
102:                 static uint8_t *pucAlignedHeap = NULL;
103:                 
104:                 	/* Ensure that blocks are always aligned to the required number of bytes. */
105:                 	#if portBYTE_ALIGNMENT != 1
106:                 		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
9D00A9DC  30820007   ANDI V0, A0, 7
9D00A9E0  10400004   BEQ V0, ZERO, 0x9D00A9F4
9D00A9E4  00808021   ADDU S0, A0, ZERO
107:                 		{
108:                 			/* Byte alignment required. */
109:                 			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
9D00A9E8  2402FFF8   ADDIU V0, ZERO, -8
9D00A9EC  00828024   AND S0, A0, V0
9D00A9F0  26100008   ADDIU S0, S0, 8
110:                 		}
111:                 	#endif
112:                 
113:                 	vTaskSuspendAll();
9D00A9F4  0F403736   JAL vTaskSuspendAll
9D00A9F8  00000000   NOP
114:                 	{
115:                 		if( pucAlignedHeap == NULL )
9D00A9FC  8F82808C   LW V0, -32628(GP)
9D00AA00  14400007   BNE V0, ZERO, 0x9D00AA20
9D00AA04  8F828090   LW V0, -32624(GP)
116:                 		{
117:                 			/* Ensure the heap starts on a correctly aligned boundary. */
118:                 			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
9D00AA08  2403FFF8   ADDIU V1, ZERO, -8
9D00AA0C  3C02A000   LUI V0, -24576
9D00AA10  24420CA0   ADDIU V0, V0, 3232
9D00AA14  00431024   AND V0, V0, V1
9D00AA18  AF82808C   SW V0, -32628(GP)
119:                 		}
120:                 
121:                 		/* Check there is enough room left for the allocation. */
122:                 		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
9D00AA1C  8F828090   LW V0, -32624(GP)
9D00AA20  02028021   ADDU S0, S0, V0
9D00AA24  3C030001   LUI V1, 1
9D00AA28  24633878   ADDIU V1, V1, 14456
9D00AA2C  0203182B   SLTU V1, S0, V1
9D00AA30  1060000D   BEQ V1, ZERO, 0x9D00AA68
9D00AA34  0050182B   SLTU V1, V0, S0
9D00AA38  1060000B   BEQ V1, ZERO, 0x9D00AA68
9D00AA3C  00000000   NOP
123:                 			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
124:                 		{
125:                 			/* Return the next free byte then increment the index past this
126:                 			block. */
127:                 			pvReturn = pucAlignedHeap + xNextFreeByte;
9D00AA40  8F91808C   LW S1, -32628(GP)
9D00AA44  02228821   ADDU S1, S1, V0
128:                 			xNextFreeByte += xWantedSize;
129:                 		}
130:                 
131:                 		traceMALLOC( pvReturn, xWantedSize );
132:                 	}
133:                 	( void ) xTaskResumeAll();
9D00AA48  0F402184   JAL xTaskResumeAll
9D00AA4C  AF908090   SW S0, -32624(GP)
9D00AA68  0F402184   JAL xTaskResumeAll
9D00AA6C  00008821   ADDU S1, ZERO, ZERO
9D00AA70  0B402A96   J 0x9D00AA58
9D00AA74  00000000   NOP
134:                 
135:                 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
136:                 	{
137:                 		if( pvReturn == NULL )
9D00AA50  56200009   BNEL S1, ZERO, 0x9D00AA78
9D00AA54  02201021   ADDU V0, S1, ZERO
138:                 		{
139:                 			extern void vApplicationMallocFailedHook( void );
140:                 			vApplicationMallocFailedHook();
9D00AA58  0F403633   JAL vApplicationMallocFailedHook
9D00AA5C  00000000   NOP
141:                 		}
142:                 	}
143:                 	#endif
144:                 
145:                 	return pvReturn;
146:                 }
9D00AA60  0B402A9E   J 0x9D00AA78
9D00AA64  02201021   ADDU V0, S1, ZERO
9D00AA78  8FBF001C   LW RA, 28(SP)
9D00AA7C  8FB10018   LW S1, 24(SP)
9D00AA80  8FB00014   LW S0, 20(SP)
9D00AA84  03E00008   JR RA
9D00AA88  27BD0020   ADDIU SP, SP, 32
147:                 /*-----------------------------------------------------------*/
148:                 
149:                 void vPortFree( void *pv )
150:                 {
9D00DD80  03E00008   JR RA
9D00DD84  00000000   NOP
151:                 	/* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and
152:                 	heap_4.c for alternative implementations, and the memory management pages of
153:                 	http://www.FreeRTOS.org for more information. */
154:                 	( void ) pv;
155:                 
156:                 	/* Force an assert as it is invalid to call this function. */
157:                 	configASSERT( pv == NULL );
158:                 }
159:                 /*-----------------------------------------------------------*/
160:                 
161:                 void vPortInitialiseBlocks( void )
162:                 {
163:                 	/* Only required when static memory is not cleared. */
164:                 	xNextFreeByte = ( size_t ) 0;
165:                 }
166:                 /*-----------------------------------------------------------*/
167:                 
168:                 size_t xPortGetFreeHeapSize( void )
169:                 {
170:                 	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
171:                 }
00000000  00000000   NOP
172:                 
173:                 
174:                 
---  c:/microchip/harmony/v1_08_01/third_party/rtos/freertos/source/list.c  -----------------------------
1:                   /*
2:                       FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  
71:                  #include <stdlib.h>
72:                  #include "FreeRTOS.h"
73:                  #include "list.h"
74:                  
75:                  /*-----------------------------------------------------------
76:                   * PUBLIC LIST API documented in list.h
77:                   *----------------------------------------------------------*/
78:                  
79:                  void vListInitialise( List_t * const pxList )
80:                  {
81:                  	/* The list structure contains a list item which is used to mark the
82:                  	end of the list.  To initialise the list the list end is inserted
83:                  	as the only list entry. */
84:                  	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D00DA24  24820008   ADDIU V0, A0, 8
9D00DA28  AC820004   SW V0, 4(A0)
85:                  
86:                  	/* The list end value is the highest possible value in the list to
87:                  	ensure it remains at the end of the list. */
88:                  	pxList->xListEnd.xItemValue = portMAX_DELAY;
9D00DA2C  2403FFFF   ADDIU V1, ZERO, -1
9D00DA30  AC830008   SW V1, 8(A0)
89:                  
90:                  	/* The list end next and previous pointers point to itself so we know
91:                  	when the list is empty. */
92:                  	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D00DA34  AC82000C   SW V0, 12(A0)
93:                  	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D00DA38  AC820010   SW V0, 16(A0)
94:                  
95:                  	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
9D00DA3C  03E00008   JR RA
9D00DA40  AC800000   SW ZERO, 0(A0)
96:                  
97:                  	/* Write known values into the list if
98:                  	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
99:                  	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
100:                 	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
101:                 }
102:                 /*-----------------------------------------------------------*/
103:                 
104:                 void vListInitialiseItem( ListItem_t * const pxItem )
105:                 {
106:                 	/* Make sure the list item is not recorded as being on a list. */
107:                 	pxItem->pvContainer = NULL;
9D00DD70  03E00008   JR RA
9D00DD74  AC800010   SW ZERO, 16(A0)
108:                 
109:                 	/* Write known values into the list item if
110:                 	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
111:                 	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
112:                 	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
113:                 }
114:                 /*-----------------------------------------------------------*/
115:                 
116:                 void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
117:                 {
118:                 ListItem_t * const pxIndex = pxList->pxIndex;
9D00D7BC  8C820004   LW V0, 4(A0)
119:                 
120:                 	/* Only effective when configASSERT() is also defined, these tests may catch
121:                 	the list data structures being overwritten in memory.  They will not catch
122:                 	data errors caused by incorrect configuration or use of FreeRTOS. */
123:                 	listTEST_LIST_INTEGRITY( pxList );
124:                 	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
125:                 
126:                 	/* Insert a new list item into pxList, but rather than sort the list,
127:                 	makes the new list item the last item to be removed by a call to
128:                 	listGET_OWNER_OF_NEXT_ENTRY(). */
129:                 	pxNewListItem->pxNext = pxIndex;
9D00D7C0  ACA20004   SW V0, 4(A1)
130:                 	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
9D00D7C4  8C430008   LW V1, 8(V0)
9D00D7C8  ACA30008   SW V1, 8(A1)
131:                 
132:                 	/* Only used during decision coverage testing. */
133:                 	mtCOVERAGE_TEST_DELAY();
134:                 
135:                 	pxIndex->pxPrevious->pxNext = pxNewListItem;
9D00D7CC  8C430008   LW V1, 8(V0)
9D00D7D0  AC650004   SW A1, 4(V1)
136:                 	pxIndex->pxPrevious = pxNewListItem;
9D00D7D4  AC450008   SW A1, 8(V0)
137:                 
138:                 	/* Remember which list the item is in. */
139:                 	pxNewListItem->pvContainer = ( void * ) pxList;
9D00D7D8  ACA40010   SW A0, 16(A1)
140:                 
141:                 	( pxList->uxNumberOfItems )++;
9D00D7DC  8C820000   LW V0, 0(A0)
9D00D7E0  24420001   ADDIU V0, V0, 1
9D00D7E4  03E00008   JR RA
9D00D7E8  AC820000   SW V0, 0(A0)
142:                 }
143:                 /*-----------------------------------------------------------*/
144:                 
145:                 void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
146:                 {
147:                 ListItem_t *pxIterator;
148:                 const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
9D00CA6C  8CA70000   LW A3, 0(A1)
149:                 
150:                 	/* Only effective when configASSERT() is also defined, these tests may catch
151:                 	the list data structures being overwritten in memory.  They will not catch
152:                 	data errors caused by incorrect configuration or use of FreeRTOS. */
153:                 	listTEST_LIST_INTEGRITY( pxList );
154:                 	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );
155:                 
156:                 	/* Insert the new list item into the list, sorted in xItemValue order.
157:                 
158:                 	If the list already contains a list item with the same item value then the
159:                 	new list item should be placed after it.  This ensures that TCB's which are
160:                 	stored in ready lists (all of which have the same xItemValue value) get a
161:                 	share of the CPU.  However, if the xItemValue is the same as the back marker
162:                 	the iteration loop below will not end.  Therefore the value is checked
163:                 	first, and the algorithm slightly modified if necessary. */
164:                 	if( xValueOfInsertion == portMAX_DELAY )
9D00CA70  2402FFFF   ADDIU V0, ZERO, -1
9D00CA74  14E20003   BNE A3, V0, 0x9D00CA84
9D00CA78  24830008   ADDIU V1, A0, 8
9D00CA7C  0B4032A8   J 0x9D00CAA0
9D00CA80  8C830010   LW V1, 16(A0)
165:                 	{
166:                 		pxIterator = pxList->xListEnd.pxPrevious;
167:                 	}
168:                 	else
169:                 	{
170:                 		/* *** NOTE ***********************************************************
171:                 		If you find your application is crashing here then likely causes are
172:                 		listed below.  In addition see http://www.freertos.org/FAQHelp.html for
173:                 		more tips, and ensure configASSERT() is defined!
174:                 		http://www.freertos.org/a00110.html#configASSERT
175:                 
176:                 			1) Stack overflow -
177:                 			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
178:                 			2) Incorrect interrupt priority assignment, especially on Cortex-M
179:                 			   parts where numerically high priority values denote low actual
180:                 			   interrupt priorities, which can seem counter intuitive.  See
181:                 			   http://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
182:                 			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
183:                 			   http://www.freertos.org/a00110.html
184:                 			3) Calling an API function from within a critical section or when
185:                 			   the scheduler is suspended, or calling an API function that does
186:                 			   not end in "FromISR" from an interrupt.
187:                 			4) Using a queue or semaphore before it has been initialised or
188:                 			   before the scheduler has been started (are interrupts firing
189:                 			   before vTaskStartScheduler() has been called?).
190:                 		**********************************************************************/
191:                 
192:                 		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
9D00CA84  8C620004   LW V0, 4(V1)
9D00CA88  8C460000   LW A2, 0(V0)
9D00CA8C  00E6302B   SLTU A2, A3, A2
9D00CA90  54C00005   BNEL A2, ZERO, 0x9D00CAA8
9D00CA94  ACA20004   SW V0, 4(A1)
9D00CA98  0B4032A1   J 0x9D00CA84
9D00CA9C  00401821   ADDU V1, V0, ZERO
193:                 		{
194:                 			/* There is nothing to do here, just iterating to the wanted
195:                 			insertion position. */
196:                 		}
197:                 	}
198:                 
199:                 	pxNewListItem->pxNext = pxIterator->pxNext;
9D00CAA0  8C620004   LW V0, 4(V1)
9D00CAA4  ACA20004   SW V0, 4(A1)
200:                 	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
9D00CAA8  AC450008   SW A1, 8(V0)
201:                 	pxNewListItem->pxPrevious = pxIterator;
9D00CAAC  ACA30008   SW V1, 8(A1)
202:                 	pxIterator->pxNext = pxNewListItem;
9D00CAB0  AC650004   SW A1, 4(V1)
203:                 
204:                 	/* Remember which list the item is in.  This allows fast removal of the
205:                 	item later. */
206:                 	pxNewListItem->pvContainer = ( void * ) pxList;
9D00CAB4  ACA40010   SW A0, 16(A1)
207:                 
208:                 	( pxList->uxNumberOfItems )++;
9D00CAB8  8C820000   LW V0, 0(A0)
9D00CABC  24420001   ADDIU V0, V0, 1
9D00CAC0  03E00008   JR RA
9D00CAC4  AC820000   SW V0, 0(A0)
209:                 }
210:                 /*-----------------------------------------------------------*/
211:                 
212:                 UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
213:                 {
214:                 /* The list item knows which list it is in.  Obtain the list from the list
215:                 item. */
216:                 List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
9D00D230  8C830010   LW V1, 16(A0)
217:                 
218:                 	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
9D00D234  8C820004   LW V0, 4(A0)
9D00D238  8C850008   LW A1, 8(A0)
9D00D23C  AC450008   SW A1, 8(V0)
219:                 	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
9D00D240  8C820008   LW V0, 8(A0)
9D00D244  8C850004   LW A1, 4(A0)
9D00D248  AC450004   SW A1, 4(V0)
220:                 
221:                 	/* Only used during decision coverage testing. */
222:                 	mtCOVERAGE_TEST_DELAY();
223:                 
224:                 	/* Make sure the index is left pointing to a valid item. */
225:                 	if( pxList->pxIndex == pxItemToRemove )
9D00D24C  8C620004   LW V0, 4(V1)
9D00D250  54440004   BNEL V0, A0, 0x9D00D264
9D00D254  AC800010   SW ZERO, 16(A0)
226:                 	{
227:                 		pxList->pxIndex = pxItemToRemove->pxPrevious;
9D00D258  8C420008   LW V0, 8(V0)
9D00D25C  AC620004   SW V0, 4(V1)
228:                 	}
229:                 	else
230:                 	{
231:                 		mtCOVERAGE_TEST_MARKER();
232:                 	}
233:                 
234:                 	pxItemToRemove->pvContainer = NULL;
9D00D260  AC800010   SW ZERO, 16(A0)
235:                 	( pxList->uxNumberOfItems )--;
9D00D264  8C620000   LW V0, 0(V1)
9D00D268  2442FFFF   ADDIU V0, V0, -1
236:                 
237:                 	return pxList->uxNumberOfItems;
238:                 }
9D00D26C  03E00008   JR RA
9D00D270  AC620000   SW V0, 0(V1)
239:                 /*-----------------------------------------------------------*/
240:                 
---  c:/microchip/harmony/v1_08_01/third_party/rtos/freertos/source/event_groups.c  ---------------------
1:                   /*
2:                       FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
3:                       All rights reserved
4:                   
5:                       VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                   
7:                       This file is part of the FreeRTOS distribution.
8:                   
9:                       FreeRTOS is free software; you can redistribute it and/or modify it under
10:                      the terms of the GNU General Public License (version 2) as published by the
11:                      Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
12:                  
13:                      ***************************************************************************
14:                      >>!   NOTE: The modification to the GPL is included to allow you to     !<<
15:                      >>!   distribute a combined work that includes FreeRTOS without being   !<<
16:                      >>!   obliged to provide the source code for proprietary components     !<<
17:                      >>!   outside of the FreeRTOS kernel.                                   !<<
18:                      ***************************************************************************
19:                  
20:                      FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
21:                      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
22:                      FOR A PARTICULAR PURPOSE.  Full license text is available on the following
23:                      link: http://www.freertos.org/a00114.html
24:                  
25:                      ***************************************************************************
26:                       *                                                                       *
27:                       *    FreeRTOS provides completely free yet professionally developed,    *
28:                       *    robust, strictly quality controlled, supported, and cross          *
29:                       *    platform software that is more than just the market leader, it     *
30:                       *    is the industry's de facto standard.                               *
31:                       *                                                                       *
32:                       *    Help yourself get started quickly while simultaneously helping     *
33:                       *    to support the FreeRTOS project by purchasing a FreeRTOS           *
34:                       *    tutorial book, reference manual, or both:                          *
35:                       *    http://www.FreeRTOS.org/Documentation                              *
36:                       *                                                                       *
37:                      ***************************************************************************
38:                  
39:                      http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
40:                      the FAQ page "My application does not run, what could be wrong?".  Have you
41:                      defined configASSERT()?
42:                  
43:                      http://www.FreeRTOS.org/support - In return for receiving this top quality
44:                      embedded software for free we request you assist our global community by
45:                      participating in the support forum.
46:                  
47:                      http://www.FreeRTOS.org/training - Investing in training allows your team to
48:                      be as productive as possible as early as possible.  Now you can receive
49:                      FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
50:                      Ltd, and the world's leading authority on the world's leading RTOS.
51:                  
52:                      http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
53:                      including FreeRTOS+Trace - an indispensable productivity tool, a DOS
54:                      compatible FAT file system, and our tiny thread aware UDP/IP stack.
55:                  
56:                      http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
57:                      Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
58:                  
59:                      http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
60:                      Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
61:                      licenses offer ticketed support, indemnification and commercial middleware.
62:                  
63:                      http://www.SafeRTOS.com - High Integrity Systems also provide a safety
64:                      engineered and independently SIL3 certified version for use in safety and
65:                      mission critical applications that require provable dependability.
66:                  
67:                      1 tab == 4 spaces!
68:                  */
69:                  
70:                  /* Standard includes. */
71:                  #include <stdlib.h>
72:                  
73:                  /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
74:                  all the API functions to use the MPU wrappers.  That should only be done when
75:                  task.h is included from an application file. */
76:                  #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
77:                  
78:                  /* FreeRTOS includes. */
79:                  #include "FreeRTOS.h"
80:                  #include "task.h"
81:                  #include "timers.h"
82:                  #include "event_groups.h"
83:                  
84:                  /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
85:                  MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
86:                  header files above, but not in this file, in order to generate the correct
87:                  privileged Vs unprivileged linkage and placement. */
88:                  #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
89:                  
90:                  #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( configUSE_TIMERS == 0 )
91:                  	#error configUSE_TIMERS must be set to 1 to make the xEventGroupSetBitFromISR() function available.
92:                  #endif
93:                  
94:                  #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 0 )
95:                  	#error INCLUDE_xTimerPendFunctionCall must also be set to one to make the xEventGroupSetBitFromISR() function available.
96:                  #endif
97:                  
98:                  /* The following bit fields convey control information in a task's event list
99:                  item value.  It is important they don't clash with the
100:                 taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
101:                 #if configUSE_16_BIT_TICKS == 1
102:                 	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
103:                 	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
104:                 	#define eventWAIT_FOR_ALL_BITS			0x0400U
105:                 	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
106:                 #else
107:                 	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
108:                 	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
109:                 	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
110:                 	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
111:                 #endif
112:                 
113:                 typedef struct xEventGroupDefinition
114:                 {
115:                 	EventBits_t uxEventBits;
116:                 	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
117:                 
118:                 	#if( configUSE_TRACE_FACILITY == 1 )
119:                 		UBaseType_t uxEventGroupNumber;
120:                 	#endif
121:                 
122:                 } EventGroup_t;
123:                 
124:                 /*-----------------------------------------------------------*/
125:                 
126:                 /*
127:                  * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
128:                  * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
129:                  * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
130:                  * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
131:                  * wait condition is met if any of the bits set in uxBitsToWait for are also set
132:                  * in uxCurrentEventBits.
133:                  */
134:                 static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );
135:                 
136:                 /*-----------------------------------------------------------*/
137:                 
138:                 EventGroupHandle_t xEventGroupCreate( void )
139:                 {
00000000  00000000   NOP
140:                 EventGroup_t *pxEventBits;
141:                 
142:                 	pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
0000000C  00000000   NOP
143:                 	if( pxEventBits != NULL )
00000014  00000000   NOP
144:                 	{
145:                 		pxEventBits->uxEventBits = 0;
0000001C  00000000   NOP
146:                 		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
00000020  00000000   NOP
147:                 		traceEVENT_GROUP_CREATE( pxEventBits );
148:                 	}
149:                 	else
150:                 	{
151:                 		traceEVENT_GROUP_CREATE_FAILED();
152:                 	}
153:                 
154:                 	return ( EventGroupHandle_t ) pxEventBits;
155:                 }
00000028  00000000   NOP
156:                 /*-----------------------------------------------------------*/
157:                 
158:                 EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
159:                 {
00000000  00000000   NOP
160:                 EventBits_t uxOriginalBitValue, uxReturn;
161:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
162:                 BaseType_t xAlreadyYielded;
163:                 BaseType_t xTimeoutOccurred = pdFALSE;
164:                 
165:                 	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
166:                 	configASSERT( uxBitsToWaitFor != 0 );
167:                 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
168:                 	{
169:                 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
170:                 	}
171:                 	#endif
172:                 
173:                 	vTaskSuspendAll();
00000028  00000000   NOP
174:                 	{
175:                 		uxOriginalBitValue = pxEventBits->uxEventBits;
00000030  00000000   NOP
176:                 
177:                 		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
00000034  00000000   NOP
178:                 
179:                 		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
00000040  00000000   NOP
180:                 		{
181:                 			/* All the rendezvous bits are now set - no need to block. */
182:                 			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
183:                 
184:                 			/* Rendezvous always clear the bits.  They will have been cleared
185:                 			already unless this is the only task in the rendezvous. */
186:                 			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00000050  00000000   NOP
187:                 
188:                 			xTicksToWait = 0;
189:                 		}
190:                 		else
191:                 		{
192:                 			if( xTicksToWait != ( TickType_t ) 0 )
00000060  00000000   NOP
193:                 			{
194:                 				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
195:                 
196:                 				/* Store the bits that the calling task is waiting for in the
197:                 				task's event list item so the kernel knows when a match is
198:                 				found.  Then enter the blocked state. */
199:                 				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
00000068  00000000   NOP
200:                 
201:                 				/* This assignment is obsolete as uxReturn will get set after
202:                 				the task unblocks, but some compilers mistakenly generate a
203:                 				warning about uxReturn being returned without being set if the
204:                 				assignment is omitted. */
205:                 				uxReturn = 0;
206:                 			}
207:                 			else
208:                 			{
209:                 				/* The rendezvous bits were not set, but no block time was
210:                 				specified - just return the current event bit value. */
211:                 				uxReturn = pxEventBits->uxEventBits;
212:                 			}
213:                 		}
214:                 	}
215:                 	xAlreadyYielded = xTaskResumeAll();
0000007C  00000000   NOP
000000E4  00000000   NOP
216:                 
217:                 	if( xTicksToWait != ( TickType_t ) 0 )
218:                 	{
219:                 		if( xAlreadyYielded == pdFALSE )
00000084  00000000   NOP
220:                 		{
221:                 			portYIELD_WITHIN_API();
0000008C  00000000   NOP
222:                 		}
223:                 		else
224:                 		{
225:                 			mtCOVERAGE_TEST_MARKER();
226:                 		}
227:                 
228:                 		/* The task blocked to wait for its required bits to be set - at this
229:                 		point either the required bits were set or the block time expired.  If
230:                 		the required bits were set they will have been stored in the task's
231:                 		event list item, and they should now be retrieved then cleared. */
232:                 		uxReturn = uxTaskResetEventItemValue();
0000009C  00000000   NOP
233:                 
234:                 		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
000000A8  00000000   NOP
235:                 		{
236:                 			/* The task timed out, just return the current event bit value. */
237:                 			taskENTER_CRITICAL();
000000B4  00000000   NOP
238:                 			{
239:                 				uxReturn = pxEventBits->uxEventBits;
000000BC  00000000   NOP
240:                 
241:                 				/* Although the task got here because it timed out before the
242:                 				bits it was waiting for were set, it is possible that since it
243:                 				unblocked another task has set the bits.  If this is the case
244:                 				then it needs to clear the bits before exiting. */
245:                 				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
000000C0  00000000   NOP
246:                 				{
247:                 					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
000000CC  00000000   NOP
248:                 				}
249:                 				else
250:                 				{
251:                 					mtCOVERAGE_TEST_MARKER();
252:                 				}
253:                 			}
254:                 			taskEXIT_CRITICAL();
000000D4  00000000   NOP
255:                 
256:                 			xTimeoutOccurred = pdTRUE;
257:                 		}
258:                 		else
259:                 		{
260:                 			/* The task unblocked because the bits were set. */
261:                 		}
262:                 
263:                 		/* Control bits might be set as the task had blocked should not be
264:                 		returned. */
265:                 		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
000000DC  00000000   NOP
266:                 	}
267:                 
268:                 	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
269:                 
270:                 	return uxReturn;
271:                 }
000000EC  00000000   NOP
272:                 /*-----------------------------------------------------------*/
273:                 
274:                 EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
275:                 {
00000000  00000000   NOP
276:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
277:                 EventBits_t uxReturn, uxControlBits = 0;
278:                 BaseType_t xWaitConditionMet, xAlreadyYielded;
279:                 BaseType_t xTimeoutOccurred = pdFALSE;
280:                 
281:                 	/* Check the user is not attempting to wait on the bits used by the kernel
282:                 	itself, and that at least one bit is being requested. */
283:                 	configASSERT( xEventGroup );
284:                 	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
285:                 	configASSERT( uxBitsToWaitFor != 0 );
286:                 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
287:                 	{
288:                 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
289:                 	}
290:                 	#endif
291:                 
292:                 	vTaskSuspendAll();
00000028  00000000   NOP
293:                 	{
294:                 		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
295:                 
296:                 		/* Check to see if the wait condition is already met or not. */
297:                 		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
298:                 
299:                 		if( xWaitConditionMet != pdFALSE )
00000050  00000000   NOP
300:                 		{
301:                 			/* The wait condition has already been met so there is no need to
302:                 			block. */
303:                 			uxReturn = uxCurrentEventBits;
304:                 			xTicksToWait = ( TickType_t ) 0;
305:                 
306:                 			/* Clear the wait bits if requested to do so. */
307:                 			if( xClearOnExit != pdFALSE )
00000058  00000000   NOP
308:                 			{
309:                 				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00000060  00000000   NOP
310:                 			}
311:                 			else
312:                 			{
313:                 				mtCOVERAGE_TEST_MARKER();
314:                 			}
315:                 		}
316:                 		else if( xTicksToWait == ( TickType_t ) 0 )
0000006C  00000000   NOP
317:                 		{
318:                 			/* The wait condition has not been met, but no block time was
319:                 			specified, so just return the current value. */
320:                 			uxReturn = uxCurrentEventBits;
321:                 		}
322:                 		else
323:                 		{
324:                 			/* The task is going to block to wait for its required bits to be
325:                 			set.  uxControlBits are used to remember the specified behaviour of
326:                 			this call to xEventGroupWaitBits() - for use when the event bits
327:                 			unblock the task. */
328:                 			if( xClearOnExit != pdFALSE )
329:                 			{
330:                 				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
331:                 			}
332:                 			else
333:                 			{
334:                 				mtCOVERAGE_TEST_MARKER();
335:                 			}
336:                 
337:                 			if( xWaitForAllBits != pdFALSE )
00000074  00000000   NOP
338:                 			{
339:                 				uxControlBits |= eventWAIT_FOR_ALL_BITS;
0000007C  00000000   NOP
340:                 			}
341:                 			else
342:                 			{
343:                 				mtCOVERAGE_TEST_MARKER();
344:                 			}
345:                 
346:                 			/* Store the bits that the calling task is waiting for in the
347:                 			task's event list item so the kernel knows when a match is
348:                 			found.  Then enter the blocked state. */
349:                 			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
00000084  00000000   NOP
350:                 
351:                 			/* This is obsolete as it will get set after the task unblocks, but
352:                 			some compilers mistakenly generate a warning about the variable
353:                 			being returned without being set if it is not done. */
354:                 			uxReturn = 0;
355:                 
356:                 			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
357:                 		}
358:                 	}
359:                 	xAlreadyYielded = xTaskResumeAll();
00000094  00000000   NOP
0000011C  00000000   NOP
360:                 
361:                 	if( xTicksToWait != ( TickType_t ) 0 )
362:                 	{
363:                 		if( xAlreadyYielded == pdFALSE )
0000009C  00000000   NOP
364:                 		{
365:                 			portYIELD_WITHIN_API();
000000A4  00000000   NOP
366:                 		}
367:                 		else
368:                 		{
369:                 			mtCOVERAGE_TEST_MARKER();
370:                 		}
371:                 
372:                 		/* The task blocked to wait for its required bits to be set - at this
373:                 		point either the required bits were set or the block time expired.  If
374:                 		the required bits were set they will have been stored in the task's
375:                 		event list item, and they should now be retrieved then cleared. */
376:                 		uxReturn = uxTaskResetEventItemValue();
000000B4  00000000   NOP
377:                 
378:                 		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
000000C0  00000000   NOP
379:                 		{
380:                 			taskENTER_CRITICAL();
000000CC  00000000   NOP
381:                 			{
382:                 				/* The task timed out, just return the current event bit value. */
383:                 				uxReturn = pxEventBits->uxEventBits;
384:                 
385:                 				/* It is possible that the event bits were updated between this
386:                 				task leaving the Blocked state and running again. */
387:                 				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
000000F4  00000000   NOP
388:                 				{
389:                 					if( xClearOnExit != pdFALSE )
000000FC  00000000   NOP
390:                 					{
391:                 						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00000104  00000000   NOP
392:                 					}
393:                 					else
394:                 					{
395:                 						mtCOVERAGE_TEST_MARKER();
396:                 					}
397:                 				}
398:                 				else
399:                 				{
400:                 					mtCOVERAGE_TEST_MARKER();
401:                 				}
402:                 			}
403:                 			taskEXIT_CRITICAL();
0000010C  00000000   NOP
404:                 
405:                 			/* Prevent compiler warnings when trace macros are not used. */
406:                 			xTimeoutOccurred = pdFALSE;
407:                 		}
408:                 		else
409:                 		{
410:                 			/* The task unblocked because the bits were set. */
411:                 		}
412:                 
413:                 		/* The task blocked so control bits may have been set. */
414:                 		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
00000114  00000000   NOP
415:                 	}
416:                 	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
417:                 
418:                 	return uxReturn;
419:                 }
00000124  00000000   NOP
420:                 /*-----------------------------------------------------------*/
421:                 
422:                 EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
423:                 {
00000000  00000000   NOP
424:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
425:                 EventBits_t uxReturn;
426:                 
427:                 	/* Check the user is not attempting to clear the bits used by the kernel
428:                 	itself. */
429:                 	configASSERT( xEventGroup );
430:                 	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
431:                 
432:                 	taskENTER_CRITICAL();
00000018  00000000   NOP
433:                 	{
434:                 		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
435:                 
436:                 		/* The value returned is the event group value prior to the bits being
437:                 		cleared. */
438:                 		uxReturn = pxEventBits->uxEventBits;
00000020  00000000   NOP
439:                 
440:                 		/* Clear the bits. */
441:                 		pxEventBits->uxEventBits &= ~uxBitsToClear;
00000024  00000000   NOP
442:                 	}
443:                 	taskEXIT_CRITICAL();
0000002C  00000000   NOP
444:                 
445:                 	return uxReturn;
446:                 }
00000034  00000000   NOP
447:                 /*-----------------------------------------------------------*/
448:                 
449:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
450:                 
451:                 	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
452:                 	{
453:                 		BaseType_t xReturn;
454:                 
455:                 		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
456:                 		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
457:                 
458:                 		return xReturn;
459:                 	}
460:                 
461:                 #endif
462:                 /*-----------------------------------------------------------*/
463:                 
464:                 EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
465:                 {
00000000  00000000   NOP
466:                 UBaseType_t uxSavedInterruptStatus;
467:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
468:                 EventBits_t uxReturn;
469:                 
470:                 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0000000C  00000000   NOP
471:                 	{
472:                 		uxReturn = pxEventBits->uxEventBits;
00000014  00000000   NOP
473:                 	}
474:                 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00000018  00000000   NOP
475:                 
476:                 	return uxReturn;
477:                 }
00000020  00000000   NOP
478:                 /*-----------------------------------------------------------*/
479:                 
480:                 EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
481:                 {
00000000  00000000   NOP
482:                 ListItem_t *pxListItem, *pxNext;
483:                 ListItem_t const *pxListEnd;
484:                 List_t *pxList;
485:                 EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
00000048  00000000   NOP
000000B8  00000000   NOP
486:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
487:                 BaseType_t xMatchFound = pdFALSE;
488:                 
489:                 	/* Check the user is not attempting to set the bits used by the kernel
490:                 	itself. */
491:                 	configASSERT( xEventGroup );
492:                 	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
493:                 
494:                 	pxList = &( pxEventBits->xTasksWaitingForBits );
495:                 	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
496:                 	vTaskSuspendAll();
0000002C  00000000   NOP
497:                 	{
498:                 		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
499:                 
500:                 		pxListItem = listGET_HEAD_ENTRY( pxList );
00000034  00000000   NOP
501:                 
502:                 		/* Set the bits. */
503:                 		pxEventBits->uxEventBits |= uxBitsToSet;
00000038  00000000   NOP
504:                 
505:                 		/* See if the new bit value should unblock any tasks. */
506:                 		while( pxListItem != pxListEnd )
00000040  00000000   NOP
000000A8  00000000   NOP
507:                 		{
508:                 			pxNext = listGET_NEXT( pxListItem );
00000058  00000000   NOP
000000B0  00000000   NOP
509:                 			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
0000005C  00000000   NOP
510:                 			xMatchFound = pdFALSE;
511:                 
512:                 			/* Split the bits waited for from the control bits. */
513:                 			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
514:                 			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
515:                 
516:                 			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
0000004C  00000000   NOP
00000060  00000000   NOP
517:                 			{
518:                 				/* Just looking for single bit being set. */
519:                 				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
0000006C  00000000   NOP
520:                 				{
521:                 					xMatchFound = pdTRUE;
522:                 				}
523:                 				else
524:                 				{
525:                 					mtCOVERAGE_TEST_MARKER();
526:                 				}
527:                 			}
528:                 			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
0000007C  00000000   NOP
529:                 			{
530:                 				/* All bits are set. */
531:                 				xMatchFound = pdTRUE;
532:                 			}
533:                 			else
534:                 			{
535:                 				/* Need all bits to be set, but not all the bits were set. */
536:                 			}
537:                 
538:                 			if( xMatchFound != pdFALSE )
0000008C  00000000   NOP
539:                 			{
540:                 				/* The bits match.  Should the bits be cleared on exit? */
541:                 				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
00000050  00000000   NOP
542:                 				{
543:                 					uxBitsToClear |= uxBitsWaitedFor;
00000094  00000000   NOP
544:                 				}
545:                 				else
546:                 				{
547:                 					mtCOVERAGE_TEST_MARKER();
548:                 				}
549:                 
550:                 				/* Store the actual event flag value in the task's event list
551:                 				item before removing the task from the event list.  The
552:                 				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
553:                 				that is was unblocked due to its required bits matching, rather
554:                 				than because it timed out. */
555:                 				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
00000054  00000000   NOP
0000009C  00000000   NOP
556:                 			}
557:                 
558:                 			/* Move onto the next list item.  Note pxListItem->pxNext is not
559:                 			used here as the list item may have been removed from the event list
560:                 			and inserted into the ready/pending reading list. */
561:                 			pxListItem = pxNext;
562:                 		}
563:                 
564:                 		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
565:                 		bit was set in the control word. */
566:                 		pxEventBits->uxEventBits &= ~uxBitsToClear;
000000BC  00000000   NOP
567:                 	}
568:                 	( void ) xTaskResumeAll();
000000C8  00000000   NOP
569:                 
570:                 	return pxEventBits->uxEventBits;
571:                 }
000000D0  00000000   NOP
572:                 /*-----------------------------------------------------------*/
573:                 
574:                 void vEventGroupDelete( EventGroupHandle_t xEventGroup )
575:                 {
00000000  00000000   NOP
576:                 EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
577:                 const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
578:                 
579:                 	vTaskSuspendAll();
0000000C  00000000   NOP
580:                 	{
581:                 		traceEVENT_GROUP_DELETE( xEventGroup );
582:                 
583:                 		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
00000014  00000000   NOP
0000002C  00000000   NOP
584:                 		{
585:                 			/* Unblock the task, returning 0 as the event list is being deleted
586:                 			and	cannot therefore have any bits set. */
587:                 			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
588:                 			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
00000020  00000000   NOP
589:                 		}
590:                 
591:                 		vPortFree( pxEventBits );
00000038  00000000   NOP
592:                 	}
593:                 	( void ) xTaskResumeAll();
00000040  00000000   NOP
594:                 }
00000048  00000000   NOP
595:                 /*-----------------------------------------------------------*/
596:                 
597:                 /* For internal use only - execute a 'set bits' command that was pended from
598:                 an interrupt. */
599:                 void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
600:                 {
00000000  00000000   NOP
601:                 	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
00000008  00000000   NOP
602:                 }
00000010  00000000   NOP
603:                 /*-----------------------------------------------------------*/
604:                 
605:                 /* For internal use only - execute a 'clear bits' command that was pended from
606:                 an interrupt. */
607:                 void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
608:                 {
00000000  00000000   NOP
609:                 	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
00000008  00000000   NOP
610:                 }
00000010  00000000   NOP
611:                 /*-----------------------------------------------------------*/
612:                 
613:                 static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
614:                 {
615:                 BaseType_t xWaitConditionMet = pdFALSE;
616:                 
617:                 	if( xWaitForAllBits == pdFALSE )
00000030  00000000   NOP
000000D4  00000000   NOP
618:                 	{
619:                 		/* Task only has to wait for one bit within uxBitsToWaitFor to be
620:                 		set.  Is one already set? */
621:                 		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
00000038  00000000   NOP
000000DC  00000000   NOP
622:                 		{
623:                 			xWaitConditionMet = pdTRUE;
624:                 		}
625:                 		else
626:                 		{
627:                 			mtCOVERAGE_TEST_MARKER();
628:                 		}
629:                 	}
630:                 	else
631:                 	{
632:                 		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
633:                 		Are they set already? */
634:                 		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
00000044  00000000   NOP
000000E8  00000000   NOP
635:                 		{
636:                 			xWaitConditionMet = pdTRUE;
637:                 		}
638:                 		else
639:                 		{
640:                 			mtCOVERAGE_TEST_MARKER();
641:                 		}
642:                 	}
643:                 
644:                 	return xWaitConditionMet;
645:                 }
646:                 /*-----------------------------------------------------------*/
647:                 
648:                 #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
649:                 
650:                 	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
651:                 	{
652:                 	BaseType_t xReturn;
653:                 
654:                 		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
655:                 		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
656:                 
657:                 		return xReturn;
658:                 	}
659:                 
660:                 #endif
661:                 /*-----------------------------------------------------------*/
662:                 
663:                 #if (configUSE_TRACE_FACILITY == 1)
664:                 
665:                 	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
666:                 	{
667:                 	UBaseType_t xReturn;
668:                 	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
669:                 
670:                 		if( xEventGroup == NULL )
671:                 		{
672:                 			xReturn = 0;
673:                 		}
674:                 		else
675:                 		{
676:                 			xReturn = pxEventBits->uxEventGroupNumber;
677:                 		}
678:                 
679:                 		return xReturn;
680:                 	}
681:                 
682:                 #endif
683:                 
---  c:/microchip/harmony/v1_08_01/framework/system/int/src/sys_int_pic32.c  ----------------------------
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int_pic32.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "system/int/sys_int.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Function Definitions
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  /******************************************************************************
53:                  
54:                    Function:
55:                      void SYS_INT_Initialize ( void )
56:                  
57:                    Summary:
58:                      Configures and initializes the interrupt sub-system.
59:                  
60:                    Description:
61:                      This function appropriately configures and initializes the interrupt sub-system
62:                      for the current system design.
63:                  
64:                    Precondition:
65:                      None.
66:                  
67:                    Parameters:
68:                      None.
69:                  
70:                    Returns:
71:                      None.
72:                  
73:                    Example:
74:                    <code>
75:                    SYS_INT_Initialize();
76:                    </code>
77:                  
78:                    Remarks:
79:                      This function is not implemented in the System Interrupt library.  It is
80:                      implemented by the board support package (using the processor-specific
81:                      interrupt peripheral library) because it requires knowledge of the specific
82:                      interrupt requirements for each system.
83:                  */
84:                  
85:                  void SYS_INT_Initialize ( void )
86:                  
87:                  {
88:                      /* enable the multi vector */
89:                      PLIB_INT_MultiVectorSelect( INT_ID_0 );
90:                  }
91:                  
92:                  //*******************************************************************************
93:                  /*  Function:
94:                       SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
95:                  
96:                    Summary:
97:                      Disables interrupts to the processor and return the previois status.
98:                      
99:                    Description:
100:                     This function disables interrupts to the processor at the top level. This
101:                     function can be called to prevent any source from being able to generate an
102:                     interrupt. It returns the processor status (which includes global interrupt
103:                     status and Interrupt Priority status) before disabling the interrupts.
104:                 
105:                   Remarks:
106:                     See sys_int.h file for more details.
107:                 */
108:                 
109:                 SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
110:                 {
00000000  00000000   NOP
111:                     SYS_INT_PROCESSOR_STATUS processorStatus;
112:                 
113:                     /* Save the processor status and then Disable the global interrupt */
114:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
115:                 
116:                     /* return the processor status */
117:                     return processorStatus;
118:                 }
00000010  00000000   NOP
119:                 
120:                 //*******************************************************************************
121:                 /* Function:
122:                     void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
123:                 
124:                   Summary:
125:                     Restores the processor status.
126:                 
127:                   Description:
128:                     This function sets the processor status based on the 32 bit value passed as 
129:                     a parameter. 0th bit of the status is for Master Interrupt status.
130:                 
131:                   Remarks:
132:                     See sys_int.h file for more details.
133:                 */
134:                 
135:                 void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
136:                 {
00000000  00000000   NOP
137:                     PLIB_INT_SetState(INT_ID_0, processorStatus);
138:                 }
00000010  00000000   NOP
139:                 
140:                 // *****************************************************************************
141:                 /*  Disable the generation of interrupts to the CPU
142:                 
143:                   Summary:
144:                      Disables all interrupts
145:                 
146:                   Description:
147:                      This function disables all interrupts.
148:                 
149:                   Remarks:
150:                     This API will be depricated soon. Use "SYS_INT_StatusGetAndDisable" instead.
151:                  */
152:                 
153:                 bool SYS_INT_Disable( void )
154:                 {
00000000  00000000   NOP
155:                     SYS_INT_PROCESSOR_STATUS processorStatus;
156:                 
157:                     /* Save the processor status and then Disable the global interrupt */
158:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
159:                 
160:                     /* return the interrupt status */
161:                     return (bool)(processorStatus & 0x01);
162:                 }
00000010  00000000   NOP
163:                 
164:                 // *****************************************************************************
165:                 /* Function:
166:                     bool SYS_INT_SourceDisable ( INT_SOURCE source )
167:                 
168:                   Summary:
169:                     Disables the interrupt source.
170:                 
171:                   Description:
172:                     This routine disables the given source from generating interrupts the 
173:                     processor when events occur.It returns the interrupt source enable/disable 
174:                 	status before disabling the interrupt source.
175:                 
176:                   Remarks:
177:                     See sys_int.h file for more details.
178:                  */
179:                 
180:                 
181:                 bool SYS_INT_SourceDisable ( INT_SOURCE source )
182:                 {
9D00CB7C  27BDFFF8   ADDIU SP, SP, -8
9D00CB80  AFBF0004   SW RA, 4(SP)
183:                     bool intSrcStatus;
184:                     SYS_INT_PROCESSOR_STATUS processorStatus;
185:                 
186:                     /* Save the processor status and then Disable the global interrupt */
187:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
188:                     
189:                     /* get the interrupt status of this source before disable is called */
190:                     intSrcStatus = PLIB_INT_SourceIsEnabled (INT_ID_0 , source);
191:                 
192:                     /* disable the interrupts */
193:                     PLIB_INT_SourceDisable (INT_ID_0 , source);
194:                 
195:                     /* restore the state of CP0 Status register before the disable occurred*/
196:                     PLIB_INT_SetState(INT_ID_0 , processorStatus);
197:                 
198:                     /* return the source status */
199:                     return intSrcStatus;
200:                 }
9D00CBC4  0002102B   SLTU V0, ZERO, V0
9D00CBC8  8FBF0004   LW RA, 4(SP)
9D00CBCC  03E00008   JR RA
9D00CBD0  27BD0008   ADDIU SP, SP, 8
201:                 
202:                 
203:                 // *****************************************************************************
204:                 /* Sets the external interrupt trigger type.
205:                 
206:                   Summary:
207:                     Sets the external interrupt trigger type.
208:                 
209:                   Description:
210:                     This function sets the External interrupt trigger type.
211:                 
212:                   Remarks:
213:                     Refer the datasheet to know the external interrupt sources supported.
214:                  */
215:                 
216:                 void SYS_INT_ExternalInterruptTriggerSet ( 	INT_EXTERNAL_SOURCES source,
217:                 										INT_EXTERNAL_EDGE_TRIGGER edgeTrigger )
218:                 {
219:                 	if ( edgeTrigger == INT_EDGE_TRIGGER_RISING )
00000000  00000000   NOP
220:                 	{
221:                 		PLIB_INT_ExternalRisingEdgeSelect ( INT_ID_0, source );
222:                 	}
223:                 	else
224:                 	{
225:                 		PLIB_INT_ExternalFallingEdgeSelect ( INT_ID_0, source );
226:                 	}
227:                 }
228:                 
---  c:/microchip/harmony/v1_08_01/framework/system/devcon/src/sys_devcon_pic32mx.c  --------------------
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/osc/plib_osc.h"
55:                  #include "peripheral/pcache/plib_pcache.h"
56:                  #include "peripheral/bmx/plib_bmx.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  //
70:                  #ifndef PLIB_PCACHE_PREFETCH_ENABLE_ALL
71:                  #define PLIB_PCACHE_PREFETCH_ENABLE_ALL 3
72:                  #endif
73:                  
74:                  // *****************************************************************************
75:                  /* Function:
76:                      void SYS_DEVCON_PerformanceConfig( void )
77:                  
78:                    Summary:
79:                      Configures the PFM wait states and prefetch (cache) module for maximum 
80:                      performance.
81:                  
82:                    Description:
83:                      This function configures the PFM wait states and prefetch (cache) module 
84:                      for maximum performance.
85:                  
86:                    Remarks:
87:                      None.
88:                  */
89:                  
90:                  void __attribute__((nomips16)) SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
91:                  {
9D00A1B8  27BDFFF8   ADDIU SP, SP, -8
9D00A1BC  AFBF0004   SW RA, 4(SP)
92:                      bool int_flag = false;
93:                      register unsigned long tmp = 0;
94:                  
95:                      /* Set kseg0 coherency algorithm to "cacheable, non-coherent, write-back, 
96:                       * write-allocate. This is needed for the prefetch buffer */
97:                      asm("mfc0 %0,$16,0" :  "=r"(tmp));
9D00A1C0  40038000   MFC0 V1, Config
98:                      tmp = (tmp & ~7) | 3;
9D00A1C4  2402FFF8   ADDIU V0, ZERO, -8
9D00A1C8  00621024   AND V0, V1, V0
9D00A1CC  34420003   ORI V0, V0, 3
99:                      asm("mtc0 %0,$16,0" :: "r" (tmp));
9D00A1D0  40828000   MTC0 V0, Config
100:                 
101:                     /* Set the PFM wait states based on the system clock */
102:                     #if defined(PLIB_PCACHE_ExistsWaitState)
103:                     if (PLIB_PCACHE_ExistsWaitState(PCACHE_ID_0))
104:                     {
105:                         int ws; /* number of wait states */
106:                         if (sysclk <= 30000000)
9D00A1D4  3C0201C9   LUI V0, 457
9D00A1D8  3442C381   ORI V0, V0, -15487
9D00A1DC  0082102B   SLTU V0, A0, V0
9D00A1E0  14400008   BNE V0, ZERO, PLIB_INT_GetStateAndDisable
9D00A1E4  00001821   ADDU V1, ZERO, ZERO
107:                             ws = 0;
108:                         else if (sysclk <= 60000000)
9D00A1E8  3C030393   LUI V1, 915
9D00A1EC  34638701   ORI V1, V1, -30975
9D00A1F0  0083182B   SLTU V1, A0, V1
109:                             ws = 1;
9D00A1F4  24020001   ADDIU V0, ZERO, 1
9D00A1F8  24050002   ADDIU A1, ZERO, 2
9D00A1FC  00A3100A   MOVZ V0, A1, V1
9D00A200  00401821   ADDU V1, V0, ZERO
110:                         else
111:                             ws = 2;
112:                 
113:                         /* Interrupts must be disabled when changing wait states */
114:                         int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00A224  30840001   ANDI A0, A0, 1
115:                 
116:                         PLIB_PCACHE_WaitStateSet(PCACHE_ID_0, ws);
117:                 
118:                         if (int_flag)
9D00A228  10800005   BEQ A0, ZERO, SYS_DEVCON_PerformanceConfig::PLIB_INT_GetStateAndDisable
9D00A22C  00000000   NOP
119:                         {
120:                             PLIB_INT_Enable(INT_ID_0);
121:                             int_flag = false;
122:                         }
123:                     }
124:                     #endif // defined(PLIB_PCACHE_ExistsWaitState)
125:                 
126:                     /* Interrupts must be disabled when enabling the Prefetch Cache Module */
127:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00A26C  30620001   ANDI V0, V1, 1
128:                 
129:                     /* Enable Prefetch Cache Module */
130:                     #if defined(PLIB_PCACHE_ExistsPrefetchEnable)
131:                     if (PLIB_PCACHE_ExistsPrefetchEnable(PCACHE_ID_0))
132:                     {
133:                         PLIB_PCACHE_PrefetchEnableSet(PCACHE_ID_0, PLIB_PCACHE_PREFETCH_ENABLE_ALL);
134:                     }
135:                     #endif
136:                 
137:                     /* Set the SRAM wait states to zero */
138:                     #if defined (PLIB_BMX_ExistsDataRamWaitState)
139:                     if (PLIB_BMX_ExistsDataRamWaitState(BMX_ID_0))
140:                     {
141:                         PLIB_BMX_DataRamWaitStateSet(BMX_ID_0, PLIB_BMX_DATA_RAM_WAIT_ZERO);
142:                     }            
143:                     #endif
144:                     if (int_flag)
9D00A270  10400006   BEQ V0, ZERO, 0x9D00A28C
9D00A274  8FBF0004   LW RA, 4(SP)
145:                     {
146:                         PLIB_INT_Enable(INT_ID_0);
147:                     }
148:                 }
9D00A288  8FBF0004   LW RA, 4(SP)
9D00A28C  03E00008   JR RA
9D00A290  27BD0008   ADDIU SP, SP, 8
149:                 
150:                 /*******************************************************************************
151:                  End of File
152:                 */
153:                 
---  c:/microchip/harmony/v1_08_01/framework/system/devcon/src/sys_devcon.c  ----------------------------
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "system/devcon/src/sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/devcon/plib_devcon.h"
55:                  #include "peripheral/osc/plib_osc.h"
56:                  
57:                  // *****************************************************************************
58:                  // *****************************************************************************
59:                  // Section: File Scope or Global Constants
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: Variable Definitions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  /* System Device Control Instance */
70:                  SYS_DEVCON_OBJECT sysDevconObj;
71:                  
72:                  
73:                  // *****************************************************************************
74:                  // *****************************************************************************
75:                  // Section: SYS DEVCON Module Initialization Routines
76:                  // *****************************************************************************
77:                  // *****************************************************************************
78:                  
79:                  // *****************************************************************************
80:                  /* Function:
81:                      SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX           index,
82:                                                         const SYS_MODULE_INIT * const    init )
83:                  
84:                    Summary:
85:                      Initializes data for the instance of the Device Control module and opens
86:                      the specific module instance.
87:                  
88:                    Description:
89:                      This function initializes the instance of the Device Control module,
90:                      using the specified initialization data. It also initializes any
91:                      internal data structures.
92:                  
93:                    Remarks:
94:                      This routine should only be called once during system initialization
95:                      unless SYS_DEVCON_Deinitialize is first called to deinitialize the device
96:                      instance before reinitializing it. If the system was already initialized
97:                      it safely returns without causing any disturbance.
98:                  */
99:                  
100:                 SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX index,
101:                                                    const SYS_MODULE_INIT * const init )
102:                 {
103:                     sysDevconObj.status = SYS_STATUS_READY;
9D00DCC4  24020002   ADDIU V0, ZERO, 2
9D00DCC8  AF828104   SW V0, -32508(GP)
104:                 
105:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
9D00DCCC  AF808100   SW ZERO, -32512(GP)
106:                 
107:                     return (SYS_MODULE_OBJ)SYS_DEVCON_INDEX_0;
108:                 }
9D00DCD0  03E00008   JR RA
9D00DCD4  00001021   ADDU V0, ZERO, ZERO
109:                 
110:                 
111:                 // *****************************************************************************
112:                 /* Function:
113:                     void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ                  object,
114:                                                const SYS_MODULE_INIT * const   init )
115:                 
116:                    Summary:
117:                     Reinitializes and refreshes the hardware for the instance of the Device 
118:                     Control module.
119:                 
120:                    Description:
121:                     This function reinitializes the instance of the Device Control module using 
122:                     the supplied data. It modifies the internal data structure.
123:                 
124:                    Remarks:
125:                     This operation uses the same initialization data structure as the
126:                     SYS_DEVCON_Initialize operation. This operation can be used to change the
127:                     power state of a DEVCON module. This function can be called multiple times
128:                     to reinitialize the module. This operation uses the same initialization
129:                     data structure as the Initialize operation. This operation can also be
130:                     used to refresh the hardware registers as defined by the initialization
131:                     data.
132:                 */
133:                 
134:                 void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ object,
135:                                            const SYS_MODULE_INIT * const init )
136:                 {
137:                     sysDevconObj.status = SYS_STATUS_READY;
00000000  00000000   NOP
138:                 
139:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
00000008  00000000   NOP
140:                 }
141:                 
142:                 
143:                 // *****************************************************************************
144:                 /* Function:
145:                     void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
146:                 
147:                   Summary:
148:                     Deinitializes the specific module instance of the DEVCON module
149:                 
150:                   Description:
151:                     This function deinitializes the specific module instance disabling its operation 
152:                     (and any hardware for driver modules). Resets all of the internal data
153:                     structures and fields for the specified instance to the default settings.
154:                 
155:                   Remarks:
156:                     Once the Initialize operation has been called, the Deinitialize
157:                     operation must be called before the Initialize operation can be called
158:                     again.
159:                 */
160:                 
161:                 void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
162:                 {
163:                     sysDevconObj.status = SYS_STATUS_UNINITIALIZED;
164:                 }
165:                 
166:                 
167:                 // *****************************************************************************
168:                 /* Function:
169:                     SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
170:                 
171:                   Summary:
172:                     Returns status of the specific instance of the Device Control module.
173:                 
174:                   Description:
175:                     This function returns the status of the specific module instance.
176:                 
177:                   Remarks:
178:                     None.
179:                 */
180:                 
181:                 SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
182:                 {
183:                     return sysDevconObj.status; 
184:                 }
00000000  00000000   NOP
185:                 
186:                 
187:                 // *****************************************************************************
188:                 /* Function:
189:                     void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
190:                 
191:                   Summary:
192:                     Maintains the system Device Control state machine.
193:                 
194:                   Description:
195:                     This function is used to maintain the system Device Control internal state machine.
196:                 
197:                   Remarks:
198:                     This function is normally not called directly by an application.  It is
199:                     called by the system's Tasks routine (SYS_Tasks) or by the appropriate raw
200:                     ISR.
201:                 */
202:                 
203:                 void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
204:                 {
9D00DD68  03E00008   JR RA
9D00DD6C  00000000   NOP
205:                     switch (sysDevconObj.state)
206:                     {
207:                         case SYS_DEVCON_STATE_INIT:
208:                         case SYS_DEVCON_STATE_BUSY:
209:                         case SYS_DEVCON_STATE_READY:
210:                         default:
211:                             break;
212:                     }
213:                 }
214:                 
215:                     
216:                 // *****************************************************************************
217:                 // *****************************************************************************
218:                 // Section: SYS DEVCON Client Setup Routines
219:                 // *****************************************************************************
220:                 // *****************************************************************************
221:                 
222:                 // *****************************************************************************
223:                 /* Function:
224:                     void SYS_DEVCON_SystemUnlock( void )
225:                 
226:                   Summary:
227:                     Performs a system unlock sequence by writing to the SYSKEY register.
228:                 
229:                   Description:
230:                     Performs a system unlock sequence by writing to the SYSKEY register. A 
231:                     system unlock sequence is required before performing certain actions such
232:                     as changing a clock frequency or IO unlocking.
233:                 
234:                   Remarks:
235:                     None.
236:                 */
237:                 
238:                 void SYS_DEVCON_SystemUnlock( void )
239:                 {
9D00CB24  27BDFFF8   ADDIU SP, SP, -8
9D00CB28  AFBF0004   SW RA, 4(SP)
240:                     bool int_flag = false;
241:                 
242:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00CB54  30620001   ANDI V0, V1, 1
243:                 
244:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
245:                 
246:                     if (int_flag)
9D00CB58  10400006   BEQ V0, ZERO, 0x9D00CB74
9D00CB5C  8FBF0004   LW RA, 4(SP)
247:                     {
248:                         PLIB_INT_Enable(INT_ID_0);
249:                     }
250:                 }
9D00CB70  8FBF0004   LW RA, 4(SP)
9D00CB74  03E00008   JR RA
9D00CB78  27BD0008   ADDIU SP, SP, 8
251:                 
252:                 
253:                 // *****************************************************************************
254:                 /* Function:
255:                     void SYS_DEVCON_SystemLock( void )
256:                 
257:                   Summary:
258:                     Performs a system lock sequence by writing to the SYSKEY register.
259:                 
260:                   Description:
261:                     Performs a system lock sequence by writing to the SYSKEY register. A 
262:                     system lock sequence is required after performing the action that required
263:                     a system lock sequence.
264:                 
265:                   Remarks:
266:                     None.
267:                 */
268:                 
269:                 void SYS_DEVCON_SystemLock( void )
270:                 {
9D00D040  27BDFFF8   ADDIU SP, SP, -8
9D00D044  AFBF0004   SW RA, 4(SP)
271:                     bool int_flag = false;
272:                    
273:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00D060  30420001   ANDI V0, V0, 1
274:                 
275:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
276:                 
277:                     if (int_flag)
9D00D064  10400006   BEQ V0, ZERO, 0x9D00D080
9D00D068  8FBF0004   LW RA, 4(SP)
278:                     {
279:                         PLIB_INT_Enable(INT_ID_0);
280:                     }
281:                 }
9D00D07C  8FBF0004   LW RA, 4(SP)
9D00D080  03E00008   JR RA
9D00D084  27BD0008   ADDIU SP, SP, 8
282:                 
283:                 
284:                 // *****************************************************************************
285:                 /* Function:
286:                     void SYS_DEVCON_JTAGEnable( void )
287:                 
288:                   Summary:
289:                     Enables the JTAG port on the device.
290:                 
291:                   Description:
292:                     Enables the JTAG port on the device.
293:                 
294:                   Remarks:
295:                     None.
296:                 */
297:                 
298:                 void SYS_DEVCON_JTAGEnable( void )
299:                 {
300:                     PLIB_DEVCON_JTAGPortEnable(DEVCON_ID_0);
301:                 }
302:                 
303:                 
304:                 // *****************************************************************************
305:                 /* Function:
306:                     void SYS_DEVCON_JTAGDisable( void )
307:                 
308:                   Summary:
309:                     Disables the JTAG port on the device.
310:                 
311:                   Description:
312:                     Disables the JTAG port on the device.
313:                 
314:                   Remarks:
315:                     None.
316:                 */
317:                 
318:                 void SYS_DEVCON_JTAGDisable( void )
319:                 {
320:                     PLIB_DEVCON_JTAGPortDisable(DEVCON_ID_0);
321:                 }
322:                 
323:                 
324:                 // *****************************************************************************
325:                 /* Function:
326:                     void SYS_DEVCON_TraceEnable( void )
327:                 
328:                   Summary:
329:                     Enables the Trace output port on the device.
330:                 
331:                   Description:
332:                     Enables the Trace output port on the device.
333:                 
334:                   Remarks:
335:                     None.
336:                 */
337:                 
338:                 void SYS_DEVCON_TraceEnable( void )
339:                 {
340:                     #if defined PLIB_DEVCON_ExistsTraceOutput
341:                         if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
342:                         {
343:                             PLIB_DEVCON_TraceOutputEnable(DEVCON_ID_0);
344:                         }
345:                     #endif
346:                 }
347:                 
348:                 
349:                 // *****************************************************************************
350:                 /* Function:
351:                     void SYS_DEVCON_TraceDisable( void )
352:                 
353:                   Summary:
354:                     Disables the Trace output port on the device.
355:                 
356:                   Description:
357:                     Disables the Trace output port on the device.
358:                 
359:                   Remarks:
360:                     None.
361:                 */
362:                 
363:                 void SYS_DEVCON_TraceDisable( void )
364:                 {
365:                     #if defined PLIB_DEVCON_ExistsTraceOutput
366:                     if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
367:                     {
368:                         PLIB_DEVCON_TraceOutputDisable(DEVCON_ID_0);
369:                     }
370:                     #endif
371:                 }
372:                 
373:                 
374:                 // *****************************************************************************
375:                 /* Function:
376:                     void SYS_DEVCON_PowerModeEnter(SYS_POWER_MODE pwrMode)
377:                 
378:                   Summary:
379:                     Puts the device in a low-power state.
380:                 
381:                   Description:
382:                     This function puts the device in a low-power state.
383:                 
384:                   Remarks:
385:                     None.
386:                 */
387:                 
388:                 void __attribute__((nomips16)) SYS_DEVCON_PowerModeEnter( SYS_POWER_MODE pwrMode )
389:                 {
00000000  00000000   NOP
390:                     OSC_OPERATION_ON_WAIT op = SYS_POWER_MODE_IDLE;
0000000C  00000000   NOP
391:                 
392:                     switch (pwrMode)
393:                     {
394:                         case SYS_POWER_MODE_IDLE:
395:                             op = OSC_ON_WAIT_IDLE;
396:                             break;
397:                         case SYS_POWER_MODE_SLEEP:
398:                             op = OSC_ON_WAIT_SLEEP;
399:                             break;
400:                         default:
401:                             break;
402:                     }
403:                 
404:                     
405:                     #if defined PLIB_OSC_ExistsOnWaitAction
406:                     if(PLIB_OSC_ExistsOnWaitAction(OSC_ID_0))
407:                     {
408:                         SYS_DEVCON_SystemUnlock();
00000010  00000000   NOP
409:                         PLIB_OSC_OnWaitActionSet (OSC_ID_0, op);
410:                         SYS_DEVCON_SystemLock();
00000038  00000000   NOP
411:                     }
412:                     #endif
413:                     asm volatile ( "wait" );
00000040  00000000   NOP
414:                 }
00000044  00000000   NOP
415:                 
416:                 
417:                 /*******************************************************************************
418:                  End of File
419:                 */
420:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_wakeonstart_default.h  ----
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_WakeOnStart_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : WakeOnStart
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsWakeOnStart
16:                          PLIB_USART_WakeOnStartEnable
17:                          PLIB_USART_WakeOnStartDisable
18:                          PLIB_USART_WakeOnStartIsEnabled
19:                          PLIB_USART_InitializeModeGeneral
20:                          PLIB_USART_ErrorsGet
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _USART_WAKEONSTART_DEFAULT_H
51:                  #define _USART_WAKEONSTART_DEFAULT_H
52:                  
53:                  //******************************************************************************
54:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
55:                  
56:                    VREGs:
57:                      _USART_WAKE_ON_START_VREG(index)
58:                  
59:                    MASKs:
60:                      _USART_WAKE_ON_START_MASK(index)
61:                  
62:                    POSs:
63:                      _USART_WAKE_ON_START_POS(index)
64:                  
65:                    LENs:
66:                      _USART_WAKE_ON_START_LEN(index)
67:                  
68:                  */
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USART_ExistsWakeOnStart_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USART_ExistsWakeOnStart
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_USART_ExistsWakeOnStart function.
79:                  */
80:                  
81:                  #define PLIB_USART_ExistsWakeOnStart PLIB_USART_ExistsWakeOnStart
82:                  PLIB_TEMPLATE bool USART_ExistsWakeOnStart_Default( USART_MODULE_ID index )
83:                  {
84:                      return true;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  USART_WakeOnStartEnable_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_USART_WakeOnStartEnable
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_USART_WakeOnStartEnable function.
96:                  */
97:                  
98:                  PLIB_TEMPLATE void USART_WakeOnStartEnable_Default( USART_MODULE_ID index )
99:                  {
100:                     _SFR_BIT_SET(_USART_WAKE_ON_START_VREG(index),
101:                         _USART_WAKE_ON_START_POS(index) );
102:                 }
103:                 
104:                 
105:                 //******************************************************************************
106:                 /* Function :  USART_WakeOnStartDisable_Default
107:                 
108:                   Summary:
109:                     Implements Default variant of PLIB_USART_WakeOnStartDisable
110:                 
111:                   Description:
112:                     This template implements the Default variant of the PLIB_USART_WakeOnStartDisable function.
113:                 */
114:                 
115:                 PLIB_TEMPLATE void USART_WakeOnStartDisable_Default( USART_MODULE_ID index )
116:                 {
117:                     _SFR_BIT_CLEAR(_USART_WAKE_ON_START_VREG(index),
118:                         _USART_WAKE_ON_START_POS(index) );
119:                 }
120:                 
121:                 
122:                 //******************************************************************************
123:                 /* Function :  USART_WakeOnStartIsEnabled_Default
124:                 
125:                   Summary:
126:                     Implements Default variant of PLIB_USART_WakeOnStartIsEnabled
127:                 
128:                   Description:
129:                     This template implements the Default variant of the PLIB_USART_WakeOnStartIsEnabled function.
130:                 */
131:                 
132:                 PLIB_TEMPLATE bool USART_WakeOnStartIsEnabled_Default( USART_MODULE_ID index )
133:                 {
134:                     return _SFR_BIT_READ(_USART_WAKE_ON_START_VREG(index),
135:                         _USART_WAKE_ON_START_POS(index) );
136:                 }
137:                 
138:                 
139:                 //******************************************************************************
140:                 /* Function :  USART_InitializeModeGeneral_Default
141:                 
142:                   Summary:
143:                     Implements Default variant of PLIB_USART_InitializeModeGeneral
144:                 
145:                   Description:
146:                     This template implements the Default variant of the PLIB_USART_InitializeModeGeneral function.
147:                 */
148:                 
149:                 PLIB_TEMPLATE void USART_InitializeModeGeneral_Default( USART_MODULE_ID index, bool autobaud, bool loopBackMode, bool wakeFromSleep, bool irdaMode, bool stopInIdle )
150:                 {
151:                     SFR_TYPE * umode = _USART_WAKE_ON_START_VREG(index);
152:                     uint32_t value = 0;
153:                 
154:                     /* Clear all relevant bits */
155:                 
156:                     * umode &= 0xCF1F;
9D0016D0  3C04BF80   LUI A0, -16512
9D0016D4  8C8A6000   LW T2, 24576(A0)
9D0016D8  314ACF1F   ANDI T2, T2, -12513
9D0016DC  AC8A6000   SW T2, 24576(A0)
9D001744  3C04BF80   LUI A0, -16512
9D001748  8C8A6400   LW T2, 25600(A0)
9D00174C  314ACF1F   ANDI T2, T2, -12513
9D001750  AC8A6400   SW T2, 25600(A0)
9D0017B8  3C04BF80   LUI A0, -16512
9D0017BC  8C8A6800   LW T2, 26624(A0)
9D0017C0  314ACF1F   ANDI T2, T2, -12513
9D0017C4  AC8A6800   SW T2, 26624(A0)
9D00182C  3C04BF80   LUI A0, -16512
9D001830  8C8A6200   LW T2, 25088(A0)
9D001834  314ACF1F   ANDI T2, T2, -12513
9D001838  AC8A6200   SW T2, 25088(A0)
9D0018A0  3C04BF80   LUI A0, -16512
9D0018A4  8C8A6600   LW T2, 26112(A0)
9D0018A8  314ACF1F   ANDI T2, T2, -12513
9D0018AC  AC8A6600   SW T2, 26112(A0)
9D001914  3C04BF80   LUI A0, -16512
9D001918  8C8A6A00   LW T2, 27136(A0)
9D00191C  314ACF1F   ANDI T2, T2, -12513
9D001920  AC8A6A00   SW T2, 27136(A0)
157:                 
158:                     value |= (autobaud)         ? 0x20  : 0;
9D0016E0  24040020   ADDIU A0, ZERO, 32
9D0016E4  0003200A   MOVZ A0, ZERO, V1
9D0016E8  00801821   ADDU V1, A0, ZERO
9D001754  24040020   ADDIU A0, ZERO, 32
9D001758  0003200A   MOVZ A0, ZERO, V1
9D00175C  00801821   ADDU V1, A0, ZERO
9D0017C8  24040020   ADDIU A0, ZERO, 32
9D0017CC  0003200A   MOVZ A0, ZERO, V1
9D0017D0  00801821   ADDU V1, A0, ZERO
9D00183C  24040020   ADDIU A0, ZERO, 32
9D001840  0003200A   MOVZ A0, ZERO, V1
9D001844  00801821   ADDU V1, A0, ZERO
9D0018B0  24040020   ADDIU A0, ZERO, 32
9D0018B4  0003200A   MOVZ A0, ZERO, V1
9D0018B8  00801821   ADDU V1, A0, ZERO
9D001924  24040020   ADDIU A0, ZERO, 32
9D001928  0003200A   MOVZ A0, ZERO, V1
9D00192C  00801821   ADDU V1, A0, ZERO
159:                     value |= (loopBackMode)     ? 0x40  : 0;
9D0016EC  24040040   ADDIU A0, ZERO, 64
9D0016F0  0002200A   MOVZ A0, ZERO, V0
9D0016F4  00801021   ADDU V0, A0, ZERO
9D001724  006A1825   OR V1, V1, T2
9D001760  24040040   ADDIU A0, ZERO, 64
9D001764  0002200A   MOVZ A0, ZERO, V0
9D001768  00801021   ADDU V0, A0, ZERO
9D001798  006A1825   OR V1, V1, T2
9D0017D4  24040040   ADDIU A0, ZERO, 64
9D0017D8  0002200A   MOVZ A0, ZERO, V0
9D0017DC  00801021   ADDU V0, A0, ZERO
9D00180C  006A1825   OR V1, V1, T2
9D001848  24040040   ADDIU A0, ZERO, 64
9D00184C  0002200A   MOVZ A0, ZERO, V0
9D001850  00801021   ADDU V0, A0, ZERO
9D001880  006A1825   OR V1, V1, T2
9D0018BC  24040040   ADDIU A0, ZERO, 64
9D0018C0  0002200A   MOVZ A0, ZERO, V0
9D0018C4  00801021   ADDU V0, A0, ZERO
9D0018F4  006A1825   OR V1, V1, T2
9D001930  24040040   ADDIU A0, ZERO, 64
9D001934  0002200A   MOVZ A0, ZERO, V0
9D001938  00801021   ADDU V0, A0, ZERO
9D001968  006A1825   OR V1, V1, T2
160:                     value |= (wakeFromSleep)    ? 0x80  : 0;
9D0016F8  24040080   ADDIU A0, ZERO, 128
9D0016FC  0009200A   MOVZ A0, ZERO, T1
9D001700  00804821   ADDU T1, A0, ZERO
9D001728  00621025   OR V0, V1, V0
9D00176C  24040080   ADDIU A0, ZERO, 128
9D001770  0009200A   MOVZ A0, ZERO, T1
9D001774  00804821   ADDU T1, A0, ZERO
9D00179C  00621025   OR V0, V1, V0
9D0017E0  24040080   ADDIU A0, ZERO, 128
9D0017E4  0009200A   MOVZ A0, ZERO, T1
9D0017E8  00804821   ADDU T1, A0, ZERO
9D001810  00621025   OR V0, V1, V0
9D001854  24040080   ADDIU A0, ZERO, 128
9D001858  0009200A   MOVZ A0, ZERO, T1
9D00185C  00804821   ADDU T1, A0, ZERO
9D001884  00621025   OR V0, V1, V0
9D0018C8  24040080   ADDIU A0, ZERO, 128
9D0018CC  0009200A   MOVZ A0, ZERO, T1
9D0018D0  00804821   ADDU T1, A0, ZERO
9D0018F8  00621025   OR V0, V1, V0
9D00193C  24040080   ADDIU A0, ZERO, 128
9D001940  0009200A   MOVZ A0, ZERO, T1
9D001944  00804821   ADDU T1, A0, ZERO
9D00196C  00621025   OR V0, V1, V0
161:                     value |= (stopInIdle )      ? 0x2000 : 0;
9D001704  24042000   ADDIU A0, ZERO, 8192
9D001708  0007200A   MOVZ A0, ZERO, A3
9D00170C  00803821   ADDU A3, A0, ZERO
9D00172C  00494825   OR T1, V0, T1
9D001778  24042000   ADDIU A0, ZERO, 8192
9D00177C  0007200A   MOVZ A0, ZERO, A3
9D001780  00803821   ADDU A3, A0, ZERO
9D0017A0  00494825   OR T1, V0, T1
9D0017EC  24042000   ADDIU A0, ZERO, 8192
9D0017F0  0007200A   MOVZ A0, ZERO, A3
9D0017F4  00803821   ADDU A3, A0, ZERO
9D001814  00494825   OR T1, V0, T1
9D001860  24042000   ADDIU A0, ZERO, 8192
9D001864  0007200A   MOVZ A0, ZERO, A3
9D001868  00803821   ADDU A3, A0, ZERO
9D001888  00494825   OR T1, V0, T1
9D0018D4  24042000   ADDIU A0, ZERO, 8192
9D0018D8  0007200A   MOVZ A0, ZERO, A3
9D0018DC  00803821   ADDU A3, A0, ZERO
9D0018FC  00494825   OR T1, V0, T1
9D001948  24042000   ADDIU A0, ZERO, 8192
9D00194C  0007200A   MOVZ A0, ZERO, A3
9D001950  00803821   ADDU A3, A0, ZERO
9D001970  00494825   OR T1, V0, T1
162:                     value |= (irdaMode)         ? 0x1000 : 0;
9D001710  24041000   ADDIU A0, ZERO, 4096
9D001714  0008200A   MOVZ A0, ZERO, T0
9D001718  00804021   ADDU T0, A0, ZERO
9D001730  01273825   OR A3, T1, A3
9D001784  24041000   ADDIU A0, ZERO, 4096
9D001788  0008200A   MOVZ A0, ZERO, T0
9D00178C  00804021   ADDU T0, A0, ZERO
9D0017A4  01273825   OR A3, T1, A3
9D0017F8  24041000   ADDIU A0, ZERO, 4096
9D0017FC  0008200A   MOVZ A0, ZERO, T0
9D001800  00804021   ADDU T0, A0, ZERO
9D001818  01273825   OR A3, T1, A3
9D00186C  24041000   ADDIU A0, ZERO, 4096
9D001870  0008200A   MOVZ A0, ZERO, T0
9D001874  00804021   ADDU T0, A0, ZERO
9D00188C  01273825   OR A3, T1, A3
9D0018E0  24041000   ADDIU A0, ZERO, 4096
9D0018E4  0008200A   MOVZ A0, ZERO, T0
9D0018E8  00804021   ADDU T0, A0, ZERO
9D001900  01273825   OR A3, T1, A3
9D001954  24041000   ADDIU A0, ZERO, 4096
9D001958  0008200A   MOVZ A0, ZERO, T0
9D00195C  00804021   ADDU T0, A0, ZERO
9D001974  01273825   OR A3, T1, A3
163:                 
164:                     /* Set the relevant bits */
165:                     *umode |= value;
9D00171C  3C04BF80   LUI A0, -16512
9D001720  8C8A6000   LW T2, 24576(A0)
9D001734  00E84025   OR T0, A3, T0
9D001738  AC886000   SW T0, 24576(A0)
9D001790  3C04BF80   LUI A0, -16512
9D001794  8C8A6400   LW T2, 25600(A0)
9D0017A8  00E84025   OR T0, A3, T0
9D0017AC  AC886400   SW T0, 25600(A0)
9D001804  3C04BF80   LUI A0, -16512
9D001808  8C8A6800   LW T2, 26624(A0)
9D00181C  00E84025   OR T0, A3, T0
9D001820  AC886800   SW T0, 26624(A0)
9D001878  3C04BF80   LUI A0, -16512
9D00187C  8C8A6200   LW T2, 25088(A0)
9D001890  00E84025   OR T0, A3, T0
9D001894  AC886200   SW T0, 25088(A0)
9D0018EC  3C04BF80   LUI A0, -16512
9D0018F0  8C8A6600   LW T2, 26112(A0)
9D001904  00E84025   OR T0, A3, T0
9D001908  AC886600   SW T0, 26112(A0)
9D001960  3C04BF80   LUI A0, -16512
9D001964  8C8A6A00   LW T2, 27136(A0)
9D001978  00E84025   OR T0, A3, T0
9D00197C  AC886A00   SW T0, 27136(A0)
166:                     
167:                 
168:                 
169:                 }
170:                 
171:                 //******************************************************************************
172:                 /* Function :  USART_ErrorsGet_Default
173:                 
174:                   Summary:
175:                     Implements Default variant of PLIB_USART_ErrorsGet
176:                 
177:                   Description:
178:                     This template implements the Default variant of the PLIB_USART_ErrorsGet function.
179:                 */
180:                 
181:                 PLIB_TEMPLATE USART_ERROR USART_ErrorsGet_Default( USART_MODULE_ID index)
182:                 {
183:                     SFR_TYPE * usta = _USART_RECEIVER_FRAMING_ERROR_VREG(index);
184:                 
185:                     /* Clear all relevant bits */
186:                 
187:                     return((USART_ERROR)((*usta & 0xE) >> 1));
188:                 }
189:                 
190:                 #endif /*_USART_WAKEONSTART_DEFAULT_H*/
191:                 
192:                 /******************************************************************************
193:                  End of File
194:                 */
195:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_transmitterempty_default.h  
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_TransmitterEmpty_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterEmpty
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_TransmitterIsEmpty
16:                          PLIB_USART_ExistsTransmitterEmptyStatus
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTEREMPTY_DEFAULT_H
47:                  #define _USART_TRANSMITTEREMPTY_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _USART_TRANSMITTER_EMPTY_VREG(index)
54:                  
55:                    MASKs: 
56:                      _USART_TRANSMITTER_EMPTY_MASK(index)
57:                  
58:                    POSs: 
59:                      _USART_TRANSMITTER_EMPTY_POS(index)
60:                  
61:                    LENs: 
62:                      _USART_TRANSMITTER_EMPTY_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  USART_TransmitterIsEmpty_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_USART_TransmitterIsEmpty 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_USART_TransmitterIsEmpty function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE bool USART_TransmitterIsEmpty_Default( USART_MODULE_ID index )
78:                  {
79:                      return _SFR_BIT_READ(_USART_TRANSMITTER_EMPTY_VREG(index),
000000BC  00000000   NOP
0000018C  00000000   NOP
80:                                               _USART_TRANSMITTER_EMPTY_POS(index) );
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  USART_ExistsTransmitterEmptyStatus_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_USART_ExistsTransmitterEmptyStatus
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitterEmptyStatus function.
92:                  */
93:                  
94:                  #define PLIB_USART_ExistsTransmitterEmptyStatus PLIB_USART_ExistsTransmitterEmptyStatus
95:                  PLIB_TEMPLATE bool USART_ExistsTransmitterEmptyStatus_Default( USART_MODULE_ID index )
96:                  {
97:                      return true;
98:                  }
99:                  
100:                 
101:                 #endif /*_USART_TRANSMITTEREMPTY_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_transmitterbufferfull_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_TransmitterBufferFull_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterBufferFull
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitterBufferFullStatus
16:                          PLIB_USART_TransmitterBufferIsFull
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTERBUFFERFULL_DEFAULT_H
47:                  #define _USART_TRANSMITTERBUFFERFULL_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _USART_TRANSMITTER_BUFFER_FULL_VREG(index)
54:                  
55:                    MASKs: 
56:                      _USART_TRANSMITTER_BUFFER_FULL_MASK(index)
57:                  
58:                    POSs: 
59:                      _USART_TRANSMITTER_BUFFER_FULL_POS(index)
60:                  
61:                    LENs: 
62:                      _USART_TRANSMITTER_BUFFER_FULL_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  USART_ExistsTransmitterBufferFullStatus_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_USART_ExistsTransmitterBufferFullStatus
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitterBufferFullStatus function.
75:                  */
76:                  
77:                  #define PLIB_USART_ExistsTransmitterBufferFullStatus PLIB_USART_ExistsTransmitterBufferFullStatus
78:                  PLIB_TEMPLATE bool USART_ExistsTransmitterBufferFullStatus_Default( USART_MODULE_ID index )
79:                  {
80:                      return true;
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  USART_TransmitterBufferIsFull_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_USART_TransmitterBufferIsFull 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_USART_TransmitterBufferIsFull function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE bool USART_TransmitterBufferIsFull_Default( USART_MODULE_ID index )
95:                  {
96:                      return _SFR_BIT_READ(_USART_TRANSMITTER_BUFFER_FULL_VREG(index),
9D00BF44  3C03BF80   LUI V1, -16512
9D00BF48  8C626010   LW V0, 24592(V1)
9D00BF4C  30420200   ANDI V0, V0, 512
00000064  00000000   NOP
00000114  00000000   NOP
00000118  00000000   NOP
00000168  00000000   NOP
000001DC  00000000   NOP
00000374  00000000   NOP
00000410  00000000   NOP
0000044C  00000000   NOP
000004D8  00000000   NOP
97:                                               _USART_TRANSMITTER_BUFFER_FULL_POS(index) );
98:                  }
99:                  
100:                 
101:                 #endif /*_USART_TRANSMITTERBUFFERFULL_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_transmitter_default.h  ----
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Transmitter_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Transmitter
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitter
16:                          PLIB_USART_TransmitterByteSend
17:                          PLIB_USART_TransmitterAddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_TRANSMITTER_DEFAULT_H
48:                  #define _USART_TRANSMITTER_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
52:                  
53:                    VREGs:
54:                      _USART_TRANSMITTER_SEND_VREG(index)
55:                  
56:                    MASKs:
57:                      _USART_TRANSMITTER_SEND_MASK(index)
58:                  
59:                    POSs:
60:                      _USART_TRANSMITTER_SEND_POS(index)
61:                  
62:                    LENs:
63:                      _USART_TRANSMITTER_SEND_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ExistsTransmitter_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ExistsTransmitter
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitter function.
76:                  */
77:                  
78:                  #define PLIB_USART_ExistsTransmitter PLIB_USART_ExistsTransmitter
79:                  PLIB_TEMPLATE bool USART_ExistsTransmitter_Default( USART_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USART_TransmitterByteSend_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USART_TransmitterByteSend
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USART_TransmitterByteSend function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void USART_TransmitterByteSend_Default( USART_MODULE_ID index , int8_t data )
96:                  {
97:                      _SFR_FIELD_WRITE(_USART_TRANSMITTER_SEND_VREG(index),
9D008940  3C02BF80   LUI V0, -16512
9D008944  8C436020   LW V1, 24608(V0)
9D008948  AC526020   SW S2, 24608(V0)
9D008984  3C02BF80   LUI V0, -16512
9D008988  8C436420   LW V1, 25632(V0)
9D00898C  AC526420   SW S2, 25632(V0)
9D008998  3C02BF80   LUI V0, -16512
9D00899C  8C436820   LW V1, 26656(V0)
9D0089A0  AC526820   SW S2, 26656(V0)
9D0089AC  3C02BF80   LUI V0, -16512
9D0089B0  8C436220   LW V1, 25120(V0)
9D0089B4  AC526220   SW S2, 25120(V0)
9D0089C0  3C02BF80   LUI V0, -16512
9D0089C4  8C436620   LW V1, 26144(V0)
9D0089C8  AC526620   SW S2, 26144(V0)
9D0089D4  3C02BF80   LUI V0, -16512
9D0089D8  8C436A20   LW V1, 27168(V0)
9D0089DC  AC526A20   SW S2, 27168(V0)
00000138  00000000   NOP
000003D0  00000000   NOP
00000488  00000000   NOP
00000498  00000000   NOP
000004A8  00000000   NOP
000004B8  00000000   NOP
000004C8  00000000   NOP
98:                                           _USART_TRANSMITTER_SEND_MASK(index),
99:                                           _USART_TRANSMITTER_SEND_POS(index) ,
100:                                          data);
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USART_TransmitterAddressGet_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USART_TransmitterAddressGet
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USART_TransmitterAddressGet function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE void* USART_TransmitterAddressGet_Default( USART_MODULE_ID index )
115:                 {
116:                 	return (uint32_t*)_USART_TRANSMITTER_SEND_VREG(index);
117:                 }
118:                 
119:                 #endif /*_USART_TRANSMITTER_DEFAULT_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_transmitter9bits_indataonly.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Transmitter9Bits_InDataOnly.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Transmitter9Bits
13:                      and its Variant : InDataOnly
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitter9BitsSend
16:                          PLIB_USART_Transmitter9BitsSend
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTER9BITS_INDATAONLY_H
47:                  #define _USART_TRANSMITTER9BITS_INDATAONLY_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
51:                  
52:                    VREGs:
53:                      _USART_TRANSMITTER_DATA_ONLY_VREG(index)
54:                  
55:                    MASKs:
56:                      _USART_TRANSMITTER_DATA_ONLY_MASK(index)
57:                  
58:                    POSs:
59:                      _USART_TRANSMITTER_DATA_ONLY_POS(index)
60:                  
61:                    LENs:
62:                      _USART_TRANSMITTER_DATA_ONLY_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  USART_ExistsTransmitter9BitsSend_InDataOnly
69:                  
70:                    Summary:
71:                      Implements InDataOnly variant of PLIB_USART_ExistsTransmitter9BitsSend
72:                  
73:                    Description:
74:                      This template implements the InDataOnly variant of the PLIB_USART_ExistsTransmitter9BitsSend function.
75:                  */
76:                  
77:                  #define PLIB_USART_ExistsTransmitter9BitsSend PLIB_USART_ExistsTransmitter9BitsSend
78:                  PLIB_TEMPLATE bool USART_ExistsTransmitter9BitsSend_InDataOnly( USART_MODULE_ID index )
79:                  {
80:                      return true;
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  USART_Transmitter9BitsSend_InDataOnly
86:                  
87:                    Summary:
88:                      Implements InDataOnly variant of PLIB_USART_Transmitter9BitsSend
89:                  
90:                    Description:
91:                      This template implements the InDataOnly variant of the PLIB_USART_Transmitter9BitsSend function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void USART_Transmitter9BitsSend_InDataOnly( USART_MODULE_ID index , int8_t data , bool Bit9th )
95:                  {
96:                      SFR_TYPE temp;
97:                  	if (Bit9th == 0)
98:                  	{
99:                  		_SFR_WRITE(_USART_TRANSMITTER_DATA_ONLY_VREG(index),
0000018C  00000000   NOP
000002F4  00000000   NOP
00000304  00000000   NOP
00000310  00000000   NOP
0000031C  00000000   NOP
00000328  00000000   NOP
00000334  00000000   NOP
100:                     			data);
101:                 	}
102:                 	else
103:                 	{
104:                 		temp = data;
000001F4  00000000   NOP
00000218  00000000   NOP
00000238  00000000   NOP
00000258  00000000   NOP
00000278  00000000   NOP
00000298  00000000   NOP
105:                 		temp = (temp|(Bit9th<<8));
000001F8  00000000   NOP
0000021C  00000000   NOP
0000023C  00000000   NOP
0000025C  00000000   NOP
0000027C  00000000   NOP
0000029C  00000000   NOP
106:                 		_SFR_WRITE(_USART_TRANSMITTER_DATA_ONLY_VREG(index),temp);
00000204  00000000   NOP
00000228  00000000   NOP
00000248  00000000   NOP
00000268  00000000   NOP
00000288  00000000   NOP
000002A8  00000000   NOP
107:                 	}
108:                 }
109:                 
110:                 
111:                 #endif /*_USART_TRANSMITTER9BITS_INDATAONLY_H*/
112:                 
113:                 /******************************************************************************
114:                  End of File
115:                 */
116:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_receiveroverrunerror_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverOverrunError_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverOverrunError
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverOverrunStatus
16:                          PLIB_USART_ReceiverOverrunErrorClear
17:                          PLIB_USART_ReceiverOverrunHasOccurred
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVEROVERRUNERROR_DEFAULT_H
48:                  #define _USART_RECEIVEROVERRUNERROR_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _USART_RECEIVER_OVERRUN_ERROR_VREG(index)
55:                  
56:                    MASKs: 
57:                      _USART_RECEIVER_OVERRUN_ERROR_MASK(index)
58:                  
59:                    POSs: 
60:                      _USART_RECEIVER_OVERRUN_ERROR_POS(index)
61:                  
62:                    LENs: 
63:                      _USART_RECEIVER_OVERRUN_ERROR_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ExistsReceiverOverrunStatus_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ExistsReceiverOverrunStatus
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverOverrunStatus function.
76:                  */
77:                  
78:                  #define PLIB_USART_ExistsReceiverOverrunStatus PLIB_USART_ExistsReceiverOverrunStatus
79:                  PLIB_TEMPLATE bool USART_ExistsReceiverOverrunStatus_Default( USART_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USART_ReceiverOverrunErrorClear_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USART_ReceiverOverrunErrorClear 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USART_ReceiverOverrunErrorClear function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void USART_ReceiverOverrunErrorClear_Default( USART_MODULE_ID index )
96:                  {
97:                      _SFR_BIT_CLEAR(_USART_RECEIVER_OVERRUN_ERROR_VREG(index),
9D006524  3C02BF80   LUI V0, -16512
9D006528  24426010   ADDIU V0, V0, 24592
9D00652C  AC430004   SW V1, 4(V0)
9D0065F4  3C02BF80   LUI V0, -16512
9D0065F8  24426410   ADDIU V0, V0, 25616
9D0065FC  AC430004   SW V1, 4(V0)
9D006600  0B40194C   J 0x9D006530
9D006604  00000000   NOP
9D006608  3C02BF80   LUI V0, -16512
9D00660C  24426810   ADDIU V0, V0, 26640
9D006610  AC430004   SW V1, 4(V0)
9D006614  0B40194C   J 0x9D006530
9D006618  00000000   NOP
9D00661C  3C02BF80   LUI V0, -16512
9D006620  24426210   ADDIU V0, V0, 25104
9D006624  AC430004   SW V1, 4(V0)
9D006628  0B40194C   J 0x9D006530
9D00662C  00000000   NOP
9D006630  3C02BF80   LUI V0, -16512
9D006634  24426610   ADDIU V0, V0, 26128
9D006638  AC430004   SW V1, 4(V0)
9D00663C  0B40194C   J 0x9D006530
9D006640  00000000   NOP
9D006644  3C02BF80   LUI V0, -16512
9D006648  24426A10   ADDIU V0, V0, 27152
9D00664C  AC430004   SW V1, 4(V0)
9D006650  0B40194C   J 0x9D006530
9D006654  00000000   NOP
98:                                         _USART_RECEIVER_OVERRUN_ERROR_POS(index) );
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  USART_ReceiverOverrunHasOccurred_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_USART_ReceiverOverrunHasOccurred 
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_USART_ReceiverOverrunHasOccurred function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE bool USART_ReceiverOverrunHasOccurred_Default( USART_MODULE_ID index )
113:                 {
114:                     return _SFR_BIT_READ(_USART_RECEIVER_OVERRUN_ERROR_VREG(index),
9D006510  3C02BF80   LUI V0, -16512
9D006514  8C426010   LW V0, 24592(V0)
9D006518  30420002   ANDI V0, V0, 2
9D006568  3C02BF80   LUI V0, -16512
9D00656C  8C426410   LW V0, 25616(V0)
9D006570  30420002   ANDI V0, V0, 2
9D006584  3C02BF80   LUI V0, -16512
9D006588  8C426810   LW V0, 26640(V0)
9D00658C  30420002   ANDI V0, V0, 2
9D0065A0  3C02BF80   LUI V0, -16512
9D0065A4  8C426210   LW V0, 25104(V0)
9D0065A8  30420002   ANDI V0, V0, 2
9D0065BC  3C02BF80   LUI V0, -16512
9D0065C0  8C426610   LW V0, 26128(V0)
9D0065C4  30420002   ANDI V0, V0, 2
9D0065D8  3C02BF80   LUI V0, -16512
9D0065DC  8C426A10   LW V0, 27152(V0)
9D0065E0  30420002   ANDI V0, V0, 2
115:                                              _USART_RECEIVER_OVERRUN_ERROR_POS(index) );
116:                 }
117:                 
118:                 
119:                 #endif /*_USART_RECEIVEROVERRUNERROR_DEFAULT_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_receiverinterruptmode_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverInterruptMode_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverInterruptMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverInterruptMode
16:                          PLIB_USART_ReceiverInterruptModeSelect
17:                          PLIB_USART_InitializeOperation
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERINTERRUPTMODE_DEFAULT_H
48:                  #define _USART_RECEIVERINTERRUPTMODE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _USART_RECEIVER_FIFO_LEVEL_VREG(index)
55:                  
56:                    MASKs: 
57:                      _USART_RECEIVER_FIFO_LEVEL_MASK(index)
58:                  
59:                    POSs: 
60:                      _USART_RECEIVER_FIFO_LEVEL_POS(index)
61:                  
62:                    LENs: 
63:                      _USART_RECEIVER_FIFO_LEVEL_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ExistsReceiverInterruptMode_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ExistsReceiverInterruptMode
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverInterruptMode function.
76:                  */
77:                  
78:                  #define PLIB_USART_ExistsReceiverInterruptMode PLIB_USART_ExistsReceiverInterruptMode
79:                  PLIB_TEMPLATE bool USART_ExistsReceiverInterruptMode_Default( USART_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USART_ReceiverInterruptModeSelect_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USART_ReceiverInterruptModeSelect 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USART_ReceiverInterruptModeSelect function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void USART_ReceiverInterruptModeSelect_Default( USART_MODULE_ID index , USART_RECEIVE_INTR_MODE interruptMode )
96:                  {
97:                      _SFR_FIELD_WRITE(_USART_RECEIVER_FIFO_LEVEL_VREG(index),
98:                                      _USART_RECEIVER_FIFO_LEVEL_MASK(index),
99:                                      _USART_RECEIVER_FIFO_LEVEL_POS(index),
100:                                     interruptMode);
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USART_InitializeOperation_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USART_InitializeOperation 
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USART_InitializeOperation function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE void USART_InitializeOperation_Default( USART_MODULE_ID index , USART_RECEIVE_INTR_MODE receiveInterruptMode ,
115:                         USART_TRANSMIT_INTR_MODE transmitInterruptMode, USART_OPERATION_MODE operationMode)
116:                 {
117:                     SFR_TYPE * usta = _USART_RECEIVER_FIFO_LEVEL_VREG(index);
118:                     SFR_TYPE * umode = _USART_ENABLE_CONTROL_VREG(index);
119:                 
120:                     uint32_t value = 0;
121:                 
122:                     // Clear the values initially
123:                     *usta &= ~0xCFCF;
9D001AA0  3C03BF80   LUI V1, -16512
9D001AA4  8C646010   LW A0, 24592(V1)
9D001AA8  3C02FFFF   LUI V0, -1
9D001AAC  24423030   ADDIU V0, V0, 12336
9D001AB0  00821024   AND V0, A0, V0
9D001AB4  AC626010   SW V0, 24592(V1)
9D002130  0B4006A9   J 0x9D001AA4
9D002134  3C03BF80   LUI V1, -16512
9D002174  0B4008A4   J 0x9D002290
9D002178  3C03BF80   LUI V1, -16512
9D0021B8  0B4008B9   J 0x9D0022E4
9D0021BC  3C03BF80   LUI V1, -16512
9D0021FC  0B4008CE   J 0x9D002338
9D002200  3C03BF80   LUI V1, -16512
9D002240  0B4008E3   J 0x9D00238C
9D002244  3C03BF80   LUI V1, -16512
9D002284  0B4008F8   J 0x9D0023E0
9D002288  3C03BF80   LUI V1, -16512
9D00228C  3C03BF80   LUI V1, -16512
9D002290  8C646410   LW A0, 25616(V1)
9D002294  3C02FFFF   LUI V0, -1
9D002298  24423030   ADDIU V0, V0, 12336
9D00229C  00821024   AND V0, A0, V0
9D0022A0  AC626410   SW V0, 25616(V1)
9D0022E0  3C03BF80   LUI V1, -16512
9D0022E4  8C646810   LW A0, 26640(V1)
9D0022E8  3C02FFFF   LUI V0, -1
9D0022EC  24423030   ADDIU V0, V0, 12336
9D0022F0  00821024   AND V0, A0, V0
9D0022F4  AC626810   SW V0, 26640(V1)
9D002334  3C03BF80   LUI V1, -16512
9D002338  8C646210   LW A0, 25104(V1)
9D00233C  3C02FFFF   LUI V0, -1
9D002340  24423030   ADDIU V0, V0, 12336
9D002344  00821024   AND V0, A0, V0
9D002348  AC626210   SW V0, 25104(V1)
9D002388  3C03BF80   LUI V1, -16512
9D00238C  8C646610   LW A0, 26128(V1)
9D002390  3C02FFFF   LUI V0, -1
9D002394  24423030   ADDIU V0, V0, 12336
9D002398  00821024   AND V0, A0, V0
9D00239C  AC626610   SW V0, 26128(V1)
9D0023DC  3C03BF80   LUI V1, -16512
9D0023E0  8C646A10   LW A0, 27152(V1)
9D0023E4  3C02FFFF   LUI V0, -1
9D0023E8  24423030   ADDIU V0, V0, 12336
9D0023EC  00821024   AND V0, A0, V0
9D0023F0  AC626A10   SW V0, 27152(V1)
124:                     *umode &= ~0x0300;
9D001AB8  3C02BF80   LUI V0, -16512
9D001ABC  8C476000   LW A3, 24576(V0)
9D001AC0  2404FCFF   ADDIU A0, ZERO, -769
9D001AC4  00E42024   AND A0, A3, A0
9D001AC8  AC446000   SW A0, 24576(V0)
9D0022A4  3C02BF80   LUI V0, -16512
9D0022A8  8C476400   LW A3, 25600(V0)
9D0022AC  2404FCFF   ADDIU A0, ZERO, -769
9D0022B0  00E42024   AND A0, A3, A0
9D0022B4  AC446400   SW A0, 25600(V0)
9D0022F8  3C02BF80   LUI V0, -16512
9D0022FC  8C476800   LW A3, 26624(V0)
9D002300  2404FCFF   ADDIU A0, ZERO, -769
9D002304  00E42024   AND A0, A3, A0
9D002308  AC446800   SW A0, 26624(V0)
9D00234C  3C02BF80   LUI V0, -16512
9D002350  8C476200   LW A3, 25088(V0)
9D002354  2404FCFF   ADDIU A0, ZERO, -769
9D002358  00E42024   AND A0, A3, A0
9D00235C  AC446200   SW A0, 25088(V0)
9D0023A0  3C02BF80   LUI V0, -16512
9D0023A4  8C476600   LW A3, 26112(V0)
9D0023A8  2404FCFF   ADDIU A0, ZERO, -769
9D0023AC  00E42024   AND A0, A3, A0
9D0023B0  AC446600   SW A0, 26112(V0)
9D0023F4  3C02BF80   LUI V0, -16512
9D0023F8  8C476A00   LW A3, 27136(V0)
9D0023FC  2404FCFF   ADDIU A0, ZERO, -769
9D002400  00E42024   AND A0, A3, A0
9D002404  AC446A00   SW A0, 27136(V0)
125:                 
126:                     value |= (receiveInterruptMode << 6);
127:                     value |= (transmitInterruptMode << 14);
128:                     *usta |= value;
9D001ACC  8C646010   LW A0, 24592(V1)
9D001AD0  34844000   ORI A0, A0, 16384
9D001AD4  AC646010   SW A0, 24592(V1)
9D0022B8  8C646410   LW A0, 25616(V1)
9D0022BC  34844000   ORI A0, A0, 16384
9D0022C0  AC646410   SW A0, 25616(V1)
9D00230C  8C646810   LW A0, 26640(V1)
9D002310  34844000   ORI A0, A0, 16384
9D002314  AC646810   SW A0, 26640(V1)
9D002360  8C646210   LW A0, 25104(V1)
9D002364  34844000   ORI A0, A0, 16384
9D002368  AC646210   SW A0, 25104(V1)
9D0023B4  8C646610   LW A0, 26128(V1)
9D0023B8  34844000   ORI A0, A0, 16384
9D0023BC  AC646610   SW A0, 26128(V1)
9D002408  8C646A10   LW A0, 27152(V1)
9D00240C  34844000   ORI A0, A0, 16384
9D002410  AC646A10   SW A0, 27152(V1)
129:                     value = 0;
130:                     value |= (operationMode << 8);
9D001ADC  00063200   SLL A2, A2, 8
9D0022C8  00063200   SLL A2, A2, 8
9D00231C  00063200   SLL A2, A2, 8
9D002370  00063200   SLL A2, A2, 8
9D0023C4  00063200   SLL A2, A2, 8
9D002418  00063200   SLL A2, A2, 8
131:                     *umode |= value; 
9D001AD8  8C436000   LW V1, 24576(V0)
9D001AE0  00C33025   OR A2, A2, V1
9D001AE4  AC466000   SW A2, 24576(V0)
9D0022C4  8C436400   LW V1, 25600(V0)
9D0022CC  00C33025   OR A2, A2, V1
9D0022D0  AC466400   SW A2, 25600(V0)
9D002318  8C436800   LW V1, 26624(V0)
9D002320  00C33025   OR A2, A2, V1
9D002324  AC466800   SW A2, 26624(V0)
9D00236C  8C436200   LW V1, 25088(V0)
9D002374  00C33025   OR A2, A2, V1
9D002378  AC466200   SW A2, 25088(V0)
9D0023C0  8C436600   LW V1, 26112(V0)
9D0023C8  00C33025   OR A2, A2, V1
9D0023CC  AC466600   SW A2, 26112(V0)
9D002414  8C436A00   LW V1, 27136(V0)
9D00241C  00C33025   OR A2, A2, V1
9D002420  AC466A00   SW A2, 27136(V0)
9D002424  8CA30014   LW V1, 20(A1)
9D002428  0B400948   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00242C  8CA2001C   LW V0, 28(A1)
9D002430  3C04BF80   LUI A0, -16512
9D002434  8C856410   LW A1, 25616(A0)
9D002438  34A51400   ORI A1, A1, 5120
9D00243C  AC856410   SW A1, 25616(A0)
9D002440  0062001B   DIVU V1, V0
9D002444  004001F4   TEQ V0, ZERO
9D002448  00001012   MFLO V0
9D00244C  00022082   SRL A0, V0, 2
9D002450  2484FFFF   ADDIU A0, A0, -1
9D002454  3C030001   LUI V1, 1
9D002458  0083182B   SLTU V1, A0, V1
9D00245C  5460FDD8   BNEL V1, ZERO, 0x9D001BC0
9D002460  3C02BF80   LUI V0, -16512
9D002464  0B4006F7   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002468  3C03BF80   LUI V1, -16512
9D00246C  3C04BF80   LUI A0, -16512
9D002470  8C856810   LW A1, 26640(A0)
9D002474  34A51400   ORI A1, A1, 5120
9D002478  AC856810   SW A1, 26640(A0)
9D00247C  0062001B   DIVU V1, V0
9D002480  004001F4   TEQ V0, ZERO
9D002484  00001012   MFLO V0
9D002488  00022082   SRL A0, V0, 2
9D00248C  2484FFFF   ADDIU A0, A0, -1
9D002490  3C030001   LUI V1, 1
9D002494  0083182B   SLTU V1, A0, V1
9D002498  5460FDDE   BNEL V1, ZERO, 0x9D001C14
9D00249C  3C02BF80   LUI V0, -16512
9D0024A0  0B40070C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024A4  3C03BF80   LUI V1, -16512
9D0024A8  3C04BF80   LUI A0, -16512
9D0024AC  8C856210   LW A1, 25104(A0)
9D0024B0  34A51400   ORI A1, A1, 5120
9D0024B4  AC856210   SW A1, 25104(A0)
9D0024B8  0062001B   DIVU V1, V0
9D0024BC  004001F4   TEQ V0, ZERO
9D0024C0  00001012   MFLO V0
9D0024C4  00022082   SRL A0, V0, 2
9D0024C8  2484FFFF   ADDIU A0, A0, -1
9D0024CC  3C030001   LUI V1, 1
9D0024D0  0083182B   SLTU V1, A0, V1
9D0024D4  5460FDE4   BNEL V1, ZERO, 0x9D001C68
9D0024D8  3C02BF80   LUI V0, -16512
9D0024DC  0B400721   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024E0  3C03BF80   LUI V1, -16512
9D0024E4  3C04BF80   LUI A0, -16512
9D0024E8  8C856610   LW A1, 26128(A0)
9D0024EC  34A51400   ORI A1, A1, 5120
9D0024F0  AC856610   SW A1, 26128(A0)
9D0024F4  0062001B   DIVU V1, V0
9D0024F8  004001F4   TEQ V0, ZERO
9D0024FC  00001012   MFLO V0
9D002500  00022082   SRL A0, V0, 2
9D002504  2484FFFF   ADDIU A0, A0, -1
9D002508  3C030001   LUI V1, 1
9D00250C  0083182B   SLTU V1, A0, V1
9D002510  5460FDEA   BNEL V1, ZERO, 0x9D001CBC
9D002514  3C02BF80   LUI V0, -16512
9D002518  0B400736   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00251C  3C03BF80   LUI V1, -16512
9D002520  3C04BF80   LUI A0, -16512
9D002524  8C856A10   LW A1, 27152(A0)
9D002528  34A51400   ORI A1, A1, 5120
9D00252C  AC856A10   SW A1, 27152(A0)
9D002530  0062001B   DIVU V1, V0
9D002534  004001F4   TEQ V0, ZERO
9D002538  00001012   MFLO V0
9D00253C  00022082   SRL A0, V0, 2
9D002540  2484FFFF   ADDIU A0, A0, -1
9D002544  3C030001   LUI V1, 1
9D002548  0083182B   SLTU V1, A0, V1
9D00254C  5460FDF0   BNEL V1, ZERO, 0x9D001D10
9D002550  3C02BF80   LUI V0, -16512
9D002554  0B40074B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002558  3C03BF80   LUI V1, -16512
132:                 }
133:                 
134:                 
135:                 #endif /*_USART_RECEIVERINTERRUPTMODE_DEFAULT_H*/
136:                 
137:                 /******************************************************************************
138:                  End of File
139:                 */
140:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_receiverdataavailable_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverDataAvailable_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverDataAvailable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverDataAvailableStatus
16:                          PLIB_USART_ReceiverDataIsAvailable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_RECEIVERDATAAVAILABLE_DEFAULT_H
47:                  #define _USART_RECEIVERDATAAVAILABLE_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _USART_RECEIVER_DATA_AVAILABLE_VREG(index)
54:                  
55:                    MASKs: 
56:                      _USART_RECEIVER_DATA_AVAILABLE_MASK(index)
57:                  
58:                    POSs: 
59:                      _USART_RECEIVER_DATA_AVAILABLE_POS(index)
60:                  
61:                    LENs: 
62:                      _USART_RECEIVER_DATA_AVAILABLE_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  USART_ExistsReceiverDataAvailableStatus_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_USART_ExistsReceiverDataAvailableStatus
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverDataAvailableStatus function.
75:                  */
76:                  
77:                  #define PLIB_USART_ExistsReceiverDataAvailableStatus PLIB_USART_ExistsReceiverDataAvailableStatus
78:                  PLIB_TEMPLATE bool USART_ExistsReceiverDataAvailableStatus_Default( USART_MODULE_ID index )
79:                  {
80:                      return true;
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  USART_ReceiverDataIsAvailable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_USART_ReceiverDataIsAvailable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_USART_ReceiverDataIsAvailable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE bool USART_ReceiverDataIsAvailable_Default( USART_MODULE_ID index )
95:                  {
96:                     return _SFR_BIT_READ(_USART_RECEIVER_DATA_AVAILABLE_VREG(index),
9D00C008  3C02BF80   LUI V0, -16512
9D00C00C  8C426810   LW V0, 26640(V0)
9D00C010  30420001   ANDI V0, V0, 1
9D00C01C  3C11BF80   LUI S1, -16512
9D00C038  8E226810   LW V0, 26640(S1)
9D00C03C  30420001   ANDI V0, V0, 1
9D00C48C  3C02BF80   LUI V0, -16512
9D00C490  8C426010   LW V0, 24592(V0)
9D00C494  30420001   ANDI V0, V0, 1
9D00C4A0  3C10BF80   LUI S0, -16512
9D00C4B0  8E026010   LW V0, 24592(S0)
9D00C4B4  30420001   ANDI V0, V0, 1
0000004C  00000000   NOP
0000005C  00000000   NOP
00000064  00000000   NOP
00000104  00000000   NOP
0000013C  00000000   NOP
00000228  00000000   NOP
97:                                               _USART_RECEIVER_DATA_AVAILABLE_POS(index) );
98:                  }
99:                  
100:                 
101:                 #endif /*_USART_RECEIVERDATAAVAILABLE_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_receiveraddressdetect_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddressDetect_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddressDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddressDetect
16:                          PLIB_USART_ReceiverAddressDetectEnable
17:                          PLIB_USART_ReceiverAddressDetectDisable
18:                          PLIB_USART_ReceiverAddressIsReceived
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_RECEIVERADDRESSDETECT_DEFAULT_H
49:                  #define _USART_RECEIVERADDRESSDETECT_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
53:                  
54:                    VREGs:
55:                      _USART_RECEIVER_ADDRESS_DETECT_VREG(index)
56:                  
57:                    MASKs:
58:                      _USART_RECEIVER_ADDRESS_DETECT_MASK(index)
59:                  
60:                    POSs:
61:                      _USART_RECEIVER_ADDRESS_DETECT_POS(index)
62:                  
63:                    LENs:
64:                      _USART_RECEIVER_ADDRESS_DETECT_LEN(index)
65:                  
66:                  */
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ExistsReceiverAddressDetect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ExistsReceiverAddressDetect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddressDetect function.
77:                  */
78:                  
79:                  #define PLIB_USART_ExistsReceiverAddressDetect PLIB_USART_ExistsReceiverAddressDetect
80:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddressDetect_Default( USART_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USART_ReceiverAddressDetectEnable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USART_ReceiverAddressDetectEnable
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressDetectEnable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void USART_ReceiverAddressDetectEnable_Default( USART_MODULE_ID index )
97:                  {
98:                      _SFR_BIT_SET(_USART_RECEIVER_ADDRESS_DETECT_VREG(index),
9D001490  24030020   ADDIU V1, ZERO, 32
9D001494  3C02BF80   LUI V0, -16512
9D001498  24426010   ADDIU V0, V0, 24592
9D00149C  AC430008   SW V1, 8(V0)
9D001D64  24030020   ADDIU V1, ZERO, 32
9D001D68  3C02BF80   LUI V0, -16512
9D001D6C  24426410   ADDIU V0, V0, 25616
9D001D70  AC430008   SW V1, 8(V0)
9D001D7C  24030020   ADDIU V1, ZERO, 32
9D001D80  3C02BF80   LUI V0, -16512
9D001D84  24426810   ADDIU V0, V0, 26640
9D001D88  AC430008   SW V1, 8(V0)
9D001D94  24030020   ADDIU V1, ZERO, 32
9D001D98  3C02BF80   LUI V0, -16512
9D001D9C  24426210   ADDIU V0, V0, 25104
9D001DA0  AC430008   SW V1, 8(V0)
9D001DAC  24030020   ADDIU V1, ZERO, 32
9D001DB0  3C02BF80   LUI V0, -16512
9D001DB4  24426610   ADDIU V0, V0, 26128
9D001DB8  AC430008   SW V1, 8(V0)
9D001DC4  24030020   ADDIU V1, ZERO, 32
9D001DC8  3C02BF80   LUI V0, -16512
9D001DCC  24426A10   ADDIU V0, V0, 27152
9D001DD0  AC430008   SW V1, 8(V0)
99:                          _USART_RECEIVER_ADDRESS_DETECT_POS(index) );
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USART_ReceiverAddressDetectDisable_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USART_ReceiverAddressDetectDisable
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USART_ReceiverAddressDetectDisable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void USART_ReceiverAddressDetectDisable_Default( USART_MODULE_ID index )
114:                 {
115:                     _SFR_BIT_CLEAR(_USART_RECEIVER_ADDRESS_DETECT_VREG(index),
116:                         _USART_RECEIVER_ADDRESS_DETECT_POS(index) );
117:                 }
118:                 
119:                 
120:                 //******************************************************************************
121:                 /* Function :  USART_ReceiverAddressIsReceived_Default
122:                 
123:                   Summary:
124:                     Implements Default variant of PLIB_USART_ReceiverAddressIsReceived
125:                 
126:                   Description:
127:                     This template implements the Default variant of the PLIB_USART_ReceiverAddressIsReceived function.
128:                 */
129:                 
130:                 PLIB_TEMPLATE bool USART_ReceiverAddressIsReceived_Default( USART_MODULE_ID index )
131:                 {
132:                 return _SFR_BIT_READ(_USART_RECEIVER_ADDRESS_DETECT_VREG(index),
133:                         _USART_RECEIVER_ADDRESS_DETECT_POS(index) );
134:                 }
135:                 
136:                 
137:                 #endif /*_USART_RECEIVERADDRESSDETECT_DEFAULT_H*/
138:                 
139:                 /******************************************************************************
140:                  End of File
141:                 */
142:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_receiveraddressautodetect_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddressAutoDetect_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddressAutoDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddressAutoDetect
16:                          PLIB_USART_ReceiverAddressAutoDetectEnable
17:                          PLIB_USART_ReceiverAddressAutoDetectDisable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H
48:                  #define _USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_VREG(index)
55:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_VREG(index)
56:                  
57:                    MASKs: 
58:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_MASK(index)
59:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_MASK(index)
60:                  
61:                    POSs: 
62:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_POS(index)
63:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_POS(index)
64:                  
65:                    LENs: 
66:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_LEN(index)
67:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_LEN(index)
68:                  
69:                  */
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  USART_ExistsReceiverAddressAutoDetect_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_USART_ExistsReceiverAddressAutoDetect
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddressAutoDetect function.
80:                  */
81:                  
82:                  #define PLIB_USART_ExistsReceiverAddressAutoDetect PLIB_USART_ExistsReceiverAddressAutoDetect
83:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddressAutoDetect_Default( USART_MODULE_ID index )
84:                  {
85:                      return true;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USART_ReceiverAddressAutoDetectEnable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_USART_ReceiverAddressAutoDetectEnable 
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressAutoDetectEnable function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void USART_ReceiverAddressAutoDetectEnable_Default( USART_MODULE_ID index , int8_t Mask )
100:                 {
101:                     _SFR_FIELD_WRITE(_USART_RECEIVER_ADDRESS_AUTO_DETECT_VREG(index), 
9D0015A0  3C02BF80   LUI V0, -16512
9D0015A4  8C476010   LW A3, 24592(V0)
9D0015A8  00031C00   SLL V1, V1, 16
9D0015AC  3C0600FF   LUI A2, 255
9D0015B0  00663024   AND A2, V1, A2
9D0015B4  3C03FF00   LUI V1, -256
9D0015B8  3463FFFF   ORI V1, V1, -1
9D0015BC  00E31824   AND V1, A3, V1
9D0015C0  00C31825   OR V1, A2, V1
9D0015C4  AC436010   SW V1, 24592(V0)
9D001F0C  3C02BF80   LUI V0, -16512
9D001F10  8C476410   LW A3, 25616(V0)
9D001F14  00031C00   SLL V1, V1, 16
9D001F18  3C0600FF   LUI A2, 255
9D001F1C  00661824   AND V1, V1, A2
9D001F20  3C06FF00   LUI A2, -256
9D001F24  34C6FFFF   ORI A2, A2, -1
9D001F28  00E63024   AND A2, A3, A2
9D001F2C  00661825   OR V1, V1, A2
9D001F30  AC436410   SW V1, 25616(V0)
9D001F60  3C02BF80   LUI V0, -16512
9D001F64  8C476810   LW A3, 26640(V0)
9D001F68  00031C00   SLL V1, V1, 16
9D001F6C  3C0600FF   LUI A2, 255
9D001F70  00661824   AND V1, V1, A2
9D001F74  3C06FF00   LUI A2, -256
9D001F78  34C6FFFF   ORI A2, A2, -1
9D001F7C  00E63024   AND A2, A3, A2
9D001F80  00661825   OR V1, V1, A2
9D001F84  AC436810   SW V1, 26640(V0)
9D001FB4  3C02BF80   LUI V0, -16512
9D001FB8  8C476210   LW A3, 25104(V0)
9D001FBC  00031C00   SLL V1, V1, 16
9D001FC0  3C0600FF   LUI A2, 255
9D001FC4  00661824   AND V1, V1, A2
9D001FC8  3C06FF00   LUI A2, -256
9D001FCC  34C6FFFF   ORI A2, A2, -1
9D001FD0  00E63024   AND A2, A3, A2
9D001FD4  00661825   OR V1, V1, A2
9D001FD8  AC436210   SW V1, 25104(V0)
9D001FFC  3C02BF80   LUI V0, -16512
9D002000  8C476610   LW A3, 26128(V0)
9D002004  00031C00   SLL V1, V1, 16
9D002008  3C0600FF   LUI A2, 255
9D00200C  00661824   AND V1, V1, A2
9D002010  3C06FF00   LUI A2, -256
9D002014  34C6FFFF   ORI A2, A2, -1
9D002018  00E63024   AND A2, A3, A2
9D00201C  00661825   OR V1, V1, A2
9D002020  AC436610   SW V1, 26128(V0)
9D002044  3C02BF80   LUI V0, -16512
9D002048  8C476A10   LW A3, 27152(V0)
9D00204C  00031C00   SLL V1, V1, 16
9D002050  3C0600FF   LUI A2, 255
9D002054  00661824   AND V1, V1, A2
9D002058  3C06FF00   LUI A2, -256
9D00205C  34C6FFFF   ORI A2, A2, -1
9D002060  00E63024   AND A2, A3, A2
9D002064  00661825   OR V1, V1, A2
9D002068  AC436A10   SW V1, 27152(V0)
102:                             _USART_RECEIVER_ADDRESS_AUTO_DETECT_MASK(index),
103:                             _USART_RECEIVER_ADDRESS_AUTO_DETECT_POS(index),
104:                             Mask);
105:                     _SFR_BIT_SET(_USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_VREG(index),
9D0015C8  24426010   ADDIU V0, V0, 24592
9D0015CC  3C030100   LUI V1, 256
9D0015D0  AC430008   SW V1, 8(V0)
9D001F34  24426410   ADDIU V0, V0, 25616
9D001F38  3C030100   LUI V1, 256
9D001F3C  AC430008   SW V1, 8(V0)
9D001F88  24426810   ADDIU V0, V0, 26640
9D001F8C  3C030100   LUI V1, 256
9D001F90  AC430008   SW V1, 8(V0)
9D001FDC  24426210   ADDIU V0, V0, 25104
9D001FE0  3C030100   LUI V1, 256
9D001FE4  AC430008   SW V1, 8(V0)
9D002024  24426610   ADDIU V0, V0, 26128
9D002028  3C030100   LUI V1, 256
9D00202C  AC430008   SW V1, 8(V0)
9D00206C  24426A10   ADDIU V0, V0, 27152
9D002070  3C030100   LUI V1, 256
9D002074  AC430008   SW V1, 8(V0)
106:                         _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_POS(index) );
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  USART_ReceiverAddressAutoDetectDisable_Default
112:                 
113:                   Summary:
114:                     Implements Default variant of PLIB_USART_ReceiverAddressAutoDetectDisable 
115:                 
116:                   Description:
117:                     This template implements the Default variant of the PLIB_USART_ReceiverAddressAutoDetectDisable function.
118:                 */
119:                 
120:                 PLIB_TEMPLATE void USART_ReceiverAddressAutoDetectDisable_Default( USART_MODULE_ID index )
121:                 {
122:                     _SFR_BIT_CLEAR(_USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_VREG(index),
123:                         _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_POS(index) );
124:                 }
125:                 
126:                 
127:                 #endif /*_USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_receiveraddress_default.h  
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddress_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddress
16:                          PLIB_USART_AddressSet
17:                          PLIB_USART_AddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERADDRESS_DEFAULT_H
48:                  #define _USART_RECEIVERADDRESS_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_VREG(index)
55:                  
56:                    MASKs: 
57:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_MASK(index)
58:                  
59:                    POSs: 
60:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_POS(index)
61:                  
62:                    LENs: 
63:                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ExistsReceiverAddress_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ExistsReceiverAddress
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddress function.
76:                  */
77:                  
78:                  #define PLIB_USART_ExistsReceiverAddress PLIB_USART_ExistsReceiverAddress
79:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddress_Default( USART_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USART_AddressSet_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USART_AddressSet 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USART_AddressSet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void USART_AddressSet_Default( USART_MODULE_ID index , uint8_t address )
96:                  {
97:                     _SFR_FIELD_WRITE(_USART_RECEIVER_ADDRESS_AUTO_DETECT_VREG(index),
9D0014E8  3C03BF80   LUI V1, -16512
9D0014EC  8C676010   LW A3, 24592(V1)
9D0014F0  00021400   SLL V0, V0, 16
9D0014F4  3C06FF00   LUI A2, -256
9D0014F8  34C6FFFF   ORI A2, A2, -1
9D0014FC  00E63024   AND A2, A3, A2
9D001500  00461025   OR V0, V0, A2
9D001504  AC626010   SW V0, 24592(V1)
9D001DDC  3C03BF80   LUI V1, -16512
9D001DE0  8C676410   LW A3, 25616(V1)
9D001DE4  00021400   SLL V0, V0, 16
9D001DE8  3C06FF00   LUI A2, -256
9D001DEC  34C6FFFF   ORI A2, A2, -1
9D001DF0  00E63024   AND A2, A3, A2
9D001DF4  00461025   OR V0, V0, A2
9D001DF8  AC626410   SW V0, 25616(V1)
9D001E04  3C03BF80   LUI V1, -16512
9D001E08  8C676810   LW A3, 26640(V1)
9D001E0C  00021400   SLL V0, V0, 16
9D001E10  3C06FF00   LUI A2, -256
9D001E14  34C6FFFF   ORI A2, A2, -1
9D001E18  00E63024   AND A2, A3, A2
9D001E1C  00461025   OR V0, V0, A2
9D001E20  AC626810   SW V0, 26640(V1)
9D001E2C  3C03BF80   LUI V1, -16512
9D001E30  8C676210   LW A3, 25104(V1)
9D001E34  00021400   SLL V0, V0, 16
9D001E38  3C06FF00   LUI A2, -256
9D001E3C  34C6FFFF   ORI A2, A2, -1
9D001E40  00E63024   AND A2, A3, A2
9D001E44  00461025   OR V0, V0, A2
9D001E48  AC626210   SW V0, 25104(V1)
9D001E54  3C03BF80   LUI V1, -16512
9D001E58  8C676610   LW A3, 26128(V1)
9D001E5C  00021400   SLL V0, V0, 16
9D001E60  3C06FF00   LUI A2, -256
9D001E64  34C6FFFF   ORI A2, A2, -1
9D001E68  00E63024   AND A2, A3, A2
9D001E6C  00461025   OR V0, V0, A2
9D001E70  AC626610   SW V0, 26128(V1)
9D001E7C  3C03BF80   LUI V1, -16512
9D001E80  8C676A10   LW A3, 27152(V1)
9D001E84  00021400   SLL V0, V0, 16
9D001E88  3C06FF00   LUI A2, -256
9D001E8C  34C6FFFF   ORI A2, A2, -1
9D001E90  00E63024   AND A2, A3, A2
9D001E94  00461025   OR V0, V0, A2
9D001E98  AC626A10   SW V0, 27152(V1)
98:                                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_MASK(index),
99:                                      _USART_RECEIVER_ADDRESS_AUTO_DETECT_POS(index),
100:                                     address);
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USART_AddressGet_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USART_AddressGet 
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USART_AddressGet function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE uint8_t USART_AddressGet_Default( USART_MODULE_ID index )
115:                 {
116:                     return (uint8_t)_SFR_FIELD_READ(_USART_RECEIVER_ADDRESS_AUTO_DETECT_VREG(index),
9D001508  0B400554   J 0x9D001550
9D00150C  3C02BF80   LUI V0, -16512
9D00154C  3C02BF80   LUI V0, -16512
9D001550  8C436010   LW V1, 24592(V0)
9D001554  7C633C00   EXT V1, V1, 16, 8
9D001DFC  0B4007AA   J 0x9D001EA8
9D001E00  3C02BF80   LUI V0, -16512
9D001E24  0B4007AF   J 0x9D001EBC
9D001E28  3C02BF80   LUI V0, -16512
9D001E4C  0B4007B4   J 0x9D001ED0
9D001E50  3C02BF80   LUI V0, -16512
9D001E74  0B4007B9   J 0x9D001EE4
9D001E78  3C02BF80   LUI V0, -16512
9D001E9C  0B4007BE   J 0x9D001EF8
9D001EA0  3C02BF80   LUI V0, -16512
9D001EA4  3C02BF80   LUI V0, -16512
9D001EA8  8C436410   LW V1, 25616(V0)
9D001EAC  7C633C00   EXT V1, V1, 16, 8
9D001EB8  3C02BF80   LUI V0, -16512
9D001EBC  8C436810   LW V1, 26640(V0)
9D001EC0  7C633C00   EXT V1, V1, 16, 8
9D001ECC  3C02BF80   LUI V0, -16512
9D001ED0  8C436210   LW V1, 25104(V0)
9D001ED4  7C633C00   EXT V1, V1, 16, 8
9D001EE0  3C02BF80   LUI V0, -16512
9D001EE4  8C436610   LW V1, 26128(V0)
9D001EE8  7C633C00   EXT V1, V1, 16, 8
9D001EF4  3C02BF80   LUI V0, -16512
9D001EF8  8C436A10   LW V1, 27152(V0)
9D001EFC  7C633C00   EXT V1, V1, 16, 8
9D001F00  0B400811   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001F04  7C031C20   SEB V1, V1
9D001F08  00001821   ADDU V1, ZERO, ZERO
9D001F0C  3C02BF80   LUI V0, -16512
9D001F10  8C476410   LW A3, 25616(V0)
9D001F14  00031C00   SLL V1, V1, 16
9D001F18  3C0600FF   LUI A2, 255
9D001F1C  00661824   AND V1, V1, A2
9D001F20  3C06FF00   LUI A2, -256
9D001F24  34C6FFFF   ORI A2, A2, -1
9D001F28  00E63024   AND A2, A3, A2
9D001F2C  00661825   OR V1, V1, A2
9D001F30  AC436410   SW V1, 25616(V0)
9D001F34  24426410   ADDIU V0, V0, 25616
9D001F38  3C030100   LUI V1, 256
9D001F3C  AC430008   SW V1, 8(V0)
9D001F40  8CA30020   LW V1, 32(A1)
9D001F44  24020002   ADDIU V0, ZERO, 2
9D001F48  1462004F   BNE V1, V0, 0x9D002088
9D001F4C  00004021   ADDU T0, ZERO, ZERO
9D001F50  00001021   ADDU V0, ZERO, ZERO
9D001F54  0B4005A1   J 0x9D001684
9D001F58  00003021   ADDU A2, ZERO, ZERO
9D001F5C  00001821   ADDU V1, ZERO, ZERO
9D001F60  3C02BF80   LUI V0, -16512
9D001F64  8C476810   LW A3, 26640(V0)
9D001F68  00031C00   SLL V1, V1, 16
9D001F6C  3C0600FF   LUI A2, 255
9D001F70  00661824   AND V1, V1, A2
9D001F74  3C06FF00   LUI A2, -256
9D001F78  34C6FFFF   ORI A2, A2, -1
9D001F7C  00E63024   AND A2, A3, A2
9D001F80  00661825   OR V1, V1, A2
9D001F84  AC436810   SW V1, 26640(V0)
9D001F88  24426810   ADDIU V0, V0, 26640
9D001F8C  3C030100   LUI V1, 256
9D001F90  AC430008   SW V1, 8(V0)
9D001F94  8CA30020   LW V1, 32(A1)
9D001F98  24020002   ADDIU V0, ZERO, 2
9D001F9C  1462004B   BNE V1, V0, 0x9D0020CC
9D001FA0  00004021   ADDU T0, ZERO, ZERO
9D001FA4  00001021   ADDU V0, ZERO, ZERO
9D001FA8  0B4005A1   J 0x9D001684
9D001FAC  00003021   ADDU A2, ZERO, ZERO
9D001FB0  00001821   ADDU V1, ZERO, ZERO
9D001FB4  3C02BF80   LUI V0, -16512
9D001FB8  8C476210   LW A3, 25104(V0)
9D001FBC  00031C00   SLL V1, V1, 16
9D001FC0  3C0600FF   LUI A2, 255
9D001FC4  00661824   AND V1, V1, A2
9D001FC8  3C06FF00   LUI A2, -256
9D001FCC  34C6FFFF   ORI A2, A2, -1
9D001FD0  00E63024   AND A2, A3, A2
9D001FD4  00661825   OR V1, V1, A2
9D001FD8  AC436210   SW V1, 25104(V0)
9D001FDC  24426210   ADDIU V0, V0, 25104
9D001FE0  3C030100   LUI V1, 256
9D001FE4  AC430008   SW V1, 8(V0)
9D001FE8  00003021   ADDU A2, ZERO, ZERO
9D001FEC  00004021   ADDU T0, ZERO, ZERO
9D001FF0  0B400582   J 0x9D001608
9D001FF4  00001021   ADDU V0, ZERO, ZERO
9D001FF8  00001821   ADDU V1, ZERO, ZERO
9D001FFC  3C02BF80   LUI V0, -16512
9D002000  8C476610   LW A3, 26128(V0)
9D002004  00031C00   SLL V1, V1, 16
9D002008  3C0600FF   LUI A2, 255
9D00200C  00661824   AND V1, V1, A2
9D002010  3C06FF00   LUI A2, -256
9D002014  34C6FFFF   ORI A2, A2, -1
9D002018  00E63024   AND A2, A3, A2
9D00201C  00661825   OR V1, V1, A2
9D002020  AC436610   SW V1, 26128(V0)
9D002024  24426610   ADDIU V0, V0, 26128
9D002028  3C030100   LUI V1, 256
9D00202C  AC430008   SW V1, 8(V0)
9D002030  00003021   ADDU A2, ZERO, ZERO
9D002034  00004021   ADDU T0, ZERO, ZERO
9D002038  0B400582   J 0x9D001608
9D00203C  00001021   ADDU V0, ZERO, ZERO
9D002040  00001821   ADDU V1, ZERO, ZERO
9D002044  3C02BF80   LUI V0, -16512
9D002048  8C476A10   LW A3, 27152(V0)
9D00204C  00031C00   SLL V1, V1, 16
9D002050  3C0600FF   LUI A2, 255
9D002054  00661824   AND V1, V1, A2
9D002058  3C06FF00   LUI A2, -256
9D00205C  34C6FFFF   ORI A2, A2, -1
9D002060  00E63024   AND A2, A3, A2
9D002064  00661825   OR V1, V1, A2
9D002068  AC436A10   SW V1, 27152(V0)
9D00206C  24426A10   ADDIU V0, V0, 27152
9D002070  3C030100   LUI V1, 256
9D002074  AC430008   SW V1, 8(V0)
9D002078  00003021   ADDU A2, ZERO, ZERO
9D00207C  00004021   ADDU T0, ZERO, ZERO
9D002080  0B400582   J 0x9D001608
9D002084  00001021   ADDU V0, ZERO, ZERO
9D002088  00001021   ADDU V0, ZERO, ZERO
9D00208C  3C04BF80   LUI A0, -16512
9D002090  8C866400   LW A2, 25600(A0)
9D002094  2404F7FF   ADDIU A0, ZERO, -2049
9D002098  00C43024   AND A2, A2, A0
9D00209C  38640001   XORI A0, V1, 1
9D0020A0  2C840001   SLTIU A0, A0, 1
9D0020A4  000422C0   SLL A0, A0, 11
9D0020A8  00862025   OR A0, A0, A2
9D0020AC  3C03BF80   LUI V1, -16512
9D0020B0  AC646400   SW A0, 25600(V1)
9D0020B4  8CA30010   LW V1, 16(A1)
9D0020B8  30690001   ANDI T1, V1, 1
9D0020BC  7C670080   EXT A3, V1, 2, 1
9D0020C0  7C630040   EXT V1, V1, 1, 1
9D0020C4  0B4005D1   J _DRV_USART_HardwareSetup::PLIB_USART_InitializeModeGeneral
9D0020C8  24060002   ADDIU A2, ZERO, 2
9D0020CC  00001021   ADDU V0, ZERO, ZERO
9D0020D0  3C04BF80   LUI A0, -16512
9D0020D4  8C866800   LW A2, 26624(A0)
9D0020D8  2404F7FF   ADDIU A0, ZERO, -2049
9D0020DC  00C43024   AND A2, A2, A0
9D0020E0  38640001   XORI A0, V1, 1
9D0020E4  2C840001   SLTIU A0, A0, 1
9D0020E8  000422C0   SLL A0, A0, 11
9D0020EC  00862025   OR A0, A0, A2
9D0020F0  3C03BF80   LUI V1, -16512
9D0020F4  AC646800   SW A0, 26624(V1)
9D0020F8  8CA30010   LW V1, 16(A1)
9D0020FC  30690001   ANDI T1, V1, 1
9D002100  7C670080   EXT A3, V1, 2, 1
9D002104  7C630040   EXT V1, V1, 1, 1
9D002108  0B4005EE   J _DRV_USART_HardwareSetup::PLIB_USART_InitializeModeGeneral
9D00210C  24060002   ADDIU A2, ZERO, 2
9D002110  3C03BF80   LUI V1, -16512
9D002114  8C676000   LW A3, 24576(V1)
9D002118  00042040   SLL A0, A0, 1
9D00211C  30840006   ANDI A0, A0, 6
9D002120  2402FFF9   ADDIU V0, ZERO, -7
9D002124  00E21024   AND V0, A3, V0
9D002128  00821025   OR V0, A0, V0
9D00212C  AC626000   SW V0, 24576(V1)
9D002130  0B4006A9   J 0x9D001AA4
9D002134  3C03BF80   LUI V1, -16512
9D002138  3C03BF80   LUI V1, -16512
9D00213C  24636400   ADDIU V1, V1, 25600
9D002140  AC640008   SW A0, 8(V1)
9D002144  0B400855   J 0x9D002154
9D002148  2442FFFC   ADDIU V0, V0, -4
9D00214C  24636400   ADDIU V1, V1, 25600
9D002150  AC640004   SW A0, 4(V1)
9D002154  3C03BF80   LUI V1, -16512
9D002158  8C676400   LW A3, 25600(V1)
9D00215C  00022040   SLL A0, V0, 1
9D002160  30840006   ANDI A0, A0, 6
9D002164  2402FFF9   ADDIU V0, ZERO, -7
9D002168  00E21024   AND V0, A3, V0
9D00216C  00821025   OR V0, A0, V0
9D002170  AC626400   SW V0, 25600(V1)
9D002174  0B4008A4   J 0x9D002290
9D002178  3C03BF80   LUI V1, -16512
9D00217C  3C03BF80   LUI V1, -16512
9D002180  24636800   ADDIU V1, V1, 26624
9D002184  AC640008   SW A0, 8(V1)
9D002188  0B400866   J 0x9D002198
9D00218C  2442FFFC   ADDIU V0, V0, -4
9D002190  24636800   ADDIU V1, V1, 26624
9D002194  AC640004   SW A0, 4(V1)
9D002198  3C03BF80   LUI V1, -16512
9D00219C  8C676800   LW A3, 26624(V1)
9D0021A0  00022040   SLL A0, V0, 1
9D0021A4  30840006   ANDI A0, A0, 6
9D0021A8  2402FFF9   ADDIU V0, ZERO, -7
9D0021AC  00E21024   AND V0, A3, V0
9D0021B0  00821025   OR V0, A0, V0
9D0021B4  AC626800   SW V0, 26624(V1)
9D0021B8  0B4008B9   J 0x9D0022E4
9D0021BC  3C03BF80   LUI V1, -16512
9D0021C0  3C03BF80   LUI V1, -16512
9D0021C4  24636200   ADDIU V1, V1, 25088
9D0021C8  AC640008   SW A0, 8(V1)
9D0021CC  0B400877   J 0x9D0021DC
9D0021D0  2442FFFC   ADDIU V0, V0, -4
9D0021D4  24636200   ADDIU V1, V1, 25088
9D0021D8  AC640004   SW A0, 4(V1)
9D0021DC  3C03BF80   LUI V1, -16512
9D0021E0  8C676200   LW A3, 25088(V1)
9D0021E4  00022040   SLL A0, V0, 1
9D0021E8  30840006   ANDI A0, A0, 6
9D0021EC  2402FFF9   ADDIU V0, ZERO, -7
9D0021F0  00E21024   AND V0, A3, V0
9D0021F4  00821025   OR V0, A0, V0
9D0021F8  AC626200   SW V0, 25088(V1)
9D0021FC  0B4008CE   J 0x9D002338
9D002200  3C03BF80   LUI V1, -16512
9D002204  3C03BF80   LUI V1, -16512
9D002208  24636600   ADDIU V1, V1, 26112
9D00220C  AC640008   SW A0, 8(V1)
9D002210  0B400888   J 0x9D002220
9D002214  2442FFFC   ADDIU V0, V0, -4
9D002218  24636600   ADDIU V1, V1, 26112
9D00221C  AC640004   SW A0, 4(V1)
9D002220  3C03BF80   LUI V1, -16512
9D002224  8C676600   LW A3, 26112(V1)
9D002228  00022040   SLL A0, V0, 1
9D00222C  30840006   ANDI A0, A0, 6
9D002230  2402FFF9   ADDIU V0, ZERO, -7
9D002234  00E21024   AND V0, A3, V0
9D002238  00821025   OR V0, A0, V0
9D00223C  AC626600   SW V0, 26112(V1)
9D002240  0B4008E3   J 0x9D00238C
9D002244  3C03BF80   LUI V1, -16512
9D002248  3C03BF80   LUI V1, -16512
9D00224C  24636A00   ADDIU V1, V1, 27136
9D002250  AC640008   SW A0, 8(V1)
9D002254  0B400899   J 0x9D002264
9D002258  2442FFFC   ADDIU V0, V0, -4
9D00225C  24636A00   ADDIU V1, V1, 27136
9D002260  AC640004   SW A0, 4(V1)
9D002264  3C03BF80   LUI V1, -16512
9D002268  8C676A00   LW A3, 27136(V1)
9D00226C  00022040   SLL A0, V0, 1
9D002270  30840006   ANDI A0, A0, 6
9D002274  2402FFF9   ADDIU V0, ZERO, -7
9D002278  00E21024   AND V0, A3, V0
9D00227C  00821025   OR V0, A0, V0
9D002280  AC626A00   SW V0, 27136(V1)
9D002284  0B4008F8   J 0x9D0023E0
9D002288  3C03BF80   LUI V1, -16512
9D00228C  3C03BF80   LUI V1, -16512
9D002290  8C646410   LW A0, 25616(V1)
9D002294  3C02FFFF   LUI V0, -1
9D002298  24423030   ADDIU V0, V0, 12336
9D00229C  00821024   AND V0, A0, V0
9D0022A0  AC626410   SW V0, 25616(V1)
9D0022A4  3C02BF80   LUI V0, -16512
9D0022A8  8C476400   LW A3, 25600(V0)
9D0022AC  2404FCFF   ADDIU A0, ZERO, -769
9D0022B0  00E42024   AND A0, A3, A0
9D0022B4  AC446400   SW A0, 25600(V0)
9D0022B8  8C646410   LW A0, 25616(V1)
9D0022BC  34844000   ORI A0, A0, 16384
9D0022C0  AC646410   SW A0, 25616(V1)
9D0022C4  8C436400   LW V1, 25600(V0)
9D0022C8  00063200   SLL A2, A2, 8
9D0022CC  00C33025   OR A2, A2, V1
9D0022D0  AC466400   SW A2, 25600(V0)
9D0022D4  8CA30014   LW V1, 20(A1)
9D0022D8  0B40090C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0022DC  8CA2001C   LW V0, 28(A1)
9D0022E0  3C03BF80   LUI V1, -16512
9D0022E4  8C646810   LW A0, 26640(V1)
9D0022E8  3C02FFFF   LUI V0, -1
9D0022EC  24423030   ADDIU V0, V0, 12336
9D0022F0  00821024   AND V0, A0, V0
9D0022F4  AC626810   SW V0, 26640(V1)
9D0022F8  3C02BF80   LUI V0, -16512
9D0022FC  8C476800   LW A3, 26624(V0)
9D002300  2404FCFF   ADDIU A0, ZERO, -769
9D002304  00E42024   AND A0, A3, A0
9D002308  AC446800   SW A0, 26624(V0)
9D00230C  8C646810   LW A0, 26640(V1)
9D002310  34844000   ORI A0, A0, 16384
9D002314  AC646810   SW A0, 26640(V1)
9D002318  8C436800   LW V1, 26624(V0)
9D00231C  00063200   SLL A2, A2, 8
9D002320  00C33025   OR A2, A2, V1
9D002324  AC466800   SW A2, 26624(V0)
9D002328  8CA30014   LW V1, 20(A1)
9D00232C  0B40091B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002330  8CA2001C   LW V0, 28(A1)
9D002334  3C03BF80   LUI V1, -16512
9D002338  8C646210   LW A0, 25104(V1)
9D00233C  3C02FFFF   LUI V0, -1
9D002340  24423030   ADDIU V0, V0, 12336
9D002344  00821024   AND V0, A0, V0
9D002348  AC626210   SW V0, 25104(V1)
9D00234C  3C02BF80   LUI V0, -16512
9D002350  8C476200   LW A3, 25088(V0)
9D002354  2404FCFF   ADDIU A0, ZERO, -769
9D002358  00E42024   AND A0, A3, A0
9D00235C  AC446200   SW A0, 25088(V0)
9D002360  8C646210   LW A0, 25104(V1)
9D002364  34844000   ORI A0, A0, 16384
9D002368  AC646210   SW A0, 25104(V1)
9D00236C  8C436200   LW V1, 25088(V0)
9D002370  00063200   SLL A2, A2, 8
9D002374  00C33025   OR A2, A2, V1
9D002378  AC466200   SW A2, 25088(V0)
9D00237C  8CA30014   LW V1, 20(A1)
9D002380  0B40092A   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002384  8CA2001C   LW V0, 28(A1)
9D002388  3C03BF80   LUI V1, -16512
9D00238C  8C646610   LW A0, 26128(V1)
9D002390  3C02FFFF   LUI V0, -1
9D002394  24423030   ADDIU V0, V0, 12336
9D002398  00821024   AND V0, A0, V0
9D00239C  AC626610   SW V0, 26128(V1)
9D0023A0  3C02BF80   LUI V0, -16512
9D0023A4  8C476600   LW A3, 26112(V0)
9D0023A8  2404FCFF   ADDIU A0, ZERO, -769
9D0023AC  00E42024   AND A0, A3, A0
9D0023B0  AC446600   SW A0, 26112(V0)
9D0023B4  8C646610   LW A0, 26128(V1)
9D0023B8  34844000   ORI A0, A0, 16384
9D0023BC  AC646610   SW A0, 26128(V1)
9D0023C0  8C436600   LW V1, 26112(V0)
9D0023C4  00063200   SLL A2, A2, 8
9D0023C8  00C33025   OR A2, A2, V1
9D0023CC  AC466600   SW A2, 26112(V0)
9D0023D0  8CA30014   LW V1, 20(A1)
9D0023D4  0B400939   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0023D8  8CA2001C   LW V0, 28(A1)
9D0023DC  3C03BF80   LUI V1, -16512
9D0023E0  8C646A10   LW A0, 27152(V1)
9D0023E4  3C02FFFF   LUI V0, -1
9D0023E8  24423030   ADDIU V0, V0, 12336
9D0023EC  00821024   AND V0, A0, V0
9D0023F0  AC626A10   SW V0, 27152(V1)
9D0023F4  3C02BF80   LUI V0, -16512
9D0023F8  8C476A00   LW A3, 27136(V0)
9D0023FC  2404FCFF   ADDIU A0, ZERO, -769
9D002400  00E42024   AND A0, A3, A0
9D002404  AC446A00   SW A0, 27136(V0)
9D002408  8C646A10   LW A0, 27152(V1)
9D00240C  34844000   ORI A0, A0, 16384
9D002410  AC646A10   SW A0, 27152(V1)
9D002414  8C436A00   LW V1, 27136(V0)
9D002418  00063200   SLL A2, A2, 8
9D00241C  00C33025   OR A2, A2, V1
9D002420  AC466A00   SW A2, 27136(V0)
9D002424  8CA30014   LW V1, 20(A1)
9D002428  0B400948   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00242C  8CA2001C   LW V0, 28(A1)
9D002430  3C04BF80   LUI A0, -16512
9D002434  8C856410   LW A1, 25616(A0)
9D002438  34A51400   ORI A1, A1, 5120
9D00243C  AC856410   SW A1, 25616(A0)
9D002440  0062001B   DIVU V1, V0
9D002444  004001F4   TEQ V0, ZERO
9D002448  00001012   MFLO V0
9D00244C  00022082   SRL A0, V0, 2
9D002450  2484FFFF   ADDIU A0, A0, -1
9D002454  3C030001   LUI V1, 1
9D002458  0083182B   SLTU V1, A0, V1
9D00245C  5460FDD8   BNEL V1, ZERO, 0x9D001BC0
9D002460  3C02BF80   LUI V0, -16512
9D002464  0B4006F7   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002468  3C03BF80   LUI V1, -16512
9D00246C  3C04BF80   LUI A0, -16512
9D002470  8C856810   LW A1, 26640(A0)
9D002474  34A51400   ORI A1, A1, 5120
9D002478  AC856810   SW A1, 26640(A0)
9D00247C  0062001B   DIVU V1, V0
9D002480  004001F4   TEQ V0, ZERO
9D002484  00001012   MFLO V0
9D002488  00022082   SRL A0, V0, 2
9D00248C  2484FFFF   ADDIU A0, A0, -1
9D002490  3C030001   LUI V1, 1
9D002494  0083182B   SLTU V1, A0, V1
9D002498  5460FDDE   BNEL V1, ZERO, 0x9D001C14
9D00249C  3C02BF80   LUI V0, -16512
9D0024A0  0B40070C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024A4  3C03BF80   LUI V1, -16512
9D0024A8  3C04BF80   LUI A0, -16512
9D0024AC  8C856210   LW A1, 25104(A0)
9D0024B0  34A51400   ORI A1, A1, 5120
9D0024B4  AC856210   SW A1, 25104(A0)
9D0024B8  0062001B   DIVU V1, V0
9D0024BC  004001F4   TEQ V0, ZERO
9D0024C0  00001012   MFLO V0
9D0024C4  00022082   SRL A0, V0, 2
9D0024C8  2484FFFF   ADDIU A0, A0, -1
9D0024CC  3C030001   LUI V1, 1
9D0024D0  0083182B   SLTU V1, A0, V1
9D0024D4  5460FDE4   BNEL V1, ZERO, 0x9D001C68
9D0024D8  3C02BF80   LUI V0, -16512
9D0024DC  0B400721   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024E0  3C03BF80   LUI V1, -16512
9D0024E4  3C04BF80   LUI A0, -16512
9D0024E8  8C856610   LW A1, 26128(A0)
9D0024EC  34A51400   ORI A1, A1, 5120
9D0024F0  AC856610   SW A1, 26128(A0)
9D0024F4  0062001B   DIVU V1, V0
9D0024F8  004001F4   TEQ V0, ZERO
9D0024FC  00001012   MFLO V0
9D002500  00022082   SRL A0, V0, 2
9D002504  2484FFFF   ADDIU A0, A0, -1
9D002508  3C030001   LUI V1, 1
9D00250C  0083182B   SLTU V1, A0, V1
9D002510  5460FDEA   BNEL V1, ZERO, 0x9D001CBC
9D002514  3C02BF80   LUI V0, -16512
9D002518  0B400736   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00251C  3C03BF80   LUI V1, -16512
9D002520  3C04BF80   LUI A0, -16512
9D002524  8C856A10   LW A1, 27152(A0)
9D002528  34A51400   ORI A1, A1, 5120
9D00252C  AC856A10   SW A1, 27152(A0)
9D002530  0062001B   DIVU V1, V0
9D002534  004001F4   TEQ V0, ZERO
9D002538  00001012   MFLO V0
9D00253C  00022082   SRL A0, V0, 2
9D002540  2484FFFF   ADDIU A0, A0, -1
9D002544  3C030001   LUI V1, 1
9D002548  0083182B   SLTU V1, A0, V1
9D00254C  5460FDF0   BNEL V1, ZERO, 0x9D001D10
9D002550  3C02BF80   LUI V0, -16512
9D002554  0B40074B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002558  3C03BF80   LUI V1, -16512
117:                                            _USART_RECEIVER_ADDRESS_AUTO_DETECT_MASK(index),
118:                                            _USART_RECEIVER_ADDRESS_AUTO_DETECT_POS(index));
119:                 }
120:                 
121:                 
122:                 #endif /*_USART_RECEIVERADDRESS_DEFAULT_H*/
123:                 
124:                 /******************************************************************************
125:                  End of File
126:                 */
127:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_receiver_default.h  -------
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Receiver_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Receiver
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiver
16:                          PLIB_USART_ReceiverByteReceive
17:                          PLIB_USART_ReceiverAddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVER_DEFAULT_H
48:                  #define _USART_RECEIVER_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
52:                  
53:                    VREGs:
54:                      _USART_RECEIVER_DATA_VREG(index)
55:                  
56:                    MASKs:
57:                      _USART_RECEIVER_DATA_MASK(index)
58:                  
59:                    POSs:
60:                      _USART_RECEIVER_DATA_POS(index)
61:                  
62:                    LENs:
63:                      _USART_RECEIVER_DATA_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ExistsReceiver_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ExistsReceiver
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ExistsReceiver function.
76:                  */
77:                  
78:                  #define PLIB_USART_ExistsReceiver PLIB_USART_ExistsReceiver
79:                  PLIB_TEMPLATE bool USART_ExistsReceiver_Default( USART_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USART_ReceiverByteReceive_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USART_ReceiverByteReceive
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USART_ReceiverByteReceive function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE int8_t USART_ReceiverByteReceive_Default( USART_MODULE_ID index )
96:                  {
97:                      return _SFR_FIELD_READ(_USART_RECEIVER_DATA_VREG(index),
9D00C020  8E506830   LW S0, 26672(S2)
9D00C024  321000FF   ANDI S0, S0, 255
9D00C4A4  8E246030   LW A0, 24624(S1)
00000070  00000000   NOP
00000080  00000000   NOP
000000A8  00000000   NOP
000000B8  00000000   NOP
000001EC  00000000   NOP
98:                                             _USART_RECEIVER_DATA_MASK(index),
99:                                             _USART_RECEIVER_DATA_POS(index) );
100:                 }
101:                 
102:                 //******************************************************************************
103:                 /* Function :  USART_ReceiverAddressGet_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_USART_ReceiverAddressGet
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_USART_ReceiverAddressGet function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void* USART_ReceiverAddressGet_Default( USART_MODULE_ID index )
113:                 {
114:                 	return (uint32_t*)_USART_RECEIVER_DATA_VREG(index);
115:                 }
116:                 
117:                 #endif /*_USART_RECEIVER_DEFAULT_H*/
118:                 
119:                 /******************************************************************************
120:                  End of File
121:                 */
122:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_linecontrolmode_rxandtxcombined.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_LineControlMode_RXandTXCombined.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LineControlMode
13:                      and its Variant : RXandTXCombined
14:                      For following APIs :
15:                          PLIB_USART_ExistsLineControlMode
16:                          PLIB_USART_LineControlModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_LINECONTROLMODE_RXANDTXCOMBINED_H
47:                  #define _USART_LINECONTROLMODE_RXANDTXCOMBINED_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _USART_LINE_CONTROL_MODE_DATA_VREG(index)
54:                      _USART_LINE_CONTROL_MODE_STOP_VREG(index)
55:                  
56:                    MASKs: 
57:                      _USART_LINE_CONTROL_MODE_DATA_MASK(index)
58:                      _USART_LINE_CONTROL_MODE_STOP_MASK(index)
59:                  
60:                    POSs: 
61:                      _USART_LINE_CONTROL_MODE_DATA_POS(index)
62:                      _USART_LINE_CONTROL_MODE_STOP_POS(index)
63:                  
64:                    LENs: 
65:                      _USART_LINE_CONTROL_MODE_DATA_LEN(index)
66:                      _USART_LINE_CONTROL_MODE_STOP_LEN(index)
67:                  
68:                  */
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USART_ExistsLineControlMode_RXandTXCombined
73:                  
74:                    Summary:
75:                      Implements RXandTXCombined variant of PLIB_USART_ExistsLineControlMode
76:                  
77:                    Description:
78:                      This template implements the RXandTXCombined variant of the PLIB_USART_ExistsLineControlMode function.
79:                  */
80:                  
81:                  #define PLIB_USART_ExistsLineControlMode PLIB_USART_ExistsLineControlMode
82:                  PLIB_TEMPLATE bool USART_ExistsLineControlMode_RXandTXCombined( USART_MODULE_ID index )
83:                  {
84:                      return true;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  USART_LineControlModeSelect_RXandTXCombined
90:                  
91:                    Summary:
92:                      Implements RXandTXCombined variant of PLIB_USART_LineControlModeSelect 
93:                  
94:                    Description:
95:                      This template implements the RXandTXCombined variant of the PLIB_USART_LineControlModeSelect function.
96:                  */
97:                  
98:                  PLIB_TEMPLATE void USART_LineControlModeSelect_RXandTXCombined( USART_MODULE_ID index , USART_LINECONTROL_MODE dataFlowConfig )
99:                  {
100:                 
101:                     if (dataFlowConfig > USART_9N1)
9D0019C8  2C430004   SLTIU V1, V0, 4
9D0019CC  14600006   BNE V1, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D0019D0  24040001   ADDIU A0, ZERO, 1
9D0019FC  2C430004   SLTIU V1, V0, 4
9D001A00  106001CD   BEQ V1, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A04  24040001   ADDIU A0, ZERO, 1
9D001A10  2C430004   SLTIU V1, V0, 4
9D001A14  106001D9   BEQ V1, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A18  24040001   ADDIU A0, ZERO, 1
9D001A24  2C430004   SLTIU V1, V0, 4
9D001A28  106001E5   BEQ V1, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A2C  24040001   ADDIU A0, ZERO, 1
9D001A38  2C430004   SLTIU V1, V0, 4
9D001A3C  106001F1   BEQ V1, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A40  24040001   ADDIU A0, ZERO, 1
9D001A4C  2C430004   SLTIU V1, V0, 4
9D001A50  106001FD   BEQ V1, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A54  24040001   ADDIU A0, ZERO, 1
00000084  00000000   NOP
000000B8  00000000   NOP
000000CC  00000000   NOP
000000E0  00000000   NOP
000000F4  00000000   NOP
00000108  00000000   NOP
102:                     {
103:                         _SFR_BIT_SET(_USART_LINE_CONTROL_MODE_STOP_VREG(index),
9D0019D4  3C03BF80   LUI V1, -16512
9D0019D8  24636000   ADDIU V1, V1, 24576
9D0019DC  AC640008   SW A0, 8(V1)
9D002138  3C03BF80   LUI V1, -16512
9D00213C  24636400   ADDIU V1, V1, 25600
9D002140  AC640008   SW A0, 8(V1)
9D00217C  3C03BF80   LUI V1, -16512
9D002180  24636800   ADDIU V1, V1, 26624
9D002184  AC640008   SW A0, 8(V1)
9D0021C0  3C03BF80   LUI V1, -16512
9D0021C4  24636200   ADDIU V1, V1, 25088
9D0021C8  AC640008   SW A0, 8(V1)
9D002204  3C03BF80   LUI V1, -16512
9D002208  24636600   ADDIU V1, V1, 26112
9D00220C  AC640008   SW A0, 8(V1)
9D002248  3C03BF80   LUI V1, -16512
9D00224C  24636A00   ADDIU V1, V1, 27136
9D002250  AC640008   SW A0, 8(V1)
00000090  00000000   NOP
00000154  00000000   NOP
00000198  00000000   NOP
000001DC  00000000   NOP
00000220  00000000   NOP
00000264  00000000   NOP
104:                             _USART_LINE_CONTROL_MODE_STOP_POS(index) );
105:                         dataFlowConfig = (USART_LINECONTROL_MODE)(dataFlowConfig - USART_8N2);
9D0019E0  0B400844   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D0019E4  2444FFFC   ADDIU A0, V0, -4
9D002144  0B400855   J 0x9D002154
9D002148  2442FFFC   ADDIU V0, V0, -4
9D002188  0B400866   J 0x9D002198
9D00218C  2442FFFC   ADDIU V0, V0, -4
9D0021CC  0B400877   J 0x9D0021DC
9D0021D0  2442FFFC   ADDIU V0, V0, -4
9D002210  0B400888   J 0x9D002220
9D002214  2442FFFC   ADDIU V0, V0, -4
9D002254  0B400899   J 0x9D002264
9D002258  2442FFFC   ADDIU V0, V0, -4
0000009C  00000000   NOP
00000160  00000000   NOP
000001A4  00000000   NOP
000001E8  00000000   NOP
0000022C  00000000   NOP
00000270  00000000   NOP
106:                     }
107:                     else
108:                     {
109:                          _SFR_BIT_CLEAR(_USART_LINE_CONTROL_MODE_STOP_VREG(index),
9D0019E8  3C03BF80   LUI V1, -16512
9D0019EC  24636000   ADDIU V1, V1, 24576
9D0019F0  AC640004   SW A0, 4(V1)
9D0019F4  0B400844   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D0019F8  00402021   ADDU A0, V0, ZERO
9D001A08  0B400853   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A0C  3C03BF80   LUI V1, -16512
9D001A1C  0B400864   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A20  3C03BF80   LUI V1, -16512
9D001A30  0B400875   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A34  3C03BF80   LUI V1, -16512
9D001A44  0B400886   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A48  3C03BF80   LUI V1, -16512
9D001A58  0B400897   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001A5C  3C03BF80   LUI V1, -16512
9D00214C  24636400   ADDIU V1, V1, 25600
9D002150  AC640004   SW A0, 4(V1)
9D002190  24636800   ADDIU V1, V1, 26624
9D002194  AC640004   SW A0, 4(V1)
9D0021D4  24636200   ADDIU V1, V1, 25088
9D0021D8  AC640004   SW A0, 4(V1)
9D002218  24636600   ADDIU V1, V1, 26112
9D00221C  AC640004   SW A0, 4(V1)
9D00225C  24636A00   ADDIU V1, V1, 27136
9D002260  AC640004   SW A0, 4(V1)
000000A4  00000000   NOP
000000C4  00000000   NOP
000000D8  00000000   NOP
000000EC  00000000   NOP
00000100  00000000   NOP
00000114  00000000   NOP
00000168  00000000   NOP
000001AC  00000000   NOP
000001F0  00000000   NOP
00000234  00000000   NOP
00000278  00000000   NOP
110:                             _USART_LINE_CONTROL_MODE_STOP_POS(index) );
111:                     }
112:                     _SFR_FIELD_WRITE( _USART_LINE_CONTROL_MODE_DATA_VREG(index),
9D002110  3C03BF80   LUI V1, -16512
9D002114  8C676000   LW A3, 24576(V1)
9D002118  00042040   SLL A0, A0, 1
9D00211C  30840006   ANDI A0, A0, 6
9D002120  2402FFF9   ADDIU V0, ZERO, -7
9D002124  00E21024   AND V0, A3, V0
9D002128  00821025   OR V0, A0, V0
9D00212C  AC626000   SW V0, 24576(V1)
9D002154  3C03BF80   LUI V1, -16512
9D002158  8C676400   LW A3, 25600(V1)
9D00215C  00022040   SLL A0, V0, 1
9D002160  30840006   ANDI A0, A0, 6
9D002164  2402FFF9   ADDIU V0, ZERO, -7
9D002168  00E21024   AND V0, A3, V0
9D00216C  00821025   OR V0, A0, V0
9D002170  AC626400   SW V0, 25600(V1)
9D002198  3C03BF80   LUI V1, -16512
9D00219C  8C676800   LW A3, 26624(V1)
9D0021A0  00022040   SLL A0, V0, 1
9D0021A4  30840006   ANDI A0, A0, 6
9D0021A8  2402FFF9   ADDIU V0, ZERO, -7
9D0021AC  00E21024   AND V0, A3, V0
9D0021B0  00821025   OR V0, A0, V0
9D0021B4  AC626800   SW V0, 26624(V1)
9D0021DC  3C03BF80   LUI V1, -16512
9D0021E0  8C676200   LW A3, 25088(V1)
9D0021E4  00022040   SLL A0, V0, 1
9D0021E8  30840006   ANDI A0, A0, 6
9D0021EC  2402FFF9   ADDIU V0, ZERO, -7
9D0021F0  00E21024   AND V0, A3, V0
9D0021F4  00821025   OR V0, A0, V0
9D0021F8  AC626200   SW V0, 25088(V1)
9D002220  3C03BF80   LUI V1, -16512
9D002224  8C676600   LW A3, 26112(V1)
9D002228  00022040   SLL A0, V0, 1
9D00222C  30840006   ANDI A0, A0, 6
9D002230  2402FFF9   ADDIU V0, ZERO, -7
9D002234  00E21024   AND V0, A3, V0
9D002238  00821025   OR V0, A0, V0
9D00223C  AC626600   SW V0, 26112(V1)
9D002264  3C03BF80   LUI V1, -16512
9D002268  8C676A00   LW A3, 27136(V1)
9D00226C  00022040   SLL A0, V0, 1
9D002270  30840006   ANDI A0, A0, 6
9D002274  2402FFF9   ADDIU V0, ZERO, -7
9D002278  00E21024   AND V0, A3, V0
9D00227C  00821025   OR V0, A0, V0
9D002280  AC626A00   SW V0, 27136(V1)
000000B0  00000000   NOP
0000012C  00000000   NOP
00000170  00000000   NOP
000001B4  00000000   NOP
000001F8  00000000   NOP
0000023C  00000000   NOP
00000280  00000000   NOP
113:                                     _USART_LINE_CONTROL_MODE_DATA_MASK(index),
114:                                     _USART_LINE_CONTROL_MODE_DATA_POS(index),
115:                                     dataFlowConfig);
116:                 }
117:                 
118:                 
119:                 #endif /*_USART_LINECONTROLMODE_RXANDTXCOMBINED_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_handshakemode_default.h  --
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_HandShakeMode_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : HandShakeMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsHandshakeMode
16:                          PLIB_USART_HandshakeModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_HANDSHAKEMODE_DEFAULT_H
47:                  #define _USART_HANDSHAKEMODE_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _USART_HAND_SHAKE_MODE_VREG(index)
54:                  
55:                    MASKs: 
56:                      _USART_HAND_SHAKE_MODE_MASK(index)
57:                  
58:                    POSs: 
59:                      _USART_HAND_SHAKE_MODE_POS(index)
60:                  
61:                    LENs: 
62:                      _USART_HAND_SHAKE_MODE_LEN(index)
63:                  
64:                  */
65:                  //******************************************************************************
66:                  /* Function :  _HandshakeModeEnumXferFunc
67:                  
68:                    Summary:
69:                      Converts superset enumeration to the part specific value
70:                  
71:                    Description:
72:                      This function converts superset enumeration to the part specific value.
73:                  */
74:                  
75:                  PLIB_TEMPLATE uint8_t _HandshakeModeEnumXferFunc( USART_HANDSHAKE_MODE handshakeMode )
76:                  {
77:                      switch(handshakeMode)
78:                      {
79:                          case USART_HANDSHAKE_MODE_FLOW_CONTROL:
80:                              return 0;
81:                          case USART_HANDSHAKE_MODE_SIMPLEX:
82:                              return 1;
83:                          default:
84:                              return 0;
85:                      }
86:                  }
87:                  
88:                  //******************************************************************************
89:                  /* Function :  USART_ExistsHandshakeMode_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_USART_ExistsHandshakeMode
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_USART_ExistsHandshakeMode function.
96:                  */
97:                  
98:                  #define PLIB_USART_ExistsHandshakeMode PLIB_USART_ExistsHandshakeMode
99:                  PLIB_TEMPLATE bool USART_ExistsHandshakeMode_Default( USART_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 //******************************************************************************
106:                 /* Function :  USART_HandshakeModeSelect_Default
107:                 
108:                   Summary:
109:                     Implements Default variant of PLIB_USART_HandshakeModeSelect 
110:                 
111:                   Description:
112:                     This template implements the Default variant of the PLIB_USART_HandshakeModeSelect function.
113:                 */
114:                 
115:                 PLIB_TEMPLATE void USART_HandshakeModeSelect_Default( USART_MODULE_ID index , USART_HANDSHAKE_MODE handshakeConfig )
116:                 {
117:                   _SFR_FIELD_WRITE(_USART_HAND_SHAKE_MODE_VREG(index),
9D001644  3C04BF80   LUI A0, -16512
9D001648  8C866000   LW A2, 24576(A0)
9D00164C  2404F7FF   ADDIU A0, ZERO, -2049
9D001650  00C43024   AND A2, A2, A0
9D001654  38640001   XORI A0, V1, 1
9D001658  2C840001   SLTIU A0, A0, 1
9D00165C  000422C0   SLL A0, A0, 11
9D001660  00862025   OR A0, A0, A2
9D001664  3C03BF80   LUI V1, -16512
9D001668  AC646000   SW A0, 24576(V1)
9D00208C  3C04BF80   LUI A0, -16512
9D002090  8C866400   LW A2, 25600(A0)
9D002094  2404F7FF   ADDIU A0, ZERO, -2049
9D002098  00C43024   AND A2, A2, A0
9D00209C  38640001   XORI A0, V1, 1
9D0020A0  2C840001   SLTIU A0, A0, 1
9D0020A4  000422C0   SLL A0, A0, 11
9D0020A8  00862025   OR A0, A0, A2
9D0020AC  3C03BF80   LUI V1, -16512
9D0020B0  AC646400   SW A0, 25600(V1)
9D0020D0  3C04BF80   LUI A0, -16512
9D0020D4  8C866800   LW A2, 26624(A0)
9D0020D8  2404F7FF   ADDIU A0, ZERO, -2049
9D0020DC  00C43024   AND A2, A2, A0
9D0020E0  38640001   XORI A0, V1, 1
9D0020E4  2C840001   SLTIU A0, A0, 1
9D0020E8  000422C0   SLL A0, A0, 11
9D0020EC  00862025   OR A0, A0, A2
9D0020F0  3C03BF80   LUI V1, -16512
9D0020F4  AC646800   SW A0, 26624(V1)
118:                                    _USART_HAND_SHAKE_MODE_MASK(index),
119:                                    _USART_HAND_SHAKE_MODE_POS(index),
120:                                    _HandshakeModeEnumXferFunc(handshakeConfig));  
121:                 }
122:                 
123:                 
124:                 #endif /*_USART_HANDSHAKEMODE_DEFAULT_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_enablecontrol_default.h  --
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsEnable
16:                          PLIB_USART_Disable
17:                          PLIB_USART_Enable
18:                          PLIB_USART_BaudSetAndEnable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_ENABLECONTROL_DEFAULT_H
49:                  #define _USART_ENABLECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
53:                  
54:                    VREGs: 
55:                      _USART_ENABLE_CONTROL_VREG(index)
56:                  
57:                    MASKs: 
58:                      _USART_ENABLE_CONTROL_MASK(index)
59:                  
60:                    POSs: 
61:                      _USART_ENABLE_CONTROL_POS(index)
62:                  
63:                    LENs: 
64:                      _USART_ENABLE_CONTROL_LEN(index)
65:                  
66:                  */
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ExistsEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ExistsEnable
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ExistsEnable function.
77:                  */
78:                  
79:                  #define PLIB_USART_ExistsEnable PLIB_USART_ExistsEnable
80:                  PLIB_TEMPLATE bool USART_ExistsEnable_Default( USART_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USART_Disable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USART_Disable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USART_Disable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void USART_Disable_Default( USART_MODULE_ID index )
97:                  {
98:                      _SFR_BIT_CLEAR(_USART_ENABLE_CONTROL_VREG(index),
9D0048E0  34038000   ORI V1, ZERO, -32768
9D0048E4  3C02BF80   LUI V0, -16512
9D0048E8  24426000   ADDIU V0, V0, 24576
9D0048EC  AC430004   SW V1, 4(V0)
9D004AE8  34038000   ORI V1, ZERO, -32768
9D004AEC  3C02BF80   LUI V0, -16512
9D004AF0  24426400   ADDIU V0, V0, 25600
9D004AF4  AC430004   SW V1, 4(V0)
9D004B00  34038000   ORI V1, ZERO, -32768
9D004B04  3C02BF80   LUI V0, -16512
9D004B08  24426800   ADDIU V0, V0, 26624
9D004B0C  AC430004   SW V1, 4(V0)
9D004B18  34038000   ORI V1, ZERO, -32768
9D004B1C  3C02BF80   LUI V0, -16512
9D004B20  24426200   ADDIU V0, V0, 25088
9D004B24  AC430004   SW V1, 4(V0)
9D004B30  34038000   ORI V1, ZERO, -32768
9D004B34  3C02BF80   LUI V0, -16512
9D004B38  24426600   ADDIU V0, V0, 26112
9D004B3C  AC430004   SW V1, 4(V0)
9D004B48  34038000   ORI V1, ZERO, -32768
9D004B4C  3C02BF80   LUI V0, -16512
9D004B50  24426A00   ADDIU V0, V0, 27136
9D004B54  AC430004   SW V1, 4(V0)
0000009C  00000000   NOP
00000100  00000000   NOP
99:                                   _USART_ENABLE_CONTROL_POS(index) );
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USART_Enable_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USART_Enable 
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USART_Enable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void USART_Enable_Default( USART_MODULE_ID index )
114:                 {
115:                     _SFR_BIT_SET(_USART_ENABLE_CONTROL_VREG(index),
9D004AC8  34038000   ORI V1, ZERO, -32768
9D004ACC  3C02BF80   LUI V0, -16512
9D004AD0  24426000   ADDIU V0, V0, 24576
9D004AD4  AC430008   SW V1, 8(V0)
9D004B60  34038000   ORI V1, ZERO, -32768
9D004B64  3C02BF80   LUI V0, -16512
9D004B68  24426400   ADDIU V0, V0, 25600
9D004B6C  AC430008   SW V1, 8(V0)
9D004B78  34038000   ORI V1, ZERO, -32768
9D004B7C  3C02BF80   LUI V0, -16512
9D004B80  24426800   ADDIU V0, V0, 26624
9D004B84  AC430008   SW V1, 8(V0)
9D004B90  34038000   ORI V1, ZERO, -32768
9D004B94  3C02BF80   LUI V0, -16512
9D004B98  24426200   ADDIU V0, V0, 25088
9D004B9C  AC430008   SW V1, 8(V0)
9D004BA8  34038000   ORI V1, ZERO, -32768
9D004BAC  3C02BF80   LUI V0, -16512
9D004BB0  24426600   ADDIU V0, V0, 26112
9D004BB4  AC430008   SW V1, 8(V0)
9D004BC0  34038000   ORI V1, ZERO, -32768
9D004BC4  3C02BF80   LUI V0, -16512
9D004BC8  24426A00   ADDIU V0, V0, 27136
9D004BCC  AC430008   SW V1, 8(V0)
116:                                  _USART_ENABLE_CONTROL_POS(index) );
117:                 }
118:                 
119:                 //******************************************************************************
120:                 /* Function :  USART_BaudSetAndEnable_Default
121:                 
122:                   Summary:
123:                     Implements Default variant of PLIB_USART_BaudSetAndEnable 
124:                 
125:                   Description:
126:                     This template implements the Default variant of the PLIB_USART_BaudSetAndEnable function.
127:                 */
128:                 
129:                 PLIB_TEMPLATE void USART_BaudSetAndEnable_Default( USART_MODULE_ID index, uint32_t systemClock, uint32_t baud  )
130:                 {
131:                     int32_t brgValueLow = 0;
132:                     int32_t brgValueHigh = 0;
133:                     SFR_TYPE * umode = _USART_ENABLE_CONTROL_VREG(index);
134:                     SFR_TYPE * usta = _USART_RECEIVER_IDLE_VREG(index);
135:                     SFR_TYPE * ubaud = _USART_BAUD_RATE_VREG(index);
136:                 
137:                     /* Enable transmit and receive */
138:                     *usta |= 0x1400;
9D001B34  3C04BF80   LUI A0, -16512
9D001B38  8C856010   LW A1, 24592(A0)
9D001B3C  34A51400   ORI A1, A1, 5120
9D001B40  AC856010   SW A1, 24592(A0)
9D002430  3C04BF80   LUI A0, -16512
9D002434  8C856410   LW A1, 25616(A0)
9D002438  34A51400   ORI A1, A1, 5120
9D00243C  AC856410   SW A1, 25616(A0)
9D00246C  3C04BF80   LUI A0, -16512
9D002470  8C856810   LW A1, 26640(A0)
9D002474  34A51400   ORI A1, A1, 5120
9D002478  AC856810   SW A1, 26640(A0)
9D0024A8  3C04BF80   LUI A0, -16512
9D0024AC  8C856210   LW A1, 25104(A0)
9D0024B0  34A51400   ORI A1, A1, 5120
9D0024B4  AC856210   SW A1, 25104(A0)
9D0024E4  3C04BF80   LUI A0, -16512
9D0024E8  8C856610   LW A1, 26128(A0)
9D0024EC  34A51400   ORI A1, A1, 5120
9D0024F0  AC856610   SW A1, 26128(A0)
9D002520  3C04BF80   LUI A0, -16512
9D002524  8C856A10   LW A1, 27152(A0)
9D002528  34A51400   ORI A1, A1, 5120
9D00252C  AC856A10   SW A1, 27152(A0)
139:                 
140:                     /* Find the BRG Value */
141:                     brgValueLow  = (((systemClock / baud) >> 4) - 1);
9D001B44  0062001B   DIVU V1, V0
9D001B48  004001F4   TEQ V0, ZERO
9D001B4C  00001012   MFLO V0
9D001B50  00022902   SRL A1, V0, 4
9D001BEC  00021102   SRL V0, V0, 4
9D001BF0  2442FFFF   ADDIU V0, V0, -1
9D001C40  00021102   SRL V0, V0, 4
9D001C44  2442FFFF   ADDIU V0, V0, -1
9D001C94  00021102   SRL V0, V0, 4
9D001C98  2442FFFF   ADDIU V0, V0, -1
9D001CE8  00021102   SRL V0, V0, 4
9D001CEC  2442FFFF   ADDIU V0, V0, -1
9D001D3C  00021102   SRL V0, V0, 4
9D001D40  2442FFFF   ADDIU V0, V0, -1
9D002440  0062001B   DIVU V1, V0
9D002444  004001F4   TEQ V0, ZERO
9D002448  00001012   MFLO V0
9D00247C  0062001B   DIVU V1, V0
9D002480  004001F4   TEQ V0, ZERO
9D002484  00001012   MFLO V0
9D0024B8  0062001B   DIVU V1, V0
9D0024BC  004001F4   TEQ V0, ZERO
9D0024C0  00001012   MFLO V0
9D0024F4  0062001B   DIVU V1, V0
9D0024F8  004001F4   TEQ V0, ZERO
9D0024FC  00001012   MFLO V0
9D002530  0062001B   DIVU V1, V0
9D002534  004001F4   TEQ V0, ZERO
9D002538  00001012   MFLO V0
142:                     brgValueHigh = (((systemClock / baud) >> 2) - 1);
9D001B54  00021082   SRL V0, V0, 2
9D001B58  2444FFFF   ADDIU A0, V0, -1
9D00244C  00022082   SRL A0, V0, 2
9D002450  2484FFFF   ADDIU A0, A0, -1
9D002488  00022082   SRL A0, V0, 2
9D00248C  2484FFFF   ADDIU A0, A0, -1
9D0024C4  00022082   SRL A0, V0, 2
9D0024C8  2484FFFF   ADDIU A0, A0, -1
9D002500  00022082   SRL A0, V0, 2
9D002504  2484FFFF   ADDIU A0, A0, -1
9D00253C  00022082   SRL A0, V0, 2
9D002540  2484FFFF   ADDIU A0, A0, -1
143:                 
144:                     /* Check if the baud value can be set with high baud settings */
145:                     if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX))
9D001B5C  3C020001   LUI V0, 1
9D001B60  0082102B   SLTU V0, A0, V0
9D001B64  10400009   BEQ V0, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D001B68  24A5FFFF   ADDIU A1, A1, -1
9D002454  3C030001   LUI V1, 1
9D002458  0083182B   SLTU V1, A0, V1
9D00245C  5460FDD8   BNEL V1, ZERO, 0x9D001BC0
9D002460  3C02BF80   LUI V0, -16512
9D002490  3C030001   LUI V1, 1
9D002494  0083182B   SLTU V1, A0, V1
9D002498  5460FDDE   BNEL V1, ZERO, 0x9D001C14
9D00249C  3C02BF80   LUI V0, -16512
9D0024CC  3C030001   LUI V1, 1
9D0024D0  0083182B   SLTU V1, A0, V1
9D0024D4  5460FDE4   BNEL V1, ZERO, 0x9D001C68
9D0024D8  3C02BF80   LUI V0, -16512
9D002508  3C030001   LUI V1, 1
9D00250C  0083182B   SLTU V1, A0, V1
9D002510  5460FDEA   BNEL V1, ZERO, 0x9D001CBC
9D002514  3C02BF80   LUI V0, -16512
9D002544  3C030001   LUI V1, 1
9D002548  0083182B   SLTU V1, A0, V1
9D00254C  5460FDF0   BNEL V1, ZERO, 0x9D001D10
9D002550  3C02BF80   LUI V0, -16512
146:                     {
147:                 	/* Set BRGH */
148:                         *umode |= 0x0008;
9D001B6C  3C02BF80   LUI V0, -16512
9D001B70  8C436000   LW V1, 24576(V0)
9D001B74  34630008   ORI V1, V1, 8
9D001B78  AC436000   SW V1, 24576(V0)
9D001BC0  8C436400   LW V1, 25600(V0)
9D001BC4  34630008   ORI V1, V1, 8
9D001BC8  AC436400   SW V1, 25600(V0)
9D001C14  8C436800   LW V1, 26624(V0)
9D001C18  34630008   ORI V1, V1, 8
9D001C1C  AC436800   SW V1, 26624(V0)
9D001C68  8C436200   LW V1, 25088(V0)
9D001C6C  34630008   ORI V1, V1, 8
9D001C70  AC436200   SW V1, 25088(V0)
9D001CBC  8C436600   LW V1, 26112(V0)
9D001CC0  34630008   ORI V1, V1, 8
9D001CC4  AC436600   SW V1, 26112(V0)
9D001D10  8C436A00   LW V1, 27136(V0)
9D001D14  34630008   ORI V1, V1, 8
9D001D18  AC436A00   SW V1, 27136(V0)
149:                         *ubaud = brgValueHigh;
9D001B7C  3C02BF80   LUI V0, -16512
9D001B80  AC446040   SW A0, 24640(V0)
9D001BCC  3C02BF80   LUI V0, -16512
9D001BD0  AC446440   SW A0, 25664(V0)
9D001C20  3C02BF80   LUI V0, -16512
9D001C24  AC446840   SW A0, 26688(V0)
9D001C74  3C02BF80   LUI V0, -16512
9D001C78  AC446240   SW A0, 25152(V0)
9D001CC8  3C02BF80   LUI V0, -16512
9D001CCC  AC446640   SW A0, 26176(V0)
9D001D1C  3C02BF80   LUI V0, -16512
9D001D20  AC446A40   SW A0, 27200(V0)
150:                     }
151:                     else
152:                     {
153:                 	/* Clear BRGH */
154:                         *umode &= ~0x0008;
9D001B8C  3C02BF80   LUI V0, -16512
9D001B90  8C446000   LW A0, 24576(V0)
9D001B94  2403FFF7   ADDIU V1, ZERO, -9
9D001B98  00831824   AND V1, A0, V1
9D001B9C  AC436000   SW V1, 24576(V0)
9D001BDC  8C656400   LW A1, 25600(V1)
9D001BE0  2404FFF7   ADDIU A0, ZERO, -9
9D001BE4  00A42024   AND A0, A1, A0
9D001BE8  AC646400   SW A0, 25600(V1)
9D001C30  8C656800   LW A1, 26624(V1)
9D001C34  2404FFF7   ADDIU A0, ZERO, -9
9D001C38  00A42024   AND A0, A1, A0
9D001C3C  AC646800   SW A0, 26624(V1)
9D001C84  8C656200   LW A1, 25088(V1)
9D001C88  2404FFF7   ADDIU A0, ZERO, -9
9D001C8C  00A42024   AND A0, A1, A0
9D001C90  AC646200   SW A0, 25088(V1)
9D001CD8  8C656600   LW A1, 26112(V1)
9D001CDC  2404FFF7   ADDIU A0, ZERO, -9
9D001CE0  00A42024   AND A0, A1, A0
9D001CE4  AC646600   SW A0, 26112(V1)
9D001D2C  8C656A00   LW A1, 27136(V1)
9D001D30  2404FFF7   ADDIU A0, ZERO, -9
9D001D34  00A42024   AND A0, A1, A0
9D001D38  AC646A00   SW A0, 27136(V1)
9D002464  0B4006F7   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002468  3C03BF80   LUI V1, -16512
9D0024A0  0B40070C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024A4  3C03BF80   LUI V1, -16512
9D0024DC  0B400721   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024E0  3C03BF80   LUI V1, -16512
9D002518  0B400736   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00251C  3C03BF80   LUI V1, -16512
9D002554  0B40074B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
155:                         *ubaud = brgValueLow;
9D001BA0  3C02BF80   LUI V0, -16512
9D001BA4  AC456040   SW A1, 24640(V0)
9D001BF4  3C04BF80   LUI A0, -16512
9D001BF8  AC826440   SW V0, 25664(A0)
9D001C48  3C04BF80   LUI A0, -16512
9D001C4C  AC826840   SW V0, 26688(A0)
9D001C9C  3C04BF80   LUI A0, -16512
9D001CA0  AC826240   SW V0, 25152(A0)
9D001CF0  3C04BF80   LUI A0, -16512
9D001CF4  AC826640   SW V0, 26176(A0)
9D001D44  3C04BF80   LUI A0, -16512
9D001D48  AC826A40   SW V0, 27200(A0)
156:                     }
157:                 
158:                     /* Enable the UART */
159:                     *umode |= 0x8000;
9D001B84  0B4006EB   J 0x9D001BAC
9D001B88  3C02BF80   LUI V0, -16512
9D001BA8  3C02BF80   LUI V0, -16512
9D001BAC  8C436000   LW V1, 24576(V0)
9D001BB0  34638000   ORI V1, V1, -32768
9D001BB4  AC436000   SW V1, 24576(V0)
9D001BB8  03E00008   JR RA
9D001BBC  00000000   NOP
9D001BD4  0B400700   J 0x9D001C00
9D001BD8  3C02BF80   LUI V0, -16512
9D001BFC  3C02BF80   LUI V0, -16512
9D001C00  8C436400   LW V1, 25600(V0)
9D001C04  34638000   ORI V1, V1, -32768
9D001C08  AC436400   SW V1, 25600(V0)
9D001C0C  03E00008   JR RA
9D001C10  00000000   NOP
9D001C28  0B400715   J 0x9D001C54
9D001C2C  3C02BF80   LUI V0, -16512
9D001C50  3C02BF80   LUI V0, -16512
9D001C54  8C436800   LW V1, 26624(V0)
9D001C58  34638000   ORI V1, V1, -32768
9D001C5C  AC436800   SW V1, 26624(V0)
9D001C60  03E00008   JR RA
9D001C64  00000000   NOP
9D001C7C  0B40072A   J 0x9D001CA8
9D001C80  3C02BF80   LUI V0, -16512
9D001CA4  3C02BF80   LUI V0, -16512
9D001CA8  8C436200   LW V1, 25088(V0)
9D001CAC  34638000   ORI V1, V1, -32768
9D001CB0  AC436200   SW V1, 25088(V0)
9D001CB4  03E00008   JR RA
9D001CB8  00000000   NOP
9D001CD0  0B40073F   J 0x9D001CFC
9D001CD4  3C02BF80   LUI V0, -16512
9D001CF8  3C02BF80   LUI V0, -16512
9D001CFC  8C436600   LW V1, 26112(V0)
9D001D00  34638000   ORI V1, V1, -32768
9D001D04  AC436600   SW V1, 26112(V0)
9D001D08  03E00008   JR RA
9D001D0C  00000000   NOP
9D001D24  0B400754   J 0x9D001D50
9D001D28  3C02BF80   LUI V0, -16512
9D001D4C  3C02BF80   LUI V0, -16512
9D001D50  8C436A00   LW V1, 27136(V0)
9D001D54  34638000   ORI V1, V1, -32768
9D001D58  AC436A00   SW V1, 27136(V0)
9D001D5C  03E00008   JR RA
9D001D60  00000000   NOP
9D001D64  24030020   ADDIU V1, ZERO, 32
9D001D68  3C02BF80   LUI V0, -16512
9D001D6C  24426410   ADDIU V0, V0, 25616
9D001D70  AC430008   SW V1, 8(V0)
9D001D74  0B400777   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001D78  90A2000C   LBU V0, 12(A1)
9D001D7C  24030020   ADDIU V1, ZERO, 32
9D001D80  3C02BF80   LUI V0, -16512
9D001D84  24426810   ADDIU V0, V0, 26640
9D001D88  AC430008   SW V1, 8(V0)
9D001D8C  0B400781   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001D90  90A2000C   LBU V0, 12(A1)
9D001D94  24030020   ADDIU V1, ZERO, 32
9D001D98  3C02BF80   LUI V0, -16512
9D001D9C  24426210   ADDIU V0, V0, 25104
9D001DA0  AC430008   SW V1, 8(V0)
9D001DA4  0B40078B   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001DA8  90A2000C   LBU V0, 12(A1)
9D001DAC  24030020   ADDIU V1, ZERO, 32
9D001DB0  3C02BF80   LUI V0, -16512
9D001DB4  24426610   ADDIU V0, V0, 26128
9D001DB8  AC430008   SW V1, 8(V0)
9D001DBC  0B400795   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001DC0  90A2000C   LBU V0, 12(A1)
9D001DC4  24030020   ADDIU V1, ZERO, 32
9D001DC8  3C02BF80   LUI V0, -16512
9D001DCC  24426A10   ADDIU V0, V0, 27152
9D001DD0  AC430008   SW V1, 8(V0)
9D001DD4  0B40079F   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001DD8  90A2000C   LBU V0, 12(A1)
9D001DDC  3C03BF80   LUI V1, -16512
9D001DE0  8C676410   LW A3, 25616(V1)
9D001DE4  00021400   SLL V0, V0, 16
9D001DE8  3C06FF00   LUI A2, -256
9D001DEC  34C6FFFF   ORI A2, A2, -1
9D001DF0  00E63024   AND A2, A3, A2
9D001DF4  00461025   OR V0, V0, A2
9D001DF8  AC626410   SW V0, 25616(V1)
9D001DFC  0B4007AA   J 0x9D001EA8
9D001E00  3C02BF80   LUI V0, -16512
9D001E04  3C03BF80   LUI V1, -16512
9D001E08  8C676810   LW A3, 26640(V1)
9D001E0C  00021400   SLL V0, V0, 16
9D001E10  3C06FF00   LUI A2, -256
9D001E14  34C6FFFF   ORI A2, A2, -1
9D001E18  00E63024   AND A2, A3, A2
9D001E1C  00461025   OR V0, V0, A2
9D001E20  AC626810   SW V0, 26640(V1)
9D001E24  0B4007AF   J 0x9D001EBC
9D001E28  3C02BF80   LUI V0, -16512
9D001E2C  3C03BF80   LUI V1, -16512
9D001E30  8C676210   LW A3, 25104(V1)
9D001E34  00021400   SLL V0, V0, 16
9D001E38  3C06FF00   LUI A2, -256
9D001E3C  34C6FFFF   ORI A2, A2, -1
9D001E40  00E63024   AND A2, A3, A2
9D001E44  00461025   OR V0, V0, A2
9D001E48  AC626210   SW V0, 25104(V1)
9D001E4C  0B4007B4   J 0x9D001ED0
9D001E50  3C02BF80   LUI V0, -16512
9D001E54  3C03BF80   LUI V1, -16512
9D001E58  8C676610   LW A3, 26128(V1)
9D001E5C  00021400   SLL V0, V0, 16
9D001E60  3C06FF00   LUI A2, -256
9D001E64  34C6FFFF   ORI A2, A2, -1
9D001E68  00E63024   AND A2, A3, A2
9D001E6C  00461025   OR V0, V0, A2
9D001E70  AC626610   SW V0, 26128(V1)
9D001E74  0B4007B9   J 0x9D001EE4
9D001E78  3C02BF80   LUI V0, -16512
9D001E7C  3C03BF80   LUI V1, -16512
9D001E80  8C676A10   LW A3, 27152(V1)
9D001E84  00021400   SLL V0, V0, 16
9D001E88  3C06FF00   LUI A2, -256
9D001E8C  34C6FFFF   ORI A2, A2, -1
9D001E90  00E63024   AND A2, A3, A2
9D001E94  00461025   OR V0, V0, A2
9D001E98  AC626A10   SW V0, 27152(V1)
9D001E9C  0B4007BE   J 0x9D001EF8
9D001EA0  3C02BF80   LUI V0, -16512
9D001EA4  3C02BF80   LUI V0, -16512
9D001EA8  8C436410   LW V1, 25616(V0)
9D001EAC  7C633C00   EXT V1, V1, 16, 8
9D001EB0  0B4007C3   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EB4  7C031C20   SEB V1, V1
9D001EB8  3C02BF80   LUI V0, -16512
9D001EBC  8C436810   LW V1, 26640(V0)
9D001EC0  7C633C00   EXT V1, V1, 16, 8
9D001EC4  0B4007D8   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EC8  7C031C20   SEB V1, V1
9D001ECC  3C02BF80   LUI V0, -16512
9D001ED0  8C436210   LW V1, 25104(V0)
9D001ED4  7C633C00   EXT V1, V1, 16, 8
9D001ED8  0B4007ED   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EDC  7C031C20   SEB V1, V1
9D001EE0  3C02BF80   LUI V0, -16512
9D001EE4  8C436610   LW V1, 26128(V0)
9D001EE8  7C633C00   EXT V1, V1, 16, 8
9D001EEC  0B4007FF   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EF0  7C031C20   SEB V1, V1
9D001EF4  3C02BF80   LUI V0, -16512
9D001EF8  8C436A10   LW V1, 27152(V0)
9D001EFC  7C633C00   EXT V1, V1, 16, 8
9D001F00  0B400811   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001F04  7C031C20   SEB V1, V1
9D001F08  00001821   ADDU V1, ZERO, ZERO
9D001F0C  3C02BF80   LUI V0, -16512
9D001F10  8C476410   LW A3, 25616(V0)
9D001F14  00031C00   SLL V1, V1, 16
9D001F18  3C0600FF   LUI A2, 255
9D001F1C  00661824   AND V1, V1, A2
9D001F20  3C06FF00   LUI A2, -256
9D001F24  34C6FFFF   ORI A2, A2, -1
9D001F28  00E63024   AND A2, A3, A2
9D001F2C  00661825   OR V1, V1, A2
9D001F30  AC436410   SW V1, 25616(V0)
9D001F34  24426410   ADDIU V0, V0, 25616
9D001F38  3C030100   LUI V1, 256
9D001F3C  AC430008   SW V1, 8(V0)
9D001F40  8CA30020   LW V1, 32(A1)
9D001F44  24020002   ADDIU V0, ZERO, 2
9D001F48  1462004F   BNE V1, V0, 0x9D002088
9D001F4C  00004021   ADDU T0, ZERO, ZERO
9D001F50  00001021   ADDU V0, ZERO, ZERO
9D001F54  0B4005A1   J 0x9D001684
9D001F58  00003021   ADDU A2, ZERO, ZERO
9D001F5C  00001821   ADDU V1, ZERO, ZERO
9D001F60  3C02BF80   LUI V0, -16512
9D001F64  8C476810   LW A3, 26640(V0)
9D001F68  00031C00   SLL V1, V1, 16
9D001F6C  3C0600FF   LUI A2, 255
9D001F70  00661824   AND V1, V1, A2
9D001F74  3C06FF00   LUI A2, -256
9D001F78  34C6FFFF   ORI A2, A2, -1
9D001F7C  00E63024   AND A2, A3, A2
9D001F80  00661825   OR V1, V1, A2
9D001F84  AC436810   SW V1, 26640(V0)
9D001F88  24426810   ADDIU V0, V0, 26640
9D001F8C  3C030100   LUI V1, 256
9D001F90  AC430008   SW V1, 8(V0)
9D001F94  8CA30020   LW V1, 32(A1)
9D001F98  24020002   ADDIU V0, ZERO, 2
9D001F9C  1462004B   BNE V1, V0, 0x9D0020CC
9D001FA0  00004021   ADDU T0, ZERO, ZERO
9D001FA4  00001021   ADDU V0, ZERO, ZERO
9D001FA8  0B4005A1   J 0x9D001684
9D001FAC  00003021   ADDU A2, ZERO, ZERO
9D001FB0  00001821   ADDU V1, ZERO, ZERO
9D001FB4  3C02BF80   LUI V0, -16512
9D001FB8  8C476210   LW A3, 25104(V0)
9D001FBC  00031C00   SLL V1, V1, 16
9D001FC0  3C0600FF   LUI A2, 255
9D001FC4  00661824   AND V1, V1, A2
9D001FC8  3C06FF00   LUI A2, -256
9D001FCC  34C6FFFF   ORI A2, A2, -1
9D001FD0  00E63024   AND A2, A3, A2
9D001FD4  00661825   OR V1, V1, A2
9D001FD8  AC436210   SW V1, 25104(V0)
9D001FDC  24426210   ADDIU V0, V0, 25104
9D001FE0  3C030100   LUI V1, 256
9D001FE4  AC430008   SW V1, 8(V0)
9D001FE8  00003021   ADDU A2, ZERO, ZERO
9D001FEC  00004021   ADDU T0, ZERO, ZERO
9D001FF0  0B400582   J 0x9D001608
9D001FF4  00001021   ADDU V0, ZERO, ZERO
9D001FF8  00001821   ADDU V1, ZERO, ZERO
9D001FFC  3C02BF80   LUI V0, -16512
9D002000  8C476610   LW A3, 26128(V0)
9D002004  00031C00   SLL V1, V1, 16
9D002008  3C0600FF   LUI A2, 255
9D00200C  00661824   AND V1, V1, A2
9D002010  3C06FF00   LUI A2, -256
9D002014  34C6FFFF   ORI A2, A2, -1
9D002018  00E63024   AND A2, A3, A2
9D00201C  00661825   OR V1, V1, A2
9D002020  AC436610   SW V1, 26128(V0)
9D002024  24426610   ADDIU V0, V0, 26128
9D002028  3C030100   LUI V1, 256
9D00202C  AC430008   SW V1, 8(V0)
9D002030  00003021   ADDU A2, ZERO, ZERO
9D002034  00004021   ADDU T0, ZERO, ZERO
9D002038  0B400582   J 0x9D001608
9D00203C  00001021   ADDU V0, ZERO, ZERO
9D002040  00001821   ADDU V1, ZERO, ZERO
9D002044  3C02BF80   LUI V0, -16512
9D002048  8C476A10   LW A3, 27152(V0)
9D00204C  00031C00   SLL V1, V1, 16
9D002050  3C0600FF   LUI A2, 255
9D002054  00661824   AND V1, V1, A2
9D002058  3C06FF00   LUI A2, -256
9D00205C  34C6FFFF   ORI A2, A2, -1
9D002060  00E63024   AND A2, A3, A2
9D002064  00661825   OR V1, V1, A2
9D002068  AC436A10   SW V1, 27152(V0)
9D00206C  24426A10   ADDIU V0, V0, 27152
9D002070  3C030100   LUI V1, 256
9D002074  AC430008   SW V1, 8(V0)
9D002078  00003021   ADDU A2, ZERO, ZERO
9D00207C  00004021   ADDU T0, ZERO, ZERO
9D002080  0B400582   J 0x9D001608
9D002084  00001021   ADDU V0, ZERO, ZERO
9D002088  00001021   ADDU V0, ZERO, ZERO
9D00208C  3C04BF80   LUI A0, -16512
9D002090  8C866400   LW A2, 25600(A0)
9D002094  2404F7FF   ADDIU A0, ZERO, -2049
9D002098  00C43024   AND A2, A2, A0
9D00209C  38640001   XORI A0, V1, 1
9D0020A0  2C840001   SLTIU A0, A0, 1
9D0020A4  000422C0   SLL A0, A0, 11
9D0020A8  00862025   OR A0, A0, A2
9D0020AC  3C03BF80   LUI V1, -16512
9D0020B0  AC646400   SW A0, 25600(V1)
9D0020B4  8CA30010   LW V1, 16(A1)
9D0020B8  30690001   ANDI T1, V1, 1
9D0020BC  7C670080   EXT A3, V1, 2, 1
9D0020C0  7C630040   EXT V1, V1, 1, 1
9D0020C4  0B4005D1   J _DRV_USART_HardwareSetup::PLIB_USART_InitializeModeGeneral
9D0020C8  24060002   ADDIU A2, ZERO, 2
9D0020CC  00001021   ADDU V0, ZERO, ZERO
9D0020D0  3C04BF80   LUI A0, -16512
9D0020D4  8C866800   LW A2, 26624(A0)
9D0020D8  2404F7FF   ADDIU A0, ZERO, -2049
9D0020DC  00C43024   AND A2, A2, A0
9D0020E0  38640001   XORI A0, V1, 1
9D0020E4  2C840001   SLTIU A0, A0, 1
9D0020E8  000422C0   SLL A0, A0, 11
9D0020EC  00862025   OR A0, A0, A2
9D0020F0  3C03BF80   LUI V1, -16512
9D0020F4  AC646800   SW A0, 26624(V1)
9D0020F8  8CA30010   LW V1, 16(A1)
9D0020FC  30690001   ANDI T1, V1, 1
9D002100  7C670080   EXT A3, V1, 2, 1
9D002104  7C630040   EXT V1, V1, 1, 1
9D002108  0B4005EE   J _DRV_USART_HardwareSetup::PLIB_USART_InitializeModeGeneral
9D00210C  24060002   ADDIU A2, ZERO, 2
9D002110  3C03BF80   LUI V1, -16512
9D002114  8C676000   LW A3, 24576(V1)
9D002118  00042040   SLL A0, A0, 1
9D00211C  30840006   ANDI A0, A0, 6
9D002120  2402FFF9   ADDIU V0, ZERO, -7
9D002124  00E21024   AND V0, A3, V0
9D002128  00821025   OR V0, A0, V0
9D00212C  AC626000   SW V0, 24576(V1)
9D002130  0B4006A9   J 0x9D001AA4
9D002134  3C03BF80   LUI V1, -16512
9D002138  3C03BF80   LUI V1, -16512
9D00213C  24636400   ADDIU V1, V1, 25600
9D002140  AC640008   SW A0, 8(V1)
9D002144  0B400855   J 0x9D002154
9D002148  2442FFFC   ADDIU V0, V0, -4
9D00214C  24636400   ADDIU V1, V1, 25600
9D002150  AC640004   SW A0, 4(V1)
9D002154  3C03BF80   LUI V1, -16512
9D002158  8C676400   LW A3, 25600(V1)
9D00215C  00022040   SLL A0, V0, 1
9D002160  30840006   ANDI A0, A0, 6
9D002164  2402FFF9   ADDIU V0, ZERO, -7
9D002168  00E21024   AND V0, A3, V0
9D00216C  00821025   OR V0, A0, V0
9D002170  AC626400   SW V0, 25600(V1)
9D002174  0B4008A4   J 0x9D002290
9D002178  3C03BF80   LUI V1, -16512
9D00217C  3C03BF80   LUI V1, -16512
9D002180  24636800   ADDIU V1, V1, 26624
9D002184  AC640008   SW A0, 8(V1)
9D002188  0B400866   J 0x9D002198
9D00218C  2442FFFC   ADDIU V0, V0, -4
9D002190  24636800   ADDIU V1, V1, 26624
9D002194  AC640004   SW A0, 4(V1)
9D002198  3C03BF80   LUI V1, -16512
9D00219C  8C676800   LW A3, 26624(V1)
9D0021A0  00022040   SLL A0, V0, 1
9D0021A4  30840006   ANDI A0, A0, 6
9D0021A8  2402FFF9   ADDIU V0, ZERO, -7
9D0021AC  00E21024   AND V0, A3, V0
9D0021B0  00821025   OR V0, A0, V0
9D0021B4  AC626800   SW V0, 26624(V1)
9D0021B8  0B4008B9   J 0x9D0022E4
9D0021BC  3C03BF80   LUI V1, -16512
9D0021C0  3C03BF80   LUI V1, -16512
9D0021C4  24636200   ADDIU V1, V1, 25088
9D0021C8  AC640008   SW A0, 8(V1)
9D0021CC  0B400877   J 0x9D0021DC
9D0021D0  2442FFFC   ADDIU V0, V0, -4
9D0021D4  24636200   ADDIU V1, V1, 25088
9D0021D8  AC640004   SW A0, 4(V1)
9D0021DC  3C03BF80   LUI V1, -16512
9D0021E0  8C676200   LW A3, 25088(V1)
9D0021E4  00022040   SLL A0, V0, 1
9D0021E8  30840006   ANDI A0, A0, 6
9D0021EC  2402FFF9   ADDIU V0, ZERO, -7
9D0021F0  00E21024   AND V0, A3, V0
9D0021F4  00821025   OR V0, A0, V0
9D0021F8  AC626200   SW V0, 25088(V1)
9D0021FC  0B4008CE   J 0x9D002338
9D002200  3C03BF80   LUI V1, -16512
9D002204  3C03BF80   LUI V1, -16512
9D002208  24636600   ADDIU V1, V1, 26112
9D00220C  AC640008   SW A0, 8(V1)
9D002210  0B400888   J 0x9D002220
9D002214  2442FFFC   ADDIU V0, V0, -4
9D002218  24636600   ADDIU V1, V1, 26112
9D00221C  AC640004   SW A0, 4(V1)
9D002220  3C03BF80   LUI V1, -16512
9D002224  8C676600   LW A3, 26112(V1)
9D002228  00022040   SLL A0, V0, 1
9D00222C  30840006   ANDI A0, A0, 6
9D002230  2402FFF9   ADDIU V0, ZERO, -7
9D002234  00E21024   AND V0, A3, V0
9D002238  00821025   OR V0, A0, V0
9D00223C  AC626600   SW V0, 26112(V1)
9D002240  0B4008E3   J 0x9D00238C
9D002244  3C03BF80   LUI V1, -16512
9D002248  3C03BF80   LUI V1, -16512
9D00224C  24636A00   ADDIU V1, V1, 27136
9D002250  AC640008   SW A0, 8(V1)
9D002254  0B400899   J 0x9D002264
9D002258  2442FFFC   ADDIU V0, V0, -4
9D00225C  24636A00   ADDIU V1, V1, 27136
9D002260  AC640004   SW A0, 4(V1)
9D002264  3C03BF80   LUI V1, -16512
9D002268  8C676A00   LW A3, 27136(V1)
9D00226C  00022040   SLL A0, V0, 1
9D002270  30840006   ANDI A0, A0, 6
9D002274  2402FFF9   ADDIU V0, ZERO, -7
9D002278  00E21024   AND V0, A3, V0
9D00227C  00821025   OR V0, A0, V0
9D002280  AC626A00   SW V0, 27136(V1)
9D002284  0B4008F8   J 0x9D0023E0
9D002288  3C03BF80   LUI V1, -16512
9D00228C  3C03BF80   LUI V1, -16512
9D002290  8C646410   LW A0, 25616(V1)
9D002294  3C02FFFF   LUI V0, -1
9D002298  24423030   ADDIU V0, V0, 12336
9D00229C  00821024   AND V0, A0, V0
9D0022A0  AC626410   SW V0, 25616(V1)
9D0022A4  3C02BF80   LUI V0, -16512
9D0022A8  8C476400   LW A3, 25600(V0)
9D0022AC  2404FCFF   ADDIU A0, ZERO, -769
9D0022B0  00E42024   AND A0, A3, A0
9D0022B4  AC446400   SW A0, 25600(V0)
9D0022B8  8C646410   LW A0, 25616(V1)
9D0022BC  34844000   ORI A0, A0, 16384
9D0022C0  AC646410   SW A0, 25616(V1)
9D0022C4  8C436400   LW V1, 25600(V0)
9D0022C8  00063200   SLL A2, A2, 8
9D0022CC  00C33025   OR A2, A2, V1
9D0022D0  AC466400   SW A2, 25600(V0)
9D0022D4  8CA30014   LW V1, 20(A1)
9D0022D8  0B40090C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0022DC  8CA2001C   LW V0, 28(A1)
9D0022E0  3C03BF80   LUI V1, -16512
9D0022E4  8C646810   LW A0, 26640(V1)
9D0022E8  3C02FFFF   LUI V0, -1
9D0022EC  24423030   ADDIU V0, V0, 12336
9D0022F0  00821024   AND V0, A0, V0
9D0022F4  AC626810   SW V0, 26640(V1)
9D0022F8  3C02BF80   LUI V0, -16512
9D0022FC  8C476800   LW A3, 26624(V0)
9D002300  2404FCFF   ADDIU A0, ZERO, -769
9D002304  00E42024   AND A0, A3, A0
9D002308  AC446800   SW A0, 26624(V0)
9D00230C  8C646810   LW A0, 26640(V1)
9D002310  34844000   ORI A0, A0, 16384
9D002314  AC646810   SW A0, 26640(V1)
9D002318  8C436800   LW V1, 26624(V0)
9D00231C  00063200   SLL A2, A2, 8
9D002320  00C33025   OR A2, A2, V1
9D002324  AC466800   SW A2, 26624(V0)
9D002328  8CA30014   LW V1, 20(A1)
9D00232C  0B40091B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002330  8CA2001C   LW V0, 28(A1)
9D002334  3C03BF80   LUI V1, -16512
9D002338  8C646210   LW A0, 25104(V1)
9D00233C  3C02FFFF   LUI V0, -1
9D002340  24423030   ADDIU V0, V0, 12336
9D002344  00821024   AND V0, A0, V0
9D002348  AC626210   SW V0, 25104(V1)
9D00234C  3C02BF80   LUI V0, -16512
9D002350  8C476200   LW A3, 25088(V0)
9D002354  2404FCFF   ADDIU A0, ZERO, -769
9D002358  00E42024   AND A0, A3, A0
9D00235C  AC446200   SW A0, 25088(V0)
9D002360  8C646210   LW A0, 25104(V1)
9D002364  34844000   ORI A0, A0, 16384
9D002368  AC646210   SW A0, 25104(V1)
9D00236C  8C436200   LW V1, 25088(V0)
9D002370  00063200   SLL A2, A2, 8
9D002374  00C33025   OR A2, A2, V1
9D002378  AC466200   SW A2, 25088(V0)
9D00237C  8CA30014   LW V1, 20(A1)
9D002380  0B40092A   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002384  8CA2001C   LW V0, 28(A1)
9D002388  3C03BF80   LUI V1, -16512
9D00238C  8C646610   LW A0, 26128(V1)
9D002390  3C02FFFF   LUI V0, -1
9D002394  24423030   ADDIU V0, V0, 12336
9D002398  00821024   AND V0, A0, V0
9D00239C  AC626610   SW V0, 26128(V1)
9D0023A0  3C02BF80   LUI V0, -16512
9D0023A4  8C476600   LW A3, 26112(V0)
9D0023A8  2404FCFF   ADDIU A0, ZERO, -769
9D0023AC  00E42024   AND A0, A3, A0
9D0023B0  AC446600   SW A0, 26112(V0)
9D0023B4  8C646610   LW A0, 26128(V1)
9D0023B8  34844000   ORI A0, A0, 16384
9D0023BC  AC646610   SW A0, 26128(V1)
9D0023C0  8C436600   LW V1, 26112(V0)
9D0023C4  00063200   SLL A2, A2, 8
9D0023C8  00C33025   OR A2, A2, V1
9D0023CC  AC466600   SW A2, 26112(V0)
9D0023D0  8CA30014   LW V1, 20(A1)
9D0023D4  0B400939   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0023D8  8CA2001C   LW V0, 28(A1)
9D0023DC  3C03BF80   LUI V1, -16512
9D0023E0  8C646A10   LW A0, 27152(V1)
9D0023E4  3C02FFFF   LUI V0, -1
9D0023E8  24423030   ADDIU V0, V0, 12336
9D0023EC  00821024   AND V0, A0, V0
9D0023F0  AC626A10   SW V0, 27152(V1)
9D0023F4  3C02BF80   LUI V0, -16512
9D0023F8  8C476A00   LW A3, 27136(V0)
9D0023FC  2404FCFF   ADDIU A0, ZERO, -769
9D002400  00E42024   AND A0, A3, A0
9D002404  AC446A00   SW A0, 27136(V0)
9D002408  8C646A10   LW A0, 27152(V1)
9D00240C  34844000   ORI A0, A0, 16384
9D002410  AC646A10   SW A0, 27152(V1)
9D002414  8C436A00   LW V1, 27136(V0)
9D002418  00063200   SLL A2, A2, 8
9D00241C  00C33025   OR A2, A2, V1
9D002420  AC466A00   SW A2, 27136(V0)
9D002424  8CA30014   LW V1, 20(A1)
9D002428  0B400948   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00242C  8CA2001C   LW V0, 28(A1)
9D002430  3C04BF80   LUI A0, -16512
9D002434  8C856410   LW A1, 25616(A0)
9D002438  34A51400   ORI A1, A1, 5120
9D00243C  AC856410   SW A1, 25616(A0)
9D002440  0062001B   DIVU V1, V0
9D002444  004001F4   TEQ V0, ZERO
9D002448  00001012   MFLO V0
9D00244C  00022082   SRL A0, V0, 2
9D002450  2484FFFF   ADDIU A0, A0, -1
9D002454  3C030001   LUI V1, 1
9D002458  0083182B   SLTU V1, A0, V1
9D00245C  5460FDD8   BNEL V1, ZERO, 0x9D001BC0
9D002460  3C02BF80   LUI V0, -16512
9D002464  0B4006F7   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002468  3C03BF80   LUI V1, -16512
9D00246C  3C04BF80   LUI A0, -16512
9D002470  8C856810   LW A1, 26640(A0)
9D002474  34A51400   ORI A1, A1, 5120
9D002478  AC856810   SW A1, 26640(A0)
9D00247C  0062001B   DIVU V1, V0
9D002480  004001F4   TEQ V0, ZERO
9D002484  00001012   MFLO V0
9D002488  00022082   SRL A0, V0, 2
9D00248C  2484FFFF   ADDIU A0, A0, -1
9D002490  3C030001   LUI V1, 1
9D002494  0083182B   SLTU V1, A0, V1
9D002498  5460FDDE   BNEL V1, ZERO, 0x9D001C14
9D00249C  3C02BF80   LUI V0, -16512
9D0024A0  0B40070C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024A4  3C03BF80   LUI V1, -16512
9D0024A8  3C04BF80   LUI A0, -16512
9D0024AC  8C856210   LW A1, 25104(A0)
9D0024B0  34A51400   ORI A1, A1, 5120
9D0024B4  AC856210   SW A1, 25104(A0)
9D0024B8  0062001B   DIVU V1, V0
9D0024BC  004001F4   TEQ V0, ZERO
9D0024C0  00001012   MFLO V0
9D0024C4  00022082   SRL A0, V0, 2
9D0024C8  2484FFFF   ADDIU A0, A0, -1
9D0024CC  3C030001   LUI V1, 1
9D0024D0  0083182B   SLTU V1, A0, V1
9D0024D4  5460FDE4   BNEL V1, ZERO, 0x9D001C68
9D0024D8  3C02BF80   LUI V0, -16512
9D0024DC  0B400721   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024E0  3C03BF80   LUI V1, -16512
9D0024E4  3C04BF80   LUI A0, -16512
9D0024E8  8C856610   LW A1, 26128(A0)
9D0024EC  34A51400   ORI A1, A1, 5120
9D0024F0  AC856610   SW A1, 26128(A0)
9D0024F4  0062001B   DIVU V1, V0
9D0024F8  004001F4   TEQ V0, ZERO
9D0024FC  00001012   MFLO V0
9D002500  00022082   SRL A0, V0, 2
9D002504  2484FFFF   ADDIU A0, A0, -1
9D002508  3C030001   LUI V1, 1
9D00250C  0083182B   SLTU V1, A0, V1
9D002510  5460FDEA   BNEL V1, ZERO, 0x9D001CBC
9D002514  3C02BF80   LUI V0, -16512
9D002518  0B400736   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00251C  3C03BF80   LUI V1, -16512
9D002520  3C04BF80   LUI A0, -16512
9D002524  8C856A10   LW A1, 27152(A0)
9D002528  34A51400   ORI A1, A1, 5120
9D00252C  AC856A10   SW A1, 27152(A0)
9D002530  0062001B   DIVU V1, V0
9D002534  004001F4   TEQ V0, ZERO
9D002538  00001012   MFLO V0
9D00253C  00022082   SRL A0, V0, 2
9D002540  2484FFFF   ADDIU A0, A0, -1
9D002544  3C030001   LUI V1, 1
9D002548  0083182B   SLTU V1, A0, V1
9D00254C  5460FDF0   BNEL V1, ZERO, 0x9D001D10
9D002550  3C02BF80   LUI V0, -16512
9D002554  0B40074B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002558  3C03BF80   LUI V1, -16512
160:                 }
161:                 
162:                 #endif /*_USART_ENABLECONTROL_DEFAULT_H*/
163:                 
164:                 /******************************************************************************
165:                  End of File
166:                 */
167:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_baudratehigh_in16bitregister.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_BaudRateHigh_In16BitRegister.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BaudRateHigh
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_USART_ExistsBaudRateHigh
16:                          PLIB_USART_BaudRateHighSet
17:                          PLIB_USART_BaudRateHighDisable
18:                          PLIB_USART_BaudRateHighEnable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_BAUDRATEHIGH_IN16BITREGISTER_H
49:                  #define _USART_BAUDRATEHIGH_IN16BITREGISTER_H
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
53:                  
54:                    VREGs: 
55:                      _USART_BAUD_RATE_HIGH_16_VREG(index)
56:                      _USART_BAUD_RATE_HIGH_ENABLE_16_VREG(index)
57:                  
58:                    MASKs: 
59:                      _USART_BAUD_RATE_HIGH_16_MASK(index)
60:                      _USART_BAUD_RATE_HIGH_ENABLE_16_MASK(index)
61:                  
62:                    POSs: 
63:                      _USART_BAUD_RATE_HIGH_16_POS(index)
64:                      _USART_BAUD_RATE_HIGH_ENABLE_16_POS(index)
65:                  
66:                    LENs: 
67:                      _USART_BAUD_RATE_HIGH_16_LEN(index)
68:                      _USART_BAUD_RATE_HIGH_ENABLE_16_LEN(index)
69:                  
70:                  */
71:                  
72:                  
73:                  //******************************************************************************
74:                  /* Function :  USART_ExistsBaudRateHigh_In16BitRegister
75:                  
76:                    Summary:
77:                      Implements In16BitRegister variant of PLIB_USART_ExistsBaudRateHigh
78:                  
79:                    Description:
80:                      This template implements the In16BitRegister variant of the PLIB_USART_ExistsBaudRateHigh function.
81:                  */
82:                  
83:                  #define PLIB_USART_ExistsBaudRateHigh PLIB_USART_ExistsBaudRateHigh
84:                  PLIB_TEMPLATE bool USART_ExistsBaudRateHigh_In16BitRegister( USART_MODULE_ID index )
85:                  {
86:                      return true;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  USART_BaudRateHighSet_In16BitRegister
92:                  
93:                    Summary:
94:                      Implements In16BitRegister variant of PLIB_USART_BaudRateHighSet 
95:                  
96:                    Description:
97:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateHighSet function.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void USART_BaudRateHighSet_In16BitRegister( USART_MODULE_ID index , uint32_t clockFrequency , uint32_t baudRate )
101:                 {
102:                     uint32_t brg = (clockFrequency/(4*baudRate))-1; 
000000D0  00000000   NOP
000000F8  00000000   NOP
00000120  00000000   NOP
00000148  00000000   NOP
00000170  00000000   NOP
00000198  00000000   NOP
103:                     _SFR_FIELD_WRITE(_USART_BAUD_RATE_HIGH_16_VREG(index),
000000E4  00000000   NOP
0000010C  00000000   NOP
00000134  00000000   NOP
0000015C  00000000   NOP
00000184  00000000   NOP
000001AC  00000000   NOP
104:                 	                 _USART_BAUD_RATE_HIGH_16_MASK(index),
105:                 					 _USART_BAUD_RATE_HIGH_16_POS(index),
106:                 					 brg);
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  USART_BaudRateHighDisable_In16BitRegister
112:                 
113:                   Summary:
114:                     Implements In16BitRegister variant of PLIB_USART_BaudRateHighDisable 
115:                 
116:                   Description:
117:                     This template implements the In16BitRegister variant of the PLIB_USART_BaudRateHighDisable function.
118:                 */
119:                 
120:                 PLIB_TEMPLATE void USART_BaudRateHighDisable_In16BitRegister( USART_MODULE_ID index )
121:                 {
122:                     _SFR_BIT_CLEAR(_USART_BAUD_RATE_HIGH_ENABLE_16_VREG(index),
00000214  00000000   NOP
000003A0  00000000   NOP
000003B8  00000000   NOP
000003D0  00000000   NOP
000003E8  00000000   NOP
00000400  00000000   NOP
123:                 	             _USART_BAUD_RATE_HIGH_ENABLE_16_POS(index));
124:                 }
125:                 
126:                 
127:                 //******************************************************************************
128:                 /* Function :  USART_BaudRateHighEnable_In16BitRegister
129:                 
130:                   Summary:
131:                     Implements In16BitRegister variant of PLIB_USART_BaudRateHighEnable 
132:                 
133:                   Description:
134:                     This template implements the In16BitRegister variant of the PLIB_USART_BaudRateHighEnable function.
135:                 */
136:                 
137:                 PLIB_TEMPLATE void USART_BaudRateHighEnable_In16BitRegister( USART_MODULE_ID index )
138:                 {
139:                     _SFR_BIT_SET(_USART_BAUD_RATE_HIGH_ENABLE_16_VREG(index),
000000B8  00000000   NOP
00000328  00000000   NOP
00000340  00000000   NOP
00000358  00000000   NOP
00000370  00000000   NOP
00000388  00000000   NOP
140:                 	             _USART_BAUD_RATE_HIGH_ENABLE_16_POS(index));
141:                 	
142:                 }
143:                 
144:                 
145:                 #endif /*_USART_BAUDRATEHIGH_IN16BITREGISTER_H*/
146:                 
147:                 /******************************************************************************
148:                  End of File
149:                 */
150:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/templates/usart_baudrate_in16bitregister.h  
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_BaudRate_In16BitRegister.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BaudRate
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_USART_ExistsBaudRate
16:                          PLIB_USART_BaudRateSet
17:                          PLIB_USART_BaudRateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_BAUDRATE_IN16BITREGISTER_H
48:                  #define _USART_BAUDRATE_IN16BITREGISTER_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _USART_BAUD_RATE_VREG(index)
55:                  
56:                    MASKs: 
57:                      _USART_BAUD_RATE_MASK(index)
58:                  
59:                    POSs: 
60:                      _USART_BAUD_RATE_POS(index)
61:                  
62:                    LENs: 
63:                      _USART_BAUD_RATE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ExistsBaudRate_In16BitRegister
70:                  
71:                    Summary:
72:                      Implements In16BitRegister variant of PLIB_USART_ExistsBaudRate
73:                  
74:                    Description:
75:                      This template implements the In16BitRegister variant of the PLIB_USART_ExistsBaudRate function.
76:                  */
77:                  
78:                  #define PLIB_USART_ExistsBaudRate PLIB_USART_ExistsBaudRate
79:                  PLIB_TEMPLATE bool USART_ExistsBaudRate_In16BitRegister( USART_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USART_BaudRateSet_In16BitRegister
87:                  
88:                    Summary:
89:                      Implements In16BitRegister variant of PLIB_USART_BaudRateSet 
90:                  
91:                    Description:
92:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateSet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void USART_BaudRateSet_In16BitRegister( USART_MODULE_ID index , uint32_t clockFrequency , uint32_t baudRate )
96:                  {
97:                     uint32_t brg;
98:                     
99:                     brg = (((clockFrequency/baudRate) >> 4) - 1);
0000022C  00000000   NOP
00000254  00000000   NOP
0000027C  00000000   NOP
000002A4  00000000   NOP
000002CC  00000000   NOP
000002F4  00000000   NOP
100:                 
101:                    _SFR_FIELD_WRITE(_USART_BAUD_RATE_VREG(index),
00000240  00000000   NOP
00000268  00000000   NOP
00000290  00000000   NOP
000002B8  00000000   NOP
000002E0  00000000   NOP
00000308  00000000   NOP
102:                                     _USART_BAUD_RATE_MASK(index),
103:                 					_USART_BAUD_RATE_POS(index),
104:                 					brg);
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  USART_BaudRateGet_In16BitRegister
110:                 
111:                   Summary:
112:                     Implements In16BitRegister variant of PLIB_USART_BaudRateGet 
113:                 
114:                   Description:
115:                     This template implements the In16BitRegister variant of the PLIB_USART_BaudRateGet function.
116:                 */
117:                 
118:                 PLIB_TEMPLATE uint32_t USART_BaudRateGet_In16BitRegister( USART_MODULE_ID index , int32_t clockFrequency )
119:                 {
120:                     unsigned short baudReg;
121:                 	
122:                 	baudReg = _SFR_FIELD_READ(_USART_BAUD_RATE_VREG(index),
123:                 								_USART_BAUD_RATE_MASK(index),
124:                 								_USART_BAUD_RATE_POS(index));
125:                 					
126:                 	 return clockFrequency/(16 *(baudReg+1));
127:                 }
128:                 
129:                 
130:                 #endif /*_USART_BAUDRATE_IN16BITREGISTER_H*/
131:                 
132:                 /******************************************************************************
133:                  End of File
134:                 */
135:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/usart/processor/usart_p32mx795f512l.h  ----------
1:                   /* Created by plibgen $Revision: 1.31 $ */
2:                   
3:                   #ifndef _USART_P32MX795F512L_H
4:                   #define _USART_P32MX795F512L_H
5:                   
6:                   /* Section 1 - Enumerate instances, define constants, VREGs */
7:                   
8:                   #include <xc.h>
9:                   #include <stdbool.h>
10:                  
11:                  #include "peripheral/peripheral_common_32bit.h"
12:                  
13:                  /* Default definition used for all API dispatch functions */
14:                  #ifndef PLIB_INLINE_API
15:                      #define PLIB_INLINE_API extern inline
16:                  #endif
17:                  
18:                  /* Default definition used for all other functions */
19:                  #ifndef PLIB_INLINE
20:                      #define PLIB_INLINE extern inline
21:                  #endif
22:                  
23:                  typedef enum {
24:                  
25:                      USART_ID_1 = 0,
26:                      USART_ID_3,
27:                      USART_ID_2,
28:                      USART_ID_4,
29:                      USART_ID_6,
30:                      USART_ID_5,
31:                      USART_NUMBER_OF_MODULES
32:                  
33:                  } USART_MODULE_ID;
34:                  
35:                  typedef enum {
36:                  
37:                      USART_HANDSHAKE_MODE_FLOW_CONTROL = 0x00,
38:                      USART_HANDSHAKE_MODE_SIMPLEX = 0x01
39:                  
40:                  } USART_HANDSHAKE_MODE;
41:                  
42:                  typedef enum {
43:                  
44:                      USART_ENABLE_TX_RX_BCLK_USED = 0x03,
45:                      USART_ENABLE_TX_RX_CTS_RTS_USED = 0x02,
46:                      USART_ENABLE_TX_RX_RTS_USED = 0x01,
47:                      USART_ENABLE_TX_RX_USED = 0x00
48:                  
49:                  } USART_OPERATION_MODE;
50:                  
51:                  typedef enum {
52:                  
53:                      USART_8N1 = 0x00,
54:                      USART_8E1 = 0x01,
55:                      USART_8O1 = 0x02,
56:                      USART_9N1 = 0x03,
57:                      USART_8N2 = 0x04,
58:                      USART_8E2 = 0x05,
59:                      USART_8O2 = 0x06,
60:                      USART_9N2 = 0x07
61:                  
62:                  } USART_LINECONTROL_MODE;
63:                  
64:                  typedef enum {
65:                  
66:                      USART_BRG_CLOCK_SOURCE_NONE
67:                  
68:                  } USART_BRG_CLOCK_SOURCE;
69:                  
70:                  typedef enum {
71:                  
72:                      USART_ERROR_NONE = 0x00,
73:                      USART_ERROR_RECEIVER_OVERRUN = 0x01,
74:                      USART_ERROR_FRAMING = 0x02,
75:                      USART_ERROR_PARITY = 0x04
76:                  
77:                  } USART_ERROR;
78:                  
79:                  typedef enum {
80:                  
81:                      USART_TRANSMIT_FIFO_NOT_FULL = 0x00,
82:                      USART_TRANSMIT_FIFO_IDLE = 0x01,
83:                      USART_TRANSMIT_FIFO_EMPTY = 0x02
84:                  
85:                  } USART_TRANSMIT_INTR_MODE;
86:                  
87:                  typedef enum {
88:                  
89:                      USART_RECEIVE_FIFO_3B4FULL = 0x02,
90:                      USART_RECEIVE_FIFO_HALF_FULL = 0x01,
91:                      USART_RECEIVE_FIFO_ONE_CHAR = 0x00
92:                  
93:                  } USART_RECEIVE_INTR_MODE;
94:                  
95:                  PLIB_INLINE SFR_TYPE* _USART_LINE_CONTROL_MODE_STOP_VREG(USART_MODULE_ID i)
96:                  {
97:                      switch (i) {
98:                          case USART_ID_1 :
99:                              return &U1MODE;
100:                         case USART_ID_3 :
101:                             return &U3MODE;
102:                         case USART_ID_2 :
103:                             return &U2MODE;
104:                         case USART_ID_4 :
105:                             return &U4MODE;
106:                         case USART_ID_6 :
107:                             return &U6MODE;
108:                         case USART_ID_5 :
109:                             return &U5MODE;
110:                         case USART_NUMBER_OF_MODULES :
111:                         default :
112:                             return (SFR_TYPE*)-1;
113:                     }
114:                 }
115:                 
116:                 PLIB_INLINE SFR_TYPE* _USART_LINE_CONTROL_MODE_DATA_VREG(USART_MODULE_ID i)
117:                 {
118:                     switch (i) {
119:                         case USART_ID_1 :
120:                             return &U1MODE;
121:                         case USART_ID_3 :
122:                             return &U3MODE;
123:                         case USART_ID_2 :
124:                             return &U2MODE;
125:                         case USART_ID_4 :
126:                             return &U4MODE;
127:                         case USART_ID_6 :
128:                             return &U6MODE;
129:                         case USART_ID_5 :
130:                             return &U5MODE;
131:                         case USART_NUMBER_OF_MODULES :
132:                         default :
133:                             return (SFR_TYPE*)-1;
134:                     }
135:                 }
136:                 
137:                 PLIB_INLINE SFR_TYPE* _USART_BAUD_RATE_HIGH_ENABLE_16_VREG(USART_MODULE_ID i)
138:                 {
139:                     switch (i) {
140:                         case USART_ID_1 :
141:                             return &U1MODE;
142:                         case USART_ID_3 :
143:                             return &U3MODE;
144:                         case USART_ID_2 :
145:                             return &U2MODE;
146:                         case USART_ID_4 :
147:                             return &U4MODE;
148:                         case USART_ID_6 :
149:                             return &U6MODE;
150:                         case USART_ID_5 :
151:                             return &U5MODE;
152:                         case USART_NUMBER_OF_MODULES :
153:                         default :
154:                             return (SFR_TYPE*)-1;
155:                     }
156:                 }
157:                 
158:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_POLARITY_INVERT_VREG(USART_MODULE_ID i)
159:                 {
160:                     switch (i) {
161:                         case USART_ID_1 :
162:                             return &U1MODE;
163:                         case USART_ID_3 :
164:                             return &U3MODE;
165:                         case USART_ID_2 :
166:                             return &U2MODE;
167:                         case USART_ID_4 :
168:                             return &U4MODE;
169:                         case USART_ID_6 :
170:                             return &U6MODE;
171:                         case USART_ID_5 :
172:                             return &U5MODE;
173:                         case USART_NUMBER_OF_MODULES :
174:                         default :
175:                             return (SFR_TYPE*)-1;
176:                     }
177:                 }
178:                 
179:                 PLIB_INLINE SFR_TYPE* _USART_BAUD_RATE_AUTO_DETECT_VREG(USART_MODULE_ID i)
180:                 {
181:                     switch (i) {
182:                         case USART_ID_1 :
183:                             return &U1MODE;
184:                         case USART_ID_3 :
185:                             return &U3MODE;
186:                         case USART_ID_2 :
187:                             return &U2MODE;
188:                         case USART_ID_4 :
189:                             return &U4MODE;
190:                         case USART_ID_6 :
191:                             return &U6MODE;
192:                         case USART_ID_5 :
193:                             return &U5MODE;
194:                         case USART_NUMBER_OF_MODULES :
195:                         default :
196:                             return (SFR_TYPE*)-1;
197:                     }
198:                 }
199:                 
200:                 PLIB_INLINE SFR_TYPE* _USART_LOOP_BACK_VREG(USART_MODULE_ID i)
201:                 {
202:                     switch (i) {
203:                         case USART_ID_1 :
204:                             return &U1MODE;
205:                         case USART_ID_3 :
206:                             return &U3MODE;
207:                         case USART_ID_2 :
208:                             return &U2MODE;
209:                         case USART_ID_4 :
210:                             return &U4MODE;
211:                         case USART_ID_6 :
212:                             return &U6MODE;
213:                         case USART_ID_5 :
214:                             return &U5MODE;
215:                         case USART_NUMBER_OF_MODULES :
216:                         default :
217:                             return (SFR_TYPE*)-1;
218:                     }
219:                 }
220:                 
221:                 PLIB_INLINE SFR_TYPE* _USART_WAKE_ON_START_VREG(USART_MODULE_ID i)
222:                 {
223:                     switch (i) {
224:                         case USART_ID_1 :
225:                             return &U1MODE;
226:                         case USART_ID_3 :
227:                             return &U3MODE;
228:                         case USART_ID_2 :
229:                             return &U2MODE;
230:                         case USART_ID_4 :
231:                             return &U4MODE;
232:                         case USART_ID_6 :
233:                             return &U6MODE;
234:                         case USART_ID_5 :
235:                             return &U5MODE;
236:                         case USART_NUMBER_OF_MODULES :
237:                         default :
238:                             return (SFR_TYPE*)-1;
239:                     }
240:                 }
241:                 
242:                 PLIB_INLINE SFR_TYPE* _USART_OPERATION_MODE_VREG(USART_MODULE_ID i)
243:                 {
244:                     switch (i) {
245:                         case USART_ID_1 :
246:                             return &U1MODE;
247:                         case USART_ID_3 :
248:                             return &U3MODE;
249:                         case USART_ID_2 :
250:                             return &U2MODE;
251:                         case USART_ID_4 :
252:                             return (SFR_TYPE*)-1;
253:                         case USART_ID_6 :
254:                             return (SFR_TYPE*)-1;
255:                         case USART_ID_5 :
256:                             return (SFR_TYPE*)-1;
257:                         case USART_NUMBER_OF_MODULES :
258:                         default :
259:                             return (SFR_TYPE*)-1;
260:                     }
261:                 }
262:                 
263:                 PLIB_INLINE SFR_TYPE* _USART_HAND_SHAKE_MODE_VREG(USART_MODULE_ID i)
264:                 {
265:                     switch (i) {
266:                         case USART_ID_1 :
267:                             return &U1MODE;
268:                         case USART_ID_3 :
269:                             return &U3MODE;
270:                         case USART_ID_2 :
271:                             return &U2MODE;
272:                         case USART_ID_4 :
273:                             return (SFR_TYPE*)-1;
274:                         case USART_ID_6 :
275:                             return (SFR_TYPE*)-1;
276:                         case USART_ID_5 :
277:                             return (SFR_TYPE*)-1;
278:                         case USART_NUMBER_OF_MODULES :
279:                         default :
280:                             return (SFR_TYPE*)-1;
281:                     }
282:                 }
283:                 
284:                 PLIB_INLINE SFR_TYPE* _USART_IRDA_ENABLE_CONTROL_VREG(USART_MODULE_ID i)
285:                 {
286:                     switch (i) {
287:                         case USART_ID_1 :
288:                             return &U1MODE;
289:                         case USART_ID_3 :
290:                             return &U3MODE;
291:                         case USART_ID_2 :
292:                             return &U2MODE;
293:                         case USART_ID_4 :
294:                             return &U4MODE;
295:                         case USART_ID_6 :
296:                             return &U6MODE;
297:                         case USART_ID_5 :
298:                             return &U5MODE;
299:                         case USART_NUMBER_OF_MODULES :
300:                         default :
301:                             return (SFR_TYPE*)-1;
302:                     }
303:                 }
304:                 
305:                 PLIB_INLINE SFR_TYPE* _USART_STOP_IN_IDLE_VREG(USART_MODULE_ID i)
306:                 {
307:                     switch (i) {
308:                         case USART_ID_1 :
309:                             return &U1MODE;
310:                         case USART_ID_3 :
311:                             return &U3MODE;
312:                         case USART_ID_2 :
313:                             return &U2MODE;
314:                         case USART_ID_4 :
315:                             return &U4MODE;
316:                         case USART_ID_6 :
317:                             return &U6MODE;
318:                         case USART_ID_5 :
319:                             return &U5MODE;
320:                         case USART_NUMBER_OF_MODULES :
321:                         default :
322:                             return (SFR_TYPE*)-1;
323:                     }
324:                 }
325:                 
326:                 PLIB_INLINE SFR_TYPE* _USART_ENABLE_CONTROL_VREG(USART_MODULE_ID i)
327:                 {
328:                     switch (i) {
329:                         case USART_ID_1 :
330:                             return &U1MODE;
331:                         case USART_ID_3 :
332:                             return &U3MODE;
333:                         case USART_ID_2 :
334:                             return &U2MODE;
335:                         case USART_ID_4 :
336:                             return &U4MODE;
337:                         case USART_ID_6 :
338:                             return &U6MODE;
339:                         case USART_ID_5 :
340:                             return &U5MODE;
341:                         case USART_NUMBER_OF_MODULES :
342:                         default :
343:                             return (SFR_TYPE*)-1;
344:                     }
345:                 }
346:                 
347:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_DATA_AVAILABLE_VREG(USART_MODULE_ID i)
348:                 {
349:                     switch (i) {
350:                         case USART_ID_1 :
351:                             return &U1STA;
352:                         case USART_ID_3 :
353:                             return &U3STA;
354:                         case USART_ID_2 :
355:                             return &U2STA;
356:                         case USART_ID_4 :
357:                             return &U4STA;
358:                         case USART_ID_6 :
359:                             return &U6STA;
360:                         case USART_ID_5 :
361:                             return &U5STA;
362:                         case USART_NUMBER_OF_MODULES :
363:                         default :
364:                             return (SFR_TYPE*)-1;
365:                     }
366:                 }
367:                 
368:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_OVERRUN_ERROR_VREG(USART_MODULE_ID i)
369:                 {
370:                     switch (i) {
371:                         case USART_ID_1 :
372:                             return &U1STA;
373:                         case USART_ID_3 :
374:                             return &U3STA;
375:                         case USART_ID_2 :
376:                             return &U2STA;
377:                         case USART_ID_4 :
378:                             return &U4STA;
379:                         case USART_ID_6 :
380:                             return &U6STA;
381:                         case USART_ID_5 :
382:                             return &U5STA;
383:                         case USART_NUMBER_OF_MODULES :
384:                         default :
385:                             return (SFR_TYPE*)-1;
386:                     }
387:                 }
388:                 
389:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_FRAMING_ERROR_VREG(USART_MODULE_ID i)
390:                 {
391:                     switch (i) {
392:                         case USART_ID_1 :
393:                             return &U1STA;
394:                         case USART_ID_3 :
395:                             return &U3STA;
396:                         case USART_ID_2 :
397:                             return &U2STA;
398:                         case USART_ID_4 :
399:                             return &U4STA;
400:                         case USART_ID_6 :
401:                             return &U6STA;
402:                         case USART_ID_5 :
403:                             return &U5STA;
404:                         case USART_NUMBER_OF_MODULES :
405:                         default :
406:                             return (SFR_TYPE*)-1;
407:                     }
408:                 }
409:                 
410:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_PARITY_ERROR_VREG(USART_MODULE_ID i)
411:                 {
412:                     switch (i) {
413:                         case USART_ID_1 :
414:                             return &U1STA;
415:                         case USART_ID_3 :
416:                             return &U3STA;
417:                         case USART_ID_2 :
418:                             return &U2STA;
419:                         case USART_ID_4 :
420:                             return &U4STA;
421:                         case USART_ID_6 :
422:                             return &U6STA;
423:                         case USART_ID_5 :
424:                             return &U5STA;
425:                         case USART_NUMBER_OF_MODULES :
426:                         default :
427:                             return (SFR_TYPE*)-1;
428:                     }
429:                 }
430:                 
431:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_IDLE_VREG(USART_MODULE_ID i)
432:                 {
433:                     switch (i) {
434:                         case USART_ID_1 :
435:                             return &U1STA;
436:                         case USART_ID_3 :
437:                             return &U3STA;
438:                         case USART_ID_2 :
439:                             return &U2STA;
440:                         case USART_ID_4 :
441:                             return &U4STA;
442:                         case USART_ID_6 :
443:                             return &U6STA;
444:                         case USART_ID_5 :
445:                             return &U5STA;
446:                         case USART_NUMBER_OF_MODULES :
447:                         default :
448:                             return (SFR_TYPE*)-1;
449:                     }
450:                 }
451:                 
452:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_ADDRESS_DETECT_VREG(USART_MODULE_ID i)
453:                 {
454:                     switch (i) {
455:                         case USART_ID_1 :
456:                             return &U1STA;
457:                         case USART_ID_3 :
458:                             return &U3STA;
459:                         case USART_ID_2 :
460:                             return &U2STA;
461:                         case USART_ID_4 :
462:                             return &U4STA;
463:                         case USART_ID_6 :
464:                             return &U6STA;
465:                         case USART_ID_5 :
466:                             return &U5STA;
467:                         case USART_NUMBER_OF_MODULES :
468:                         default :
469:                             return (SFR_TYPE*)-1;
470:                     }
471:                 }
472:                 
473:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_FIFO_LEVEL_VREG(USART_MODULE_ID i)
474:                 {
475:                     switch (i) {
476:                         case USART_ID_1 :
477:                             return &U1STA;
478:                         case USART_ID_3 :
479:                             return &U3STA;
480:                         case USART_ID_2 :
481:                             return &U2STA;
482:                         case USART_ID_4 :
483:                             return &U4STA;
484:                         case USART_ID_6 :
485:                             return &U6STA;
486:                         case USART_ID_5 :
487:                             return &U5STA;
488:                         case USART_NUMBER_OF_MODULES :
489:                         default :
490:                             return (SFR_TYPE*)-1;
491:                     }
492:                 }
493:                 
494:                 PLIB_INLINE SFR_TYPE* _USART_TRANSMITTER_EMPTY_VREG(USART_MODULE_ID i)
495:                 {
496:                     switch (i) {
497:                         case USART_ID_1 :
498:                             return &U1STA;
499:                         case USART_ID_3 :
500:                             return &U3STA;
501:                         case USART_ID_2 :
502:                             return &U2STA;
503:                         case USART_ID_4 :
504:                             return &U4STA;
505:                         case USART_ID_6 :
506:                             return &U6STA;
507:                         case USART_ID_5 :
508:                             return &U5STA;
509:                         case USART_NUMBER_OF_MODULES :
510:                         default :
511:                             return (SFR_TYPE*)-1;
512:                     }
513:                 }
514:                 
515:                 PLIB_INLINE SFR_TYPE* _USART_TRANSMITTER_BUFFER_FULL_VREG(USART_MODULE_ID i)
516:                 {
517:                     switch (i) {
518:                         case USART_ID_1 :
519:                             return &U1STA;
520:                         case USART_ID_3 :
521:                             return &U3STA;
522:                         case USART_ID_2 :
523:                             return &U2STA;
524:                         case USART_ID_4 :
525:                             return &U4STA;
526:                         case USART_ID_6 :
527:                             return &U6STA;
528:                         case USART_ID_5 :
529:                             return &U5STA;
530:                         case USART_NUMBER_OF_MODULES :
531:                         default :
532:                             return (SFR_TYPE*)-1;
533:                     }
534:                 }
535:                 
536:                 PLIB_INLINE SFR_TYPE* _USART_TRANSMITTER_ENABLE_CONTROL_VREG(USART_MODULE_ID i)
537:                 {
538:                     switch (i) {
539:                         case USART_ID_1 :
540:                             return &U1STA;
541:                         case USART_ID_3 :
542:                             return &U3STA;
543:                         case USART_ID_2 :
544:                             return &U2STA;
545:                         case USART_ID_4 :
546:                             return &U4STA;
547:                         case USART_ID_6 :
548:                             return &U6STA;
549:                         case USART_ID_5 :
550:                             return &U5STA;
551:                         case USART_NUMBER_OF_MODULES :
552:                         default :
553:                             return (SFR_TYPE*)-1;
554:                     }
555:                 }
556:                 
557:                 PLIB_INLINE SFR_TYPE* _USART_TRANSMITTER_BREAK_SEND_VREG(USART_MODULE_ID i)
558:                 {
559:                     switch (i) {
560:                         case USART_ID_1 :
561:                             return &U1STA;
562:                         case USART_ID_3 :
563:                             return &U3STA;
564:                         case USART_ID_2 :
565:                             return &U2STA;
566:                         case USART_ID_4 :
567:                             return &U4STA;
568:                         case USART_ID_6 :
569:                             return &U6STA;
570:                         case USART_ID_5 :
571:                             return &U5STA;
572:                         case USART_NUMBER_OF_MODULES :
573:                         default :
574:                             return (SFR_TYPE*)-1;
575:                     }
576:                 }
577:                 
578:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_ENABLE_VREG(USART_MODULE_ID i)
579:                 {
580:                     switch (i) {
581:                         case USART_ID_1 :
582:                             return &U1STA;
583:                         case USART_ID_3 :
584:                             return &U3STA;
585:                         case USART_ID_2 :
586:                             return &U2STA;
587:                         case USART_ID_4 :
588:                             return &U4STA;
589:                         case USART_ID_6 :
590:                             return &U6STA;
591:                         case USART_ID_5 :
592:                             return &U5STA;
593:                         case USART_NUMBER_OF_MODULES :
594:                         default :
595:                             return (SFR_TYPE*)-1;
596:                     }
597:                 }
598:                 
599:                 PLIB_INLINE SFR_TYPE* _USART_TRANSMITTER_IDLE_IS_LOW32_VREG(USART_MODULE_ID i)
600:                 {
601:                     switch (i) {
602:                         case USART_ID_1 :
603:                             return &U1STA;
604:                         case USART_ID_3 :
605:                             return &U3STA;
606:                         case USART_ID_2 :
607:                             return &U2STA;
608:                         case USART_ID_4 :
609:                             return &U4STA;
610:                         case USART_ID_6 :
611:                             return &U6STA;
612:                         case USART_ID_5 :
613:                             return &U5STA;
614:                         case USART_NUMBER_OF_MODULES :
615:                         default :
616:                             return (SFR_TYPE*)-1;
617:                     }
618:                 }
619:                 
620:                 PLIB_INLINE SFR_TYPE* _USART_TRANSMITTER_INTR_MODE_SELECT_VREG(USART_MODULE_ID i)
621:                 {
622:                     switch (i) {
623:                         case USART_ID_1 :
624:                             return &U1STA;
625:                         case USART_ID_3 :
626:                             return &U3STA;
627:                         case USART_ID_2 :
628:                             return &U2STA;
629:                         case USART_ID_4 :
630:                             return &U4STA;
631:                         case USART_ID_6 :
632:                             return &U6STA;
633:                         case USART_ID_5 :
634:                             return &U5STA;
635:                         case USART_NUMBER_OF_MODULES :
636:                         default :
637:                             return (SFR_TYPE*)-1;
638:                     }
639:                 }
640:                 
641:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_ADDRESS_AUTO_DETECT_VREG(USART_MODULE_ID i)
642:                 {
643:                     switch (i) {
644:                         case USART_ID_1 :
645:                             return &U1STA;
646:                         case USART_ID_3 :
647:                             return &U3STA;
648:                         case USART_ID_2 :
649:                             return &U2STA;
650:                         case USART_ID_4 :
651:                             return &U4STA;
652:                         case USART_ID_6 :
653:                             return &U6STA;
654:                         case USART_ID_5 :
655:                             return &U5STA;
656:                         case USART_NUMBER_OF_MODULES :
657:                         default :
658:                             return (SFR_TYPE*)-1;
659:                     }
660:                 }
661:                 
662:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_VREG(USART_MODULE_ID i)
663:                 {
664:                     switch (i) {
665:                         case USART_ID_1 :
666:                             return &U1STA;
667:                         case USART_ID_3 :
668:                             return &U3STA;
669:                         case USART_ID_2 :
670:                             return &U2STA;
671:                         case USART_ID_4 :
672:                             return &U4STA;
673:                         case USART_ID_6 :
674:                             return &U6STA;
675:                         case USART_ID_5 :
676:                             return &U5STA;
677:                         case USART_NUMBER_OF_MODULES :
678:                         default :
679:                             return (SFR_TYPE*)-1;
680:                     }
681:                 }
682:                 
683:                 PLIB_INLINE SFR_TYPE* _USART_TRANSMITTER_SEND_VREG(USART_MODULE_ID i)
684:                 {
685:                     switch (i) {
686:                         case USART_ID_1 :
687:                             return &U1TXREG;
688:                         case USART_ID_3 :
689:                             return &U3TXREG;
690:                         case USART_ID_2 :
691:                             return &U2TXREG;
692:                         case USART_ID_4 :
693:                             return &U4TXREG;
694:                         case USART_ID_6 :
695:                             return &U6TXREG;
696:                         case USART_ID_5 :
697:                             return &U5TXREG;
698:                         case USART_NUMBER_OF_MODULES :
699:                         default :
700:                             return (SFR_TYPE*)-1;
701:                     }
702:                 }
703:                 
704:                 PLIB_INLINE SFR_TYPE* _USART_TRANSMITTER_DATA_ONLY_VREG(USART_MODULE_ID i)
705:                 {
706:                     switch (i) {
707:                         case USART_ID_1 :
708:                             return &U1TXREG;
709:                         case USART_ID_3 :
710:                             return &U3TXREG;
711:                         case USART_ID_2 :
712:                             return &U2TXREG;
713:                         case USART_ID_4 :
714:                             return &U4TXREG;
715:                         case USART_ID_6 :
716:                             return &U6TXREG;
717:                         case USART_ID_5 :
718:                             return &U5TXREG;
719:                         case USART_NUMBER_OF_MODULES :
720:                         default :
721:                             return (SFR_TYPE*)-1;
722:                     }
723:                 }
724:                 
725:                 PLIB_INLINE SFR_TYPE* _USART_RECEIVER_DATA_VREG(USART_MODULE_ID i)
726:                 {
727:                     switch (i) {
728:                         case USART_ID_1 :
729:                             return &U1RXREG;
730:                         case USART_ID_3 :
731:                             return &U3RXREG;
732:                         case USART_ID_2 :
733:                             return &U2RXREG;
734:                         case USART_ID_4 :
735:                             return &U4RXREG;
736:                         case USART_ID_6 :
737:                             return &U6RXREG;
738:                         case USART_ID_5 :
739:                             return &U5RXREG;
740:                         case USART_NUMBER_OF_MODULES :
741:                         default :
742:                             return (SFR_TYPE*)-1;
743:                     }
744:                 }
745:                 
746:                 PLIB_INLINE SFR_TYPE* _USART_BAUD_RATE_HIGH_16_VREG(USART_MODULE_ID i)
747:                 {
748:                     switch (i) {
749:                         case USART_ID_1 :
750:                             return &U1BRG;
751:                         case USART_ID_3 :
752:                             return &U3BRG;
753:                         case USART_ID_2 :
754:                             return &U2BRG;
755:                         case USART_ID_4 :
756:                             return &U4BRG;
757:                         case USART_ID_6 :
758:                             return &U6BRG;
759:                         case USART_ID_5 :
760:                             return &U5BRG;
761:                         case USART_NUMBER_OF_MODULES :
762:                         default :
763:                             return (SFR_TYPE*)-1;
764:                     }
765:                 }
766:                 
767:                 PLIB_INLINE SFR_TYPE* _USART_BAUD_RATE_VREG(USART_MODULE_ID i)
768:                 {
769:                     switch (i) {
770:                         case USART_ID_1 :
771:                             return &U1BRG;
772:                         case USART_ID_3 :
773:                             return &U3BRG;
774:                         case USART_ID_2 :
775:                             return &U2BRG;
776:                         case USART_ID_4 :
777:                             return &U4BRG;
778:                         case USART_ID_6 :
779:                             return &U6BRG;
780:                         case USART_ID_5 :
781:                             return &U5BRG;
782:                         case USART_NUMBER_OF_MODULES :
783:                         default :
784:                             return (SFR_TYPE*)-1;
785:                     }
786:                 }
787:                 
788:                 PLIB_INLINE SFR_DATA _USART_LINE_CONTROL_MODE_STOP_MASK(USART_MODULE_ID i)
789:                 {
790:                     switch (i) {
791:                         case USART_ID_1 :
792:                             return _U1MODE_STSEL_MASK;
793:                         case USART_ID_3 :
794:                             return _U3MODE_STSEL_MASK;
795:                         case USART_ID_2 :
796:                             return _U2MODE_STSEL_MASK;
797:                         case USART_ID_4 :
798:                             return _U4MODE_STSEL_MASK;
799:                         case USART_ID_6 :
800:                             return _U6MODE_STSEL_MASK;
801:                         case USART_ID_5 :
802:                             return _U5MODE_STSEL_MASK;
803:                         case USART_NUMBER_OF_MODULES :
804:                         default :
805:                             return (SFR_DATA)-1;
806:                     }
807:                 }
808:                 
809:                 PLIB_INLINE SFR_DATA _USART_LINE_CONTROL_MODE_DATA_MASK(USART_MODULE_ID i)
810:                 {
811:                     switch (i) {
812:                         case USART_ID_1 :
813:                             return _U1MODE_PDSEL_MASK;
814:                         case USART_ID_3 :
815:                             return _U3MODE_PDSEL_MASK;
816:                         case USART_ID_2 :
817:                             return _U2MODE_PDSEL_MASK;
818:                         case USART_ID_4 :
819:                             return _U4MODE_PDSEL_MASK;
820:                         case USART_ID_6 :
821:                             return _U6MODE_PDSEL_MASK;
822:                         case USART_ID_5 :
823:                             return _U5MODE_PDSEL_MASK;
824:                         case USART_NUMBER_OF_MODULES :
825:                         default :
826:                             return (SFR_DATA)-1;
827:                     }
828:                 }
829:                 
830:                 PLIB_INLINE SFR_DATA _USART_BAUD_RATE_HIGH_ENABLE_16_MASK(USART_MODULE_ID i)
831:                 {
832:                     switch (i) {
833:                         case USART_ID_1 :
834:                             return _U1MODE_BRGH_MASK;
835:                         case USART_ID_3 :
836:                             return _U3MODE_BRGH_MASK;
837:                         case USART_ID_2 :
838:                             return _U2MODE_BRGH_MASK;
839:                         case USART_ID_4 :
840:                             return _U4MODE_BRGH_MASK;
841:                         case USART_ID_6 :
842:                             return _U6MODE_BRGH_MASK;
843:                         case USART_ID_5 :
844:                             return _U5MODE_BRGH_MASK;
845:                         case USART_NUMBER_OF_MODULES :
846:                         default :
847:                             return (SFR_DATA)-1;
848:                     }
849:                 }
850:                 
851:                 PLIB_INLINE SFR_DATA _USART_RECEIVER_POLARITY_INVERT_MASK(USART_MODULE_ID i)
852:                 {
853:                     switch (i) {
854:                         case USART_ID_1 :
855:                             return _U1MODE_RXINV_MASK;
856:                         case USART_ID_3 :
857:                             return _U3MODE_RXINV_MASK;
858:                         case USART_ID_2 :
859:                             return _U2MODE_RXINV_MASK;
860:                         case USART_ID_4 :
861:                             return _U4MODE_RXINV_MASK;
862:                         case USART_ID_6 :
863:                             return _U6MODE_RXINV_MASK;
864:                         case USART_ID_5 :
865:                             return _U5MODE_RXINV_MASK;
866:                         case USART_NUMBER_OF_MODULES :
867:                         default :
868:                             return (SFR_DATA)-1;
869:                     }
870:                 }
871:                 
872:                 PLIB_INLINE SFR_DATA _USART_BAUD_RATE_AUTO_DETECT_MASK(USART_MODULE_ID i)
873:                 {
874:                     switch (i) {
875:                         case USART_ID_1 :
876:                             return _U1MODE_ABAUD_MASK;
877:                         case USART_ID_3 :
878:                             return _U3MODE_ABAUD_MASK;
879:                         case USART_ID_2 :
880:                             return _U2MODE_ABAUD_MASK;
881:                         case USART_ID_4 :
882:                             return _U4MODE_ABAUD_MASK;
883:                         case USART_ID_6 :
884:                             return _U6MODE_ABAUD_MASK;
885:                         case USART_ID_5 :
886:                             return _U5MODE_ABAUD_MASK;
887:                         case USART_NUMBER_OF_MODULES :
888:                         default :
889:                             return (SFR_DATA)-1;
890:                     }
891:                 }
892:                 
893:                 PLIB_INLINE SFR_DATA _USART_LOOP_BACK_MASK(USART_MODULE_ID i)
894:                 {
895:                     switch (i) {
896:                         case USART_ID_1 :
897:                             return _U1MODE_LPBACK_MASK;
898:                         case USART_ID_3 :
899:                             return _U3MODE_LPBACK_MASK;
900:                         case USART_ID_2 :
901:                             return _U2MODE_LPBACK_MASK;
902:                         case USART_ID_4 :
903:                             return _U4MODE_LPBACK_MASK;
904:                         case USART_ID_6 :
905:                             return _U6MODE_LPBACK_MASK;
906:                         case USART_ID_5 :
907:                             return _U5MODE_LPBACK_MASK;
908:                         case USART_NUMBER_OF_MODULES :
909:                         default :
910:                             return (SFR_DATA)-1;
911:                     }
912:                 }
913:                 
914:                 PLIB_INLINE SFR_DATA _USART_WAKE_ON_START_MASK(USART_MODULE_ID i)
915:                 {
916:                     switch (i) {
917:                         case USART_ID_1 :
918:                             return _U1MODE_WAKE_MASK;
919:                         case USART_ID_3 :
920:                             return _U3MODE_WAKE_MASK;
921:                         case USART_ID_2 :
922:                             return _U2MODE_WAKE_MASK;
923:                         case USART_ID_4 :
924:                             return _U4MODE_WAKE_MASK;
925:                         case USART_ID_6 :
926:                             return _U6MODE_WAKE_MASK;
927:                         case USART_ID_5 :
928:                             return _U5MODE_WAKE_MASK;
929:                         case USART_NUMBER_OF_MODULES :
930:                         default :
931:                             return (SFR_DATA)-1;
932:                     }
933:                 }
934:                 
935:                 PLIB_INLINE SFR_DATA _USART_OPERATION_MODE_MASK(USART_MODULE_ID i)
936:                 {
937:                     switch (i) {
938:                         case USART_ID_1 :
939:                             return _U1MODE_UEN_MASK;
940:                         case USART_ID_3 :
941:                             return _U3MODE_UEN_MASK;
942:                         case USART_ID_2 :
943:                             return _U2MODE_UEN_MASK;
944:                         case USART_ID_4 :
945:                             return (SFR_DATA)-1;
946:                         case USART_ID_6 :
947:                             return (SFR_DATA)-1;
948:                         case USART_ID_5 :
949:                             return (SFR_DATA)-1;
950:                         case USART_NUMBER_OF_MODULES :
951:                         default :
952:                             return (SFR_DATA)-1;
953:                     }
954:                 }
955:                 
956:                 PLIB_INLINE SFR_DATA _USART_HAND_SHAKE_MODE_MASK(USART_MODULE_ID i)
957:                 {
958:                     switch (i) {
959:                         case USART_ID_1 :
960:                             return _U1MODE_RTSMD_MASK;
961:                         case USART_ID_3 :
962:                             return _U3MODE_RTSMD_MASK;
963:                         case USART_ID_2 :
964:                             return _U2MODE_RTSMD_MASK;
965:                         case USART_ID_4 :
966:                             return (SFR_DATA)-1;
967:                         case USART_ID_6 :
968:                             return (SFR_DATA)-1;
969:                         case USART_ID_5 :
970:                             return (SFR_DATA)-1;
971:                         case USART_NUMBER_OF_MODULES :
972:                         default :
973:                             return (SFR_DATA)-1;
974:                     }
975:                 }
976:                 
977:                 PLIB_INLINE SFR_DATA _USART_IRDA_ENABLE_CONTROL_MASK(USART_MODULE_ID i)
978:                 {
979:                     switch (i) {
980:                         case USART_ID_1 :
981:                             return _U1MODE_IREN_MASK;
982:                         case USART_ID_3 :
983:                             return _U3MODE_IREN_MASK;
984:                         case USART_ID_2 :
985:                             return _U2MODE_IREN_MASK;
986:                         case USART_ID_4 :
987:                             return _U4MODE_IREN_MASK;
988:                         case USART_ID_6 :
989:                             return _U6MODE_IREN_MASK;
990:                         case USART_ID_5 :
991:                             return _U5MODE_IREN_MASK;
992:                         case USART_NUMBER_OF_MODULES :
993:                         default :
994:                             return (SFR_DATA)-1;
995:                     }
996:                 }
997:                 
998:                 PLIB_INLINE SFR_DATA _USART_STOP_IN_IDLE_MASK(USART_MODULE_ID i)
999:                 {
1000:                    switch (i) {
1001:                        case USART_ID_1 :
1002:                            return _U1MODE_SIDL_MASK;
1003:                        case USART_ID_3 :
1004:                            return _U3MODE_SIDL_MASK;
1005:                        case USART_ID_2 :
1006:                            return _U2MODE_SIDL_MASK;
1007:                        case USART_ID_4 :
1008:                            return _U4MODE_SIDL_MASK;
1009:                        case USART_ID_6 :
1010:                            return _U6MODE_SIDL_MASK;
1011:                        case USART_ID_5 :
1012:                            return _U5MODE_SIDL_MASK;
1013:                        case USART_NUMBER_OF_MODULES :
1014:                        default :
1015:                            return (SFR_DATA)-1;
1016:                    }
1017:                }
1018:                
1019:                PLIB_INLINE SFR_DATA _USART_ENABLE_CONTROL_MASK(USART_MODULE_ID i)
1020:                {
1021:                    switch (i) {
1022:                        case USART_ID_1 :
1023:                            return _U1MODE_ON_MASK;
1024:                        case USART_ID_3 :
1025:                            return _U3MODE_ON_MASK;
1026:                        case USART_ID_2 :
1027:                            return _U2MODE_ON_MASK;
1028:                        case USART_ID_4 :
1029:                            return _U4MODE_ON_MASK;
1030:                        case USART_ID_6 :
1031:                            return _U6MODE_ON_MASK;
1032:                        case USART_ID_5 :
1033:                            return _U5MODE_ON_MASK;
1034:                        case USART_NUMBER_OF_MODULES :
1035:                        default :
1036:                            return (SFR_DATA)-1;
1037:                    }
1038:                }
1039:                
1040:                PLIB_INLINE SFR_DATA _USART_RECEIVER_DATA_AVAILABLE_MASK(USART_MODULE_ID i)
1041:                {
1042:                    switch (i) {
1043:                        case USART_ID_1 :
1044:                            return _U1STA_URXDA_MASK;
1045:                        case USART_ID_3 :
1046:                            return _U3STA_URXDA_MASK;
1047:                        case USART_ID_2 :
1048:                            return _U2STA_URXDA_MASK;
1049:                        case USART_ID_4 :
1050:                            return _U4STA_URXDA_MASK;
1051:                        case USART_ID_6 :
1052:                            return _U6STA_URXDA_MASK;
1053:                        case USART_ID_5 :
1054:                            return _U5STA_URXDA_MASK;
1055:                        case USART_NUMBER_OF_MODULES :
1056:                        default :
1057:                            return (SFR_DATA)-1;
1058:                    }
1059:                }
1060:                
1061:                PLIB_INLINE SFR_DATA _USART_RECEIVER_OVERRUN_ERROR_MASK(USART_MODULE_ID i)
1062:                {
1063:                    switch (i) {
1064:                        case USART_ID_1 :
1065:                            return _U1STA_OERR_MASK;
1066:                        case USART_ID_3 :
1067:                            return _U3STA_OERR_MASK;
1068:                        case USART_ID_2 :
1069:                            return _U2STA_OERR_MASK;
1070:                        case USART_ID_4 :
1071:                            return _U4STA_OERR_MASK;
1072:                        case USART_ID_6 :
1073:                            return _U6STA_OERR_MASK;
1074:                        case USART_ID_5 :
1075:                            return _U5STA_OERR_MASK;
1076:                        case USART_NUMBER_OF_MODULES :
1077:                        default :
1078:                            return (SFR_DATA)-1;
1079:                    }
1080:                }
1081:                
1082:                PLIB_INLINE SFR_DATA _USART_RECEIVER_FRAMING_ERROR_MASK(USART_MODULE_ID i)
1083:                {
1084:                    switch (i) {
1085:                        case USART_ID_1 :
1086:                            return _U1STA_FERR_MASK;
1087:                        case USART_ID_3 :
1088:                            return _U3STA_FERR_MASK;
1089:                        case USART_ID_2 :
1090:                            return _U2STA_FERR_MASK;
1091:                        case USART_ID_4 :
1092:                            return _U4STA_FERR_MASK;
1093:                        case USART_ID_6 :
1094:                            return _U6STA_FERR_MASK;
1095:                        case USART_ID_5 :
1096:                            return _U5STA_FERR_MASK;
1097:                        case USART_NUMBER_OF_MODULES :
1098:                        default :
1099:                            return (SFR_DATA)-1;
1100:                    }
1101:                }
1102:                
1103:                PLIB_INLINE SFR_DATA _USART_RECEIVER_PARITY_ERROR_MASK(USART_MODULE_ID i)
1104:                {
1105:                    switch (i) {
1106:                        case USART_ID_1 :
1107:                            return _U1STA_PERR_MASK;
1108:                        case USART_ID_3 :
1109:                            return _U3STA_PERR_MASK;
1110:                        case USART_ID_2 :
1111:                            return _U2STA_PERR_MASK;
1112:                        case USART_ID_4 :
1113:                            return _U4STA_PERR_MASK;
1114:                        case USART_ID_6 :
1115:                            return _U6STA_PERR_MASK;
1116:                        case USART_ID_5 :
1117:                            return _U5STA_PERR_MASK;
1118:                        case USART_NUMBER_OF_MODULES :
1119:                        default :
1120:                            return (SFR_DATA)-1;
1121:                    }
1122:                }
1123:                
1124:                PLIB_INLINE SFR_DATA _USART_RECEIVER_IDLE_MASK(USART_MODULE_ID i)
1125:                {
1126:                    switch (i) {
1127:                        case USART_ID_1 :
1128:                            return _U1STA_RIDLE_MASK;
1129:                        case USART_ID_3 :
1130:                            return _U3STA_RIDLE_MASK;
1131:                        case USART_ID_2 :
1132:                            return _U2STA_RIDLE_MASK;
1133:                        case USART_ID_4 :
1134:                            return _U4STA_RIDLE_MASK;
1135:                        case USART_ID_6 :
1136:                            return _U6STA_RIDLE_MASK;
1137:                        case USART_ID_5 :
1138:                            return _U5STA_RIDLE_MASK;
1139:                        case USART_NUMBER_OF_MODULES :
1140:                        default :
1141:                            return (SFR_DATA)-1;
1142:                    }
1143:                }
1144:                
1145:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ADDRESS_DETECT_MASK(USART_MODULE_ID i)
1146:                {
1147:                    switch (i) {
1148:                        case USART_ID_1 :
1149:                            return _U1STA_ADDEN_MASK;
1150:                        case USART_ID_3 :
1151:                            return _U3STA_ADDEN_MASK;
1152:                        case USART_ID_2 :
1153:                            return _U2STA_ADDEN_MASK;
1154:                        case USART_ID_4 :
1155:                            return _U4STA_ADDEN_MASK;
1156:                        case USART_ID_6 :
1157:                            return _U6STA_ADDEN_MASK;
1158:                        case USART_ID_5 :
1159:                            return _U5STA_ADDEN_MASK;
1160:                        case USART_NUMBER_OF_MODULES :
1161:                        default :
1162:                            return (SFR_DATA)-1;
1163:                    }
1164:                }
1165:                
1166:                PLIB_INLINE SFR_DATA _USART_RECEIVER_FIFO_LEVEL_MASK(USART_MODULE_ID i)
1167:                {
1168:                    switch (i) {
1169:                        case USART_ID_1 :
1170:                            return _U1STA_URXISEL_MASK;
1171:                        case USART_ID_3 :
1172:                            return _U3STA_URXISEL_MASK;
1173:                        case USART_ID_2 :
1174:                            return _U2STA_URXISEL_MASK;
1175:                        case USART_ID_4 :
1176:                            return _U4STA_URXISEL_MASK;
1177:                        case USART_ID_6 :
1178:                            return _U6STA_URXISEL_MASK;
1179:                        case USART_ID_5 :
1180:                            return _U5STA_URXISEL_MASK;
1181:                        case USART_NUMBER_OF_MODULES :
1182:                        default :
1183:                            return (SFR_DATA)-1;
1184:                    }
1185:                }
1186:                
1187:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_EMPTY_MASK(USART_MODULE_ID i)
1188:                {
1189:                    switch (i) {
1190:                        case USART_ID_1 :
1191:                            return _U1STA_TRMT_MASK;
1192:                        case USART_ID_3 :
1193:                            return _U3STA_TRMT_MASK;
1194:                        case USART_ID_2 :
1195:                            return _U2STA_TRMT_MASK;
1196:                        case USART_ID_4 :
1197:                            return _U4STA_TRMT_MASK;
1198:                        case USART_ID_6 :
1199:                            return _U6STA_TRMT_MASK;
1200:                        case USART_ID_5 :
1201:                            return _U5STA_TRMT_MASK;
1202:                        case USART_NUMBER_OF_MODULES :
1203:                        default :
1204:                            return (SFR_DATA)-1;
1205:                    }
1206:                }
1207:                
1208:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_BUFFER_FULL_MASK(USART_MODULE_ID i)
1209:                {
1210:                    switch (i) {
1211:                        case USART_ID_1 :
1212:                            return _U1STA_UTXBF_MASK;
1213:                        case USART_ID_3 :
1214:                            return _U3STA_UTXBF_MASK;
1215:                        case USART_ID_2 :
1216:                            return _U2STA_UTXBF_MASK;
1217:                        case USART_ID_4 :
1218:                            return _U4STA_UTXBF_MASK;
1219:                        case USART_ID_6 :
1220:                            return _U6STA_UTXBF_MASK;
1221:                        case USART_ID_5 :
1222:                            return _U5STA_UTXBF_MASK;
1223:                        case USART_NUMBER_OF_MODULES :
1224:                        default :
1225:                            return (SFR_DATA)-1;
1226:                    }
1227:                }
1228:                
1229:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_ENABLE_CONTROL_MASK(USART_MODULE_ID i)
1230:                {
1231:                    switch (i) {
1232:                        case USART_ID_1 :
1233:                            return _U1STA_UTXEN_MASK;
1234:                        case USART_ID_3 :
1235:                            return _U3STA_UTXEN_MASK;
1236:                        case USART_ID_2 :
1237:                            return _U2STA_UTXEN_MASK;
1238:                        case USART_ID_4 :
1239:                            return _U4STA_UTXEN_MASK;
1240:                        case USART_ID_6 :
1241:                            return _U6STA_UTXEN_MASK;
1242:                        case USART_ID_5 :
1243:                            return _U5STA_UTXEN_MASK;
1244:                        case USART_NUMBER_OF_MODULES :
1245:                        default :
1246:                            return (SFR_DATA)-1;
1247:                    }
1248:                }
1249:                
1250:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_BREAK_SEND_MASK(USART_MODULE_ID i)
1251:                {
1252:                    switch (i) {
1253:                        case USART_ID_1 :
1254:                            return _U1STA_UTXBRK_MASK;
1255:                        case USART_ID_3 :
1256:                            return _U3STA_UTXBRK_MASK;
1257:                        case USART_ID_2 :
1258:                            return _U2STA_UTXBRK_MASK;
1259:                        case USART_ID_4 :
1260:                            return _U4STA_UTXBRK_MASK;
1261:                        case USART_ID_6 :
1262:                            return _U6STA_UTXBRK_MASK;
1263:                        case USART_ID_5 :
1264:                            return _U5STA_UTXBRK_MASK;
1265:                        case USART_NUMBER_OF_MODULES :
1266:                        default :
1267:                            return (SFR_DATA)-1;
1268:                    }
1269:                }
1270:                
1271:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ENABLE_MASK(USART_MODULE_ID i)
1272:                {
1273:                    switch (i) {
1274:                        case USART_ID_1 :
1275:                            return _U1STA_URXEN_MASK;
1276:                        case USART_ID_3 :
1277:                            return _U3STA_URXEN_MASK;
1278:                        case USART_ID_2 :
1279:                            return _U2STA_URXEN_MASK;
1280:                        case USART_ID_4 :
1281:                            return _U4STA_URXEN_MASK;
1282:                        case USART_ID_6 :
1283:                            return _U6STA_URXEN_MASK;
1284:                        case USART_ID_5 :
1285:                            return _U5STA_URXEN_MASK;
1286:                        case USART_NUMBER_OF_MODULES :
1287:                        default :
1288:                            return (SFR_DATA)-1;
1289:                    }
1290:                }
1291:                
1292:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_IDLE_IS_LOW32_MASK(USART_MODULE_ID i)
1293:                {
1294:                    switch (i) {
1295:                        case USART_ID_1 :
1296:                            return _U1STA_UTXINV_MASK;
1297:                        case USART_ID_3 :
1298:                            return _U3STA_UTXINV_MASK;
1299:                        case USART_ID_2 :
1300:                            return _U2STA_UTXINV_MASK;
1301:                        case USART_ID_4 :
1302:                            return _U4STA_UTXINV_MASK;
1303:                        case USART_ID_6 :
1304:                            return _U6STA_UTXINV_MASK;
1305:                        case USART_ID_5 :
1306:                            return _U5STA_UTXINV_MASK;
1307:                        case USART_NUMBER_OF_MODULES :
1308:                        default :
1309:                            return (SFR_DATA)-1;
1310:                    }
1311:                }
1312:                
1313:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_INTR_MODE_SELECT_MASK(USART_MODULE_ID i)
1314:                {
1315:                    switch (i) {
1316:                        case USART_ID_1 :
1317:                            return _U1STA_UTXISEL_MASK;
1318:                        case USART_ID_3 :
1319:                            return _U3STA_UTXISEL_MASK;
1320:                        case USART_ID_2 :
1321:                            return _U2STA_UTXISEL_MASK;
1322:                        case USART_ID_4 :
1323:                            return _U4STA_UTXISEL_MASK;
1324:                        case USART_ID_6 :
1325:                            return _U6STA_UTXISEL_MASK;
1326:                        case USART_ID_5 :
1327:                            return _U5STA_UTXISEL_MASK;
1328:                        case USART_NUMBER_OF_MODULES :
1329:                        default :
1330:                            return (SFR_DATA)-1;
1331:                    }
1332:                }
1333:                
1334:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ADDRESS_AUTO_DETECT_MASK(USART_MODULE_ID i)
1335:                {
1336:                    switch (i) {
1337:                        case USART_ID_1 :
1338:                            return _U1STA_ADDR_MASK;
1339:                        case USART_ID_3 :
1340:                            return _U3STA_ADDR_MASK;
1341:                        case USART_ID_2 :
1342:                            return _U2STA_ADDR_MASK;
1343:                        case USART_ID_4 :
1344:                            return _U4STA_ADDR_MASK;
1345:                        case USART_ID_6 :
1346:                            return _U6STA_ADDR_MASK;
1347:                        case USART_ID_5 :
1348:                            return _U5STA_ADDR_MASK;
1349:                        case USART_NUMBER_OF_MODULES :
1350:                        default :
1351:                            return (SFR_DATA)-1;
1352:                    }
1353:                }
1354:                
1355:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_MASK(USART_MODULE_ID i)
1356:                {
1357:                    switch (i) {
1358:                        case USART_ID_1 :
1359:                            return _U1STA_ADM_EN_MASK;
1360:                        case USART_ID_3 :
1361:                            return _U3STA_ADM_EN_MASK;
1362:                        case USART_ID_2 :
1363:                            return _U2STA_ADM_EN_MASK;
1364:                        case USART_ID_4 :
1365:                            return _U4STA_ADM_EN_MASK;
1366:                        case USART_ID_6 :
1367:                            return _U6STA_ADM_EN_MASK;
1368:                        case USART_ID_5 :
1369:                            return _U5STA_ADM_EN_MASK;
1370:                        case USART_NUMBER_OF_MODULES :
1371:                        default :
1372:                            return (SFR_DATA)-1;
1373:                    }
1374:                }
1375:                
1376:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_SEND_MASK(USART_MODULE_ID i)
1377:                {
1378:                    switch (i) {
1379:                        case USART_ID_1 :
1380:                            return (SFR_DATA)-1;
1381:                        case USART_ID_3 :
1382:                            return (SFR_DATA)-1;
1383:                        case USART_ID_2 :
1384:                            return (SFR_DATA)-1;
1385:                        case USART_ID_4 :
1386:                            return (SFR_DATA)-1;
1387:                        case USART_ID_6 :
1388:                            return (SFR_DATA)-1;
1389:                        case USART_ID_5 :
1390:                            return (SFR_DATA)-1;
1391:                        case USART_NUMBER_OF_MODULES :
1392:                        default :
1393:                            return (SFR_DATA)-1;
1394:                    }
1395:                }
1396:                
1397:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_DATA_ONLY_MASK(USART_MODULE_ID i)
1398:                {
1399:                    switch (i) {
1400:                        case USART_ID_1 :
1401:                            return (SFR_DATA)-1;
1402:                        case USART_ID_3 :
1403:                            return (SFR_DATA)-1;
1404:                        case USART_ID_2 :
1405:                            return (SFR_DATA)-1;
1406:                        case USART_ID_4 :
1407:                            return (SFR_DATA)-1;
1408:                        case USART_ID_6 :
1409:                            return (SFR_DATA)-1;
1410:                        case USART_ID_5 :
1411:                            return (SFR_DATA)-1;
1412:                        case USART_NUMBER_OF_MODULES :
1413:                        default :
1414:                            return (SFR_DATA)-1;
1415:                    }
1416:                }
1417:                
1418:                PLIB_INLINE SFR_DATA _USART_RECEIVER_DATA_MASK(USART_MODULE_ID i)
1419:                {
1420:                    switch (i) {
1421:                        case USART_ID_1 :
1422:                            return (SFR_DATA)-1;
1423:                        case USART_ID_3 :
1424:                            return (SFR_DATA)-1;
1425:                        case USART_ID_2 :
1426:                            return (SFR_DATA)-1;
1427:                        case USART_ID_4 :
1428:                            return (SFR_DATA)-1;
1429:                        case USART_ID_6 :
1430:                            return (SFR_DATA)-1;
1431:                        case USART_ID_5 :
1432:                            return (SFR_DATA)-1;
1433:                        case USART_NUMBER_OF_MODULES :
1434:                        default :
1435:                            return (SFR_DATA)-1;
1436:                    }
1437:                }
1438:                
1439:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_HIGH_16_MASK(USART_MODULE_ID i)
1440:                {
1441:                    switch (i) {
1442:                        case USART_ID_1 :
1443:                            return (SFR_DATA)-1;
1444:                        case USART_ID_3 :
1445:                            return (SFR_DATA)-1;
1446:                        case USART_ID_2 :
1447:                            return (SFR_DATA)-1;
1448:                        case USART_ID_4 :
1449:                            return (SFR_DATA)-1;
1450:                        case USART_ID_6 :
1451:                            return (SFR_DATA)-1;
1452:                        case USART_ID_5 :
1453:                            return (SFR_DATA)-1;
1454:                        case USART_NUMBER_OF_MODULES :
1455:                        default :
1456:                            return (SFR_DATA)-1;
1457:                    }
1458:                }
1459:                
1460:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_MASK(USART_MODULE_ID i)
1461:                {
1462:                    switch (i) {
1463:                        case USART_ID_1 :
1464:                            return (SFR_DATA)-1;
1465:                        case USART_ID_3 :
1466:                            return (SFR_DATA)-1;
1467:                        case USART_ID_2 :
1468:                            return (SFR_DATA)-1;
1469:                        case USART_ID_4 :
1470:                            return (SFR_DATA)-1;
1471:                        case USART_ID_6 :
1472:                            return (SFR_DATA)-1;
1473:                        case USART_ID_5 :
1474:                            return (SFR_DATA)-1;
1475:                        case USART_NUMBER_OF_MODULES :
1476:                        default :
1477:                            return (SFR_DATA)-1;
1478:                    }
1479:                }
1480:                
1481:                PLIB_INLINE SFR_DATA _USART_LINE_CONTROL_MODE_STOP_POS(USART_MODULE_ID i)
1482:                {
1483:                    switch (i) {
1484:                        case USART_ID_1 :
1485:                            return _U1MODE_STSEL_POSITION;
1486:                        case USART_ID_3 :
1487:                            return _U3MODE_STSEL_POSITION;
1488:                        case USART_ID_2 :
1489:                            return _U2MODE_STSEL_POSITION;
1490:                        case USART_ID_4 :
1491:                            return _U4MODE_STSEL_POSITION;
1492:                        case USART_ID_6 :
1493:                            return _U6MODE_STSEL_POSITION;
1494:                        case USART_ID_5 :
1495:                            return _U5MODE_STSEL_POSITION;
1496:                        case USART_NUMBER_OF_MODULES :
1497:                        default :
1498:                            return (SFR_DATA)-1;
1499:                    }
1500:                }
1501:                
1502:                PLIB_INLINE SFR_DATA _USART_LINE_CONTROL_MODE_DATA_POS(USART_MODULE_ID i)
1503:                {
1504:                    switch (i) {
1505:                        case USART_ID_1 :
1506:                            return _U1MODE_PDSEL_POSITION;
1507:                        case USART_ID_3 :
1508:                            return _U3MODE_PDSEL_POSITION;
1509:                        case USART_ID_2 :
1510:                            return _U2MODE_PDSEL_POSITION;
1511:                        case USART_ID_4 :
1512:                            return _U4MODE_PDSEL_POSITION;
1513:                        case USART_ID_6 :
1514:                            return _U6MODE_PDSEL_POSITION;
1515:                        case USART_ID_5 :
1516:                            return _U5MODE_PDSEL_POSITION;
1517:                        case USART_NUMBER_OF_MODULES :
1518:                        default :
1519:                            return (SFR_DATA)-1;
1520:                    }
1521:                }
1522:                
1523:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_HIGH_ENABLE_16_POS(USART_MODULE_ID i)
1524:                {
1525:                    switch (i) {
1526:                        case USART_ID_1 :
1527:                            return _U1MODE_BRGH_POSITION;
1528:                        case USART_ID_3 :
1529:                            return _U3MODE_BRGH_POSITION;
1530:                        case USART_ID_2 :
1531:                            return _U2MODE_BRGH_POSITION;
1532:                        case USART_ID_4 :
1533:                            return _U4MODE_BRGH_POSITION;
1534:                        case USART_ID_6 :
1535:                            return _U6MODE_BRGH_POSITION;
1536:                        case USART_ID_5 :
1537:                            return _U5MODE_BRGH_POSITION;
1538:                        case USART_NUMBER_OF_MODULES :
1539:                        default :
1540:                            return (SFR_DATA)-1;
1541:                    }
1542:                }
1543:                
1544:                PLIB_INLINE SFR_DATA _USART_RECEIVER_POLARITY_INVERT_POS(USART_MODULE_ID i)
1545:                {
1546:                    switch (i) {
1547:                        case USART_ID_1 :
1548:                            return _U1MODE_RXINV_POSITION;
1549:                        case USART_ID_3 :
1550:                            return _U3MODE_RXINV_POSITION;
1551:                        case USART_ID_2 :
1552:                            return _U2MODE_RXINV_POSITION;
1553:                        case USART_ID_4 :
1554:                            return _U4MODE_RXINV_POSITION;
1555:                        case USART_ID_6 :
1556:                            return _U6MODE_RXINV_POSITION;
1557:                        case USART_ID_5 :
1558:                            return _U5MODE_RXINV_POSITION;
1559:                        case USART_NUMBER_OF_MODULES :
1560:                        default :
1561:                            return (SFR_DATA)-1;
1562:                    }
1563:                }
1564:                
1565:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_AUTO_DETECT_POS(USART_MODULE_ID i)
1566:                {
1567:                    switch (i) {
1568:                        case USART_ID_1 :
1569:                            return _U1MODE_ABAUD_POSITION;
1570:                        case USART_ID_3 :
1571:                            return _U3MODE_ABAUD_POSITION;
1572:                        case USART_ID_2 :
1573:                            return _U2MODE_ABAUD_POSITION;
1574:                        case USART_ID_4 :
1575:                            return _U4MODE_ABAUD_POSITION;
1576:                        case USART_ID_6 :
1577:                            return _U6MODE_ABAUD_POSITION;
1578:                        case USART_ID_5 :
1579:                            return _U5MODE_ABAUD_POSITION;
1580:                        case USART_NUMBER_OF_MODULES :
1581:                        default :
1582:                            return (SFR_DATA)-1;
1583:                    }
1584:                }
1585:                
1586:                PLIB_INLINE SFR_DATA _USART_LOOP_BACK_POS(USART_MODULE_ID i)
1587:                {
1588:                    switch (i) {
1589:                        case USART_ID_1 :
1590:                            return _U1MODE_LPBACK_POSITION;
1591:                        case USART_ID_3 :
1592:                            return _U3MODE_LPBACK_POSITION;
1593:                        case USART_ID_2 :
1594:                            return _U2MODE_LPBACK_POSITION;
1595:                        case USART_ID_4 :
1596:                            return _U4MODE_LPBACK_POSITION;
1597:                        case USART_ID_6 :
1598:                            return _U6MODE_LPBACK_POSITION;
1599:                        case USART_ID_5 :
1600:                            return _U5MODE_LPBACK_POSITION;
1601:                        case USART_NUMBER_OF_MODULES :
1602:                        default :
1603:                            return (SFR_DATA)-1;
1604:                    }
1605:                }
1606:                
1607:                PLIB_INLINE SFR_DATA _USART_WAKE_ON_START_POS(USART_MODULE_ID i)
1608:                {
1609:                    switch (i) {
1610:                        case USART_ID_1 :
1611:                            return _U1MODE_WAKE_POSITION;
1612:                        case USART_ID_3 :
1613:                            return _U3MODE_WAKE_POSITION;
1614:                        case USART_ID_2 :
1615:                            return _U2MODE_WAKE_POSITION;
1616:                        case USART_ID_4 :
1617:                            return _U4MODE_WAKE_POSITION;
1618:                        case USART_ID_6 :
1619:                            return _U6MODE_WAKE_POSITION;
1620:                        case USART_ID_5 :
1621:                            return _U5MODE_WAKE_POSITION;
1622:                        case USART_NUMBER_OF_MODULES :
1623:                        default :
1624:                            return (SFR_DATA)-1;
1625:                    }
1626:                }
1627:                
1628:                PLIB_INLINE SFR_DATA _USART_OPERATION_MODE_POS(USART_MODULE_ID i)
1629:                {
1630:                    switch (i) {
1631:                        case USART_ID_1 :
1632:                            return _U1MODE_UEN_POSITION;
1633:                        case USART_ID_3 :
1634:                            return _U3MODE_UEN_POSITION;
1635:                        case USART_ID_2 :
1636:                            return _U2MODE_UEN_POSITION;
1637:                        case USART_ID_4 :
1638:                            return (SFR_DATA)-1;
1639:                        case USART_ID_6 :
1640:                            return (SFR_DATA)-1;
1641:                        case USART_ID_5 :
1642:                            return (SFR_DATA)-1;
1643:                        case USART_NUMBER_OF_MODULES :
1644:                        default :
1645:                            return (SFR_DATA)-1;
1646:                    }
1647:                }
1648:                
1649:                PLIB_INLINE SFR_DATA _USART_HAND_SHAKE_MODE_POS(USART_MODULE_ID i)
1650:                {
1651:                    switch (i) {
1652:                        case USART_ID_1 :
1653:                            return _U1MODE_RTSMD_POSITION;
1654:                        case USART_ID_3 :
1655:                            return _U3MODE_RTSMD_POSITION;
1656:                        case USART_ID_2 :
1657:                            return _U2MODE_RTSMD_POSITION;
1658:                        case USART_ID_4 :
1659:                            return (SFR_DATA)-1;
1660:                        case USART_ID_6 :
1661:                            return (SFR_DATA)-1;
1662:                        case USART_ID_5 :
1663:                            return (SFR_DATA)-1;
1664:                        case USART_NUMBER_OF_MODULES :
1665:                        default :
1666:                            return (SFR_DATA)-1;
1667:                    }
1668:                }
1669:                
1670:                PLIB_INLINE SFR_DATA _USART_IRDA_ENABLE_CONTROL_POS(USART_MODULE_ID i)
1671:                {
1672:                    switch (i) {
1673:                        case USART_ID_1 :
1674:                            return _U1MODE_IREN_POSITION;
1675:                        case USART_ID_3 :
1676:                            return _U3MODE_IREN_POSITION;
1677:                        case USART_ID_2 :
1678:                            return _U2MODE_IREN_POSITION;
1679:                        case USART_ID_4 :
1680:                            return _U4MODE_IREN_POSITION;
1681:                        case USART_ID_6 :
1682:                            return _U6MODE_IREN_POSITION;
1683:                        case USART_ID_5 :
1684:                            return _U5MODE_IREN_POSITION;
1685:                        case USART_NUMBER_OF_MODULES :
1686:                        default :
1687:                            return (SFR_DATA)-1;
1688:                    }
1689:                }
1690:                
1691:                PLIB_INLINE SFR_DATA _USART_STOP_IN_IDLE_POS(USART_MODULE_ID i)
1692:                {
1693:                    switch (i) {
1694:                        case USART_ID_1 :
1695:                            return _U1MODE_SIDL_POSITION;
1696:                        case USART_ID_3 :
1697:                            return _U3MODE_SIDL_POSITION;
1698:                        case USART_ID_2 :
1699:                            return _U2MODE_SIDL_POSITION;
1700:                        case USART_ID_4 :
1701:                            return _U4MODE_SIDL_POSITION;
1702:                        case USART_ID_6 :
1703:                            return _U6MODE_SIDL_POSITION;
1704:                        case USART_ID_5 :
1705:                            return _U5MODE_SIDL_POSITION;
1706:                        case USART_NUMBER_OF_MODULES :
1707:                        default :
1708:                            return (SFR_DATA)-1;
1709:                    }
1710:                }
1711:                
1712:                PLIB_INLINE SFR_DATA _USART_ENABLE_CONTROL_POS(USART_MODULE_ID i)
1713:                {
1714:                    switch (i) {
1715:                        case USART_ID_1 :
1716:                            return _U1MODE_ON_POSITION;
1717:                        case USART_ID_3 :
1718:                            return _U3MODE_ON_POSITION;
1719:                        case USART_ID_2 :
1720:                            return _U2MODE_ON_POSITION;
1721:                        case USART_ID_4 :
1722:                            return _U4MODE_ON_POSITION;
1723:                        case USART_ID_6 :
1724:                            return _U6MODE_ON_POSITION;
1725:                        case USART_ID_5 :
1726:                            return _U5MODE_ON_POSITION;
1727:                        case USART_NUMBER_OF_MODULES :
1728:                        default :
1729:                            return (SFR_DATA)-1;
1730:                    }
1731:                }
1732:                
1733:                PLIB_INLINE SFR_DATA _USART_RECEIVER_DATA_AVAILABLE_POS(USART_MODULE_ID i)
1734:                {
1735:                    switch (i) {
1736:                        case USART_ID_1 :
1737:                            return _U1STA_URXDA_POSITION;
1738:                        case USART_ID_3 :
1739:                            return _U3STA_URXDA_POSITION;
1740:                        case USART_ID_2 :
1741:                            return _U2STA_URXDA_POSITION;
1742:                        case USART_ID_4 :
1743:                            return _U4STA_URXDA_POSITION;
1744:                        case USART_ID_6 :
1745:                            return _U6STA_URXDA_POSITION;
1746:                        case USART_ID_5 :
1747:                            return _U5STA_URXDA_POSITION;
1748:                        case USART_NUMBER_OF_MODULES :
1749:                        default :
1750:                            return (SFR_DATA)-1;
1751:                    }
1752:                }
1753:                
1754:                PLIB_INLINE SFR_DATA _USART_RECEIVER_OVERRUN_ERROR_POS(USART_MODULE_ID i)
1755:                {
1756:                    switch (i) {
1757:                        case USART_ID_1 :
1758:                            return _U1STA_OERR_POSITION;
1759:                        case USART_ID_3 :
1760:                            return _U3STA_OERR_POSITION;
1761:                        case USART_ID_2 :
1762:                            return _U2STA_OERR_POSITION;
1763:                        case USART_ID_4 :
1764:                            return _U4STA_OERR_POSITION;
1765:                        case USART_ID_6 :
1766:                            return _U6STA_OERR_POSITION;
1767:                        case USART_ID_5 :
1768:                            return _U5STA_OERR_POSITION;
1769:                        case USART_NUMBER_OF_MODULES :
1770:                        default :
1771:                            return (SFR_DATA)-1;
1772:                    }
1773:                }
1774:                
1775:                PLIB_INLINE SFR_DATA _USART_RECEIVER_FRAMING_ERROR_POS(USART_MODULE_ID i)
1776:                {
1777:                    switch (i) {
1778:                        case USART_ID_1 :
1779:                            return _U1STA_FERR_POSITION;
1780:                        case USART_ID_3 :
1781:                            return _U3STA_FERR_POSITION;
1782:                        case USART_ID_2 :
1783:                            return _U2STA_FERR_POSITION;
1784:                        case USART_ID_4 :
1785:                            return _U4STA_FERR_POSITION;
1786:                        case USART_ID_6 :
1787:                            return _U6STA_FERR_POSITION;
1788:                        case USART_ID_5 :
1789:                            return _U5STA_FERR_POSITION;
1790:                        case USART_NUMBER_OF_MODULES :
1791:                        default :
1792:                            return (SFR_DATA)-1;
1793:                    }
1794:                }
1795:                
1796:                PLIB_INLINE SFR_DATA _USART_RECEIVER_PARITY_ERROR_POS(USART_MODULE_ID i)
1797:                {
1798:                    switch (i) {
1799:                        case USART_ID_1 :
1800:                            return _U1STA_PERR_POSITION;
1801:                        case USART_ID_3 :
1802:                            return _U3STA_PERR_POSITION;
1803:                        case USART_ID_2 :
1804:                            return _U2STA_PERR_POSITION;
1805:                        case USART_ID_4 :
1806:                            return _U4STA_PERR_POSITION;
1807:                        case USART_ID_6 :
1808:                            return _U6STA_PERR_POSITION;
1809:                        case USART_ID_5 :
1810:                            return _U5STA_PERR_POSITION;
1811:                        case USART_NUMBER_OF_MODULES :
1812:                        default :
1813:                            return (SFR_DATA)-1;
1814:                    }
1815:                }
1816:                
1817:                PLIB_INLINE SFR_DATA _USART_RECEIVER_IDLE_POS(USART_MODULE_ID i)
1818:                {
1819:                    switch (i) {
1820:                        case USART_ID_1 :
1821:                            return _U1STA_RIDLE_POSITION;
1822:                        case USART_ID_3 :
1823:                            return _U3STA_RIDLE_POSITION;
1824:                        case USART_ID_2 :
1825:                            return _U2STA_RIDLE_POSITION;
1826:                        case USART_ID_4 :
1827:                            return _U4STA_RIDLE_POSITION;
1828:                        case USART_ID_6 :
1829:                            return _U6STA_RIDLE_POSITION;
1830:                        case USART_ID_5 :
1831:                            return _U5STA_RIDLE_POSITION;
1832:                        case USART_NUMBER_OF_MODULES :
1833:                        default :
1834:                            return (SFR_DATA)-1;
1835:                    }
1836:                }
1837:                
1838:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ADDRESS_DETECT_POS(USART_MODULE_ID i)
1839:                {
1840:                    switch (i) {
1841:                        case USART_ID_1 :
1842:                            return _U1STA_ADDEN_POSITION;
1843:                        case USART_ID_3 :
1844:                            return _U3STA_ADDEN_POSITION;
1845:                        case USART_ID_2 :
1846:                            return _U2STA_ADDEN_POSITION;
1847:                        case USART_ID_4 :
1848:                            return _U4STA_ADDEN_POSITION;
1849:                        case USART_ID_6 :
1850:                            return _U6STA_ADDEN_POSITION;
1851:                        case USART_ID_5 :
1852:                            return _U5STA_ADDEN_POSITION;
1853:                        case USART_NUMBER_OF_MODULES :
1854:                        default :
1855:                            return (SFR_DATA)-1;
1856:                    }
1857:                }
1858:                
1859:                PLIB_INLINE SFR_DATA _USART_RECEIVER_FIFO_LEVEL_POS(USART_MODULE_ID i)
1860:                {
1861:                    switch (i) {
1862:                        case USART_ID_1 :
1863:                            return _U1STA_URXISEL_POSITION;
1864:                        case USART_ID_3 :
1865:                            return _U3STA_URXISEL_POSITION;
1866:                        case USART_ID_2 :
1867:                            return _U2STA_URXISEL_POSITION;
1868:                        case USART_ID_4 :
1869:                            return _U4STA_URXISEL_POSITION;
1870:                        case USART_ID_6 :
1871:                            return _U6STA_URXISEL_POSITION;
1872:                        case USART_ID_5 :
1873:                            return _U5STA_URXISEL_POSITION;
1874:                        case USART_NUMBER_OF_MODULES :
1875:                        default :
1876:                            return (SFR_DATA)-1;
1877:                    }
1878:                }
1879:                
1880:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_EMPTY_POS(USART_MODULE_ID i)
1881:                {
1882:                    switch (i) {
1883:                        case USART_ID_1 :
1884:                            return _U1STA_TRMT_POSITION;
1885:                        case USART_ID_3 :
1886:                            return _U3STA_TRMT_POSITION;
1887:                        case USART_ID_2 :
1888:                            return _U2STA_TRMT_POSITION;
1889:                        case USART_ID_4 :
1890:                            return _U4STA_TRMT_POSITION;
1891:                        case USART_ID_6 :
1892:                            return _U6STA_TRMT_POSITION;
1893:                        case USART_ID_5 :
1894:                            return _U5STA_TRMT_POSITION;
1895:                        case USART_NUMBER_OF_MODULES :
1896:                        default :
1897:                            return (SFR_DATA)-1;
1898:                    }
1899:                }
1900:                
1901:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_BUFFER_FULL_POS(USART_MODULE_ID i)
1902:                {
1903:                    switch (i) {
1904:                        case USART_ID_1 :
1905:                            return _U1STA_UTXBF_POSITION;
1906:                        case USART_ID_3 :
1907:                            return _U3STA_UTXBF_POSITION;
1908:                        case USART_ID_2 :
1909:                            return _U2STA_UTXBF_POSITION;
1910:                        case USART_ID_4 :
1911:                            return _U4STA_UTXBF_POSITION;
1912:                        case USART_ID_6 :
1913:                            return _U6STA_UTXBF_POSITION;
1914:                        case USART_ID_5 :
1915:                            return _U5STA_UTXBF_POSITION;
1916:                        case USART_NUMBER_OF_MODULES :
1917:                        default :
1918:                            return (SFR_DATA)-1;
1919:                    }
1920:                }
1921:                
1922:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_ENABLE_CONTROL_POS(USART_MODULE_ID i)
1923:                {
1924:                    switch (i) {
1925:                        case USART_ID_1 :
1926:                            return _U1STA_UTXEN_POSITION;
1927:                        case USART_ID_3 :
1928:                            return _U3STA_UTXEN_POSITION;
1929:                        case USART_ID_2 :
1930:                            return _U2STA_UTXEN_POSITION;
1931:                        case USART_ID_4 :
1932:                            return _U4STA_UTXEN_POSITION;
1933:                        case USART_ID_6 :
1934:                            return _U6STA_UTXEN_POSITION;
1935:                        case USART_ID_5 :
1936:                            return _U5STA_UTXEN_POSITION;
1937:                        case USART_NUMBER_OF_MODULES :
1938:                        default :
1939:                            return (SFR_DATA)-1;
1940:                    }
1941:                }
1942:                
1943:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_BREAK_SEND_POS(USART_MODULE_ID i)
1944:                {
1945:                    switch (i) {
1946:                        case USART_ID_1 :
1947:                            return _U1STA_UTXBRK_POSITION;
1948:                        case USART_ID_3 :
1949:                            return _U3STA_UTXBRK_POSITION;
1950:                        case USART_ID_2 :
1951:                            return _U2STA_UTXBRK_POSITION;
1952:                        case USART_ID_4 :
1953:                            return _U4STA_UTXBRK_POSITION;
1954:                        case USART_ID_6 :
1955:                            return _U6STA_UTXBRK_POSITION;
1956:                        case USART_ID_5 :
1957:                            return _U5STA_UTXBRK_POSITION;
1958:                        case USART_NUMBER_OF_MODULES :
1959:                        default :
1960:                            return (SFR_DATA)-1;
1961:                    }
1962:                }
1963:                
1964:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ENABLE_POS(USART_MODULE_ID i)
1965:                {
1966:                    switch (i) {
1967:                        case USART_ID_1 :
1968:                            return _U1STA_URXEN_POSITION;
1969:                        case USART_ID_3 :
1970:                            return _U3STA_URXEN_POSITION;
1971:                        case USART_ID_2 :
1972:                            return _U2STA_URXEN_POSITION;
1973:                        case USART_ID_4 :
1974:                            return _U4STA_URXEN_POSITION;
1975:                        case USART_ID_6 :
1976:                            return _U6STA_URXEN_POSITION;
1977:                        case USART_ID_5 :
1978:                            return _U5STA_URXEN_POSITION;
1979:                        case USART_NUMBER_OF_MODULES :
1980:                        default :
1981:                            return (SFR_DATA)-1;
1982:                    }
1983:                }
1984:                
1985:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_IDLE_IS_LOW32_POS(USART_MODULE_ID i)
1986:                {
1987:                    switch (i) {
1988:                        case USART_ID_1 :
1989:                            return _U1STA_UTXINV_POSITION;
1990:                        case USART_ID_3 :
1991:                            return _U3STA_UTXINV_POSITION;
1992:                        case USART_ID_2 :
1993:                            return _U2STA_UTXINV_POSITION;
1994:                        case USART_ID_4 :
1995:                            return _U4STA_UTXINV_POSITION;
1996:                        case USART_ID_6 :
1997:                            return _U6STA_UTXINV_POSITION;
1998:                        case USART_ID_5 :
1999:                            return _U5STA_UTXINV_POSITION;
2000:                        case USART_NUMBER_OF_MODULES :
2001:                        default :
2002:                            return (SFR_DATA)-1;
2003:                    }
2004:                }
2005:                
2006:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_INTR_MODE_SELECT_POS(USART_MODULE_ID i)
2007:                {
2008:                    switch (i) {
2009:                        case USART_ID_1 :
2010:                            return _U1STA_UTXISEL_POSITION;
2011:                        case USART_ID_3 :
2012:                            return _U3STA_UTXISEL_POSITION;
2013:                        case USART_ID_2 :
2014:                            return _U2STA_UTXISEL_POSITION;
2015:                        case USART_ID_4 :
2016:                            return _U4STA_UTXISEL_POSITION;
2017:                        case USART_ID_6 :
2018:                            return _U6STA_UTXISEL_POSITION;
2019:                        case USART_ID_5 :
2020:                            return _U5STA_UTXISEL_POSITION;
2021:                        case USART_NUMBER_OF_MODULES :
2022:                        default :
2023:                            return (SFR_DATA)-1;
2024:                    }
2025:                }
2026:                
2027:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ADDRESS_AUTO_DETECT_POS(USART_MODULE_ID i)
2028:                {
2029:                    switch (i) {
2030:                        case USART_ID_1 :
2031:                            return _U1STA_ADDR_POSITION;
2032:                        case USART_ID_3 :
2033:                            return _U3STA_ADDR_POSITION;
2034:                        case USART_ID_2 :
2035:                            return _U2STA_ADDR_POSITION;
2036:                        case USART_ID_4 :
2037:                            return _U4STA_ADDR_POSITION;
2038:                        case USART_ID_6 :
2039:                            return _U6STA_ADDR_POSITION;
2040:                        case USART_ID_5 :
2041:                            return _U5STA_ADDR_POSITION;
2042:                        case USART_NUMBER_OF_MODULES :
2043:                        default :
2044:                            return (SFR_DATA)-1;
2045:                    }
2046:                }
2047:                
2048:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_POS(USART_MODULE_ID i)
2049:                {
2050:                    switch (i) {
2051:                        case USART_ID_1 :
2052:                            return _U1STA_ADM_EN_POSITION;
2053:                        case USART_ID_3 :
2054:                            return _U3STA_ADM_EN_POSITION;
2055:                        case USART_ID_2 :
2056:                            return _U2STA_ADM_EN_POSITION;
2057:                        case USART_ID_4 :
2058:                            return _U4STA_ADM_EN_POSITION;
2059:                        case USART_ID_6 :
2060:                            return _U6STA_ADM_EN_POSITION;
2061:                        case USART_ID_5 :
2062:                            return _U5STA_ADM_EN_POSITION;
2063:                        case USART_NUMBER_OF_MODULES :
2064:                        default :
2065:                            return (SFR_DATA)-1;
2066:                    }
2067:                }
2068:                
2069:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_SEND_POS(USART_MODULE_ID i)
2070:                {
2071:                    switch (i) {
2072:                        case USART_ID_1 :
2073:                            return (SFR_DATA)0;
2074:                        case USART_ID_3 :
2075:                            return (SFR_DATA)0;
2076:                        case USART_ID_2 :
2077:                            return (SFR_DATA)0;
2078:                        case USART_ID_4 :
2079:                            return (SFR_DATA)0;
2080:                        case USART_ID_6 :
2081:                            return (SFR_DATA)0;
2082:                        case USART_ID_5 :
2083:                            return (SFR_DATA)0;
2084:                        case USART_NUMBER_OF_MODULES :
2085:                        default :
2086:                            return (SFR_DATA)-1;
2087:                    }
2088:                }
2089:                
2090:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_DATA_ONLY_POS(USART_MODULE_ID i)
2091:                {
2092:                    switch (i) {
2093:                        case USART_ID_1 :
2094:                            return (SFR_DATA)0;
2095:                        case USART_ID_3 :
2096:                            return (SFR_DATA)0;
2097:                        case USART_ID_2 :
2098:                            return (SFR_DATA)0;
2099:                        case USART_ID_4 :
2100:                            return (SFR_DATA)0;
2101:                        case USART_ID_6 :
2102:                            return (SFR_DATA)0;
2103:                        case USART_ID_5 :
2104:                            return (SFR_DATA)0;
2105:                        case USART_NUMBER_OF_MODULES :
2106:                        default :
2107:                            return (SFR_DATA)-1;
2108:                    }
2109:                }
2110:                
2111:                PLIB_INLINE SFR_DATA _USART_RECEIVER_DATA_POS(USART_MODULE_ID i)
2112:                {
2113:                    switch (i) {
2114:                        case USART_ID_1 :
2115:                            return (SFR_DATA)0;
2116:                        case USART_ID_3 :
2117:                            return (SFR_DATA)0;
2118:                        case USART_ID_2 :
2119:                            return (SFR_DATA)0;
2120:                        case USART_ID_4 :
2121:                            return (SFR_DATA)0;
2122:                        case USART_ID_6 :
2123:                            return (SFR_DATA)0;
2124:                        case USART_ID_5 :
2125:                            return (SFR_DATA)0;
2126:                        case USART_NUMBER_OF_MODULES :
2127:                        default :
2128:                            return (SFR_DATA)-1;
2129:                    }
2130:                }
2131:                
2132:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_HIGH_16_POS(USART_MODULE_ID i)
2133:                {
2134:                    switch (i) {
2135:                        case USART_ID_1 :
2136:                            return (SFR_DATA)0;
2137:                        case USART_ID_3 :
2138:                            return (SFR_DATA)0;
2139:                        case USART_ID_2 :
2140:                            return (SFR_DATA)0;
2141:                        case USART_ID_4 :
2142:                            return (SFR_DATA)0;
2143:                        case USART_ID_6 :
2144:                            return (SFR_DATA)0;
2145:                        case USART_ID_5 :
2146:                            return (SFR_DATA)0;
2147:                        case USART_NUMBER_OF_MODULES :
2148:                        default :
2149:                            return (SFR_DATA)-1;
2150:                    }
2151:                }
2152:                
2153:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_POS(USART_MODULE_ID i)
2154:                {
2155:                    switch (i) {
2156:                        case USART_ID_1 :
2157:                            return (SFR_DATA)0;
2158:                        case USART_ID_3 :
2159:                            return (SFR_DATA)0;
2160:                        case USART_ID_2 :
2161:                            return (SFR_DATA)0;
2162:                        case USART_ID_4 :
2163:                            return (SFR_DATA)0;
2164:                        case USART_ID_6 :
2165:                            return (SFR_DATA)0;
2166:                        case USART_ID_5 :
2167:                            return (SFR_DATA)0;
2168:                        case USART_NUMBER_OF_MODULES :
2169:                        default :
2170:                            return (SFR_DATA)-1;
2171:                    }
2172:                }
2173:                
2174:                PLIB_INLINE SFR_DATA _USART_LINE_CONTROL_MODE_STOP_LEN(USART_MODULE_ID i)
2175:                {
2176:                    switch (i) {
2177:                        case USART_ID_1 :
2178:                            return _U1MODE_STSEL_LENGTH;
2179:                        case USART_ID_3 :
2180:                            return _U3MODE_STSEL_LENGTH;
2181:                        case USART_ID_2 :
2182:                            return _U2MODE_STSEL_LENGTH;
2183:                        case USART_ID_4 :
2184:                            return _U4MODE_STSEL_LENGTH;
2185:                        case USART_ID_6 :
2186:                            return _U6MODE_STSEL_LENGTH;
2187:                        case USART_ID_5 :
2188:                            return _U5MODE_STSEL_LENGTH;
2189:                        case USART_NUMBER_OF_MODULES :
2190:                        default :
2191:                            return (SFR_DATA)-1;
2192:                    }
2193:                }
2194:                
2195:                PLIB_INLINE SFR_DATA _USART_LINE_CONTROL_MODE_DATA_LEN(USART_MODULE_ID i)
2196:                {
2197:                    switch (i) {
2198:                        case USART_ID_1 :
2199:                            return _U1MODE_PDSEL_LENGTH;
2200:                        case USART_ID_3 :
2201:                            return _U3MODE_PDSEL_LENGTH;
2202:                        case USART_ID_2 :
2203:                            return _U2MODE_PDSEL_LENGTH;
2204:                        case USART_ID_4 :
2205:                            return _U4MODE_PDSEL_LENGTH;
2206:                        case USART_ID_6 :
2207:                            return _U6MODE_PDSEL_LENGTH;
2208:                        case USART_ID_5 :
2209:                            return _U5MODE_PDSEL_LENGTH;
2210:                        case USART_NUMBER_OF_MODULES :
2211:                        default :
2212:                            return (SFR_DATA)-1;
2213:                    }
2214:                }
2215:                
2216:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_HIGH_ENABLE_16_LEN(USART_MODULE_ID i)
2217:                {
2218:                    switch (i) {
2219:                        case USART_ID_1 :
2220:                            return _U1MODE_BRGH_LENGTH;
2221:                        case USART_ID_3 :
2222:                            return _U3MODE_BRGH_LENGTH;
2223:                        case USART_ID_2 :
2224:                            return _U2MODE_BRGH_LENGTH;
2225:                        case USART_ID_4 :
2226:                            return _U4MODE_BRGH_LENGTH;
2227:                        case USART_ID_6 :
2228:                            return _U6MODE_BRGH_LENGTH;
2229:                        case USART_ID_5 :
2230:                            return _U5MODE_BRGH_LENGTH;
2231:                        case USART_NUMBER_OF_MODULES :
2232:                        default :
2233:                            return (SFR_DATA)-1;
2234:                    }
2235:                }
2236:                
2237:                PLIB_INLINE SFR_DATA _USART_RECEIVER_POLARITY_INVERT_LEN(USART_MODULE_ID i)
2238:                {
2239:                    switch (i) {
2240:                        case USART_ID_1 :
2241:                            return _U1MODE_RXINV_LENGTH;
2242:                        case USART_ID_3 :
2243:                            return _U3MODE_RXINV_LENGTH;
2244:                        case USART_ID_2 :
2245:                            return _U2MODE_RXINV_LENGTH;
2246:                        case USART_ID_4 :
2247:                            return _U4MODE_RXINV_LENGTH;
2248:                        case USART_ID_6 :
2249:                            return _U6MODE_RXINV_LENGTH;
2250:                        case USART_ID_5 :
2251:                            return _U5MODE_RXINV_LENGTH;
2252:                        case USART_NUMBER_OF_MODULES :
2253:                        default :
2254:                            return (SFR_DATA)-1;
2255:                    }
2256:                }
2257:                
2258:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_AUTO_DETECT_LEN(USART_MODULE_ID i)
2259:                {
2260:                    switch (i) {
2261:                        case USART_ID_1 :
2262:                            return _U1MODE_ABAUD_LENGTH;
2263:                        case USART_ID_3 :
2264:                            return _U3MODE_ABAUD_LENGTH;
2265:                        case USART_ID_2 :
2266:                            return _U2MODE_ABAUD_LENGTH;
2267:                        case USART_ID_4 :
2268:                            return _U4MODE_ABAUD_LENGTH;
2269:                        case USART_ID_6 :
2270:                            return _U6MODE_ABAUD_LENGTH;
2271:                        case USART_ID_5 :
2272:                            return _U5MODE_ABAUD_LENGTH;
2273:                        case USART_NUMBER_OF_MODULES :
2274:                        default :
2275:                            return (SFR_DATA)-1;
2276:                    }
2277:                }
2278:                
2279:                PLIB_INLINE SFR_DATA _USART_LOOP_BACK_LEN(USART_MODULE_ID i)
2280:                {
2281:                    switch (i) {
2282:                        case USART_ID_1 :
2283:                            return _U1MODE_LPBACK_LENGTH;
2284:                        case USART_ID_3 :
2285:                            return _U3MODE_LPBACK_LENGTH;
2286:                        case USART_ID_2 :
2287:                            return _U2MODE_LPBACK_LENGTH;
2288:                        case USART_ID_4 :
2289:                            return _U4MODE_LPBACK_LENGTH;
2290:                        case USART_ID_6 :
2291:                            return _U6MODE_LPBACK_LENGTH;
2292:                        case USART_ID_5 :
2293:                            return _U5MODE_LPBACK_LENGTH;
2294:                        case USART_NUMBER_OF_MODULES :
2295:                        default :
2296:                            return (SFR_DATA)-1;
2297:                    }
2298:                }
2299:                
2300:                PLIB_INLINE SFR_DATA _USART_WAKE_ON_START_LEN(USART_MODULE_ID i)
2301:                {
2302:                    switch (i) {
2303:                        case USART_ID_1 :
2304:                            return _U1MODE_WAKE_LENGTH;
2305:                        case USART_ID_3 :
2306:                            return _U3MODE_WAKE_LENGTH;
2307:                        case USART_ID_2 :
2308:                            return _U2MODE_WAKE_LENGTH;
2309:                        case USART_ID_4 :
2310:                            return _U4MODE_WAKE_LENGTH;
2311:                        case USART_ID_6 :
2312:                            return _U6MODE_WAKE_LENGTH;
2313:                        case USART_ID_5 :
2314:                            return _U5MODE_WAKE_LENGTH;
2315:                        case USART_NUMBER_OF_MODULES :
2316:                        default :
2317:                            return (SFR_DATA)-1;
2318:                    }
2319:                }
2320:                
2321:                PLIB_INLINE SFR_DATA _USART_OPERATION_MODE_LEN(USART_MODULE_ID i)
2322:                {
2323:                    switch (i) {
2324:                        case USART_ID_1 :
2325:                            return _U1MODE_UEN_LENGTH;
2326:                        case USART_ID_3 :
2327:                            return _U3MODE_UEN_LENGTH;
2328:                        case USART_ID_2 :
2329:                            return _U2MODE_UEN_LENGTH;
2330:                        case USART_ID_4 :
2331:                            return (SFR_DATA)-1;
2332:                        case USART_ID_6 :
2333:                            return (SFR_DATA)-1;
2334:                        case USART_ID_5 :
2335:                            return (SFR_DATA)-1;
2336:                        case USART_NUMBER_OF_MODULES :
2337:                        default :
2338:                            return (SFR_DATA)-1;
2339:                    }
2340:                }
2341:                
2342:                PLIB_INLINE SFR_DATA _USART_HAND_SHAKE_MODE_LEN(USART_MODULE_ID i)
2343:                {
2344:                    switch (i) {
2345:                        case USART_ID_1 :
2346:                            return _U1MODE_RTSMD_LENGTH;
2347:                        case USART_ID_3 :
2348:                            return _U3MODE_RTSMD_LENGTH;
2349:                        case USART_ID_2 :
2350:                            return _U2MODE_RTSMD_LENGTH;
2351:                        case USART_ID_4 :
2352:                            return (SFR_DATA)-1;
2353:                        case USART_ID_6 :
2354:                            return (SFR_DATA)-1;
2355:                        case USART_ID_5 :
2356:                            return (SFR_DATA)-1;
2357:                        case USART_NUMBER_OF_MODULES :
2358:                        default :
2359:                            return (SFR_DATA)-1;
2360:                    }
2361:                }
2362:                
2363:                PLIB_INLINE SFR_DATA _USART_IRDA_ENABLE_CONTROL_LEN(USART_MODULE_ID i)
2364:                {
2365:                    switch (i) {
2366:                        case USART_ID_1 :
2367:                            return _U1MODE_IREN_LENGTH;
2368:                        case USART_ID_3 :
2369:                            return _U3MODE_IREN_LENGTH;
2370:                        case USART_ID_2 :
2371:                            return _U2MODE_IREN_LENGTH;
2372:                        case USART_ID_4 :
2373:                            return _U4MODE_IREN_LENGTH;
2374:                        case USART_ID_6 :
2375:                            return _U6MODE_IREN_LENGTH;
2376:                        case USART_ID_5 :
2377:                            return _U5MODE_IREN_LENGTH;
2378:                        case USART_NUMBER_OF_MODULES :
2379:                        default :
2380:                            return (SFR_DATA)-1;
2381:                    }
2382:                }
2383:                
2384:                PLIB_INLINE SFR_DATA _USART_STOP_IN_IDLE_LEN(USART_MODULE_ID i)
2385:                {
2386:                    switch (i) {
2387:                        case USART_ID_1 :
2388:                            return _U1MODE_SIDL_LENGTH;
2389:                        case USART_ID_3 :
2390:                            return _U3MODE_SIDL_LENGTH;
2391:                        case USART_ID_2 :
2392:                            return _U2MODE_SIDL_LENGTH;
2393:                        case USART_ID_4 :
2394:                            return _U4MODE_SIDL_LENGTH;
2395:                        case USART_ID_6 :
2396:                            return _U6MODE_SIDL_LENGTH;
2397:                        case USART_ID_5 :
2398:                            return _U5MODE_SIDL_LENGTH;
2399:                        case USART_NUMBER_OF_MODULES :
2400:                        default :
2401:                            return (SFR_DATA)-1;
2402:                    }
2403:                }
2404:                
2405:                PLIB_INLINE SFR_DATA _USART_ENABLE_CONTROL_LEN(USART_MODULE_ID i)
2406:                {
2407:                    switch (i) {
2408:                        case USART_ID_1 :
2409:                            return _U1MODE_ON_LENGTH;
2410:                        case USART_ID_3 :
2411:                            return _U3MODE_ON_LENGTH;
2412:                        case USART_ID_2 :
2413:                            return _U2MODE_ON_LENGTH;
2414:                        case USART_ID_4 :
2415:                            return _U4MODE_ON_LENGTH;
2416:                        case USART_ID_6 :
2417:                            return _U6MODE_ON_LENGTH;
2418:                        case USART_ID_5 :
2419:                            return _U5MODE_ON_LENGTH;
2420:                        case USART_NUMBER_OF_MODULES :
2421:                        default :
2422:                            return (SFR_DATA)-1;
2423:                    }
2424:                }
2425:                
2426:                PLIB_INLINE SFR_DATA _USART_RECEIVER_DATA_AVAILABLE_LEN(USART_MODULE_ID i)
2427:                {
2428:                    switch (i) {
2429:                        case USART_ID_1 :
2430:                            return _U1STA_URXDA_LENGTH;
2431:                        case USART_ID_3 :
2432:                            return _U3STA_URXDA_LENGTH;
2433:                        case USART_ID_2 :
2434:                            return _U2STA_URXDA_LENGTH;
2435:                        case USART_ID_4 :
2436:                            return _U4STA_URXDA_LENGTH;
2437:                        case USART_ID_6 :
2438:                            return _U6STA_URXDA_LENGTH;
2439:                        case USART_ID_5 :
2440:                            return _U5STA_URXDA_LENGTH;
2441:                        case USART_NUMBER_OF_MODULES :
2442:                        default :
2443:                            return (SFR_DATA)-1;
2444:                    }
2445:                }
2446:                
2447:                PLIB_INLINE SFR_DATA _USART_RECEIVER_OVERRUN_ERROR_LEN(USART_MODULE_ID i)
2448:                {
2449:                    switch (i) {
2450:                        case USART_ID_1 :
2451:                            return _U1STA_OERR_LENGTH;
2452:                        case USART_ID_3 :
2453:                            return _U3STA_OERR_LENGTH;
2454:                        case USART_ID_2 :
2455:                            return _U2STA_OERR_LENGTH;
2456:                        case USART_ID_4 :
2457:                            return _U4STA_OERR_LENGTH;
2458:                        case USART_ID_6 :
2459:                            return _U6STA_OERR_LENGTH;
2460:                        case USART_ID_5 :
2461:                            return _U5STA_OERR_LENGTH;
2462:                        case USART_NUMBER_OF_MODULES :
2463:                        default :
2464:                            return (SFR_DATA)-1;
2465:                    }
2466:                }
2467:                
2468:                PLIB_INLINE SFR_DATA _USART_RECEIVER_FRAMING_ERROR_LEN(USART_MODULE_ID i)
2469:                {
2470:                    switch (i) {
2471:                        case USART_ID_1 :
2472:                            return _U1STA_FERR_LENGTH;
2473:                        case USART_ID_3 :
2474:                            return _U3STA_FERR_LENGTH;
2475:                        case USART_ID_2 :
2476:                            return _U2STA_FERR_LENGTH;
2477:                        case USART_ID_4 :
2478:                            return _U4STA_FERR_LENGTH;
2479:                        case USART_ID_6 :
2480:                            return _U6STA_FERR_LENGTH;
2481:                        case USART_ID_5 :
2482:                            return _U5STA_FERR_LENGTH;
2483:                        case USART_NUMBER_OF_MODULES :
2484:                        default :
2485:                            return (SFR_DATA)-1;
2486:                    }
2487:                }
2488:                
2489:                PLIB_INLINE SFR_DATA _USART_RECEIVER_PARITY_ERROR_LEN(USART_MODULE_ID i)
2490:                {
2491:                    switch (i) {
2492:                        case USART_ID_1 :
2493:                            return _U1STA_PERR_LENGTH;
2494:                        case USART_ID_3 :
2495:                            return _U3STA_PERR_LENGTH;
2496:                        case USART_ID_2 :
2497:                            return _U2STA_PERR_LENGTH;
2498:                        case USART_ID_4 :
2499:                            return _U4STA_PERR_LENGTH;
2500:                        case USART_ID_6 :
2501:                            return _U6STA_PERR_LENGTH;
2502:                        case USART_ID_5 :
2503:                            return _U5STA_PERR_LENGTH;
2504:                        case USART_NUMBER_OF_MODULES :
2505:                        default :
2506:                            return (SFR_DATA)-1;
2507:                    }
2508:                }
2509:                
2510:                PLIB_INLINE SFR_DATA _USART_RECEIVER_IDLE_LEN(USART_MODULE_ID i)
2511:                {
2512:                    switch (i) {
2513:                        case USART_ID_1 :
2514:                            return _U1STA_RIDLE_LENGTH;
2515:                        case USART_ID_3 :
2516:                            return _U3STA_RIDLE_LENGTH;
2517:                        case USART_ID_2 :
2518:                            return _U2STA_RIDLE_LENGTH;
2519:                        case USART_ID_4 :
2520:                            return _U4STA_RIDLE_LENGTH;
2521:                        case USART_ID_6 :
2522:                            return _U6STA_RIDLE_LENGTH;
2523:                        case USART_ID_5 :
2524:                            return _U5STA_RIDLE_LENGTH;
2525:                        case USART_NUMBER_OF_MODULES :
2526:                        default :
2527:                            return (SFR_DATA)-1;
2528:                    }
2529:                }
2530:                
2531:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ADDRESS_DETECT_LEN(USART_MODULE_ID i)
2532:                {
2533:                    switch (i) {
2534:                        case USART_ID_1 :
2535:                            return _U1STA_ADDEN_LENGTH;
2536:                        case USART_ID_3 :
2537:                            return _U3STA_ADDEN_LENGTH;
2538:                        case USART_ID_2 :
2539:                            return _U2STA_ADDEN_LENGTH;
2540:                        case USART_ID_4 :
2541:                            return _U4STA_ADDEN_LENGTH;
2542:                        case USART_ID_6 :
2543:                            return _U6STA_ADDEN_LENGTH;
2544:                        case USART_ID_5 :
2545:                            return _U5STA_ADDEN_LENGTH;
2546:                        case USART_NUMBER_OF_MODULES :
2547:                        default :
2548:                            return (SFR_DATA)-1;
2549:                    }
2550:                }
2551:                
2552:                PLIB_INLINE SFR_DATA _USART_RECEIVER_FIFO_LEVEL_LEN(USART_MODULE_ID i)
2553:                {
2554:                    switch (i) {
2555:                        case USART_ID_1 :
2556:                            return _U1STA_URXISEL_LENGTH;
2557:                        case USART_ID_3 :
2558:                            return _U3STA_URXISEL_LENGTH;
2559:                        case USART_ID_2 :
2560:                            return _U2STA_URXISEL_LENGTH;
2561:                        case USART_ID_4 :
2562:                            return _U4STA_URXISEL_LENGTH;
2563:                        case USART_ID_6 :
2564:                            return _U6STA_URXISEL_LENGTH;
2565:                        case USART_ID_5 :
2566:                            return _U5STA_URXISEL_LENGTH;
2567:                        case USART_NUMBER_OF_MODULES :
2568:                        default :
2569:                            return (SFR_DATA)-1;
2570:                    }
2571:                }
2572:                
2573:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_EMPTY_LEN(USART_MODULE_ID i)
2574:                {
2575:                    switch (i) {
2576:                        case USART_ID_1 :
2577:                            return _U1STA_TRMT_LENGTH;
2578:                        case USART_ID_3 :
2579:                            return _U3STA_TRMT_LENGTH;
2580:                        case USART_ID_2 :
2581:                            return _U2STA_TRMT_LENGTH;
2582:                        case USART_ID_4 :
2583:                            return _U4STA_TRMT_LENGTH;
2584:                        case USART_ID_6 :
2585:                            return _U6STA_TRMT_LENGTH;
2586:                        case USART_ID_5 :
2587:                            return _U5STA_TRMT_LENGTH;
2588:                        case USART_NUMBER_OF_MODULES :
2589:                        default :
2590:                            return (SFR_DATA)-1;
2591:                    }
2592:                }
2593:                
2594:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_BUFFER_FULL_LEN(USART_MODULE_ID i)
2595:                {
2596:                    switch (i) {
2597:                        case USART_ID_1 :
2598:                            return _U1STA_UTXBF_LENGTH;
2599:                        case USART_ID_3 :
2600:                            return _U3STA_UTXBF_LENGTH;
2601:                        case USART_ID_2 :
2602:                            return _U2STA_UTXBF_LENGTH;
2603:                        case USART_ID_4 :
2604:                            return _U4STA_UTXBF_LENGTH;
2605:                        case USART_ID_6 :
2606:                            return _U6STA_UTXBF_LENGTH;
2607:                        case USART_ID_5 :
2608:                            return _U5STA_UTXBF_LENGTH;
2609:                        case USART_NUMBER_OF_MODULES :
2610:                        default :
2611:                            return (SFR_DATA)-1;
2612:                    }
2613:                }
2614:                
2615:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_ENABLE_CONTROL_LEN(USART_MODULE_ID i)
2616:                {
2617:                    switch (i) {
2618:                        case USART_ID_1 :
2619:                            return _U1STA_UTXEN_LENGTH;
2620:                        case USART_ID_3 :
2621:                            return _U3STA_UTXEN_LENGTH;
2622:                        case USART_ID_2 :
2623:                            return _U2STA_UTXEN_LENGTH;
2624:                        case USART_ID_4 :
2625:                            return _U4STA_UTXEN_LENGTH;
2626:                        case USART_ID_6 :
2627:                            return _U6STA_UTXEN_LENGTH;
2628:                        case USART_ID_5 :
2629:                            return _U5STA_UTXEN_LENGTH;
2630:                        case USART_NUMBER_OF_MODULES :
2631:                        default :
2632:                            return (SFR_DATA)-1;
2633:                    }
2634:                }
2635:                
2636:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_BREAK_SEND_LEN(USART_MODULE_ID i)
2637:                {
2638:                    switch (i) {
2639:                        case USART_ID_1 :
2640:                            return _U1STA_UTXBRK_LENGTH;
2641:                        case USART_ID_3 :
2642:                            return _U3STA_UTXBRK_LENGTH;
2643:                        case USART_ID_2 :
2644:                            return _U2STA_UTXBRK_LENGTH;
2645:                        case USART_ID_4 :
2646:                            return _U4STA_UTXBRK_LENGTH;
2647:                        case USART_ID_6 :
2648:                            return _U6STA_UTXBRK_LENGTH;
2649:                        case USART_ID_5 :
2650:                            return _U5STA_UTXBRK_LENGTH;
2651:                        case USART_NUMBER_OF_MODULES :
2652:                        default :
2653:                            return (SFR_DATA)-1;
2654:                    }
2655:                }
2656:                
2657:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ENABLE_LEN(USART_MODULE_ID i)
2658:                {
2659:                    switch (i) {
2660:                        case USART_ID_1 :
2661:                            return _U1STA_URXEN_LENGTH;
2662:                        case USART_ID_3 :
2663:                            return _U3STA_URXEN_LENGTH;
2664:                        case USART_ID_2 :
2665:                            return _U2STA_URXEN_LENGTH;
2666:                        case USART_ID_4 :
2667:                            return _U4STA_URXEN_LENGTH;
2668:                        case USART_ID_6 :
2669:                            return _U6STA_URXEN_LENGTH;
2670:                        case USART_ID_5 :
2671:                            return _U5STA_URXEN_LENGTH;
2672:                        case USART_NUMBER_OF_MODULES :
2673:                        default :
2674:                            return (SFR_DATA)-1;
2675:                    }
2676:                }
2677:                
2678:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_IDLE_IS_LOW32_LEN(USART_MODULE_ID i)
2679:                {
2680:                    switch (i) {
2681:                        case USART_ID_1 :
2682:                            return _U1STA_UTXINV_LENGTH;
2683:                        case USART_ID_3 :
2684:                            return _U3STA_UTXINV_LENGTH;
2685:                        case USART_ID_2 :
2686:                            return _U2STA_UTXINV_LENGTH;
2687:                        case USART_ID_4 :
2688:                            return _U4STA_UTXINV_LENGTH;
2689:                        case USART_ID_6 :
2690:                            return _U6STA_UTXINV_LENGTH;
2691:                        case USART_ID_5 :
2692:                            return _U5STA_UTXINV_LENGTH;
2693:                        case USART_NUMBER_OF_MODULES :
2694:                        default :
2695:                            return (SFR_DATA)-1;
2696:                    }
2697:                }
2698:                
2699:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_INTR_MODE_SELECT_LEN(USART_MODULE_ID i)
2700:                {
2701:                    switch (i) {
2702:                        case USART_ID_1 :
2703:                            return _U1STA_UTXISEL_LENGTH;
2704:                        case USART_ID_3 :
2705:                            return _U3STA_UTXISEL_LENGTH;
2706:                        case USART_ID_2 :
2707:                            return _U2STA_UTXISEL_LENGTH;
2708:                        case USART_ID_4 :
2709:                            return _U4STA_UTXISEL_LENGTH;
2710:                        case USART_ID_6 :
2711:                            return _U6STA_UTXISEL_LENGTH;
2712:                        case USART_ID_5 :
2713:                            return _U5STA_UTXISEL_LENGTH;
2714:                        case USART_NUMBER_OF_MODULES :
2715:                        default :
2716:                            return (SFR_DATA)-1;
2717:                    }
2718:                }
2719:                
2720:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ADDRESS_AUTO_DETECT_LEN(USART_MODULE_ID i)
2721:                {
2722:                    switch (i) {
2723:                        case USART_ID_1 :
2724:                            return _U1STA_ADDR_LENGTH;
2725:                        case USART_ID_3 :
2726:                            return _U3STA_ADDR_LENGTH;
2727:                        case USART_ID_2 :
2728:                            return _U2STA_ADDR_LENGTH;
2729:                        case USART_ID_4 :
2730:                            return _U4STA_ADDR_LENGTH;
2731:                        case USART_ID_6 :
2732:                            return _U6STA_ADDR_LENGTH;
2733:                        case USART_ID_5 :
2734:                            return _U5STA_ADDR_LENGTH;
2735:                        case USART_NUMBER_OF_MODULES :
2736:                        default :
2737:                            return (SFR_DATA)-1;
2738:                    }
2739:                }
2740:                
2741:                PLIB_INLINE SFR_DATA _USART_RECEIVER_ADDRESS_AUTO_DETECT_ENABLE_LEN(USART_MODULE_ID i)
2742:                {
2743:                    switch (i) {
2744:                        case USART_ID_1 :
2745:                            return _U1STA_ADM_EN_LENGTH;
2746:                        case USART_ID_3 :
2747:                            return _U3STA_ADM_EN_LENGTH;
2748:                        case USART_ID_2 :
2749:                            return _U2STA_ADM_EN_LENGTH;
2750:                        case USART_ID_4 :
2751:                            return _U4STA_ADM_EN_LENGTH;
2752:                        case USART_ID_6 :
2753:                            return _U6STA_ADM_EN_LENGTH;
2754:                        case USART_ID_5 :
2755:                            return _U5STA_ADM_EN_LENGTH;
2756:                        case USART_NUMBER_OF_MODULES :
2757:                        default :
2758:                            return (SFR_DATA)-1;
2759:                    }
2760:                }
2761:                
2762:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_SEND_LEN(USART_MODULE_ID i)
2763:                {
2764:                    switch (i) {
2765:                        case USART_ID_1 :
2766:                            return (SFR_DATA)sizeof(SFR_DATA);
2767:                        case USART_ID_3 :
2768:                            return (SFR_DATA)sizeof(SFR_DATA);
2769:                        case USART_ID_2 :
2770:                            return (SFR_DATA)sizeof(SFR_DATA);
2771:                        case USART_ID_4 :
2772:                            return (SFR_DATA)sizeof(SFR_DATA);
2773:                        case USART_ID_6 :
2774:                            return (SFR_DATA)sizeof(SFR_DATA);
2775:                        case USART_ID_5 :
2776:                            return (SFR_DATA)sizeof(SFR_DATA);
2777:                        case USART_NUMBER_OF_MODULES :
2778:                        default :
2779:                            return (SFR_DATA)-1;
2780:                    }
2781:                }
2782:                
2783:                PLIB_INLINE SFR_DATA _USART_TRANSMITTER_DATA_ONLY_LEN(USART_MODULE_ID i)
2784:                {
2785:                    switch (i) {
2786:                        case USART_ID_1 :
2787:                            return (SFR_DATA)sizeof(SFR_DATA);
2788:                        case USART_ID_3 :
2789:                            return (SFR_DATA)sizeof(SFR_DATA);
2790:                        case USART_ID_2 :
2791:                            return (SFR_DATA)sizeof(SFR_DATA);
2792:                        case USART_ID_4 :
2793:                            return (SFR_DATA)sizeof(SFR_DATA);
2794:                        case USART_ID_6 :
2795:                            return (SFR_DATA)sizeof(SFR_DATA);
2796:                        case USART_ID_5 :
2797:                            return (SFR_DATA)sizeof(SFR_DATA);
2798:                        case USART_NUMBER_OF_MODULES :
2799:                        default :
2800:                            return (SFR_DATA)-1;
2801:                    }
2802:                }
2803:                
2804:                PLIB_INLINE SFR_DATA _USART_RECEIVER_DATA_LEN(USART_MODULE_ID i)
2805:                {
2806:                    switch (i) {
2807:                        case USART_ID_1 :
2808:                            return (SFR_DATA)sizeof(SFR_DATA);
2809:                        case USART_ID_3 :
2810:                            return (SFR_DATA)sizeof(SFR_DATA);
2811:                        case USART_ID_2 :
2812:                            return (SFR_DATA)sizeof(SFR_DATA);
2813:                        case USART_ID_4 :
2814:                            return (SFR_DATA)sizeof(SFR_DATA);
2815:                        case USART_ID_6 :
2816:                            return (SFR_DATA)sizeof(SFR_DATA);
2817:                        case USART_ID_5 :
2818:                            return (SFR_DATA)sizeof(SFR_DATA);
2819:                        case USART_NUMBER_OF_MODULES :
2820:                        default :
2821:                            return (SFR_DATA)-1;
2822:                    }
2823:                }
2824:                
2825:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_HIGH_16_LEN(USART_MODULE_ID i)
2826:                {
2827:                    switch (i) {
2828:                        case USART_ID_1 :
2829:                            return (SFR_DATA)sizeof(SFR_DATA);
2830:                        case USART_ID_3 :
2831:                            return (SFR_DATA)sizeof(SFR_DATA);
2832:                        case USART_ID_2 :
2833:                            return (SFR_DATA)sizeof(SFR_DATA);
2834:                        case USART_ID_4 :
2835:                            return (SFR_DATA)sizeof(SFR_DATA);
2836:                        case USART_ID_6 :
2837:                            return (SFR_DATA)sizeof(SFR_DATA);
2838:                        case USART_ID_5 :
2839:                            return (SFR_DATA)sizeof(SFR_DATA);
2840:                        case USART_NUMBER_OF_MODULES :
2841:                        default :
2842:                            return (SFR_DATA)-1;
2843:                    }
2844:                }
2845:                
2846:                PLIB_INLINE SFR_DATA _USART_BAUD_RATE_LEN(USART_MODULE_ID i)
2847:                {
2848:                    switch (i) {
2849:                        case USART_ID_1 :
2850:                            return (SFR_DATA)sizeof(SFR_DATA);
2851:                        case USART_ID_3 :
2852:                            return (SFR_DATA)sizeof(SFR_DATA);
2853:                        case USART_ID_2 :
2854:                            return (SFR_DATA)sizeof(SFR_DATA);
2855:                        case USART_ID_4 :
2856:                            return (SFR_DATA)sizeof(SFR_DATA);
2857:                        case USART_ID_6 :
2858:                            return (SFR_DATA)sizeof(SFR_DATA);
2859:                        case USART_ID_5 :
2860:                            return (SFR_DATA)sizeof(SFR_DATA);
2861:                        case USART_NUMBER_OF_MODULES :
2862:                        default :
2863:                            return (SFR_DATA)-1;
2864:                    }
2865:                }
2866:                
2867:                /* Section 2 - Feature variant inclusion */
2868:                
2869:                #define PLIB_TEMPLATE PLIB_INLINE
2870:                #include "../templates/usart_EnableControl_Default.h"
2871:                #include "../templates/usart_HandShakeMode_Default.h"
2872:                #include "../templates/usart_HandShakeMode_Unsupported.h"
2873:                #include "../templates/usart_IrDAControl_Default.h"
2874:                #include "../templates/usart_LineControlMode_RXandTXCombined.h"
2875:                #include "../templates/usart_Loopback_Default.h"
2876:                #include "../templates/usart_OperationMode_Default.h"
2877:                #include "../templates/usart_OperationMode_Unsupported.h"
2878:                #include "../templates/usart_StopInIdle_Default.h"
2879:                #include "../templates/usart_RunInOverflow_Unsupported.h"
2880:                #include "../templates/usart_BRGClockSourceSelect_Unsupported.h"
2881:                #include "../templates/usart_UsartModuleStatus_Unsupported.h"
2882:                #include "../templates/usart_RunInSleepMode_Unsupported.h"
2883:                #include "../templates/usart_WakeOnStart_Default.h"
2884:                #include "../templates/usart_BaudRate_In16BitRegister.h"
2885:                #include "../templates/usart_BaudRateAutoDetect_Default.h"
2886:                #include "../templates/usart_BaudRateHigh_In16BitRegister.h"
2887:                #include "../templates/usart_Receiver_Default.h"
2888:                #include "../templates/usart_Receiver9Bits_Default.h"
2889:                #include "../templates/usart_ReceiverAddressAutoDetect_Default.h"
2890:                #include "../templates/usart_ReceiverAddressDetect_Default.h"
2891:                #include "../templates/usart_ReceiverAddress_Default.h"
2892:                #include "../templates/usart_ReceiverAddressMask_Unsupported.h"
2893:                #include "../templates/usart_ReceiverDataAvailable_Default.h"
2894:                #include "../templates/usart_ReceiverEnableControl_Default.h"
2895:                #include "../templates/usart_ReceiverIdle_Default.h"
2896:                #include "../templates/usart_ReceiverFramingError_Default.h"
2897:                #include "../templates/usart_ReceiverInterruptMode_Default.h"
2898:                #include "../templates/usart_ReceiverPolarityInvert_Default.h"
2899:                #include "../templates/usart_ReceiverParityError_Default.h"
2900:                #include "../templates/usart_ReceiverOverrunError_Default.h"
2901:                #include "../templates/usart_Transmitter_Default.h"
2902:                #include "../templates/usart_Transmitter9Bits_InDataOnly.h"
2903:                #include "../templates/usart_TransmitterBreak_Default.h"
2904:                #include "../templates/usart_TransmitterBufferFull_Default.h"
2905:                #include "../templates/usart_TransmitterEmpty_Default.h"
2906:                #include "../templates/usart_TransmitterEnableControl_Default.h"
2907:                #include "../templates/usart_TransmitterInterruptMode_Default.h"
2908:                #include "../templates/usart_TransmitterIdleIsLow_pic32.h"
2909:                
2910:                /* Section 3 - PLIB dispatch function definitions */
2911:                
2912:                PLIB_INLINE_API bool PLIB_USART_ExistsEnable(USART_MODULE_ID index)
2913:                {
2914:                    switch (index) {
2915:                        case USART_ID_1 :
2916:                            return USART_ExistsEnable_Default(index);
2917:                        case USART_ID_3 :
2918:                            return USART_ExistsEnable_Default(index);
2919:                        case USART_ID_2 :
2920:                            return USART_ExistsEnable_Default(index);
2921:                        case USART_ID_4 :
2922:                            return USART_ExistsEnable_Default(index);
2923:                        case USART_ID_6 :
2924:                            return USART_ExistsEnable_Default(index);
2925:                        case USART_ID_5 :
2926:                            return USART_ExistsEnable_Default(index);
2927:                        case USART_NUMBER_OF_MODULES :
2928:                        default :
2929:                            return (bool)0;
2930:                    }
2931:                }
2932:                
2933:                PLIB_INLINE_API void PLIB_USART_Disable(USART_MODULE_ID index)
2934:                {
2935:                    switch (index) {
9D004898  8CA20004   LW V0, 4(A1)
9D00489C  2C420006   SLTIU V0, V0, 6
9D0048A0  10400013   BEQ V0, ZERO, 0x9D0048F0
9D0048A4  00A08821   ADDU S1, A1, ZERO
9D0048A8  8CA30004   LW V1, 4(A1)
9D0048AC  00031880   SLL V1, V1, 2
9D0048B0  3C029D00   LUI V0, -25344
9D0048B4  244248C8   ADDIU V0, V0, 18632
9D0048B8  00431021   ADDU V0, V0, V1
9D0048BC  8C420000   LW V0, 0(V0)
9D0048C0  00400008   JR V0
9D0048C4  00000000   NOP
00000058  00000000   NOP
2936:                        case USART_ID_1 :
2937:                            USART_Disable_Default(index);
2938:                            break;
2939:                        case USART_ID_3 :
2940:                            USART_Disable_Default(index);
2941:                            break;
2942:                        case USART_ID_2 :
2943:                            USART_Disable_Default(index);
2944:                            break;
2945:                        case USART_ID_4 :
2946:                            USART_Disable_Default(index);
2947:                            break;
2948:                        case USART_ID_6 :
2949:                            USART_Disable_Default(index);
2950:                            break;
2951:                        case USART_ID_5 :
2952:                            USART_Disable_Default(index);
2953:                            break;
2954:                        case USART_NUMBER_OF_MODULES :
2955:                        default :
2956:                            break;
2957:                    }
2958:                }
2959:                
2960:                PLIB_INLINE_API void PLIB_USART_Enable(USART_MODULE_ID index)
2961:                {
2962:                    switch (index) {
9D004A80  8E220004   LW V0, 4(S1)
9D004A84  2C420006   SLTIU V0, V0, 6
9D004A88  10400014   BEQ V0, ZERO, 0x9D004ADC
9D004A8C  24020002   ADDIU V0, ZERO, 2
9D004A90  8E220004   LW V0, 4(S1)
9D004A94  00021080   SLL V0, V0, 2
9D004A98  3C039D00   LUI V1, -25344
9D004A9C  24634AB0   ADDIU V1, V1, 19120
9D004AA0  00621021   ADDU V0, V1, V0
9D004AA4  8C420000   LW V0, 0(V0)
9D004AA8  00400008   JR V0
9D004AAC  00000000   NOP
9D004AC8  34038000   ORI V1, ZERO, -32768
9D004ACC  3C02BF80   LUI V0, -16512
9D004AD0  24426000   ADDIU V0, V0, 24576
9D004AD4  AC430008   SW V1, 8(V0)
9D004AD8  24020002   ADDIU V0, ZERO, 2
9D004ADC  AE42000C   SW V0, 12(S2)
9D004AE0  0B4012F6   J 0x9D004BD8
9D004AE4  02001821   ADDU V1, S0, ZERO
9D004AE8  34038000   ORI V1, ZERO, -32768
9D004AEC  3C02BF80   LUI V0, -16512
9D004AF0  24426400   ADDIU V0, V0, 25600
9D004AF4  AC430004   SW V1, 4(V0)
9D004AF8  0B40123D   J 0x9D0048F4
9D004AFC  00101140   SLL V0, S0, 5
9D004B00  34038000   ORI V1, ZERO, -32768
9D004B04  3C02BF80   LUI V0, -16512
9D004B08  24426800   ADDIU V0, V0, 26624
9D004B0C  AC430004   SW V1, 4(V0)
9D004B10  0B40123D   J 0x9D0048F4
9D004B14  00101140   SLL V0, S0, 5
9D004B18  34038000   ORI V1, ZERO, -32768
9D004B1C  3C02BF80   LUI V0, -16512
9D004B20  24426200   ADDIU V0, V0, 25088
9D004B24  AC430004   SW V1, 4(V0)
9D004B28  0B40123D   J 0x9D0048F4
9D004B2C  00101140   SLL V0, S0, 5
9D004B30  34038000   ORI V1, ZERO, -32768
9D004B34  3C02BF80   LUI V0, -16512
9D004B38  24426600   ADDIU V0, V0, 26112
9D004B3C  AC430004   SW V1, 4(V0)
9D004B40  0B40123D   J 0x9D0048F4
9D004B44  00101140   SLL V0, S0, 5
9D004B48  34038000   ORI V1, ZERO, -32768
9D004B4C  3C02BF80   LUI V0, -16512
9D004B50  24426A00   ADDIU V0, V0, 27136
9D004B54  AC430004   SW V1, 4(V0)
9D004B58  0B40123D   J 0x9D0048F4
9D004B5C  00101140   SLL V0, S0, 5
9D004B60  34038000   ORI V1, ZERO, -32768
9D004B64  3C02BF80   LUI V0, -16512
9D004B68  24426400   ADDIU V0, V0, 25600
9D004B6C  AC430008   SW V1, 8(V0)
9D004B70  0B4012B7   J 0x9D004ADC
9D004B74  24020002   ADDIU V0, ZERO, 2
9D004B78  34038000   ORI V1, ZERO, -32768
9D004B7C  3C02BF80   LUI V0, -16512
9D004B80  24426800   ADDIU V0, V0, 26624
9D004B84  AC430008   SW V1, 8(V0)
9D004B88  0B4012B7   J 0x9D004ADC
9D004B8C  24020002   ADDIU V0, ZERO, 2
9D004B90  34038000   ORI V1, ZERO, -32768
9D004B94  3C02BF80   LUI V0, -16512
9D004B98  24426200   ADDIU V0, V0, 25088
9D004B9C  AC430008   SW V1, 8(V0)
9D004BA0  0B4012B7   J 0x9D004ADC
9D004BA4  24020002   ADDIU V0, ZERO, 2
9D004BA8  34038000   ORI V1, ZERO, -32768
9D004BAC  3C02BF80   LUI V0, -16512
9D004BB0  24426600   ADDIU V0, V0, 26112
9D004BB4  AC430008   SW V1, 8(V0)
9D004BB8  0B4012B7   J 0x9D004ADC
9D004BBC  24020002   ADDIU V0, ZERO, 2
9D004BC0  34038000   ORI V1, ZERO, -32768
9D004BC4  3C02BF80   LUI V0, -16512
9D004BC8  24426A00   ADDIU V0, V0, 27136
9D004BCC  AC430008   SW V1, 8(V0)
9D004BD0  0B4012B7   J 0x9D004ADC
9D004BD4  24020002   ADDIU V0, ZERO, 2
9D004BD8  00601021   ADDU V0, V1, ZERO
9D004BDC  8FBF0024   LW RA, 36(SP)
9D004BE0  8FB30020   LW S3, 32(SP)
9D004BE4  8FB2001C   LW S2, 28(SP)
9D004BE8  8FB10018   LW S1, 24(SP)
9D004BEC  8FB00014   LW S0, 20(SP)
9D004BF0  03E00008   JR RA
9D004BF4  27BD0028   ADDIU SP, SP, 40
2963:                        case USART_ID_1 :
2964:                            USART_Enable_Default(index);
2965:                            break;
2966:                        case USART_ID_3 :
2967:                            USART_Enable_Default(index);
2968:                            break;
2969:                        case USART_ID_2 :
2970:                            USART_Enable_Default(index);
2971:                            break;
2972:                        case USART_ID_4 :
2973:                            USART_Enable_Default(index);
2974:                            break;
2975:                        case USART_ID_6 :
2976:                            USART_Enable_Default(index);
2977:                            break;
2978:                        case USART_ID_5 :
2979:                            USART_Enable_Default(index);
2980:                            break;
2981:                        case USART_NUMBER_OF_MODULES :
2982:                        default :
2983:                            break;
2984:                    }
2985:                }
2986:                
2987:                PLIB_INLINE_API void PLIB_USART_BaudSetAndEnable(USART_MODULE_ID index, uint32_t systemClock, uint32_t baud)
2988:                {
2989:                    switch (index) {
9D001AF8  2C850006   SLTIU A1, A0, 6
9D001AFC  10A0002E   BEQ A1, ZERO, 0x9D001BB8
9D001B00  00042080   SLL A0, A0, 2
9D001B04  3C059D00   LUI A1, -25344
9D001B08  24A51B1C   ADDIU A1, A1, 6940
9D001B0C  00A42021   ADDU A0, A1, A0
9D001B10  8C840000   LW A0, 0(A0)
9D001B14  00800008   JR A0
9D001B18  00000000   NOP
2990:                        case USART_ID_1 :
2991:                            USART_BaudSetAndEnable_Default(index, systemClock, baud);
2992:                            break;
2993:                        case USART_ID_3 :
2994:                            USART_BaudSetAndEnable_Default(index, systemClock, baud);
2995:                            break;
2996:                        case USART_ID_2 :
2997:                            USART_BaudSetAndEnable_Default(index, systemClock, baud);
2998:                            break;
2999:                        case USART_ID_4 :
3000:                            USART_BaudSetAndEnable_Default(index, systemClock, baud);
3001:                            break;
3002:                        case USART_ID_6 :
3003:                            USART_BaudSetAndEnable_Default(index, systemClock, baud);
3004:                            break;
3005:                        case USART_ID_5 :
3006:                            USART_BaudSetAndEnable_Default(index, systemClock, baud);
3007:                            break;
3008:                        case USART_NUMBER_OF_MODULES :
3009:                        default :
3010:                            break;
3011:                    }
3012:                }
3013:                
3014:                PLIB_INLINE_API bool PLIB_USART_ExistsHandshakeMode(USART_MODULE_ID index)
3015:                {
3016:                    switch (index) {
3017:                        case USART_ID_1 :
3018:                            return USART_ExistsHandshakeMode_Default(index);
3019:                        case USART_ID_3 :
3020:                            return USART_ExistsHandshakeMode_Default(index);
3021:                        case USART_ID_2 :
3022:                            return USART_ExistsHandshakeMode_Default(index);
3023:                        case USART_ID_4 :
3024:                            return USART_ExistsHandshakeMode_Unsupported(index);
3025:                        case USART_ID_6 :
3026:                            return USART_ExistsHandshakeMode_Unsupported(index);
3027:                        case USART_ID_5 :
3028:                            return USART_ExistsHandshakeMode_Unsupported(index);
3029:                        case USART_NUMBER_OF_MODULES :
3030:                        default :
3031:                            return (bool)0;
3032:                    }
3033:                }
3034:                
3035:                PLIB_INLINE_API void PLIB_USART_HandshakeModeSelect(USART_MODULE_ID index, USART_HANDSHAKE_MODE handshakeConfig)
3036:                {
3037:                    switch (index) {
9D001618  24060001   ADDIU A2, ZERO, 1
9D00161C  5086029C   BEQL A0, A2, 0x9D002090
9D001620  3C04BF80   LUI A0, -16512
9D001624  50800008   BEQL A0, ZERO, 0x9D001648
9D001628  3C04BF80   LUI A0, -16512
9D00162C  24060002   ADDIU A2, ZERO, 2
9D001630  508602A8   BEQL A0, A2, 0x9D0020D4
9D001634  3C04BF80   LUI A0, -16512
3038:                        case USART_ID_1 :
3039:                            USART_HandshakeModeSelect_Default(index, handshakeConfig);
3040:                            break;
3041:                        case USART_ID_3 :
3042:                            USART_HandshakeModeSelect_Default(index, handshakeConfig);
3043:                            break;
3044:                        case USART_ID_2 :
3045:                            USART_HandshakeModeSelect_Default(index, handshakeConfig);
3046:                            break;
3047:                        case USART_ID_4 :
3048:                            USART_HandshakeModeSelect_Unsupported(index, handshakeConfig);
3049:                            break;
3050:                        case USART_ID_6 :
3051:                            USART_HandshakeModeSelect_Unsupported(index, handshakeConfig);
3052:                            break;
3053:                        case USART_ID_5 :
3054:                            USART_HandshakeModeSelect_Unsupported(index, handshakeConfig);
3055:                            break;
3056:                        case USART_NUMBER_OF_MODULES :
3057:                        default :
3058:                            break;
3059:                    }
3060:                }
3061:                
3062:                PLIB_INLINE_API bool PLIB_USART_ExistsIrDA(USART_MODULE_ID index)
3063:                {
3064:                    switch (index) {
3065:                        case USART_ID_1 :
3066:                            return USART_ExistsIrDA_Default(index);
3067:                        case USART_ID_3 :
3068:                            return USART_ExistsIrDA_Default(index);
3069:                        case USART_ID_2 :
3070:                            return USART_ExistsIrDA_Default(index);
3071:                        case USART_ID_4 :
3072:                            return USART_ExistsIrDA_Default(index);
3073:                        case USART_ID_6 :
3074:                            return USART_ExistsIrDA_Default(index);
3075:                        case USART_ID_5 :
3076:                            return USART_ExistsIrDA_Default(index);
3077:                        case USART_NUMBER_OF_MODULES :
3078:                        default :
3079:                            return (bool)0;
3080:                    }
3081:                }
3082:                
3083:                PLIB_INLINE_API void PLIB_USART_IrDADisable(USART_MODULE_ID index)
3084:                {
3085:                    switch (index) {
3086:                        case USART_ID_1 :
3087:                            USART_IrDADisable_Default(index);
3088:                            break;
3089:                        case USART_ID_3 :
3090:                            USART_IrDADisable_Default(index);
3091:                            break;
3092:                        case USART_ID_2 :
3093:                            USART_IrDADisable_Default(index);
3094:                            break;
3095:                        case USART_ID_4 :
3096:                            USART_IrDADisable_Default(index);
3097:                            break;
3098:                        case USART_ID_6 :
3099:                            USART_IrDADisable_Default(index);
3100:                            break;
3101:                        case USART_ID_5 :
3102:                            USART_IrDADisable_Default(index);
3103:                            break;
3104:                        case USART_NUMBER_OF_MODULES :
3105:                        default :
3106:                            break;
3107:                    }
3108:                }
3109:                
3110:                PLIB_INLINE_API void PLIB_USART_IrDAEnable(USART_MODULE_ID index)
3111:                {
3112:                    switch (index) {
3113:                        case USART_ID_1 :
3114:                            USART_IrDAEnable_Default(index);
3115:                            break;
3116:                        case USART_ID_3 :
3117:                            USART_IrDAEnable_Default(index);
3118:                            break;
3119:                        case USART_ID_2 :
3120:                            USART_IrDAEnable_Default(index);
3121:                            break;
3122:                        case USART_ID_4 :
3123:                            USART_IrDAEnable_Default(index);
3124:                            break;
3125:                        case USART_ID_6 :
3126:                            USART_IrDAEnable_Default(index);
3127:                            break;
3128:                        case USART_ID_5 :
3129:                            USART_IrDAEnable_Default(index);
3130:                            break;
3131:                        case USART_NUMBER_OF_MODULES :
3132:                        default :
3133:                            break;
3134:                    }
3135:                }
3136:                
3137:                PLIB_INLINE_API bool PLIB_USART_ExistsLineControlMode(USART_MODULE_ID index)
3138:                {
3139:                    switch (index) {
3140:                        case USART_ID_1 :
3141:                            return USART_ExistsLineControlMode_RXandTXCombined(index);
3142:                        case USART_ID_3 :
3143:                            return USART_ExistsLineControlMode_RXandTXCombined(index);
3144:                        case USART_ID_2 :
3145:                            return USART_ExistsLineControlMode_RXandTXCombined(index);
3146:                        case USART_ID_4 :
3147:                            return USART_ExistsLineControlMode_RXandTXCombined(index);
3148:                        case USART_ID_6 :
3149:                            return USART_ExistsLineControlMode_RXandTXCombined(index);
3150:                        case USART_ID_5 :
3151:                            return USART_ExistsLineControlMode_RXandTXCombined(index);
3152:                        case USART_NUMBER_OF_MODULES :
3153:                        default :
3154:                            return (bool)0;
3155:                    }
3156:                }
3157:                
3158:                PLIB_INLINE_API void PLIB_USART_LineControlModeSelect(USART_MODULE_ID index, USART_LINECONTROL_MODE dataFlowConfig)
3159:                {
3160:                    switch (index) {
9D001988  2C830006   SLTIU V1, A0, 6
9D00198C  10600034   BEQ V1, ZERO, 0x9D001A60
9D001990  8CA20018   LW V0, 24(A1)
9D001994  00042080   SLL A0, A0, 2
9D001998  3C039D00   LUI V1, -25344
9D00199C  246319B0   ADDIU V1, V1, 6576
9D0019A0  00641821   ADDU V1, V1, A0
9D0019A4  8C630000   LW V1, 0(V1)
9D0019A8  00600008   JR V1
9D0019AC  00000000   NOP
00000048  00000000   NOP
3161:                        case USART_ID_1 :
3162:                            USART_LineControlModeSelect_RXandTXCombined(index, dataFlowConfig);
3163:                            break;
3164:                        case USART_ID_3 :
3165:                            USART_LineControlModeSelect_RXandTXCombined(index, dataFlowConfig);
3166:                            break;
3167:                        case USART_ID_2 :
3168:                            USART_LineControlModeSelect_RXandTXCombined(index, dataFlowConfig);
3169:                            break;
3170:                        case USART_ID_4 :
3171:                            USART_LineControlModeSelect_RXandTXCombined(index, dataFlowConfig);
3172:                            break;
3173:                        case USART_ID_6 :
3174:                            USART_LineControlModeSelect_RXandTXCombined(index, dataFlowConfig);
3175:                            break;
3176:                        case USART_ID_5 :
3177:                            USART_LineControlModeSelect_RXandTXCombined(index, dataFlowConfig);
3178:                            break;
3179:                        case USART_NUMBER_OF_MODULES :
3180:                        default :
3181:                            break;
3182:                    }
3183:                }
3184:                
3185:                PLIB_INLINE_API bool PLIB_USART_ExistsLoopback(USART_MODULE_ID index)
3186:                {
3187:                    switch (index) {
3188:                        case USART_ID_1 :
3189:                            return USART_ExistsLoopback_Default(index);
3190:                        case USART_ID_3 :
3191:                            return USART_ExistsLoopback_Default(index);
3192:                        case USART_ID_2 :
3193:                            return USART_ExistsLoopback_Default(index);
3194:                        case USART_ID_4 :
3195:                            return USART_ExistsLoopback_Default(index);
3196:                        case USART_ID_6 :
3197:                            return USART_ExistsLoopback_Default(index);
3198:                        case USART_ID_5 :
3199:                            return USART_ExistsLoopback_Default(index);
3200:                        case USART_NUMBER_OF_MODULES :
3201:                        default :
3202:                            return (bool)0;
3203:                    }
3204:                }
3205:                
3206:                PLIB_INLINE_API void PLIB_USART_LoopbackEnable(USART_MODULE_ID index)
3207:                {
3208:                    switch (index) {
3209:                        case USART_ID_1 :
3210:                            USART_LoopbackEnable_Default(index);
3211:                            break;
3212:                        case USART_ID_3 :
3213:                            USART_LoopbackEnable_Default(index);
3214:                            break;
3215:                        case USART_ID_2 :
3216:                            USART_LoopbackEnable_Default(index);
3217:                            break;
3218:                        case USART_ID_4 :
3219:                            USART_LoopbackEnable_Default(index);
3220:                            break;
3221:                        case USART_ID_6 :
3222:                            USART_LoopbackEnable_Default(index);
3223:                            break;
3224:                        case USART_ID_5 :
3225:                            USART_LoopbackEnable_Default(index);
3226:                            break;
3227:                        case USART_NUMBER_OF_MODULES :
3228:                        default :
3229:                            break;
3230:                    }
3231:                }
3232:                
3233:                PLIB_INLINE_API void PLIB_USART_LoopbackDisable(USART_MODULE_ID index)
3234:                {
3235:                    switch (index) {
3236:                        case USART_ID_1 :
3237:                            USART_LoopbackDisable_Default(index);
3238:                            break;
3239:                        case USART_ID_3 :
3240:                            USART_LoopbackDisable_Default(index);
3241:                            break;
3242:                        case USART_ID_2 :
3243:                            USART_LoopbackDisable_Default(index);
3244:                            break;
3245:                        case USART_ID_4 :
3246:                            USART_LoopbackDisable_Default(index);
3247:                            break;
3248:                        case USART_ID_6 :
3249:                            USART_LoopbackDisable_Default(index);
3250:                            break;
3251:                        case USART_ID_5 :
3252:                            USART_LoopbackDisable_Default(index);
3253:                            break;
3254:                        case USART_NUMBER_OF_MODULES :
3255:                        default :
3256:                            break;
3257:                    }
3258:                }
3259:                
3260:                PLIB_INLINE_API bool PLIB_USART_ExistsOperationMode(USART_MODULE_ID index)
3261:                {
3262:                    switch (index) {
3263:                        case USART_ID_1 :
3264:                            return USART_ExistsOperationMode_Default(index);
3265:                        case USART_ID_3 :
3266:                            return USART_ExistsOperationMode_Default(index);
3267:                        case USART_ID_2 :
3268:                            return USART_ExistsOperationMode_Default(index);
3269:                        case USART_ID_4 :
3270:                            return USART_ExistsOperationMode_Unsupported(index);
3271:                        case USART_ID_6 :
3272:                            return USART_ExistsOperationMode_Unsupported(index);
3273:                        case USART_ID_5 :
3274:                            return USART_ExistsOperationMode_Unsupported(index);
3275:                        case USART_NUMBER_OF_MODULES :
3276:                        default :
3277:                            return (bool)0;
3278:                    }
3279:                }
3280:                
3281:                PLIB_INLINE_API void PLIB_USART_OperationModeSelect(USART_MODULE_ID index, USART_OPERATION_MODE operationmode)
3282:                {
3283:                    switch (index) {
3284:                        case USART_ID_1 :
3285:                            USART_OperationModeSelect_Default(index, operationmode);
3286:                            break;
3287:                        case USART_ID_3 :
3288:                            USART_OperationModeSelect_Default(index, operationmode);
3289:                            break;
3290:                        case USART_ID_2 :
3291:                            USART_OperationModeSelect_Default(index, operationmode);
3292:                            break;
3293:                        case USART_ID_4 :
3294:                            USART_OperationModeSelect_Unsupported(index, operationmode);
3295:                            break;
3296:                        case USART_ID_6 :
3297:                            USART_OperationModeSelect_Unsupported(index, operationmode);
3298:                            break;
3299:                        case USART_ID_5 :
3300:                            USART_OperationModeSelect_Unsupported(index, operationmode);
3301:                            break;
3302:                        case USART_NUMBER_OF_MODULES :
3303:                        default :
3304:                            break;
3305:                    }
3306:                }
3307:                
3308:                PLIB_INLINE_API bool PLIB_USART_ExistsStopInIdle(USART_MODULE_ID index)
3309:                {
3310:                    switch (index) {
3311:                        case USART_ID_1 :
3312:                            return USART_ExistsStopInIdle_Default(index);
3313:                        case USART_ID_3 :
3314:                            return USART_ExistsStopInIdle_Default(index);
3315:                        case USART_ID_2 :
3316:                            return USART_ExistsStopInIdle_Default(index);
3317:                        case USART_ID_4 :
3318:                            return USART_ExistsStopInIdle_Default(index);
3319:                        case USART_ID_6 :
3320:                            return USART_ExistsStopInIdle_Default(index);
3321:                        case USART_ID_5 :
3322:                            return USART_ExistsStopInIdle_Default(index);
3323:                        case USART_NUMBER_OF_MODULES :
3324:                        default :
3325:                            return (bool)0;
3326:                    }
3327:                }
3328:                
3329:                PLIB_INLINE_API void PLIB_USART_StopInIdleEnable(USART_MODULE_ID index)
3330:                {
3331:                    switch (index) {
3332:                        case USART_ID_1 :
3333:                            USART_StopInIdleEnable_Default(index);
3334:                            break;
3335:                        case USART_ID_3 :
3336:                            USART_StopInIdleEnable_Default(index);
3337:                            break;
3338:                        case USART_ID_2 :
3339:                            USART_StopInIdleEnable_Default(index);
3340:                            break;
3341:                        case USART_ID_4 :
3342:                            USART_StopInIdleEnable_Default(index);
3343:                            break;
3344:                        case USART_ID_6 :
3345:                            USART_StopInIdleEnable_Default(index);
3346:                            break;
3347:                        case USART_ID_5 :
3348:                            USART_StopInIdleEnable_Default(index);
3349:                            break;
3350:                        case USART_NUMBER_OF_MODULES :
3351:                        default :
3352:                            break;
3353:                    }
3354:                }
3355:                
3356:                PLIB_INLINE_API void PLIB_USART_StopInIdleDisable(USART_MODULE_ID index)
3357:                {
3358:                    switch (index) {
3359:                        case USART_ID_1 :
3360:                            USART_StopInIdleDisable_Default(index);
3361:                            break;
3362:                        case USART_ID_3 :
3363:                            USART_StopInIdleDisable_Default(index);
3364:                            break;
3365:                        case USART_ID_2 :
3366:                            USART_StopInIdleDisable_Default(index);
3367:                            break;
3368:                        case USART_ID_4 :
3369:                            USART_StopInIdleDisable_Default(index);
3370:                            break;
3371:                        case USART_ID_6 :
3372:                            USART_StopInIdleDisable_Default(index);
3373:                            break;
3374:                        case USART_ID_5 :
3375:                            USART_StopInIdleDisable_Default(index);
3376:                            break;
3377:                        case USART_NUMBER_OF_MODULES :
3378:                        default :
3379:                            break;
3380:                    }
3381:                }
3382:                
3383:                PLIB_INLINE_API bool PLIB_USART_ExistsRunInOverflow(USART_MODULE_ID index)
3384:                {
3385:                    switch (index) {
3386:                        case USART_ID_1 :
3387:                            return USART_ExistsRunInOverflow_Unsupported(index);
3388:                        case USART_ID_3 :
3389:                            return USART_ExistsRunInOverflow_Unsupported(index);
3390:                        case USART_ID_2 :
3391:                            return USART_ExistsRunInOverflow_Unsupported(index);
3392:                        case USART_ID_4 :
3393:                            return USART_ExistsRunInOverflow_Unsupported(index);
3394:                        case USART_ID_6 :
3395:                            return USART_ExistsRunInOverflow_Unsupported(index);
3396:                        case USART_ID_5 :
3397:                            return USART_ExistsRunInOverflow_Unsupported(index);
3398:                        case USART_NUMBER_OF_MODULES :
3399:                        default :
3400:                            return (bool)0;
3401:                    }
3402:                }
3403:                
3404:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USART_RunInOverflowEnable(USART_MODULE_ID index)
3405:                {
3406:                    switch (index) {
3407:                        case USART_ID_1 :
3408:                            USART_RunInOverflowEnable_Unsupported(index);
3409:                            break;
3410:                        case USART_ID_3 :
3411:                            USART_RunInOverflowEnable_Unsupported(index);
3412:                            break;
3413:                        case USART_ID_2 :
3414:                            USART_RunInOverflowEnable_Unsupported(index);
3415:                            break;
3416:                        case USART_ID_4 :
3417:                            USART_RunInOverflowEnable_Unsupported(index);
3418:                            break;
3419:                        case USART_ID_6 :
3420:                            USART_RunInOverflowEnable_Unsupported(index);
3421:                            break;
3422:                        case USART_ID_5 :
3423:                            USART_RunInOverflowEnable_Unsupported(index);
3424:                            break;
3425:                        case USART_NUMBER_OF_MODULES :
3426:                        default :
3427:                            break;
3428:                    }
3429:                }
3430:                
3431:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USART_RunInOverflowDisable(USART_MODULE_ID index)
3432:                {
3433:                    switch (index) {
3434:                        case USART_ID_1 :
3435:                            USART_RunInOverflowDisable_Unsupported(index);
3436:                            break;
3437:                        case USART_ID_3 :
3438:                            USART_RunInOverflowDisable_Unsupported(index);
3439:                            break;
3440:                        case USART_ID_2 :
3441:                            USART_RunInOverflowDisable_Unsupported(index);
3442:                            break;
3443:                        case USART_ID_4 :
3444:                            USART_RunInOverflowDisable_Unsupported(index);
3445:                            break;
3446:                        case USART_ID_6 :
3447:                            USART_RunInOverflowDisable_Unsupported(index);
3448:                            break;
3449:                        case USART_ID_5 :
3450:                            USART_RunInOverflowDisable_Unsupported(index);
3451:                            break;
3452:                        case USART_NUMBER_OF_MODULES :
3453:                        default :
3454:                            break;
3455:                    }
3456:                }
3457:                
3458:                PLIB_INLINE_API bool _PLIB_UNSUPPORTED PLIB_USART_RunInOverflowIsEnabled(USART_MODULE_ID index)
3459:                {
3460:                    switch (index) {
3461:                        case USART_ID_1 :
3462:                            return USART_RunInOverflowIsEnabled_Unsupported(index);
3463:                        case USART_ID_3 :
3464:                            return USART_RunInOverflowIsEnabled_Unsupported(index);
3465:                        case USART_ID_2 :
3466:                            return USART_RunInOverflowIsEnabled_Unsupported(index);
3467:                        case USART_ID_4 :
3468:                            return USART_RunInOverflowIsEnabled_Unsupported(index);
3469:                        case USART_ID_6 :
3470:                            return USART_RunInOverflowIsEnabled_Unsupported(index);
3471:                        case USART_ID_5 :
3472:                            return USART_RunInOverflowIsEnabled_Unsupported(index);
3473:                        case USART_NUMBER_OF_MODULES :
3474:                        default :
3475:                            return (bool)0;
3476:                    }
3477:                }
3478:                
3479:                PLIB_INLINE_API bool PLIB_USART_ExistsBRGClockSourceSelect(USART_MODULE_ID index)
3480:                {
3481:                    switch (index) {
3482:                        case USART_ID_1 :
3483:                            return USART_ExistsBRGClockSourceSelect_Unsupported(index);
3484:                        case USART_ID_3 :
3485:                            return USART_ExistsBRGClockSourceSelect_Unsupported(index);
3486:                        case USART_ID_2 :
3487:                            return USART_ExistsBRGClockSourceSelect_Unsupported(index);
3488:                        case USART_ID_4 :
3489:                            return USART_ExistsBRGClockSourceSelect_Unsupported(index);
3490:                        case USART_ID_6 :
3491:                            return USART_ExistsBRGClockSourceSelect_Unsupported(index);
3492:                        case USART_ID_5 :
3493:                            return USART_ExistsBRGClockSourceSelect_Unsupported(index);
3494:                        case USART_NUMBER_OF_MODULES :
3495:                        default :
3496:                            return (bool)0;
3497:                    }
3498:                }
3499:                
3500:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USART_BRGClockSourceSelect(USART_MODULE_ID index, USART_BRG_CLOCK_SOURCE brgClockSource)
3501:                {
3502:                    switch (index) {
3503:                        case USART_ID_1 :
3504:                            USART_BRGClockSourceSelect_Unsupported(index, brgClockSource);
3505:                            break;
3506:                        case USART_ID_3 :
3507:                            USART_BRGClockSourceSelect_Unsupported(index, brgClockSource);
3508:                            break;
3509:                        case USART_ID_2 :
3510:                            USART_BRGClockSourceSelect_Unsupported(index, brgClockSource);
3511:                            break;
3512:                        case USART_ID_4 :
3513:                            USART_BRGClockSourceSelect_Unsupported(index, brgClockSource);
3514:                            break;
3515:                        case USART_ID_6 :
3516:                            USART_BRGClockSourceSelect_Unsupported(index, brgClockSource);
3517:                            break;
3518:                        case USART_ID_5 :
3519:                            USART_BRGClockSourceSelect_Unsupported(index, brgClockSource);
3520:                            break;
3521:                        case USART_NUMBER_OF_MODULES :
3522:                        default :
3523:                            break;
3524:                    }
3525:                }
3526:                
3527:                PLIB_INLINE_API USART_BRG_CLOCK_SOURCE _PLIB_UNSUPPORTED PLIB_USART_BRGClockSourceGet(USART_MODULE_ID index)
3528:                {
3529:                    switch (index) {
3530:                        case USART_ID_1 :
3531:                            return USART_BRGClockSourceGet_Unsupported(index);
3532:                        case USART_ID_3 :
3533:                            return USART_BRGClockSourceGet_Unsupported(index);
3534:                        case USART_ID_2 :
3535:                            return USART_BRGClockSourceGet_Unsupported(index);
3536:                        case USART_ID_4 :
3537:                            return USART_BRGClockSourceGet_Unsupported(index);
3538:                        case USART_ID_6 :
3539:                            return USART_BRGClockSourceGet_Unsupported(index);
3540:                        case USART_ID_5 :
3541:                            return USART_BRGClockSourceGet_Unsupported(index);
3542:                        case USART_NUMBER_OF_MODULES :
3543:                        default :
3544:                            return (USART_BRG_CLOCK_SOURCE)0;
3545:                    }
3546:                }
3547:                
3548:                PLIB_INLINE_API bool PLIB_USART_ExistsModuleBusyStatus(USART_MODULE_ID index)
3549:                {
3550:                    switch (index) {
3551:                        case USART_ID_1 :
3552:                            return USART_ExistsModuleBusyStatus_Unsupported(index);
3553:                        case USART_ID_3 :
3554:                            return USART_ExistsModuleBusyStatus_Unsupported(index);
3555:                        case USART_ID_2 :
3556:                            return USART_ExistsModuleBusyStatus_Unsupported(index);
3557:                        case USART_ID_4 :
3558:                            return USART_ExistsModuleBusyStatus_Unsupported(index);
3559:                        case USART_ID_6 :
3560:                            return USART_ExistsModuleBusyStatus_Unsupported(index);
3561:                        case USART_ID_5 :
3562:                            return USART_ExistsModuleBusyStatus_Unsupported(index);
3563:                        case USART_NUMBER_OF_MODULES :
3564:                        default :
3565:                            return (bool)0;
3566:                    }
3567:                }
3568:                
3569:                PLIB_INLINE_API bool _PLIB_UNSUPPORTED PLIB_USART_ModuleIsBusy(USART_MODULE_ID index)
3570:                {
3571:                    switch (index) {
3572:                        case USART_ID_1 :
3573:                            return USART_ModuleIsBusy_Unsupported(index);
3574:                        case USART_ID_3 :
3575:                            return USART_ModuleIsBusy_Unsupported(index);
3576:                        case USART_ID_2 :
3577:                            return USART_ModuleIsBusy_Unsupported(index);
3578:                        case USART_ID_4 :
3579:                            return USART_ModuleIsBusy_Unsupported(index);
3580:                        case USART_ID_6 :
3581:                            return USART_ModuleIsBusy_Unsupported(index);
3582:                        case USART_ID_5 :
3583:                            return USART_ModuleIsBusy_Unsupported(index);
3584:                        case USART_NUMBER_OF_MODULES :
3585:                        default :
3586:                            return (bool)0;
3587:                    }
3588:                }
3589:                
3590:                PLIB_INLINE_API bool PLIB_USART_ExistsRunInSleepMode(USART_MODULE_ID index)
3591:                {
3592:                    switch (index) {
3593:                        case USART_ID_1 :
3594:                            return USART_ExistsRunInSleepMode_Unsupported(index);
3595:                        case USART_ID_3 :
3596:                            return USART_ExistsRunInSleepMode_Unsupported(index);
3597:                        case USART_ID_2 :
3598:                            return USART_ExistsRunInSleepMode_Unsupported(index);
3599:                        case USART_ID_4 :
3600:                            return USART_ExistsRunInSleepMode_Unsupported(index);
3601:                        case USART_ID_6 :
3602:                            return USART_ExistsRunInSleepMode_Unsupported(index);
3603:                        case USART_ID_5 :
3604:                            return USART_ExistsRunInSleepMode_Unsupported(index);
3605:                        case USART_NUMBER_OF_MODULES :
3606:                        default :
3607:                            return (bool)0;
3608:                    }
3609:                }
3610:                
3611:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USART_RunInSleepModeEnable(USART_MODULE_ID index)
3612:                {
3613:                    switch (index) {
3614:                        case USART_ID_1 :
3615:                            USART_RunInSleepModeEnable_Unsupported(index);
3616:                            break;
3617:                        case USART_ID_3 :
3618:                            USART_RunInSleepModeEnable_Unsupported(index);
3619:                            break;
3620:                        case USART_ID_2 :
3621:                            USART_RunInSleepModeEnable_Unsupported(index);
3622:                            break;
3623:                        case USART_ID_4 :
3624:                            USART_RunInSleepModeEnable_Unsupported(index);
3625:                            break;
3626:                        case USART_ID_6 :
3627:                            USART_RunInSleepModeEnable_Unsupported(index);
3628:                            break;
3629:                        case USART_ID_5 :
3630:                            USART_RunInSleepModeEnable_Unsupported(index);
3631:                            break;
3632:                        case USART_NUMBER_OF_MODULES :
3633:                        default :
3634:                            break;
3635:                    }
3636:                }
3637:                
3638:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USART_RunInSleepModeDisable(USART_MODULE_ID index)
3639:                {
3640:                    switch (index) {
3641:                        case USART_ID_1 :
3642:                            USART_RunInSleepModeDisable_Unsupported(index);
3643:                            break;
3644:                        case USART_ID_3 :
3645:                            USART_RunInSleepModeDisable_Unsupported(index);
3646:                            break;
3647:                        case USART_ID_2 :
3648:                            USART_RunInSleepModeDisable_Unsupported(index);
3649:                            break;
3650:                        case USART_ID_4 :
3651:                            USART_RunInSleepModeDisable_Unsupported(index);
3652:                            break;
3653:                        case USART_ID_6 :
3654:                            USART_RunInSleepModeDisable_Unsupported(index);
3655:                            break;
3656:                        case USART_ID_5 :
3657:                            USART_RunInSleepModeDisable_Unsupported(index);
3658:                            break;
3659:                        case USART_NUMBER_OF_MODULES :
3660:                        default :
3661:                            break;
3662:                    }
3663:                }
3664:                
3665:                PLIB_INLINE_API bool _PLIB_UNSUPPORTED PLIB_USART_RunInSleepModeIsEnabled(USART_MODULE_ID index)
3666:                {
3667:                    switch (index) {
3668:                        case USART_ID_1 :
3669:                            return USART_RunInSleepModeIsEnabled_Unsupported(index);
3670:                        case USART_ID_3 :
3671:                            return USART_RunInSleepModeIsEnabled_Unsupported(index);
3672:                        case USART_ID_2 :
3673:                            return USART_RunInSleepModeIsEnabled_Unsupported(index);
3674:                        case USART_ID_4 :
3675:                            return USART_RunInSleepModeIsEnabled_Unsupported(index);
3676:                        case USART_ID_6 :
3677:                            return USART_RunInSleepModeIsEnabled_Unsupported(index);
3678:                        case USART_ID_5 :
3679:                            return USART_RunInSleepModeIsEnabled_Unsupported(index);
3680:                        case USART_NUMBER_OF_MODULES :
3681:                        default :
3682:                            return (bool)0;
3683:                    }
3684:                }
3685:                
3686:                PLIB_INLINE_API bool PLIB_USART_ExistsWakeOnStart(USART_MODULE_ID index)
3687:                {
3688:                    switch (index) {
3689:                        case USART_ID_1 :
3690:                            return USART_ExistsWakeOnStart_Default(index);
3691:                        case USART_ID_3 :
3692:                            return USART_ExistsWakeOnStart_Default(index);
3693:                        case USART_ID_2 :
3694:                            return USART_ExistsWakeOnStart_Default(index);
3695:                        case USART_ID_4 :
3696:                            return USART_ExistsWakeOnStart_Default(index);
3697:                        case USART_ID_6 :
3698:                            return USART_ExistsWakeOnStart_Default(index);
3699:                        case USART_ID_5 :
3700:                            return USART_ExistsWakeOnStart_Default(index);
3701:                        case USART_NUMBER_OF_MODULES :
3702:                        default :
3703:                            return (bool)0;
3704:                    }
3705:                }
3706:                
3707:                PLIB_INLINE_API void PLIB_USART_WakeOnStartEnable(USART_MODULE_ID index)
3708:                {
3709:                    switch (index) {
3710:                        case USART_ID_1 :
3711:                            USART_WakeOnStartEnable_Default(index);
3712:                            break;
3713:                        case USART_ID_3 :
3714:                            USART_WakeOnStartEnable_Default(index);
3715:                            break;
3716:                        case USART_ID_2 :
3717:                            USART_WakeOnStartEnable_Default(index);
3718:                            break;
3719:                        case USART_ID_4 :
3720:                            USART_WakeOnStartEnable_Default(index);
3721:                            break;
3722:                        case USART_ID_6 :
3723:                            USART_WakeOnStartEnable_Default(index);
3724:                            break;
3725:                        case USART_ID_5 :
3726:                            USART_WakeOnStartEnable_Default(index);
3727:                            break;
3728:                        case USART_NUMBER_OF_MODULES :
3729:                        default :
3730:                            break;
3731:                    }
3732:                }
3733:                
3734:                PLIB_INLINE_API void PLIB_USART_WakeOnStartDisable(USART_MODULE_ID index)
3735:                {
3736:                    switch (index) {
3737:                        case USART_ID_1 :
3738:                            USART_WakeOnStartDisable_Default(index);
3739:                            break;
3740:                        case USART_ID_3 :
3741:                            USART_WakeOnStartDisable_Default(index);
3742:                            break;
3743:                        case USART_ID_2 :
3744:                            USART_WakeOnStartDisable_Default(index);
3745:                            break;
3746:                        case USART_ID_4 :
3747:                            USART_WakeOnStartDisable_Default(index);
3748:                            break;
3749:                        case USART_ID_6 :
3750:                            USART_WakeOnStartDisable_Default(index);
3751:                            break;
3752:                        case USART_ID_5 :
3753:                            USART_WakeOnStartDisable_Default(index);
3754:                            break;
3755:                        case USART_NUMBER_OF_MODULES :
3756:                        default :
3757:                            break;
3758:                    }
3759:                }
3760:                
3761:                PLIB_INLINE_API bool PLIB_USART_WakeOnStartIsEnabled(USART_MODULE_ID index)
3762:                {
3763:                    switch (index) {
3764:                        case USART_ID_1 :
3765:                            return USART_WakeOnStartIsEnabled_Default(index);
3766:                        case USART_ID_3 :
3767:                            return USART_WakeOnStartIsEnabled_Default(index);
3768:                        case USART_ID_2 :
3769:                            return USART_WakeOnStartIsEnabled_Default(index);
3770:                        case USART_ID_4 :
3771:                            return USART_WakeOnStartIsEnabled_Default(index);
3772:                        case USART_ID_6 :
3773:                            return USART_WakeOnStartIsEnabled_Default(index);
3774:                        case USART_ID_5 :
3775:                            return USART_WakeOnStartIsEnabled_Default(index);
3776:                        case USART_NUMBER_OF_MODULES :
3777:                        default :
3778:                            return (bool)0;
3779:                    }
3780:                }
3781:                
3782:                PLIB_INLINE_API void PLIB_USART_InitializeModeGeneral(USART_MODULE_ID index, bool autobaud, bool loopBackMode, bool wakeFromSleep, bool irdaMode, bool stopInIdle)
3783:                {
3784:                    switch (index) {
9D001690  2C8A0006   SLTIU T2, A0, 6
9D001694  114000BC   BEQ T2, ZERO, 0x9D001988
9D001698  7C630040   EXT V1, V1, 1, 1
9D00169C  00042080   SLL A0, A0, 2
9D0016A0  3C0A9D00   LUI T2, -25344
9D0016A4  254A16B8   ADDIU T2, T2, 5816
9D0016A8  01442021   ADDU A0, T2, A0
9D0016AC  8C840000   LW A0, 0(A0)
9D0016B0  00800008   JR A0
9D0016B4  00000000   NOP
3785:                        case USART_ID_1 :
3786:                            USART_InitializeModeGeneral_Default(index, autobaud, loopBackMode, wakeFromSleep, irdaMode, stopInIdle);
3787:                            break;
3788:                        case USART_ID_3 :
3789:                            USART_InitializeModeGeneral_Default(index, autobaud, loopBackMode, wakeFromSleep, irdaMode, stopInIdle);
3790:                            break;
3791:                        case USART_ID_2 :
3792:                            USART_InitializeModeGeneral_Default(index, autobaud, loopBackMode, wakeFromSleep, irdaMode, stopInIdle);
3793:                            break;
3794:                        case USART_ID_4 :
3795:                            USART_InitializeModeGeneral_Default(index, autobaud, loopBackMode, wakeFromSleep, irdaMode, stopInIdle);
3796:                            break;
3797:                        case USART_ID_6 :
3798:                            USART_InitializeModeGeneral_Default(index, autobaud, loopBackMode, wakeFromSleep, irdaMode, stopInIdle);
3799:                            break;
3800:                        case USART_ID_5 :
3801:                            USART_InitializeModeGeneral_Default(index, autobaud, loopBackMode, wakeFromSleep, irdaMode, stopInIdle);
3802:                            break;
3803:                        case USART_NUMBER_OF_MODULES :
3804:                        default :
3805:                            break;
3806:                    }
3807:                }
3808:                
3809:                PLIB_INLINE_API USART_ERROR PLIB_USART_ErrorsGet(USART_MODULE_ID index)
3810:                {
3811:                    switch (index) {
3812:                        case USART_ID_1 :
3813:                            return USART_ErrorsGet_Default(index);
3814:                        case USART_ID_3 :
3815:                            return USART_ErrorsGet_Default(index);
3816:                        case USART_ID_2 :
3817:                            return USART_ErrorsGet_Default(index);
3818:                        case USART_ID_4 :
3819:                            return USART_ErrorsGet_Default(index);
3820:                        case USART_ID_6 :
3821:                            return USART_ErrorsGet_Default(index);
3822:                        case USART_ID_5 :
3823:                            return USART_ErrorsGet_Default(index);
3824:                        case USART_NUMBER_OF_MODULES :
3825:                        default :
3826:                            return (USART_ERROR)0;
3827:                    }
3828:                }
3829:                
3830:                PLIB_INLINE_API bool PLIB_USART_ExistsBaudRate(USART_MODULE_ID index)
3831:                {
3832:                    switch (index) {
3833:                        case USART_ID_1 :
3834:                            return USART_ExistsBaudRate_In16BitRegister(index);
3835:                        case USART_ID_3 :
3836:                            return USART_ExistsBaudRate_In16BitRegister(index);
3837:                        case USART_ID_2 :
3838:                            return USART_ExistsBaudRate_In16BitRegister(index);
3839:                        case USART_ID_4 :
3840:                            return USART_ExistsBaudRate_In16BitRegister(index);
3841:                        case USART_ID_6 :
3842:                            return USART_ExistsBaudRate_In16BitRegister(index);
3843:                        case USART_ID_5 :
3844:                            return USART_ExistsBaudRate_In16BitRegister(index);
3845:                        case USART_NUMBER_OF_MODULES :
3846:                        default :
3847:                            return (bool)0;
3848:                    }
3849:                }
3850:                
3851:                PLIB_INLINE_API void PLIB_USART_BaudRateSet(USART_MODULE_ID index, uint32_t clockFrequency, uint32_t baudRate)
3852:                {
3853:                    switch (index) {
3854:                        case USART_ID_1 :
3855:                            USART_BaudRateSet_In16BitRegister(index, clockFrequency, baudRate);
3856:                            break;
3857:                        case USART_ID_3 :
3858:                            USART_BaudRateSet_In16BitRegister(index, clockFrequency, baudRate);
3859:                            break;
3860:                        case USART_ID_2 :
3861:                            USART_BaudRateSet_In16BitRegister(index, clockFrequency, baudRate);
3862:                            break;
3863:                        case USART_ID_4 :
3864:                            USART_BaudRateSet_In16BitRegister(index, clockFrequency, baudRate);
3865:                            break;
3866:                        case USART_ID_6 :
3867:                            USART_BaudRateSet_In16BitRegister(index, clockFrequency, baudRate);
3868:                            break;
3869:                        case USART_ID_5 :
3870:                            USART_BaudRateSet_In16BitRegister(index, clockFrequency, baudRate);
3871:                            break;
3872:                        case USART_NUMBER_OF_MODULES :
3873:                        default :
3874:                            break;
3875:                    }
3876:                }
3877:                
3878:                PLIB_INLINE_API uint32_t PLIB_USART_BaudRateGet(USART_MODULE_ID index, int32_t clockFrequency)
3879:                {
3880:                    switch (index) {
3881:                        case USART_ID_1 :
3882:                            return USART_BaudRateGet_In16BitRegister(index, clockFrequency);
3883:                        case USART_ID_3 :
3884:                            return USART_BaudRateGet_In16BitRegister(index, clockFrequency);
3885:                        case USART_ID_2 :
3886:                            return USART_BaudRateGet_In16BitRegister(index, clockFrequency);
3887:                        case USART_ID_4 :
3888:                            return USART_BaudRateGet_In16BitRegister(index, clockFrequency);
3889:                        case USART_ID_6 :
3890:                            return USART_BaudRateGet_In16BitRegister(index, clockFrequency);
3891:                        case USART_ID_5 :
3892:                            return USART_BaudRateGet_In16BitRegister(index, clockFrequency);
3893:                        case USART_NUMBER_OF_MODULES :
3894:                        default :
3895:                            return (uint32_t)0;
3896:                    }
3897:                }
3898:                
3899:                PLIB_INLINE_API bool PLIB_USART_ExistsBaudRateAutoDetect(USART_MODULE_ID index)
3900:                {
3901:                    switch (index) {
3902:                        case USART_ID_1 :
3903:                            return USART_ExistsBaudRateAutoDetect_Default(index);
3904:                        case USART_ID_3 :
3905:                            return USART_ExistsBaudRateAutoDetect_Default(index);
3906:                        case USART_ID_2 :
3907:                            return USART_ExistsBaudRateAutoDetect_Default(index);
3908:                        case USART_ID_4 :
3909:                            return USART_ExistsBaudRateAutoDetect_Default(index);
3910:                        case USART_ID_6 :
3911:                            return USART_ExistsBaudRateAutoDetect_Default(index);
3912:                        case USART_ID_5 :
3913:                            return USART_ExistsBaudRateAutoDetect_Default(index);
3914:                        case USART_NUMBER_OF_MODULES :
3915:                        default :
3916:                            return (bool)0;
3917:                    }
3918:                }
3919:                
3920:                PLIB_INLINE_API void PLIB_USART_BaudRateAutoDetectEnable(USART_MODULE_ID index)
3921:                {
3922:                    switch (index) {
3923:                        case USART_ID_1 :
3924:                            USART_BaudRateAutoDetectEnable_Default(index);
3925:                            break;
3926:                        case USART_ID_3 :
3927:                            USART_BaudRateAutoDetectEnable_Default(index);
3928:                            break;
3929:                        case USART_ID_2 :
3930:                            USART_BaudRateAutoDetectEnable_Default(index);
3931:                            break;
3932:                        case USART_ID_4 :
3933:                            USART_BaudRateAutoDetectEnable_Default(index);
3934:                            break;
3935:                        case USART_ID_6 :
3936:                            USART_BaudRateAutoDetectEnable_Default(index);
3937:                            break;
3938:                        case USART_ID_5 :
3939:                            USART_BaudRateAutoDetectEnable_Default(index);
3940:                            break;
3941:                        case USART_NUMBER_OF_MODULES :
3942:                        default :
3943:                            break;
3944:                    }
3945:                }
3946:                
3947:                PLIB_INLINE_API bool PLIB_USART_BaudRateAutoDetectIsComplete(USART_MODULE_ID index)
3948:                {
3949:                    switch (index) {
3950:                        case USART_ID_1 :
3951:                            return USART_BaudRateAutoDetectIsComplete_Default(index);
3952:                        case USART_ID_3 :
3953:                            return USART_BaudRateAutoDetectIsComplete_Default(index);
3954:                        case USART_ID_2 :
3955:                            return USART_BaudRateAutoDetectIsComplete_Default(index);
3956:                        case USART_ID_4 :
3957:                            return USART_BaudRateAutoDetectIsComplete_Default(index);
3958:                        case USART_ID_6 :
3959:                            return USART_BaudRateAutoDetectIsComplete_Default(index);
3960:                        case USART_ID_5 :
3961:                            return USART_BaudRateAutoDetectIsComplete_Default(index);
3962:                        case USART_NUMBER_OF_MODULES :
3963:                        default :
3964:                            return (bool)0;
3965:                    }
3966:                }
3967:                
3968:                PLIB_INLINE_API bool PLIB_USART_ExistsBaudRateHigh(USART_MODULE_ID index)
3969:                {
3970:                    switch (index) {
3971:                        case USART_ID_1 :
3972:                            return USART_ExistsBaudRateHigh_In16BitRegister(index);
3973:                        case USART_ID_3 :
3974:                            return USART_ExistsBaudRateHigh_In16BitRegister(index);
3975:                        case USART_ID_2 :
3976:                            return USART_ExistsBaudRateHigh_In16BitRegister(index);
3977:                        case USART_ID_4 :
3978:                            return USART_ExistsBaudRateHigh_In16BitRegister(index);
3979:                        case USART_ID_6 :
3980:                            return USART_ExistsBaudRateHigh_In16BitRegister(index);
3981:                        case USART_ID_5 :
3982:                            return USART_ExistsBaudRateHigh_In16BitRegister(index);
3983:                        case USART_NUMBER_OF_MODULES :
3984:                        default :
3985:                            return (bool)0;
3986:                    }
3987:                }
3988:                
3989:                PLIB_INLINE_API void PLIB_USART_BaudRateHighSet(USART_MODULE_ID index, uint32_t clockFrequency, uint32_t baudRate)
3990:                {
3991:                    switch (index) {
3992:                        case USART_ID_1 :
3993:                            USART_BaudRateHighSet_In16BitRegister(index, clockFrequency, baudRate);
3994:                            break;
3995:                        case USART_ID_3 :
3996:                            USART_BaudRateHighSet_In16BitRegister(index, clockFrequency, baudRate);
3997:                            break;
3998:                        case USART_ID_2 :
3999:                            USART_BaudRateHighSet_In16BitRegister(index, clockFrequency, baudRate);
4000:                            break;
4001:                        case USART_ID_4 :
4002:                            USART_BaudRateHighSet_In16BitRegister(index, clockFrequency, baudRate);
4003:                            break;
4004:                        case USART_ID_6 :
4005:                            USART_BaudRateHighSet_In16BitRegister(index, clockFrequency, baudRate);
4006:                            break;
4007:                        case USART_ID_5 :
4008:                            USART_BaudRateHighSet_In16BitRegister(index, clockFrequency, baudRate);
4009:                            break;
4010:                        case USART_NUMBER_OF_MODULES :
4011:                        default :
4012:                            break;
4013:                    }
4014:                }
4015:                
4016:                PLIB_INLINE_API void PLIB_USART_BaudRateHighDisable(USART_MODULE_ID index)
4017:                {
4018:                    switch (index) {
000001D4  00000000   NOP
4019:                        case USART_ID_1 :
4020:                            USART_BaudRateHighDisable_In16BitRegister(index);
4021:                            break;
4022:                        case USART_ID_3 :
4023:                            USART_BaudRateHighDisable_In16BitRegister(index);
4024:                            break;
4025:                        case USART_ID_2 :
4026:                            USART_BaudRateHighDisable_In16BitRegister(index);
4027:                            break;
4028:                        case USART_ID_4 :
4029:                            USART_BaudRateHighDisable_In16BitRegister(index);
4030:                            break;
4031:                        case USART_ID_6 :
4032:                            USART_BaudRateHighDisable_In16BitRegister(index);
4033:                            break;
4034:                        case USART_ID_5 :
4035:                            USART_BaudRateHighDisable_In16BitRegister(index);
4036:                            break;
4037:                        case USART_NUMBER_OF_MODULES :
4038:                        default :
4039:                            break;
4040:                    }
4041:                }
4042:                
4043:                PLIB_INLINE_API void PLIB_USART_BaudRateHighEnable(USART_MODULE_ID index)
4044:                {
4045:                    switch (index) {
00000078  00000000   NOP
4046:                        case USART_ID_1 :
4047:                            USART_BaudRateHighEnable_In16BitRegister(index);
4048:                            break;
4049:                        case USART_ID_3 :
4050:                            USART_BaudRateHighEnable_In16BitRegister(index);
4051:                            break;
4052:                        case USART_ID_2 :
4053:                            USART_BaudRateHighEnable_In16BitRegister(index);
4054:                            break;
4055:                        case USART_ID_4 :
4056:                            USART_BaudRateHighEnable_In16BitRegister(index);
4057:                            break;
4058:                        case USART_ID_6 :
4059:                            USART_BaudRateHighEnable_In16BitRegister(index);
4060:                            break;
4061:                        case USART_ID_5 :
4062:                            USART_BaudRateHighEnable_In16BitRegister(index);
4063:                            break;
4064:                        case USART_NUMBER_OF_MODULES :
4065:                        default :
4066:                            break;
4067:                    }
4068:                }
4069:                
4070:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiver(USART_MODULE_ID index)
4071:                {
4072:                    switch (index) {
4073:                        case USART_ID_1 :
4074:                            return USART_ExistsReceiver_Default(index);
4075:                        case USART_ID_3 :
4076:                            return USART_ExistsReceiver_Default(index);
4077:                        case USART_ID_2 :
4078:                            return USART_ExistsReceiver_Default(index);
4079:                        case USART_ID_4 :
4080:                            return USART_ExistsReceiver_Default(index);
4081:                        case USART_ID_6 :
4082:                            return USART_ExistsReceiver_Default(index);
4083:                        case USART_ID_5 :
4084:                            return USART_ExistsReceiver_Default(index);
4085:                        case USART_NUMBER_OF_MODULES :
4086:                        default :
4087:                            return (bool)0;
4088:                    }
4089:                }
4090:                
4091:                PLIB_INLINE_API int8_t PLIB_USART_ReceiverByteReceive(USART_MODULE_ID index)
4092:                {
4093:                    switch (index) {
0000003C  00000000   NOP
00000064  00000000   NOP
0000008C  00000000   NOP
4094:                        case USART_ID_1 :
4095:                            return USART_ReceiverByteReceive_Default(index);
4096:                        case USART_ID_3 :
4097:                            return USART_ReceiverByteReceive_Default(index);
4098:                        case USART_ID_2 :
4099:                            return USART_ReceiverByteReceive_Default(index);
4100:                        case USART_ID_4 :
4101:                            return USART_ReceiverByteReceive_Default(index);
4102:                        case USART_ID_6 :
4103:                            return USART_ReceiverByteReceive_Default(index);
4104:                        case USART_ID_5 :
4105:                            return USART_ReceiverByteReceive_Default(index);
4106:                        case USART_NUMBER_OF_MODULES :
4107:                        default :
4108:                            return (int8_t)0;
00000090  00000000   NOP
000000C4  00000000   NOP
4109:                    }
4110:                }
4111:                
4112:                PLIB_INLINE_API void* PLIB_USART_ReceiverAddressGet(USART_MODULE_ID index)
4113:                {
4114:                    switch (index) {
4115:                        case USART_ID_1 :
4116:                            return USART_ReceiverAddressGet_Default(index);
4117:                        case USART_ID_3 :
4118:                            return USART_ReceiverAddressGet_Default(index);
4119:                        case USART_ID_2 :
4120:                            return USART_ReceiverAddressGet_Default(index);
4121:                        case USART_ID_4 :
4122:                            return USART_ReceiverAddressGet_Default(index);
4123:                        case USART_ID_6 :
4124:                            return USART_ReceiverAddressGet_Default(index);
4125:                        case USART_ID_5 :
4126:                            return USART_ReceiverAddressGet_Default(index);
4127:                        case USART_NUMBER_OF_MODULES :
4128:                        default :
4129:                            return (void*)0;
4130:                    }
4131:                }
4132:                
4133:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiver9Bits(USART_MODULE_ID index)
4134:                {
4135:                    switch (index) {
4136:                        case USART_ID_1 :
4137:                            return USART_ExistsReceiver9Bits_Default(index);
4138:                        case USART_ID_3 :
4139:                            return USART_ExistsReceiver9Bits_Default(index);
4140:                        case USART_ID_2 :
4141:                            return USART_ExistsReceiver9Bits_Default(index);
4142:                        case USART_ID_4 :
4143:                            return USART_ExistsReceiver9Bits_Default(index);
4144:                        case USART_ID_6 :
4145:                            return USART_ExistsReceiver9Bits_Default(index);
4146:                        case USART_ID_5 :
4147:                            return USART_ExistsReceiver9Bits_Default(index);
4148:                        case USART_NUMBER_OF_MODULES :
4149:                        default :
4150:                            return (bool)0;
4151:                    }
4152:                }
4153:                
4154:                PLIB_INLINE_API int16_t PLIB_USART_Receiver9BitsReceive(USART_MODULE_ID index)
4155:                {
4156:                    switch (index) {
4157:                        case USART_ID_1 :
4158:                            return USART_Receiver9BitsReceive_Default(index);
4159:                        case USART_ID_3 :
4160:                            return USART_Receiver9BitsReceive_Default(index);
4161:                        case USART_ID_2 :
4162:                            return USART_Receiver9BitsReceive_Default(index);
4163:                        case USART_ID_4 :
4164:                            return USART_Receiver9BitsReceive_Default(index);
4165:                        case USART_ID_6 :
4166:                            return USART_Receiver9BitsReceive_Default(index);
4167:                        case USART_ID_5 :
4168:                            return USART_Receiver9BitsReceive_Default(index);
4169:                        case USART_NUMBER_OF_MODULES :
4170:                        default :
4171:                            return (int16_t)0;
4172:                    }
4173:                }
4174:                
4175:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverAddressAutoDetect(USART_MODULE_ID index)
4176:                {
4177:                    switch (index) {
4178:                        case USART_ID_1 :
4179:                            return USART_ExistsReceiverAddressAutoDetect_Default(index);
4180:                        case USART_ID_3 :
4181:                            return USART_ExistsReceiverAddressAutoDetect_Default(index);
4182:                        case USART_ID_2 :
4183:                            return USART_ExistsReceiverAddressAutoDetect_Default(index);
4184:                        case USART_ID_4 :
4185:                            return USART_ExistsReceiverAddressAutoDetect_Default(index);
4186:                        case USART_ID_6 :
4187:                            return USART_ExistsReceiverAddressAutoDetect_Default(index);
4188:                        case USART_ID_5 :
4189:                            return USART_ExistsReceiverAddressAutoDetect_Default(index);
4190:                        case USART_NUMBER_OF_MODULES :
4191:                        default :
4192:                            return (bool)0;
4193:                    }
4194:                }
4195:                
4196:                PLIB_INLINE_API void PLIB_USART_ReceiverAddressAutoDetectEnable(USART_MODULE_ID index, int8_t Mask)
4197:                {
4198:                    switch (index) {
9D001560  10400027   BEQ V0, ZERO, 0x9D001600
9D001564  00003021   ADDU A2, ZERO, ZERO
9D001568  00041080   SLL V0, A0, 2
9D00156C  3C039D00   LUI V1, -25344
9D001570  24631584   ADDIU V1, V1, 5508
9D001574  00621021   ADDU V0, V1, V0
9D001578  8C420000   LW V0, 0(V0)
9D00157C  00400008   JR V0
9D001580  00000000   NOP
4199:                        case USART_ID_1 :
4200:                            USART_ReceiverAddressAutoDetectEnable_Default(index, Mask);
4201:                            break;
4202:                        case USART_ID_3 :
4203:                            USART_ReceiverAddressAutoDetectEnable_Default(index, Mask);
4204:                            break;
4205:                        case USART_ID_2 :
4206:                            USART_ReceiverAddressAutoDetectEnable_Default(index, Mask);
4207:                            break;
4208:                        case USART_ID_4 :
4209:                            USART_ReceiverAddressAutoDetectEnable_Default(index, Mask);
4210:                            break;
4211:                        case USART_ID_6 :
4212:                            USART_ReceiverAddressAutoDetectEnable_Default(index, Mask);
4213:                            break;
4214:                        case USART_ID_5 :
4215:                            USART_ReceiverAddressAutoDetectEnable_Default(index, Mask);
4216:                            break;
4217:                        case USART_NUMBER_OF_MODULES :
4218:                        default :
4219:                            break;
4220:                    }
4221:                }
4222:                
4223:                PLIB_INLINE_API void PLIB_USART_ReceiverAddressAutoDetectDisable(USART_MODULE_ID index)
4224:                {
4225:                    switch (index) {
4226:                        case USART_ID_1 :
4227:                            USART_ReceiverAddressAutoDetectDisable_Default(index);
4228:                            break;
4229:                        case USART_ID_3 :
4230:                            USART_ReceiverAddressAutoDetectDisable_Default(index);
4231:                            break;
4232:                        case USART_ID_2 :
4233:                            USART_ReceiverAddressAutoDetectDisable_Default(index);
4234:                            break;
4235:                        case USART_ID_4 :
4236:                            USART_ReceiverAddressAutoDetectDisable_Default(index);
4237:                            break;
4238:                        case USART_ID_6 :
4239:                            USART_ReceiverAddressAutoDetectDisable_Default(index);
4240:                            break;
4241:                        case USART_ID_5 :
4242:                            USART_ReceiverAddressAutoDetectDisable_Default(index);
4243:                            break;
4244:                        case USART_NUMBER_OF_MODULES :
4245:                        default :
4246:                            break;
4247:                    }
4248:                }
4249:                
4250:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverAddressDetect(USART_MODULE_ID index)
4251:                {
4252:                    switch (index) {
4253:                        case USART_ID_1 :
4254:                            return USART_ExistsReceiverAddressDetect_Default(index);
4255:                        case USART_ID_3 :
4256:                            return USART_ExistsReceiverAddressDetect_Default(index);
4257:                        case USART_ID_2 :
4258:                            return USART_ExistsReceiverAddressDetect_Default(index);
4259:                        case USART_ID_4 :
4260:                            return USART_ExistsReceiverAddressDetect_Default(index);
4261:                        case USART_ID_6 :
4262:                            return USART_ExistsReceiverAddressDetect_Default(index);
4263:                        case USART_ID_5 :
4264:                            return USART_ExistsReceiverAddressDetect_Default(index);
4265:                        case USART_NUMBER_OF_MODULES :
4266:                        default :
4267:                            return (bool)0;
4268:                    }
4269:                }
4270:                
4271:                PLIB_INLINE_API void PLIB_USART_ReceiverAddressDetectEnable(USART_MODULE_ID index)
4272:                {
4273:                    switch (index) {
9D001454  2C820006   SLTIU V0, A0, 6
9D001458  10400013   BEQ V0, ZERO, 0x9D0014A8
9D00145C  00041880   SLL V1, A0, 2
9D001460  3C029D00   LUI V0, -25344
9D001464  24421478   ADDIU V0, V0, 5240
9D001468  00431021   ADDU V0, V0, V1
9D00146C  8C420000   LW V0, 0(V0)
9D001470  00400008   JR V0
9D001474  00000000   NOP
4274:                        case USART_ID_1 :
4275:                            USART_ReceiverAddressDetectEnable_Default(index);
4276:                            break;
4277:                        case USART_ID_3 :
4278:                            USART_ReceiverAddressDetectEnable_Default(index);
4279:                            break;
4280:                        case USART_ID_2 :
4281:                            USART_ReceiverAddressDetectEnable_Default(index);
4282:                            break;
4283:                        case USART_ID_4 :
4284:                            USART_ReceiverAddressDetectEnable_Default(index);
4285:                            break;
4286:                        case USART_ID_6 :
4287:                            USART_ReceiverAddressDetectEnable_Default(index);
4288:                            break;
4289:                        case USART_ID_5 :
4290:                            USART_ReceiverAddressDetectEnable_Default(index);
4291:                            break;
4292:                        case USART_NUMBER_OF_MODULES :
4293:                        default :
4294:                            break;
4295:                    }
4296:                }
4297:                
4298:                PLIB_INLINE_API void PLIB_USART_ReceiverAddressDetectDisable(USART_MODULE_ID index)
4299:                {
4300:                    switch (index) {
4301:                        case USART_ID_1 :
4302:                            USART_ReceiverAddressDetectDisable_Default(index);
4303:                            break;
4304:                        case USART_ID_3 :
4305:                            USART_ReceiverAddressDetectDisable_Default(index);
4306:                            break;
4307:                        case USART_ID_2 :
4308:                            USART_ReceiverAddressDetectDisable_Default(index);
4309:                            break;
4310:                        case USART_ID_4 :
4311:                            USART_ReceiverAddressDetectDisable_Default(index);
4312:                            break;
4313:                        case USART_ID_6 :
4314:                            USART_ReceiverAddressDetectDisable_Default(index);
4315:                            break;
4316:                        case USART_ID_5 :
4317:                            USART_ReceiverAddressDetectDisable_Default(index);
4318:                            break;
4319:                        case USART_NUMBER_OF_MODULES :
4320:                        default :
4321:                            break;
4322:                    }
4323:                }
4324:                
4325:                PLIB_INLINE_API bool PLIB_USART_ReceiverAddressIsReceived(USART_MODULE_ID index)
4326:                {
4327:                    switch (index) {
4328:                        case USART_ID_1 :
4329:                            return USART_ReceiverAddressIsReceived_Default(index);
4330:                        case USART_ID_3 :
4331:                            return USART_ReceiverAddressIsReceived_Default(index);
4332:                        case USART_ID_2 :
4333:                            return USART_ReceiverAddressIsReceived_Default(index);
4334:                        case USART_ID_4 :
4335:                            return USART_ReceiverAddressIsReceived_Default(index);
4336:                        case USART_ID_6 :
4337:                            return USART_ReceiverAddressIsReceived_Default(index);
4338:                        case USART_ID_5 :
4339:                            return USART_ReceiverAddressIsReceived_Default(index);
4340:                        case USART_NUMBER_OF_MODULES :
4341:                        default :
4342:                            return (bool)0;
4343:                    }
4344:                }
4345:                
4346:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverAddress(USART_MODULE_ID index)
4347:                {
4348:                    switch (index) {
4349:                        case USART_ID_1 :
4350:                            return USART_ExistsReceiverAddress_Default(index);
4351:                        case USART_ID_3 :
4352:                            return USART_ExistsReceiverAddress_Default(index);
4353:                        case USART_ID_2 :
4354:                            return USART_ExistsReceiverAddress_Default(index);
4355:                        case USART_ID_4 :
4356:                            return USART_ExistsReceiverAddress_Default(index);
4357:                        case USART_ID_6 :
4358:                            return USART_ExistsReceiverAddress_Default(index);
4359:                        case USART_ID_5 :
4360:                            return USART_ExistsReceiverAddress_Default(index);
4361:                        case USART_NUMBER_OF_MODULES :
4362:                        default :
4363:                            return (bool)0;
4364:                    }
4365:                }
4366:                
4367:                PLIB_INLINE_API void PLIB_USART_AddressSet(USART_MODULE_ID index, uint8_t address)
4368:                {
4369:                    switch (index) {
9D0014A8  2C830006   SLTIU V1, A0, 6
9D0014AC  10600018   BEQ V1, ZERO, 0x9D001510
9D0014B0  90A2000C   LBU V0, 12(A1)
9D0014B4  00041880   SLL V1, A0, 2
9D0014B8  3C069D00   LUI A2, -25344
9D0014BC  24C614D0   ADDIU A2, A2, 5328
9D0014C0  00C31821   ADDU V1, A2, V1
9D0014C4  8C630000   LW V1, 0(V1)
9D0014C8  00600008   JR V1
9D0014CC  00000000   NOP
4370:                        case USART_ID_1 :
4371:                            USART_AddressSet_Default(index, address);
4372:                            break;
4373:                        case USART_ID_3 :
4374:                            USART_AddressSet_Default(index, address);
4375:                            break;
4376:                        case USART_ID_2 :
4377:                            USART_AddressSet_Default(index, address);
4378:                            break;
4379:                        case USART_ID_4 :
4380:                            USART_AddressSet_Default(index, address);
4381:                            break;
4382:                        case USART_ID_6 :
4383:                            USART_AddressSet_Default(index, address);
4384:                            break;
4385:                        case USART_ID_5 :
4386:                            USART_AddressSet_Default(index, address);
4387:                            break;
4388:                        case USART_NUMBER_OF_MODULES :
4389:                        default :
4390:                            break;
4391:                    }
4392:                }
4393:                
4394:                PLIB_INLINE_API uint8_t PLIB_USART_AddressGet(USART_MODULE_ID index)
4395:                {
4396:                    switch (index) {
9D001510  2C820006   SLTIU V0, A0, 6
9D001514  10400012   BEQ V0, ZERO, 0x9D001560
9D001518  3C039D00   LUI V1, -25344
9D00151C  00041080   SLL V0, A0, 2
9D001520  24631534   ADDIU V1, V1, 5428
9D001524  00621021   ADDU V0, V1, V0
9D001528  8C420000   LW V0, 0(V0)
9D00152C  00400008   JR V0
9D001530  00000000   NOP
4397:                        case USART_ID_1 :
4398:                            return USART_AddressGet_Default(index);
4399:                        case USART_ID_3 :
4400:                            return USART_AddressGet_Default(index);
4401:                        case USART_ID_2 :
4402:                            return USART_AddressGet_Default(index);
4403:                        case USART_ID_4 :
4404:                            return USART_AddressGet_Default(index);
4405:                        case USART_ID_6 :
4406:                            return USART_AddressGet_Default(index);
4407:                        case USART_ID_5 :
4408:                            return USART_AddressGet_Default(index);
4409:                        case USART_NUMBER_OF_MODULES :
4410:                        default :
4411:                            return (uint8_t)0;
4412:                    }
4413:                }
4414:                
4415:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverAddressMask(USART_MODULE_ID index)
4416:                {
4417:                    switch (index) {
4418:                        case USART_ID_1 :
4419:                            return USART_ExistsReceiverAddressMask_Unsupported(index);
4420:                        case USART_ID_3 :
4421:                            return USART_ExistsReceiverAddressMask_Unsupported(index);
4422:                        case USART_ID_2 :
4423:                            return USART_ExistsReceiverAddressMask_Unsupported(index);
4424:                        case USART_ID_4 :
4425:                            return USART_ExistsReceiverAddressMask_Unsupported(index);
4426:                        case USART_ID_6 :
4427:                            return USART_ExistsReceiverAddressMask_Unsupported(index);
4428:                        case USART_ID_5 :
4429:                            return USART_ExistsReceiverAddressMask_Unsupported(index);
4430:                        case USART_NUMBER_OF_MODULES :
4431:                        default :
4432:                            return (bool)0;
4433:                    }
4434:                }
4435:                
4436:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_USART_AddressMaskSet(USART_MODULE_ID index, uint8_t mask)
4437:                {
4438:                    switch (index) {
4439:                        case USART_ID_1 :
4440:                            USART_AddressMaskSet_Unsupported(index, mask);
4441:                            break;
4442:                        case USART_ID_3 :
4443:                            USART_AddressMaskSet_Unsupported(index, mask);
4444:                            break;
4445:                        case USART_ID_2 :
4446:                            USART_AddressMaskSet_Unsupported(index, mask);
4447:                            break;
4448:                        case USART_ID_4 :
4449:                            USART_AddressMaskSet_Unsupported(index, mask);
4450:                            break;
4451:                        case USART_ID_6 :
4452:                            USART_AddressMaskSet_Unsupported(index, mask);
4453:                            break;
4454:                        case USART_ID_5 :
4455:                            USART_AddressMaskSet_Unsupported(index, mask);
4456:                            break;
4457:                        case USART_NUMBER_OF_MODULES :
4458:                        default :
4459:                            break;
4460:                    }
4461:                }
4462:                
4463:                PLIB_INLINE_API uint8_t _PLIB_UNSUPPORTED PLIB_USART_AddressMaskGet(USART_MODULE_ID index)
4464:                {
4465:                    switch (index) {
4466:                        case USART_ID_1 :
4467:                            return USART_AddressMaskGet_Unsupported(index);
4468:                        case USART_ID_3 :
4469:                            return USART_AddressMaskGet_Unsupported(index);
4470:                        case USART_ID_2 :
4471:                            return USART_AddressMaskGet_Unsupported(index);
4472:                        case USART_ID_4 :
4473:                            return USART_AddressMaskGet_Unsupported(index);
4474:                        case USART_ID_6 :
4475:                            return USART_AddressMaskGet_Unsupported(index);
4476:                        case USART_ID_5 :
4477:                            return USART_AddressMaskGet_Unsupported(index);
4478:                        case USART_NUMBER_OF_MODULES :
4479:                        default :
4480:                            return (uint8_t)0;
4481:                    }
4482:                }
4483:                
4484:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverDataAvailableStatus(USART_MODULE_ID index)
4485:                {
4486:                    switch (index) {
4487:                        case USART_ID_1 :
4488:                            return USART_ExistsReceiverDataAvailableStatus_Default(index);
4489:                        case USART_ID_3 :
4490:                            return USART_ExistsReceiverDataAvailableStatus_Default(index);
4491:                        case USART_ID_2 :
4492:                            return USART_ExistsReceiverDataAvailableStatus_Default(index);
4493:                        case USART_ID_4 :
4494:                            return USART_ExistsReceiverDataAvailableStatus_Default(index);
4495:                        case USART_ID_6 :
4496:                            return USART_ExistsReceiverDataAvailableStatus_Default(index);
4497:                        case USART_ID_5 :
4498:                            return USART_ExistsReceiverDataAvailableStatus_Default(index);
4499:                        case USART_NUMBER_OF_MODULES :
4500:                        default :
4501:                            return (bool)0;
4502:                    }
4503:                }
4504:                
4505:                PLIB_INLINE_API bool PLIB_USART_ReceiverDataIsAvailable(USART_MODULE_ID index)
4506:                {
4507:                    switch (index) {
0000001C  00000000   NOP
00000020  00000000   NOP
00000038  00000000   NOP
000000D8  00000000   NOP
4508:                        case USART_ID_1 :
4509:                            return USART_ReceiverDataIsAvailable_Default(index);
4510:                        case USART_ID_3 :
4511:                            return USART_ReceiverDataIsAvailable_Default(index);
4512:                        case USART_ID_2 :
4513:                            return USART_ReceiverDataIsAvailable_Default(index);
4514:                        case USART_ID_4 :
4515:                            return USART_ReceiverDataIsAvailable_Default(index);
4516:                        case USART_ID_6 :
4517:                            return USART_ReceiverDataIsAvailable_Default(index);
4518:                        case USART_ID_5 :
4519:                            return USART_ReceiverDataIsAvailable_Default(index);
4520:                        case USART_NUMBER_OF_MODULES :
4521:                        default :
4522:                            return (bool)0;
0000006C  00000000   NOP
4523:                    }
4524:                }
4525:                
4526:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverEnable(USART_MODULE_ID index)
4527:                {
4528:                    switch (index) {
4529:                        case USART_ID_1 :
4530:                            return USART_ExistsReceiverEnable_Default(index);
4531:                        case USART_ID_3 :
4532:                            return USART_ExistsReceiverEnable_Default(index);
4533:                        case USART_ID_2 :
4534:                            return USART_ExistsReceiverEnable_Default(index);
4535:                        case USART_ID_4 :
4536:                            return USART_ExistsReceiverEnable_Default(index);
4537:                        case USART_ID_6 :
4538:                            return USART_ExistsReceiverEnable_Default(index);
4539:                        case USART_ID_5 :
4540:                            return USART_ExistsReceiverEnable_Default(index);
4541:                        case USART_NUMBER_OF_MODULES :
4542:                        default :
4543:                            return (bool)0;
4544:                    }
4545:                }
4546:                
4547:                PLIB_INLINE_API void PLIB_USART_ReceiverEnable(USART_MODULE_ID index)
4548:                {
4549:                    switch (index) {
4550:                        case USART_ID_1 :
4551:                            USART_ReceiverEnable_Default(index);
4552:                            break;
4553:                        case USART_ID_3 :
4554:                            USART_ReceiverEnable_Default(index);
4555:                            break;
4556:                        case USART_ID_2 :
4557:                            USART_ReceiverEnable_Default(index);
4558:                            break;
4559:                        case USART_ID_4 :
4560:                            USART_ReceiverEnable_Default(index);
4561:                            break;
4562:                        case USART_ID_6 :
4563:                            USART_ReceiverEnable_Default(index);
4564:                            break;
4565:                        case USART_ID_5 :
4566:                            USART_ReceiverEnable_Default(index);
4567:                            break;
4568:                        case USART_NUMBER_OF_MODULES :
4569:                        default :
4570:                            break;
4571:                    }
4572:                }
4573:                
4574:                PLIB_INLINE_API void PLIB_USART_ReceiverDisable(USART_MODULE_ID index)
4575:                {
4576:                    switch (index) {
4577:                        case USART_ID_1 :
4578:                            USART_ReceiverDisable_Default(index);
4579:                            break;
4580:                        case USART_ID_3 :
4581:                            USART_ReceiverDisable_Default(index);
4582:                            break;
4583:                        case USART_ID_2 :
4584:                            USART_ReceiverDisable_Default(index);
4585:                            break;
4586:                        case USART_ID_4 :
4587:                            USART_ReceiverDisable_Default(index);
4588:                            break;
4589:                        case USART_ID_6 :
4590:                            USART_ReceiverDisable_Default(index);
4591:                            break;
4592:                        case USART_ID_5 :
4593:                            USART_ReceiverDisable_Default(index);
4594:                            break;
4595:                        case USART_NUMBER_OF_MODULES :
4596:                        default :
4597:                            break;
4598:                    }
4599:                }
4600:                
4601:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverIdleStatus(USART_MODULE_ID index)
4602:                {
4603:                    switch (index) {
4604:                        case USART_ID_1 :
4605:                            return USART_ExistsReceiverIdleStatus_Default(index);
4606:                        case USART_ID_3 :
4607:                            return USART_ExistsReceiverIdleStatus_Default(index);
4608:                        case USART_ID_2 :
4609:                            return USART_ExistsReceiverIdleStatus_Default(index);
4610:                        case USART_ID_4 :
4611:                            return USART_ExistsReceiverIdleStatus_Default(index);
4612:                        case USART_ID_6 :
4613:                            return USART_ExistsReceiverIdleStatus_Default(index);
4614:                        case USART_ID_5 :
4615:                            return USART_ExistsReceiverIdleStatus_Default(index);
4616:                        case USART_NUMBER_OF_MODULES :
4617:                        default :
4618:                            return (bool)0;
4619:                    }
4620:                }
4621:                
4622:                PLIB_INLINE_API bool PLIB_USART_ReceiverIsIdle(USART_MODULE_ID index)
4623:                {
4624:                    switch (index) {
4625:                        case USART_ID_1 :
4626:                            return USART_ReceiverIsIdle_Default(index);
4627:                        case USART_ID_3 :
4628:                            return USART_ReceiverIsIdle_Default(index);
4629:                        case USART_ID_2 :
4630:                            return USART_ReceiverIsIdle_Default(index);
4631:                        case USART_ID_4 :
4632:                            return USART_ReceiverIsIdle_Default(index);
4633:                        case USART_ID_6 :
4634:                            return USART_ReceiverIsIdle_Default(index);
4635:                        case USART_ID_5 :
4636:                            return USART_ReceiverIsIdle_Default(index);
4637:                        case USART_NUMBER_OF_MODULES :
4638:                        default :
4639:                            return (bool)0;
4640:                    }
4641:                }
4642:                
4643:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverFramingErrorStatus(USART_MODULE_ID index)
4644:                {
4645:                    switch (index) {
4646:                        case USART_ID_1 :
4647:                            return USART_ExistsReceiverFramingErrorStatus_Default(index);
4648:                        case USART_ID_3 :
4649:                            return USART_ExistsReceiverFramingErrorStatus_Default(index);
4650:                        case USART_ID_2 :
4651:                            return USART_ExistsReceiverFramingErrorStatus_Default(index);
4652:                        case USART_ID_4 :
4653:                            return USART_ExistsReceiverFramingErrorStatus_Default(index);
4654:                        case USART_ID_6 :
4655:                            return USART_ExistsReceiverFramingErrorStatus_Default(index);
4656:                        case USART_ID_5 :
4657:                            return USART_ExistsReceiverFramingErrorStatus_Default(index);
4658:                        case USART_NUMBER_OF_MODULES :
4659:                        default :
4660:                            return (bool)0;
4661:                    }
4662:                }
4663:                
4664:                PLIB_INLINE_API bool PLIB_USART_ReceiverFramingErrorHasOccurred(USART_MODULE_ID index)
4665:                {
4666:                    switch (index) {
4667:                        case USART_ID_1 :
4668:                            return USART_ReceiverFramingErrorHasOccurred_Default(index);
4669:                        case USART_ID_3 :
4670:                            return USART_ReceiverFramingErrorHasOccurred_Default(index);
4671:                        case USART_ID_2 :
4672:                            return USART_ReceiverFramingErrorHasOccurred_Default(index);
4673:                        case USART_ID_4 :
4674:                            return USART_ReceiverFramingErrorHasOccurred_Default(index);
4675:                        case USART_ID_6 :
4676:                            return USART_ReceiverFramingErrorHasOccurred_Default(index);
4677:                        case USART_ID_5 :
4678:                            return USART_ReceiverFramingErrorHasOccurred_Default(index);
4679:                        case USART_NUMBER_OF_MODULES :
4680:                        default :
4681:                            return (bool)0;
4682:                    }
4683:                }
4684:                
4685:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverInterruptMode(USART_MODULE_ID index)
4686:                {
4687:                    switch (index) {
4688:                        case USART_ID_1 :
4689:                            return USART_ExistsReceiverInterruptMode_Default(index);
4690:                        case USART_ID_3 :
4691:                            return USART_ExistsReceiverInterruptMode_Default(index);
4692:                        case USART_ID_2 :
4693:                            return USART_ExistsReceiverInterruptMode_Default(index);
4694:                        case USART_ID_4 :
4695:                            return USART_ExistsReceiverInterruptMode_Default(index);
4696:                        case USART_ID_6 :
4697:                            return USART_ExistsReceiverInterruptMode_Default(index);
4698:                        case USART_ID_5 :
4699:                            return USART_ExistsReceiverInterruptMode_Default(index);
4700:                        case USART_NUMBER_OF_MODULES :
4701:                        default :
4702:                            return (bool)0;
4703:                    }
4704:                }
4705:                
4706:                PLIB_INLINE_API void PLIB_USART_ReceiverInterruptModeSelect(USART_MODULE_ID index, USART_RECEIVE_INTR_MODE interruptMode)
4707:                {
4708:                    switch (index) {
4709:                        case USART_ID_1 :
4710:                            USART_ReceiverInterruptModeSelect_Default(index, interruptMode);
4711:                            break;
4712:                        case USART_ID_3 :
4713:                            USART_ReceiverInterruptModeSelect_Default(index, interruptMode);
4714:                            break;
4715:                        case USART_ID_2 :
4716:                            USART_ReceiverInterruptModeSelect_Default(index, interruptMode);
4717:                            break;
4718:                        case USART_ID_4 :
4719:                            USART_ReceiverInterruptModeSelect_Default(index, interruptMode);
4720:                            break;
4721:                        case USART_ID_6 :
4722:                            USART_ReceiverInterruptModeSelect_Default(index, interruptMode);
4723:                            break;
4724:                        case USART_ID_5 :
4725:                            USART_ReceiverInterruptModeSelect_Default(index, interruptMode);
4726:                            break;
4727:                        case USART_NUMBER_OF_MODULES :
4728:                        default :
4729:                            break;
4730:                    }
4731:                }
4732:                
4733:                PLIB_INLINE_API void PLIB_USART_InitializeOperation(USART_MODULE_ID index, USART_RECEIVE_INTR_MODE receiveInterruptMode, USART_TRANSMIT_INTR_MODE transmitInterruptMode, USART_OPERATION_MODE operationMode)
4734:                {
4735:                    switch (index) {
9D001A60  2C820006   SLTIU V0, A0, 6
9D001A64  50400023   BEQL V0, ZERO, 0x9D001AF4
9D001A68  8CA30014   LW V1, 20(A1)
9D001A6C  00042080   SLL A0, A0, 2
9D001A70  3C029D00   LUI V0, -25344
9D001A74  24421A88   ADDIU V0, V0, 6792
9D001A78  00441021   ADDU V0, V0, A0
9D001A7C  8C420000   LW V0, 0(V0)
9D001A80  00400008   JR V0
9D001A84  00000000   NOP
9D001AA0  3C03BF80   LUI V1, -16512
9D001AA4  8C646010   LW A0, 24592(V1)
9D001AA8  3C02FFFF   LUI V0, -1
9D001AAC  24423030   ADDIU V0, V0, 12336
9D001AB0  00821024   AND V0, A0, V0
9D001AB4  AC626010   SW V0, 24592(V1)
9D001AB8  3C02BF80   LUI V0, -16512
9D001ABC  8C476000   LW A3, 24576(V0)
9D001AC0  2404FCFF   ADDIU A0, ZERO, -769
9D001AC4  00E42024   AND A0, A3, A0
9D001AC8  AC446000   SW A0, 24576(V0)
9D001ACC  8C646010   LW A0, 24592(V1)
9D001AD0  34844000   ORI A0, A0, 16384
9D001AD4  AC646010   SW A0, 24592(V1)
9D001AD8  8C436000   LW V1, 24576(V0)
9D001ADC  00063200   SLL A2, A2, 8
9D001AE0  00C33025   OR A2, A2, V1
9D001AE4  AC466000   SW A2, 24576(V0)
9D001AE8  8CA30014   LW V1, 20(A1)
9D001AEC  0B4006CD   J 0x9D001B34
9D001AF0  8CA2001C   LW V0, 28(A1)
9D001AF4  8CA2001C   LW V0, 28(A1)
9D001AF8  2C850006   SLTIU A1, A0, 6
9D001AFC  10A0002E   BEQ A1, ZERO, 0x9D001BB8
9D001B00  00042080   SLL A0, A0, 2
9D001B04  3C059D00   LUI A1, -25344
9D001B08  24A51B1C   ADDIU A1, A1, 6940
9D001B0C  00A42021   ADDU A0, A1, A0
9D001B10  8C840000   LW A0, 0(A0)
9D001B14  00800008   JR A0
9D001B18  00000000   NOP
9D001B34  3C04BF80   LUI A0, -16512
9D001B38  8C856010   LW A1, 24592(A0)
9D001B3C  34A51400   ORI A1, A1, 5120
9D001B40  AC856010   SW A1, 24592(A0)
9D001B44  0062001B   DIVU V1, V0
9D001B48  004001F4   TEQ V0, ZERO
9D001B4C  00001012   MFLO V0
9D001B50  00022902   SRL A1, V0, 4
9D001B54  00021082   SRL V0, V0, 2
9D001B58  2444FFFF   ADDIU A0, V0, -1
9D001B5C  3C020001   LUI V0, 1
9D001B60  0082102B   SLTU V0, A0, V0
9D001B64  10400009   BEQ V0, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D001B68  24A5FFFF   ADDIU A1, A1, -1
9D001B6C  3C02BF80   LUI V0, -16512
9D001B70  8C436000   LW V1, 24576(V0)
9D001B74  34630008   ORI V1, V1, 8
9D001B78  AC436000   SW V1, 24576(V0)
9D001B7C  3C02BF80   LUI V0, -16512
9D001B80  AC446040   SW A0, 24640(V0)
9D001B84  0B4006EB   J 0x9D001BAC
9D001B88  3C02BF80   LUI V0, -16512
9D001B8C  3C02BF80   LUI V0, -16512
9D001B90  8C446000   LW A0, 24576(V0)
9D001B94  2403FFF7   ADDIU V1, ZERO, -9
9D001B98  00831824   AND V1, A0, V1
9D001B9C  AC436000   SW V1, 24576(V0)
9D001BA0  3C02BF80   LUI V0, -16512
9D001BA4  AC456040   SW A1, 24640(V0)
9D001BA8  3C02BF80   LUI V0, -16512
9D001BAC  8C436000   LW V1, 24576(V0)
9D001BB0  34638000   ORI V1, V1, -32768
9D001BB4  AC436000   SW V1, 24576(V0)
9D001BB8  03E00008   JR RA
9D001BBC  00000000   NOP
9D001BC0  8C436400   LW V1, 25600(V0)
9D001BC4  34630008   ORI V1, V1, 8
9D001BC8  AC436400   SW V1, 25600(V0)
9D001BCC  3C02BF80   LUI V0, -16512
9D001BD0  AC446440   SW A0, 25664(V0)
9D001BD4  0B400700   J 0x9D001C00
9D001BD8  3C02BF80   LUI V0, -16512
9D001BDC  8C656400   LW A1, 25600(V1)
9D001BE0  2404FFF7   ADDIU A0, ZERO, -9
9D001BE4  00A42024   AND A0, A1, A0
9D001BE8  AC646400   SW A0, 25600(V1)
9D001BEC  00021102   SRL V0, V0, 4
9D001BF0  2442FFFF   ADDIU V0, V0, -1
9D001BF4  3C04BF80   LUI A0, -16512
9D001BF8  AC826440   SW V0, 25664(A0)
9D001BFC  3C02BF80   LUI V0, -16512
9D001C00  8C436400   LW V1, 25600(V0)
9D001C04  34638000   ORI V1, V1, -32768
9D001C08  AC436400   SW V1, 25600(V0)
9D001C0C  03E00008   JR RA
9D001C10  00000000   NOP
9D001C14  8C436800   LW V1, 26624(V0)
9D001C18  34630008   ORI V1, V1, 8
9D001C1C  AC436800   SW V1, 26624(V0)
9D001C20  3C02BF80   LUI V0, -16512
9D001C24  AC446840   SW A0, 26688(V0)
9D001C28  0B400715   J 0x9D001C54
9D001C2C  3C02BF80   LUI V0, -16512
9D001C30  8C656800   LW A1, 26624(V1)
9D001C34  2404FFF7   ADDIU A0, ZERO, -9
9D001C38  00A42024   AND A0, A1, A0
9D001C3C  AC646800   SW A0, 26624(V1)
9D001C40  00021102   SRL V0, V0, 4
9D001C44  2442FFFF   ADDIU V0, V0, -1
9D001C48  3C04BF80   LUI A0, -16512
9D001C4C  AC826840   SW V0, 26688(A0)
9D001C50  3C02BF80   LUI V0, -16512
9D001C54  8C436800   LW V1, 26624(V0)
9D001C58  34638000   ORI V1, V1, -32768
9D001C5C  AC436800   SW V1, 26624(V0)
9D001C60  03E00008   JR RA
9D001C64  00000000   NOP
9D001C68  8C436200   LW V1, 25088(V0)
9D001C6C  34630008   ORI V1, V1, 8
9D001C70  AC436200   SW V1, 25088(V0)
9D001C74  3C02BF80   LUI V0, -16512
9D001C78  AC446240   SW A0, 25152(V0)
9D001C7C  0B40072A   J 0x9D001CA8
9D001C80  3C02BF80   LUI V0, -16512
9D001C84  8C656200   LW A1, 25088(V1)
9D001C88  2404FFF7   ADDIU A0, ZERO, -9
9D001C8C  00A42024   AND A0, A1, A0
9D001C90  AC646200   SW A0, 25088(V1)
9D001C94  00021102   SRL V0, V0, 4
9D001C98  2442FFFF   ADDIU V0, V0, -1
9D001C9C  3C04BF80   LUI A0, -16512
9D001CA0  AC826240   SW V0, 25152(A0)
9D001CA4  3C02BF80   LUI V0, -16512
9D001CA8  8C436200   LW V1, 25088(V0)
9D001CAC  34638000   ORI V1, V1, -32768
9D001CB0  AC436200   SW V1, 25088(V0)
9D001CB4  03E00008   JR RA
9D001CB8  00000000   NOP
9D001CBC  8C436600   LW V1, 26112(V0)
9D001CC0  34630008   ORI V1, V1, 8
9D001CC4  AC436600   SW V1, 26112(V0)
9D001CC8  3C02BF80   LUI V0, -16512
9D001CCC  AC446640   SW A0, 26176(V0)
9D001CD0  0B40073F   J 0x9D001CFC
9D001CD4  3C02BF80   LUI V0, -16512
9D001CD8  8C656600   LW A1, 26112(V1)
9D001CDC  2404FFF7   ADDIU A0, ZERO, -9
9D001CE0  00A42024   AND A0, A1, A0
9D001CE4  AC646600   SW A0, 26112(V1)
9D001CE8  00021102   SRL V0, V0, 4
9D001CEC  2442FFFF   ADDIU V0, V0, -1
9D001CF0  3C04BF80   LUI A0, -16512
9D001CF4  AC826640   SW V0, 26176(A0)
9D001CF8  3C02BF80   LUI V0, -16512
9D001CFC  8C436600   LW V1, 26112(V0)
9D001D00  34638000   ORI V1, V1, -32768
9D001D04  AC436600   SW V1, 26112(V0)
9D001D08  03E00008   JR RA
9D001D0C  00000000   NOP
9D001D10  8C436A00   LW V1, 27136(V0)
9D001D14  34630008   ORI V1, V1, 8
9D001D18  AC436A00   SW V1, 27136(V0)
9D001D1C  3C02BF80   LUI V0, -16512
9D001D20  AC446A40   SW A0, 27200(V0)
9D001D24  0B400754   J 0x9D001D50
9D001D28  3C02BF80   LUI V0, -16512
9D001D2C  8C656A00   LW A1, 27136(V1)
9D001D30  2404FFF7   ADDIU A0, ZERO, -9
9D001D34  00A42024   AND A0, A1, A0
9D001D38  AC646A00   SW A0, 27136(V1)
9D001D3C  00021102   SRL V0, V0, 4
9D001D40  2442FFFF   ADDIU V0, V0, -1
9D001D44  3C04BF80   LUI A0, -16512
9D001D48  AC826A40   SW V0, 27200(A0)
9D001D4C  3C02BF80   LUI V0, -16512
9D001D50  8C436A00   LW V1, 27136(V0)
9D001D54  34638000   ORI V1, V1, -32768
9D001D58  AC436A00   SW V1, 27136(V0)
9D001D5C  03E00008   JR RA
9D001D60  00000000   NOP
9D001D64  24030020   ADDIU V1, ZERO, 32
9D001D68  3C02BF80   LUI V0, -16512
9D001D6C  24426410   ADDIU V0, V0, 25616
9D001D70  AC430008   SW V1, 8(V0)
9D001D74  0B400777   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001D78  90A2000C   LBU V0, 12(A1)
9D001D7C  24030020   ADDIU V1, ZERO, 32
9D001D80  3C02BF80   LUI V0, -16512
9D001D84  24426810   ADDIU V0, V0, 26640
9D001D88  AC430008   SW V1, 8(V0)
9D001D8C  0B400781   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001D90  90A2000C   LBU V0, 12(A1)
9D001D94  24030020   ADDIU V1, ZERO, 32
9D001D98  3C02BF80   LUI V0, -16512
9D001D9C  24426210   ADDIU V0, V0, 25104
9D001DA0  AC430008   SW V1, 8(V0)
9D001DA4  0B40078B   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001DA8  90A2000C   LBU V0, 12(A1)
9D001DAC  24030020   ADDIU V1, ZERO, 32
9D001DB0  3C02BF80   LUI V0, -16512
9D001DB4  24426610   ADDIU V0, V0, 26128
9D001DB8  AC430008   SW V1, 8(V0)
9D001DBC  0B400795   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001DC0  90A2000C   LBU V0, 12(A1)
9D001DC4  24030020   ADDIU V1, ZERO, 32
9D001DC8  3C02BF80   LUI V0, -16512
9D001DCC  24426A10   ADDIU V0, V0, 27152
9D001DD0  AC430008   SW V1, 8(V0)
9D001DD4  0B40079F   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001DD8  90A2000C   LBU V0, 12(A1)
9D001DDC  3C03BF80   LUI V1, -16512
9D001DE0  8C676410   LW A3, 25616(V1)
9D001DE4  00021400   SLL V0, V0, 16
9D001DE8  3C06FF00   LUI A2, -256
9D001DEC  34C6FFFF   ORI A2, A2, -1
9D001DF0  00E63024   AND A2, A3, A2
9D001DF4  00461025   OR V0, V0, A2
9D001DF8  AC626410   SW V0, 25616(V1)
9D001DFC  0B4007AA   J 0x9D001EA8
9D001E00  3C02BF80   LUI V0, -16512
9D001E04  3C03BF80   LUI V1, -16512
9D001E08  8C676810   LW A3, 26640(V1)
9D001E0C  00021400   SLL V0, V0, 16
9D001E10  3C06FF00   LUI A2, -256
9D001E14  34C6FFFF   ORI A2, A2, -1
9D001E18  00E63024   AND A2, A3, A2
9D001E1C  00461025   OR V0, V0, A2
9D001E20  AC626810   SW V0, 26640(V1)
9D001E24  0B4007AF   J 0x9D001EBC
9D001E28  3C02BF80   LUI V0, -16512
9D001E2C  3C03BF80   LUI V1, -16512
9D001E30  8C676210   LW A3, 25104(V1)
9D001E34  00021400   SLL V0, V0, 16
9D001E38  3C06FF00   LUI A2, -256
9D001E3C  34C6FFFF   ORI A2, A2, -1
9D001E40  00E63024   AND A2, A3, A2
9D001E44  00461025   OR V0, V0, A2
9D001E48  AC626210   SW V0, 25104(V1)
9D001E4C  0B4007B4   J 0x9D001ED0
9D001E50  3C02BF80   LUI V0, -16512
9D001E54  3C03BF80   LUI V1, -16512
9D001E58  8C676610   LW A3, 26128(V1)
9D001E5C  00021400   SLL V0, V0, 16
9D001E60  3C06FF00   LUI A2, -256
9D001E64  34C6FFFF   ORI A2, A2, -1
9D001E68  00E63024   AND A2, A3, A2
9D001E6C  00461025   OR V0, V0, A2
9D001E70  AC626610   SW V0, 26128(V1)
9D001E74  0B4007B9   J 0x9D001EE4
9D001E78  3C02BF80   LUI V0, -16512
9D001E7C  3C03BF80   LUI V1, -16512
9D001E80  8C676A10   LW A3, 27152(V1)
9D001E84  00021400   SLL V0, V0, 16
9D001E88  3C06FF00   LUI A2, -256
9D001E8C  34C6FFFF   ORI A2, A2, -1
9D001E90  00E63024   AND A2, A3, A2
9D001E94  00461025   OR V0, V0, A2
9D001E98  AC626A10   SW V0, 27152(V1)
9D001E9C  0B4007BE   J 0x9D001EF8
9D001EA0  3C02BF80   LUI V0, -16512
9D001EA4  3C02BF80   LUI V0, -16512
9D001EA8  8C436410   LW V1, 25616(V0)
9D001EAC  7C633C00   EXT V1, V1, 16, 8
9D001EB0  0B4007C3   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EB4  7C031C20   SEB V1, V1
9D001EB8  3C02BF80   LUI V0, -16512
9D001EBC  8C436810   LW V1, 26640(V0)
9D001EC0  7C633C00   EXT V1, V1, 16, 8
9D001EC4  0B4007D8   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EC8  7C031C20   SEB V1, V1
9D001ECC  3C02BF80   LUI V0, -16512
9D001ED0  8C436210   LW V1, 25104(V0)
9D001ED4  7C633C00   EXT V1, V1, 16, 8
9D001ED8  0B4007ED   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EDC  7C031C20   SEB V1, V1
9D001EE0  3C02BF80   LUI V0, -16512
9D001EE4  8C436610   LW V1, 26128(V0)
9D001EE8  7C633C00   EXT V1, V1, 16, 8
9D001EEC  0B4007FF   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EF0  7C031C20   SEB V1, V1
9D001EF4  3C02BF80   LUI V0, -16512
9D001EF8  8C436A10   LW V1, 27152(V0)
9D001EFC  7C633C00   EXT V1, V1, 16, 8
9D001F00  0B400811   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001F04  7C031C20   SEB V1, V1
9D001F08  00001821   ADDU V1, ZERO, ZERO
9D001F0C  3C02BF80   LUI V0, -16512
9D001F10  8C476410   LW A3, 25616(V0)
9D001F14  00031C00   SLL V1, V1, 16
9D001F18  3C0600FF   LUI A2, 255
9D001F1C  00661824   AND V1, V1, A2
9D001F20  3C06FF00   LUI A2, -256
9D001F24  34C6FFFF   ORI A2, A2, -1
9D001F28  00E63024   AND A2, A3, A2
9D001F2C  00661825   OR V1, V1, A2
9D001F30  AC436410   SW V1, 25616(V0)
9D001F34  24426410   ADDIU V0, V0, 25616
9D001F38  3C030100   LUI V1, 256
9D001F3C  AC430008   SW V1, 8(V0)
9D001F40  8CA30020   LW V1, 32(A1)
9D001F44  24020002   ADDIU V0, ZERO, 2
9D001F48  1462004F   BNE V1, V0, 0x9D002088
9D001F4C  00004021   ADDU T0, ZERO, ZERO
9D001F50  00001021   ADDU V0, ZERO, ZERO
9D001F54  0B4005A1   J 0x9D001684
9D001F58  00003021   ADDU A2, ZERO, ZERO
9D001F5C  00001821   ADDU V1, ZERO, ZERO
9D001F60  3C02BF80   LUI V0, -16512
9D001F64  8C476810   LW A3, 26640(V0)
9D001F68  00031C00   SLL V1, V1, 16
9D001F6C  3C0600FF   LUI A2, 255
9D001F70  00661824   AND V1, V1, A2
9D001F74  3C06FF00   LUI A2, -256
9D001F78  34C6FFFF   ORI A2, A2, -1
9D001F7C  00E63024   AND A2, A3, A2
9D001F80  00661825   OR V1, V1, A2
9D001F84  AC436810   SW V1, 26640(V0)
9D001F88  24426810   ADDIU V0, V0, 26640
9D001F8C  3C030100   LUI V1, 256
9D001F90  AC430008   SW V1, 8(V0)
9D001F94  8CA30020   LW V1, 32(A1)
9D001F98  24020002   ADDIU V0, ZERO, 2
9D001F9C  1462004B   BNE V1, V0, 0x9D0020CC
9D001FA0  00004021   ADDU T0, ZERO, ZERO
9D001FA4  00001021   ADDU V0, ZERO, ZERO
9D001FA8  0B4005A1   J 0x9D001684
9D001FAC  00003021   ADDU A2, ZERO, ZERO
9D001FB0  00001821   ADDU V1, ZERO, ZERO
9D001FB4  3C02BF80   LUI V0, -16512
9D001FB8  8C476210   LW A3, 25104(V0)
9D001FBC  00031C00   SLL V1, V1, 16
9D001FC0  3C0600FF   LUI A2, 255
9D001FC4  00661824   AND V1, V1, A2
9D001FC8  3C06FF00   LUI A2, -256
9D001FCC  34C6FFFF   ORI A2, A2, -1
9D001FD0  00E63024   AND A2, A3, A2
9D001FD4  00661825   OR V1, V1, A2
9D001FD8  AC436210   SW V1, 25104(V0)
9D001FDC  24426210   ADDIU V0, V0, 25104
9D001FE0  3C030100   LUI V1, 256
9D001FE4  AC430008   SW V1, 8(V0)
9D001FE8  00003021   ADDU A2, ZERO, ZERO
9D001FEC  00004021   ADDU T0, ZERO, ZERO
9D001FF0  0B400582   J 0x9D001608
9D001FF4  00001021   ADDU V0, ZERO, ZERO
9D001FF8  00001821   ADDU V1, ZERO, ZERO
9D001FFC  3C02BF80   LUI V0, -16512
9D002000  8C476610   LW A3, 26128(V0)
9D002004  00031C00   SLL V1, V1, 16
9D002008  3C0600FF   LUI A2, 255
9D00200C  00661824   AND V1, V1, A2
9D002010  3C06FF00   LUI A2, -256
9D002014  34C6FFFF   ORI A2, A2, -1
9D002018  00E63024   AND A2, A3, A2
9D00201C  00661825   OR V1, V1, A2
9D002020  AC436610   SW V1, 26128(V0)
9D002024  24426610   ADDIU V0, V0, 26128
9D002028  3C030100   LUI V1, 256
9D00202C  AC430008   SW V1, 8(V0)
9D002030  00003021   ADDU A2, ZERO, ZERO
9D002034  00004021   ADDU T0, ZERO, ZERO
9D002038  0B400582   J 0x9D001608
9D00203C  00001021   ADDU V0, ZERO, ZERO
9D002040  00001821   ADDU V1, ZERO, ZERO
9D002044  3C02BF80   LUI V0, -16512
9D002048  8C476A10   LW A3, 27152(V0)
9D00204C  00031C00   SLL V1, V1, 16
9D002050  3C0600FF   LUI A2, 255
9D002054  00661824   AND V1, V1, A2
9D002058  3C06FF00   LUI A2, -256
9D00205C  34C6FFFF   ORI A2, A2, -1
9D002060  00E63024   AND A2, A3, A2
9D002064  00661825   OR V1, V1, A2
9D002068  AC436A10   SW V1, 27152(V0)
9D00206C  24426A10   ADDIU V0, V0, 27152
9D002070  3C030100   LUI V1, 256
9D002074  AC430008   SW V1, 8(V0)
9D002078  00003021   ADDU A2, ZERO, ZERO
9D00207C  00004021   ADDU T0, ZERO, ZERO
9D002080  0B400582   J 0x9D001608
9D002084  00001021   ADDU V0, ZERO, ZERO
9D002088  00001021   ADDU V0, ZERO, ZERO
9D00208C  3C04BF80   LUI A0, -16512
9D002090  8C866400   LW A2, 25600(A0)
9D002094  2404F7FF   ADDIU A0, ZERO, -2049
9D002098  00C43024   AND A2, A2, A0
9D00209C  38640001   XORI A0, V1, 1
9D0020A0  2C840001   SLTIU A0, A0, 1
9D0020A4  000422C0   SLL A0, A0, 11
9D0020A8  00862025   OR A0, A0, A2
9D0020AC  3C03BF80   LUI V1, -16512
9D0020B0  AC646400   SW A0, 25600(V1)
9D0020B4  8CA30010   LW V1, 16(A1)
9D0020B8  30690001   ANDI T1, V1, 1
9D0020BC  7C670080   EXT A3, V1, 2, 1
9D0020C0  7C630040   EXT V1, V1, 1, 1
9D0020C4  0B4005D1   J _DRV_USART_HardwareSetup::PLIB_USART_InitializeModeGeneral
9D0020C8  24060002   ADDIU A2, ZERO, 2
9D0020CC  00001021   ADDU V0, ZERO, ZERO
9D0020D0  3C04BF80   LUI A0, -16512
9D0020D4  8C866800   LW A2, 26624(A0)
9D0020D8  2404F7FF   ADDIU A0, ZERO, -2049
9D0020DC  00C43024   AND A2, A2, A0
9D0020E0  38640001   XORI A0, V1, 1
9D0020E4  2C840001   SLTIU A0, A0, 1
9D0020E8  000422C0   SLL A0, A0, 11
9D0020EC  00862025   OR A0, A0, A2
9D0020F0  3C03BF80   LUI V1, -16512
9D0020F4  AC646800   SW A0, 26624(V1)
9D0020F8  8CA30010   LW V1, 16(A1)
9D0020FC  30690001   ANDI T1, V1, 1
9D002100  7C670080   EXT A3, V1, 2, 1
9D002104  7C630040   EXT V1, V1, 1, 1
9D002108  0B4005EE   J _DRV_USART_HardwareSetup::PLIB_USART_InitializeModeGeneral
9D00210C  24060002   ADDIU A2, ZERO, 2
9D002110  3C03BF80   LUI V1, -16512
9D002114  8C676000   LW A3, 24576(V1)
9D002118  00042040   SLL A0, A0, 1
9D00211C  30840006   ANDI A0, A0, 6
9D002120  2402FFF9   ADDIU V0, ZERO, -7
9D002124  00E21024   AND V0, A3, V0
9D002128  00821025   OR V0, A0, V0
9D00212C  AC626000   SW V0, 24576(V1)
9D002130  0B4006A9   J 0x9D001AA4
9D002134  3C03BF80   LUI V1, -16512
9D002138  3C03BF80   LUI V1, -16512
9D00213C  24636400   ADDIU V1, V1, 25600
9D002140  AC640008   SW A0, 8(V1)
9D002144  0B400855   J 0x9D002154
9D002148  2442FFFC   ADDIU V0, V0, -4
9D00214C  24636400   ADDIU V1, V1, 25600
9D002150  AC640004   SW A0, 4(V1)
9D002154  3C03BF80   LUI V1, -16512
9D002158  8C676400   LW A3, 25600(V1)
9D00215C  00022040   SLL A0, V0, 1
9D002160  30840006   ANDI A0, A0, 6
9D002164  2402FFF9   ADDIU V0, ZERO, -7
9D002168  00E21024   AND V0, A3, V0
9D00216C  00821025   OR V0, A0, V0
9D002170  AC626400   SW V0, 25600(V1)
9D002174  0B4008A4   J 0x9D002290
9D002178  3C03BF80   LUI V1, -16512
9D00217C  3C03BF80   LUI V1, -16512
9D002180  24636800   ADDIU V1, V1, 26624
9D002184  AC640008   SW A0, 8(V1)
9D002188  0B400866   J 0x9D002198
9D00218C  2442FFFC   ADDIU V0, V0, -4
9D002190  24636800   ADDIU V1, V1, 26624
9D002194  AC640004   SW A0, 4(V1)
9D002198  3C03BF80   LUI V1, -16512
9D00219C  8C676800   LW A3, 26624(V1)
9D0021A0  00022040   SLL A0, V0, 1
9D0021A4  30840006   ANDI A0, A0, 6
9D0021A8  2402FFF9   ADDIU V0, ZERO, -7
9D0021AC  00E21024   AND V0, A3, V0
9D0021B0  00821025   OR V0, A0, V0
9D0021B4  AC626800   SW V0, 26624(V1)
9D0021B8  0B4008B9   J 0x9D0022E4
9D0021BC  3C03BF80   LUI V1, -16512
9D0021C0  3C03BF80   LUI V1, -16512
9D0021C4  24636200   ADDIU V1, V1, 25088
9D0021C8  AC640008   SW A0, 8(V1)
9D0021CC  0B400877   J 0x9D0021DC
9D0021D0  2442FFFC   ADDIU V0, V0, -4
9D0021D4  24636200   ADDIU V1, V1, 25088
9D0021D8  AC640004   SW A0, 4(V1)
9D0021DC  3C03BF80   LUI V1, -16512
9D0021E0  8C676200   LW A3, 25088(V1)
9D0021E4  00022040   SLL A0, V0, 1
9D0021E8  30840006   ANDI A0, A0, 6
9D0021EC  2402FFF9   ADDIU V0, ZERO, -7
9D0021F0  00E21024   AND V0, A3, V0
9D0021F4  00821025   OR V0, A0, V0
9D0021F8  AC626200   SW V0, 25088(V1)
9D0021FC  0B4008CE   J 0x9D002338
9D002200  3C03BF80   LUI V1, -16512
9D002204  3C03BF80   LUI V1, -16512
9D002208  24636600   ADDIU V1, V1, 26112
9D00220C  AC640008   SW A0, 8(V1)
9D002210  0B400888   J 0x9D002220
9D002214  2442FFFC   ADDIU V0, V0, -4
9D002218  24636600   ADDIU V1, V1, 26112
9D00221C  AC640004   SW A0, 4(V1)
9D002220  3C03BF80   LUI V1, -16512
9D002224  8C676600   LW A3, 26112(V1)
9D002228  00022040   SLL A0, V0, 1
9D00222C  30840006   ANDI A0, A0, 6
9D002230  2402FFF9   ADDIU V0, ZERO, -7
9D002234  00E21024   AND V0, A3, V0
9D002238  00821025   OR V0, A0, V0
9D00223C  AC626600   SW V0, 26112(V1)
9D002240  0B4008E3   J 0x9D00238C
9D002244  3C03BF80   LUI V1, -16512
9D002248  3C03BF80   LUI V1, -16512
9D00224C  24636A00   ADDIU V1, V1, 27136
9D002250  AC640008   SW A0, 8(V1)
9D002254  0B400899   J 0x9D002264
9D002258  2442FFFC   ADDIU V0, V0, -4
9D00225C  24636A00   ADDIU V1, V1, 27136
9D002260  AC640004   SW A0, 4(V1)
9D002264  3C03BF80   LUI V1, -16512
9D002268  8C676A00   LW A3, 27136(V1)
9D00226C  00022040   SLL A0, V0, 1
9D002270  30840006   ANDI A0, A0, 6
9D002274  2402FFF9   ADDIU V0, ZERO, -7
9D002278  00E21024   AND V0, A3, V0
9D00227C  00821025   OR V0, A0, V0
9D002280  AC626A00   SW V0, 27136(V1)
9D002284  0B4008F8   J 0x9D0023E0
9D002288  3C03BF80   LUI V1, -16512
9D00228C  3C03BF80   LUI V1, -16512
9D002290  8C646410   LW A0, 25616(V1)
9D002294  3C02FFFF   LUI V0, -1
9D002298  24423030   ADDIU V0, V0, 12336
9D00229C  00821024   AND V0, A0, V0
9D0022A0  AC626410   SW V0, 25616(V1)
9D0022A4  3C02BF80   LUI V0, -16512
9D0022A8  8C476400   LW A3, 25600(V0)
9D0022AC  2404FCFF   ADDIU A0, ZERO, -769
9D0022B0  00E42024   AND A0, A3, A0
9D0022B4  AC446400   SW A0, 25600(V0)
9D0022B8  8C646410   LW A0, 25616(V1)
9D0022BC  34844000   ORI A0, A0, 16384
9D0022C0  AC646410   SW A0, 25616(V1)
9D0022C4  8C436400   LW V1, 25600(V0)
9D0022C8  00063200   SLL A2, A2, 8
9D0022CC  00C33025   OR A2, A2, V1
9D0022D0  AC466400   SW A2, 25600(V0)
9D0022D4  8CA30014   LW V1, 20(A1)
9D0022D8  0B40090C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0022DC  8CA2001C   LW V0, 28(A1)
9D0022E0  3C03BF80   LUI V1, -16512
9D0022E4  8C646810   LW A0, 26640(V1)
9D0022E8  3C02FFFF   LUI V0, -1
9D0022EC  24423030   ADDIU V0, V0, 12336
9D0022F0  00821024   AND V0, A0, V0
9D0022F4  AC626810   SW V0, 26640(V1)
9D0022F8  3C02BF80   LUI V0, -16512
9D0022FC  8C476800   LW A3, 26624(V0)
9D002300  2404FCFF   ADDIU A0, ZERO, -769
9D002304  00E42024   AND A0, A3, A0
9D002308  AC446800   SW A0, 26624(V0)
9D00230C  8C646810   LW A0, 26640(V1)
9D002310  34844000   ORI A0, A0, 16384
9D002314  AC646810   SW A0, 26640(V1)
9D002318  8C436800   LW V1, 26624(V0)
9D00231C  00063200   SLL A2, A2, 8
9D002320  00C33025   OR A2, A2, V1
9D002324  AC466800   SW A2, 26624(V0)
9D002328  8CA30014   LW V1, 20(A1)
9D00232C  0B40091B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002330  8CA2001C   LW V0, 28(A1)
9D002334  3C03BF80   LUI V1, -16512
9D002338  8C646210   LW A0, 25104(V1)
9D00233C  3C02FFFF   LUI V0, -1
9D002340  24423030   ADDIU V0, V0, 12336
9D002344  00821024   AND V0, A0, V0
9D002348  AC626210   SW V0, 25104(V1)
9D00234C  3C02BF80   LUI V0, -16512
9D002350  8C476200   LW A3, 25088(V0)
9D002354  2404FCFF   ADDIU A0, ZERO, -769
9D002358  00E42024   AND A0, A3, A0
9D00235C  AC446200   SW A0, 25088(V0)
9D002360  8C646210   LW A0, 25104(V1)
9D002364  34844000   ORI A0, A0, 16384
9D002368  AC646210   SW A0, 25104(V1)
9D00236C  8C436200   LW V1, 25088(V0)
9D002370  00063200   SLL A2, A2, 8
9D002374  00C33025   OR A2, A2, V1
9D002378  AC466200   SW A2, 25088(V0)
9D00237C  8CA30014   LW V1, 20(A1)
9D002380  0B40092A   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002384  8CA2001C   LW V0, 28(A1)
9D002388  3C03BF80   LUI V1, -16512
9D00238C  8C646610   LW A0, 26128(V1)
9D002390  3C02FFFF   LUI V0, -1
9D002394  24423030   ADDIU V0, V0, 12336
9D002398  00821024   AND V0, A0, V0
9D00239C  AC626610   SW V0, 26128(V1)
9D0023A0  3C02BF80   LUI V0, -16512
9D0023A4  8C476600   LW A3, 26112(V0)
9D0023A8  2404FCFF   ADDIU A0, ZERO, -769
9D0023AC  00E42024   AND A0, A3, A0
9D0023B0  AC446600   SW A0, 26112(V0)
9D0023B4  8C646610   LW A0, 26128(V1)
9D0023B8  34844000   ORI A0, A0, 16384
9D0023BC  AC646610   SW A0, 26128(V1)
9D0023C0  8C436600   LW V1, 26112(V0)
9D0023C4  00063200   SLL A2, A2, 8
9D0023C8  00C33025   OR A2, A2, V1
9D0023CC  AC466600   SW A2, 26112(V0)
9D0023D0  8CA30014   LW V1, 20(A1)
9D0023D4  0B400939   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0023D8  8CA2001C   LW V0, 28(A1)
9D0023DC  3C03BF80   LUI V1, -16512
9D0023E0  8C646A10   LW A0, 27152(V1)
9D0023E4  3C02FFFF   LUI V0, -1
9D0023E8  24423030   ADDIU V0, V0, 12336
9D0023EC  00821024   AND V0, A0, V0
9D0023F0  AC626A10   SW V0, 27152(V1)
9D0023F4  3C02BF80   LUI V0, -16512
9D0023F8  8C476A00   LW A3, 27136(V0)
9D0023FC  2404FCFF   ADDIU A0, ZERO, -769
9D002400  00E42024   AND A0, A3, A0
9D002404  AC446A00   SW A0, 27136(V0)
9D002408  8C646A10   LW A0, 27152(V1)
9D00240C  34844000   ORI A0, A0, 16384
9D002410  AC646A10   SW A0, 27152(V1)
9D002414  8C436A00   LW V1, 27136(V0)
9D002418  00063200   SLL A2, A2, 8
9D00241C  00C33025   OR A2, A2, V1
9D002420  AC466A00   SW A2, 27136(V0)
9D002424  8CA30014   LW V1, 20(A1)
9D002428  0B400948   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00242C  8CA2001C   LW V0, 28(A1)
9D002430  3C04BF80   LUI A0, -16512
9D002434  8C856410   LW A1, 25616(A0)
9D002438  34A51400   ORI A1, A1, 5120
9D00243C  AC856410   SW A1, 25616(A0)
9D002440  0062001B   DIVU V1, V0
9D002444  004001F4   TEQ V0, ZERO
9D002448  00001012   MFLO V0
9D00244C  00022082   SRL A0, V0, 2
9D002450  2484FFFF   ADDIU A0, A0, -1
9D002454  3C030001   LUI V1, 1
9D002458  0083182B   SLTU V1, A0, V1
9D00245C  5460FDD8   BNEL V1, ZERO, 0x9D001BC0
9D002460  3C02BF80   LUI V0, -16512
9D002464  0B4006F7   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002468  3C03BF80   LUI V1, -16512
9D00246C  3C04BF80   LUI A0, -16512
9D002470  8C856810   LW A1, 26640(A0)
9D002474  34A51400   ORI A1, A1, 5120
9D002478  AC856810   SW A1, 26640(A0)
9D00247C  0062001B   DIVU V1, V0
9D002480  004001F4   TEQ V0, ZERO
9D002484  00001012   MFLO V0
9D002488  00022082   SRL A0, V0, 2
9D00248C  2484FFFF   ADDIU A0, A0, -1
9D002490  3C030001   LUI V1, 1
9D002494  0083182B   SLTU V1, A0, V1
9D002498  5460FDDE   BNEL V1, ZERO, 0x9D001C14
9D00249C  3C02BF80   LUI V0, -16512
9D0024A0  0B40070C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024A4  3C03BF80   LUI V1, -16512
9D0024A8  3C04BF80   LUI A0, -16512
9D0024AC  8C856210   LW A1, 25104(A0)
9D0024B0  34A51400   ORI A1, A1, 5120
9D0024B4  AC856210   SW A1, 25104(A0)
9D0024B8  0062001B   DIVU V1, V0
9D0024BC  004001F4   TEQ V0, ZERO
9D0024C0  00001012   MFLO V0
9D0024C4  00022082   SRL A0, V0, 2
9D0024C8  2484FFFF   ADDIU A0, A0, -1
9D0024CC  3C030001   LUI V1, 1
9D0024D0  0083182B   SLTU V1, A0, V1
9D0024D4  5460FDE4   BNEL V1, ZERO, 0x9D001C68
9D0024D8  3C02BF80   LUI V0, -16512
9D0024DC  0B400721   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024E0  3C03BF80   LUI V1, -16512
9D0024E4  3C04BF80   LUI A0, -16512
9D0024E8  8C856610   LW A1, 26128(A0)
9D0024EC  34A51400   ORI A1, A1, 5120
9D0024F0  AC856610   SW A1, 26128(A0)
9D0024F4  0062001B   DIVU V1, V0
9D0024F8  004001F4   TEQ V0, ZERO
9D0024FC  00001012   MFLO V0
9D002500  00022082   SRL A0, V0, 2
9D002504  2484FFFF   ADDIU A0, A0, -1
9D002508  3C030001   LUI V1, 1
9D00250C  0083182B   SLTU V1, A0, V1
9D002510  5460FDEA   BNEL V1, ZERO, 0x9D001CBC
9D002514  3C02BF80   LUI V0, -16512
9D002518  0B400736   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00251C  3C03BF80   LUI V1, -16512
9D002520  3C04BF80   LUI A0, -16512
9D002524  8C856A10   LW A1, 27152(A0)
9D002528  34A51400   ORI A1, A1, 5120
9D00252C  AC856A10   SW A1, 27152(A0)
9D002530  0062001B   DIVU V1, V0
9D002534  004001F4   TEQ V0, ZERO
9D002538  00001012   MFLO V0
9D00253C  00022082   SRL A0, V0, 2
9D002540  2484FFFF   ADDIU A0, A0, -1
9D002544  3C030001   LUI V1, 1
9D002548  0083182B   SLTU V1, A0, V1
9D00254C  5460FDF0   BNEL V1, ZERO, 0x9D001D10
9D002550  3C02BF80   LUI V0, -16512
9D002554  0B40074B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002558  3C03BF80   LUI V1, -16512
4736:                        case USART_ID_1 :
4737:                            USART_InitializeOperation_Default(index, receiveInterruptMode, transmitInterruptMode, operationMode);
4738:                            break;
4739:                        case USART_ID_3 :
4740:                            USART_InitializeOperation_Default(index, receiveInterruptMode, transmitInterruptMode, operationMode);
4741:                            break;
4742:                        case USART_ID_2 :
4743:                            USART_InitializeOperation_Default(index, receiveInterruptMode, transmitInterruptMode, operationMode);
4744:                            break;
4745:                        case USART_ID_4 :
4746:                            USART_InitializeOperation_Default(index, receiveInterruptMode, transmitInterruptMode, operationMode);
4747:                            break;
4748:                        case USART_ID_6 :
4749:                            USART_InitializeOperation_Default(index, receiveInterruptMode, transmitInterruptMode, operationMode);
4750:                            break;
4751:                        case USART_ID_5 :
4752:                            USART_InitializeOperation_Default(index, receiveInterruptMode, transmitInterruptMode, operationMode);
4753:                            break;
4754:                        case USART_NUMBER_OF_MODULES :
4755:                        default :
4756:                            break;
4757:                    }
4758:                }
4759:                
4760:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverIdleStateLowEnable(USART_MODULE_ID index)
4761:                {
4762:                    switch (index) {
4763:                        case USART_ID_1 :
4764:                            return USART_ExistsReceiverIdleStateLowEnable_Default(index);
4765:                        case USART_ID_3 :
4766:                            return USART_ExistsReceiverIdleStateLowEnable_Default(index);
4767:                        case USART_ID_2 :
4768:                            return USART_ExistsReceiverIdleStateLowEnable_Default(index);
4769:                        case USART_ID_4 :
4770:                            return USART_ExistsReceiverIdleStateLowEnable_Default(index);
4771:                        case USART_ID_6 :
4772:                            return USART_ExistsReceiverIdleStateLowEnable_Default(index);
4773:                        case USART_ID_5 :
4774:                            return USART_ExistsReceiverIdleStateLowEnable_Default(index);
4775:                        case USART_NUMBER_OF_MODULES :
4776:                        default :
4777:                            return (bool)0;
4778:                    }
4779:                }
4780:                
4781:                PLIB_INLINE_API void PLIB_USART_ReceiverIdleStateLowEnable(USART_MODULE_ID index)
4782:                {
4783:                    switch (index) {
4784:                        case USART_ID_1 :
4785:                            USART_ReceiverIdleStateLowEnable_Default(index);
4786:                            break;
4787:                        case USART_ID_3 :
4788:                            USART_ReceiverIdleStateLowEnable_Default(index);
4789:                            break;
4790:                        case USART_ID_2 :
4791:                            USART_ReceiverIdleStateLowEnable_Default(index);
4792:                            break;
4793:                        case USART_ID_4 :
4794:                            USART_ReceiverIdleStateLowEnable_Default(index);
4795:                            break;
4796:                        case USART_ID_6 :
4797:                            USART_ReceiverIdleStateLowEnable_Default(index);
4798:                            break;
4799:                        case USART_ID_5 :
4800:                            USART_ReceiverIdleStateLowEnable_Default(index);
4801:                            break;
4802:                        case USART_NUMBER_OF_MODULES :
4803:                        default :
4804:                            break;
4805:                    }
4806:                }
4807:                
4808:                PLIB_INLINE_API void PLIB_USART_ReceiverIdleStateLowDisable(USART_MODULE_ID index)
4809:                {
4810:                    switch (index) {
4811:                        case USART_ID_1 :
4812:                            USART_ReceiverIdleStateLowDisable_Default(index);
4813:                            break;
4814:                        case USART_ID_3 :
4815:                            USART_ReceiverIdleStateLowDisable_Default(index);
4816:                            break;
4817:                        case USART_ID_2 :
4818:                            USART_ReceiverIdleStateLowDisable_Default(index);
4819:                            break;
4820:                        case USART_ID_4 :
4821:                            USART_ReceiverIdleStateLowDisable_Default(index);
4822:                            break;
4823:                        case USART_ID_6 :
4824:                            USART_ReceiverIdleStateLowDisable_Default(index);
4825:                            break;
4826:                        case USART_ID_5 :
4827:                            USART_ReceiverIdleStateLowDisable_Default(index);
4828:                            break;
4829:                        case USART_NUMBER_OF_MODULES :
4830:                        default :
4831:                            break;
4832:                    }
4833:                }
4834:                
4835:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverParityErrorStatus(USART_MODULE_ID index)
4836:                {
4837:                    switch (index) {
4838:                        case USART_ID_1 :
4839:                            return USART_ExistsReceiverParityErrorStatus_Default(index);
4840:                        case USART_ID_3 :
4841:                            return USART_ExistsReceiverParityErrorStatus_Default(index);
4842:                        case USART_ID_2 :
4843:                            return USART_ExistsReceiverParityErrorStatus_Default(index);
4844:                        case USART_ID_4 :
4845:                            return USART_ExistsReceiverParityErrorStatus_Default(index);
4846:                        case USART_ID_6 :
4847:                            return USART_ExistsReceiverParityErrorStatus_Default(index);
4848:                        case USART_ID_5 :
4849:                            return USART_ExistsReceiverParityErrorStatus_Default(index);
4850:                        case USART_NUMBER_OF_MODULES :
4851:                        default :
4852:                            return (bool)0;
4853:                    }
4854:                }
4855:                
4856:                PLIB_INLINE_API bool PLIB_USART_ReceiverParityErrorHasOccurred(USART_MODULE_ID index)
4857:                {
4858:                    switch (index) {
4859:                        case USART_ID_1 :
4860:                            return USART_ReceiverParityErrorHasOccurred_Default(index);
4861:                        case USART_ID_3 :
4862:                            return USART_ReceiverParityErrorHasOccurred_Default(index);
4863:                        case USART_ID_2 :
4864:                            return USART_ReceiverParityErrorHasOccurred_Default(index);
4865:                        case USART_ID_4 :
4866:                            return USART_ReceiverParityErrorHasOccurred_Default(index);
4867:                        case USART_ID_6 :
4868:                            return USART_ReceiverParityErrorHasOccurred_Default(index);
4869:                        case USART_ID_5 :
4870:                            return USART_ReceiverParityErrorHasOccurred_Default(index);
4871:                        case USART_NUMBER_OF_MODULES :
4872:                        default :
4873:                            return (bool)0;
4874:                    }
4875:                }
4876:                
4877:                PLIB_INLINE_API bool PLIB_USART_ExistsReceiverOverrunStatus(USART_MODULE_ID index)
4878:                {
4879:                    switch (index) {
4880:                        case USART_ID_1 :
4881:                            return USART_ExistsReceiverOverrunStatus_Default(index);
4882:                        case USART_ID_3 :
4883:                            return USART_ExistsReceiverOverrunStatus_Default(index);
4884:                        case USART_ID_2 :
4885:                            return USART_ExistsReceiverOverrunStatus_Default(index);
4886:                        case USART_ID_4 :
4887:                            return USART_ExistsReceiverOverrunStatus_Default(index);
4888:                        case USART_ID_6 :
4889:                            return USART_ExistsReceiverOverrunStatus_Default(index);
4890:                        case USART_ID_5 :
4891:                            return USART_ExistsReceiverOverrunStatus_Default(index);
4892:                        case USART_NUMBER_OF_MODULES :
4893:                        default :
4894:                            return (bool)0;
4895:                    }
4896:                }
4897:                
4898:                PLIB_INLINE_API void PLIB_USART_ReceiverOverrunErrorClear(USART_MODULE_ID index)
4899:                {
4900:                    switch (index) {
4901:                        case USART_ID_1 :
4902:                            USART_ReceiverOverrunErrorClear_Default(index);
4903:                            break;
4904:                        case USART_ID_3 :
4905:                            USART_ReceiverOverrunErrorClear_Default(index);
4906:                            break;
4907:                        case USART_ID_2 :
4908:                            USART_ReceiverOverrunErrorClear_Default(index);
4909:                            break;
4910:                        case USART_ID_4 :
4911:                            USART_ReceiverOverrunErrorClear_Default(index);
4912:                            break;
4913:                        case USART_ID_6 :
4914:                            USART_ReceiverOverrunErrorClear_Default(index);
4915:                            break;
4916:                        case USART_ID_5 :
4917:                            USART_ReceiverOverrunErrorClear_Default(index);
4918:                            break;
4919:                        case USART_NUMBER_OF_MODULES :
4920:                        default :
4921:                            break;
4922:                    }
4923:                }
4924:                
4925:                PLIB_INLINE_API bool PLIB_USART_ReceiverOverrunHasOccurred(USART_MODULE_ID index)
4926:                {
4927:                    switch (index) {
9D0064CC  8E020000   LW V0, 0(S0)
9D0064D0  2C420006   SLTIU V0, V0, 6
9D0064D4  10400016   BEQ V0, ZERO, 0x9D006530
9D0064D8  3C029D00   LUI V0, -25344
9D0064DC  8E030000   LW V1, 0(S0)
9D0064E0  00031880   SLL V1, V1, 2
9D0064E4  244264F8   ADDIU V0, V0, 25848
9D0064E8  00431021   ADDU V0, V0, V1
9D0064EC  8C420000   LW V0, 0(V0)
9D0064F0  00400008   JR V0
9D0064F4  00000000   NOP
9D006510  3C02BF80   LUI V0, -16512
9D006514  8C426010   LW V0, 24592(V0)
9D006518  30420002   ANDI V0, V0, 2
9D00651C  10400004   BEQ V0, ZERO, 0x9D006530
9D006520  24030002   ADDIU V1, ZERO, 2
9D006524  3C02BF80   LUI V0, -16512
9D006528  24426010   ADDIU V0, V0, 24592
9D00652C  AC430004   SW V1, 4(V0)
9D006530  0F403092   JAL _DRV_USART_ByteErrorTasks
9D006534  00000000   NOP
9D006538  8E02002C   LW V0, 44(S0)
9D00653C  00022142   SRL A0, V0, 5
9D006540  00042100   SLL A0, A0, 4
9D006544  24840004   ADDIU A0, A0, 4
9D006548  3C03BF88   LUI V1, -16504
9D00654C  24631030   ADDIU V1, V1, 4144
9D006550  00641821   ADDU V1, V1, A0
9D006554  24040001   ADDIU A0, ZERO, 1
9D006558  00441004   SLLV V0, A0, V0
9D00655C  AC620000   SW V0, 0(V1)
9D006560  0B401997   J 0x9D00665C
9D006564  8FBF0014   LW RA, 20(SP)
9D006568  3C02BF80   LUI V0, -16512
9D00656C  8C426410   LW V0, 25616(V0)
9D006570  30420002   ANDI V0, V0, 2
9D006574  1440001F   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear
9D006578  24030002   ADDIU V1, ZERO, 2
9D00657C  0B40194C   J 0x9D006530
9D006580  00000000   NOP
9D006584  3C02BF80   LUI V0, -16512
9D006588  8C426810   LW V0, 26640(V0)
9D00658C  30420002   ANDI V0, V0, 2
9D006590  1440001D   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear::USART_ReceiverOverrunErrorClear_Default
9D006594  24030002   ADDIU V1, ZERO, 2
9D006598  0B40194C   J 0x9D006530
9D00659C  00000000   NOP
9D0065A0  3C02BF80   LUI V0, -16512
9D0065A4  8C426210   LW V0, 25104(V0)
9D0065A8  30420002   ANDI V0, V0, 2
9D0065AC  1440001B   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear::USART_ReceiverOverrunErrorClear_Default
9D0065B0  24030002   ADDIU V1, ZERO, 2
9D0065B4  0B40194C   J 0x9D006530
9D0065B8  00000000   NOP
9D0065BC  3C02BF80   LUI V0, -16512
9D0065C0  8C426610   LW V0, 26128(V0)
9D0065C4  30420002   ANDI V0, V0, 2
9D0065C8  14400019   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear::USART_ReceiverOverrunErrorClear_Default
9D0065CC  24030002   ADDIU V1, ZERO, 2
9D0065D0  0B40194C   J 0x9D006530
9D0065D4  00000000   NOP
9D0065D8  3C02BF80   LUI V0, -16512
9D0065DC  8C426A10   LW V0, 27152(V0)
9D0065E0  30420002   ANDI V0, V0, 2
9D0065E4  14400017   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear::USART_ReceiverOverrunErrorClear_Default
9D0065E8  24030002   ADDIU V1, ZERO, 2
9D0065EC  0B40194C   J 0x9D006530
9D0065F0  00000000   NOP
9D0065F4  3C02BF80   LUI V0, -16512
9D0065F8  24426410   ADDIU V0, V0, 25616
9D0065FC  AC430004   SW V1, 4(V0)
9D006600  0B40194C   J 0x9D006530
9D006604  00000000   NOP
9D006608  3C02BF80   LUI V0, -16512
9D00660C  24426810   ADDIU V0, V0, 26640
9D006610  AC430004   SW V1, 4(V0)
9D006614  0B40194C   J 0x9D006530
9D006618  00000000   NOP
9D00661C  3C02BF80   LUI V0, -16512
9D006620  24426210   ADDIU V0, V0, 25104
9D006624  AC430004   SW V1, 4(V0)
9D006628  0B40194C   J 0x9D006530
9D00662C  00000000   NOP
9D006630  3C02BF80   LUI V0, -16512
9D006634  24426610   ADDIU V0, V0, 26128
9D006638  AC430004   SW V1, 4(V0)
9D00663C  0B40194C   J 0x9D006530
9D006640  00000000   NOP
9D006644  3C02BF80   LUI V0, -16512
9D006648  24426A10   ADDIU V0, V0, 27152
9D00664C  AC430004   SW V1, 4(V0)
9D006650  0B40194C   J 0x9D006530
9D006654  00000000   NOP
9D006658  8FBF0014   LW RA, 20(SP)
9D00665C  8FB00010   LW S0, 16(SP)
9D006660  03E00008   JR RA
9D006664  27BD0018   ADDIU SP, SP, 24
4928:                        case USART_ID_1 :
4929:                            return USART_ReceiverOverrunHasOccurred_Default(index);
4930:                        case USART_ID_3 :
4931:                            return USART_ReceiverOverrunHasOccurred_Default(index);
4932:                        case USART_ID_2 :
4933:                            return USART_ReceiverOverrunHasOccurred_Default(index);
4934:                        case USART_ID_4 :
4935:                            return USART_ReceiverOverrunHasOccurred_Default(index);
4936:                        case USART_ID_6 :
4937:                            return USART_ReceiverOverrunHasOccurred_Default(index);
4938:                        case USART_ID_5 :
4939:                            return USART_ReceiverOverrunHasOccurred_Default(index);
4940:                        case USART_NUMBER_OF_MODULES :
4941:                        default :
4942:                            return (bool)0;
4943:                    }
4944:                }
4945:                
4946:                PLIB_INLINE_API bool PLIB_USART_ExistsTransmitter(USART_MODULE_ID index)
4947:                {
4948:                    switch (index) {
4949:                        case USART_ID_1 :
4950:                            return USART_ExistsTransmitter_Default(index);
4951:                        case USART_ID_3 :
4952:                            return USART_ExistsTransmitter_Default(index);
4953:                        case USART_ID_2 :
4954:                            return USART_ExistsTransmitter_Default(index);
4955:                        case USART_ID_4 :
4956:                            return USART_ExistsTransmitter_Default(index);
4957:                        case USART_ID_6 :
4958:                            return USART_ExistsTransmitter_Default(index);
4959:                        case USART_ID_5 :
4960:                            return USART_ExistsTransmitter_Default(index);
4961:                        case USART_NUMBER_OF_MODULES :
4962:                        default :
4963:                            return (bool)0;
4964:                    }
4965:                }
4966:                
4967:                PLIB_INLINE_API void PLIB_USART_TransmitterByteSend(USART_MODULE_ID index, int8_t data)
4968:                {
4969:                    switch (index) {
9D0088F8  8E020000   LW V0, 0(S0)
9D0088FC  2C420006   SLTIU V0, V0, 6
9D008900  10400012   BEQ V0, ZERO, 0x9D00894C
9D008904  7C129420   SEB S2, S2
9D008908  8E030000   LW V1, 0(S0)
9D00890C  00031880   SLL V1, V1, 2
9D008910  3C029D01   LUI V0, -25343
9D008914  24428928   ADDIU V0, V0, -30424
9D008918  00431021   ADDU V0, V0, V1
9D00891C  8C420000   LW V0, 0(V0)
9D008920  00400008   JR V0
9D008924  00000000   NOP
0000012C  00000000   NOP
000003A4  00000000   NOP
4970:                        case USART_ID_1 :
4971:                            USART_TransmitterByteSend_Default(index, data);
4972:                            break;
4973:                        case USART_ID_3 :
4974:                            USART_TransmitterByteSend_Default(index, data);
4975:                            break;
4976:                        case USART_ID_2 :
4977:                            USART_TransmitterByteSend_Default(index, data);
4978:                            break;
4979:                        case USART_ID_4 :
4980:                            USART_TransmitterByteSend_Default(index, data);
4981:                            break;
4982:                        case USART_ID_6 :
4983:                            USART_TransmitterByteSend_Default(index, data);
4984:                            break;
4985:                        case USART_ID_5 :
4986:                            USART_TransmitterByteSend_Default(index, data);
4987:                            break;
4988:                        case USART_NUMBER_OF_MODULES :
4989:                        default :
4990:                            break;
4991:                    }
4992:                }
4993:                
4994:                PLIB_INLINE_API void* PLIB_USART_TransmitterAddressGet(USART_MODULE_ID index)
4995:                {
4996:                    switch (index) {
4997:                        case USART_ID_1 :
4998:                            return USART_TransmitterAddressGet_Default(index);
4999:                        case USART_ID_3 :
5000:                            return USART_TransmitterAddressGet_Default(index);
5001:                        case USART_ID_2 :
5002:                            return USART_TransmitterAddressGet_Default(index);
5003:                        case USART_ID_4 :
5004:                            return USART_TransmitterAddressGet_Default(index);
5005:                        case USART_ID_6 :
5006:                            return USART_TransmitterAddressGet_Default(index);
5007:                        case USART_ID_5 :
5008:                            return USART_TransmitterAddressGet_Default(index);
5009:                        case USART_NUMBER_OF_MODULES :
5010:                        default :
5011:                            return (void*)0;
5012:                    }
5013:                }
5014:                
5015:                PLIB_INLINE_API bool PLIB_USART_ExistsTransmitter9BitsSend(USART_MODULE_ID index)
5016:                {
5017:                    switch (index) {
5018:                        case USART_ID_1 :
5019:                            return USART_ExistsTransmitter9BitsSend_InDataOnly(index);
5020:                        case USART_ID_3 :
5021:                            return USART_ExistsTransmitter9BitsSend_InDataOnly(index);
5022:                        case USART_ID_2 :
5023:                            return USART_ExistsTransmitter9BitsSend_InDataOnly(index);
5024:                        case USART_ID_4 :
5025:                            return USART_ExistsTransmitter9BitsSend_InDataOnly(index);
5026:                        case USART_ID_6 :
5027:                            return USART_ExistsTransmitter9BitsSend_InDataOnly(index);
5028:                        case USART_ID_5 :
5029:                            return USART_ExistsTransmitter9BitsSend_InDataOnly(index);
5030:                        case USART_NUMBER_OF_MODULES :
5031:                        default :
5032:                            return (bool)0;
5033:                    }
5034:                }
5035:                
5036:                PLIB_INLINE_API void PLIB_USART_Transmitter9BitsSend(USART_MODULE_ID index, int8_t data, bool Bit9th)
5037:                {
5038:                    switch (index) {
00000180  00000000   NOP
000001A0  00000000   NOP
000001C4  00000000   NOP
000002C4  00000000   NOP
5039:                        case USART_ID_1 :
5040:                            USART_Transmitter9BitsSend_InDataOnly(index, data, Bit9th);
5041:                            break;
5042:                        case USART_ID_3 :
5043:                            USART_Transmitter9BitsSend_InDataOnly(index, data, Bit9th);
5044:                            break;
5045:                        case USART_ID_2 :
5046:                            USART_Transmitter9BitsSend_InDataOnly(index, data, Bit9th);
5047:                            break;
5048:                        case USART_ID_4 :
5049:                            USART_Transmitter9BitsSend_InDataOnly(index, data, Bit9th);
5050:                            break;
5051:                        case USART_ID_6 :
5052:                            USART_Transmitter9BitsSend_InDataOnly(index, data, Bit9th);
5053:                            break;
5054:                        case USART_ID_5 :
5055:                            USART_Transmitter9BitsSend_InDataOnly(index, data, Bit9th);
5056:                            break;
5057:                        case USART_NUMBER_OF_MODULES :
5058:                        default :
5059:                            break;
5060:                    }
5061:                }
5062:                
5063:                PLIB_INLINE_API bool PLIB_USART_ExistsTransmitterBreak(USART_MODULE_ID index)
5064:                {
5065:                    switch (index) {
5066:                        case USART_ID_1 :
5067:                            return USART_ExistsTransmitterBreak_Default(index);
5068:                        case USART_ID_3 :
5069:                            return USART_ExistsTransmitterBreak_Default(index);
5070:                        case USART_ID_2 :
5071:                            return USART_ExistsTransmitterBreak_Default(index);
5072:                        case USART_ID_4 :
5073:                            return USART_ExistsTransmitterBreak_Default(index);
5074:                        case USART_ID_6 :
5075:                            return USART_ExistsTransmitterBreak_Default(index);
5076:                        case USART_ID_5 :
5077:                            return USART_ExistsTransmitterBreak_Default(index);
5078:                        case USART_NUMBER_OF_MODULES :
5079:                        default :
5080:                            return (bool)0;
5081:                    }
5082:                }
5083:                
5084:                PLIB_INLINE_API void PLIB_USART_TransmitterBreakSend(USART_MODULE_ID index)
5085:                {
5086:                    switch (index) {
5087:                        case USART_ID_1 :
5088:                            USART_TransmitterBreakSend_Default(index);
5089:                            break;
5090:                        case USART_ID_3 :
5091:                            USART_TransmitterBreakSend_Default(index);
5092:                            break;
5093:                        case USART_ID_2 :
5094:                            USART_TransmitterBreakSend_Default(index);
5095:                            break;
5096:                        case USART_ID_4 :
5097:                            USART_TransmitterBreakSend_Default(index);
5098:                            break;
5099:                        case USART_ID_6 :
5100:                            USART_TransmitterBreakSend_Default(index);
5101:                            break;
5102:                        case USART_ID_5 :
5103:                            USART_TransmitterBreakSend_Default(index);
5104:                            break;
5105:                        case USART_NUMBER_OF_MODULES :
5106:                        default :
5107:                            break;
5108:                    }
5109:                }
5110:                
5111:                PLIB_INLINE_API bool PLIB_USART_TransmitterBreakSendIsComplete(USART_MODULE_ID index)
5112:                {
5113:                    switch (index) {
5114:                        case USART_ID_1 :
5115:                            return USART_TransmitterBreakSendIsComplete_Default(index);
5116:                        case USART_ID_3 :
5117:                            return USART_TransmitterBreakSendIsComplete_Default(index);
5118:                        case USART_ID_2 :
5119:                            return USART_TransmitterBreakSendIsComplete_Default(index);
5120:                        case USART_ID_4 :
5121:                            return USART_TransmitterBreakSendIsComplete_Default(index);
5122:                        case USART_ID_6 :
5123:                            return USART_TransmitterBreakSendIsComplete_Default(index);
5124:                        case USART_ID_5 :
5125:                            return USART_TransmitterBreakSendIsComplete_Default(index);
5126:                        case USART_NUMBER_OF_MODULES :
5127:                        default :
5128:                            return (bool)0;
5129:                    }
5130:                }
5131:                
5132:                PLIB_INLINE_API bool PLIB_USART_ExistsTransmitterBufferFullStatus(USART_MODULE_ID index)
5133:                {
5134:                    switch (index) {
5135:                        case USART_ID_1 :
5136:                            return USART_ExistsTransmitterBufferFullStatus_Default(index);
5137:                        case USART_ID_3 :
5138:                            return USART_ExistsTransmitterBufferFullStatus_Default(index);
5139:                        case USART_ID_2 :
5140:                            return USART_ExistsTransmitterBufferFullStatus_Default(index);
5141:                        case USART_ID_4 :
5142:                            return USART_ExistsTransmitterBufferFullStatus_Default(index);
5143:                        case USART_ID_6 :
5144:                            return USART_ExistsTransmitterBufferFullStatus_Default(index);
5145:                        case USART_ID_5 :
5146:                            return USART_ExistsTransmitterBufferFullStatus_Default(index);
5147:                        case USART_NUMBER_OF_MODULES :
5148:                        default :
5149:                            return (bool)0;
5150:                    }
5151:                }
5152:                
5153:                PLIB_INLINE_API bool PLIB_USART_TransmitterBufferIsFull(USART_MODULE_ID index)
5154:                {
5155:                    switch (index) {
0000001C  00000000   NOP
000000D8  00000000   NOP
00000104  00000000   NOP
00000158  00000000   NOP
00000344  00000000   NOP
000003E4  00000000   NOP
5156:                        case USART_ID_1 :
5157:                            return USART_TransmitterBufferIsFull_Default(index);
5158:                        case USART_ID_3 :
5159:                            return USART_TransmitterBufferIsFull_Default(index);
5160:                        case USART_ID_2 :
5161:                            return USART_TransmitterBufferIsFull_Default(index);
5162:                        case USART_ID_4 :
5163:                            return USART_TransmitterBufferIsFull_Default(index);
5164:                        case USART_ID_6 :
5165:                            return USART_TransmitterBufferIsFull_Default(index);
5166:                        case USART_ID_5 :
5167:                            return USART_TransmitterBufferIsFull_Default(index);
5168:                        case USART_NUMBER_OF_MODULES :
5169:                        default :
5170:                            return (bool)0;
00000128  00000000   NOP
5171:                    }
5172:                }
5173:                
5174:                PLIB_INLINE_API bool PLIB_USART_TransmitterIsEmpty(USART_MODULE_ID index)
5175:                {
5176:                    switch (index) {
0000007C  00000000   NOP
5177:                        case USART_ID_1 :
5178:                            return USART_TransmitterIsEmpty_Default(index);
5179:                        case USART_ID_3 :
5180:                            return USART_TransmitterIsEmpty_Default(index);
5181:                        case USART_ID_2 :
5182:                            return USART_TransmitterIsEmpty_Default(index);
5183:                        case USART_ID_4 :
5184:                            return USART_TransmitterIsEmpty_Default(index);
5185:                        case USART_ID_6 :
5186:                            return USART_TransmitterIsEmpty_Default(index);
5187:                        case USART_ID_5 :
5188:                            return USART_TransmitterIsEmpty_Default(index);
5189:                        case USART_NUMBER_OF_MODULES :
5190:                        default :
5191:                            return (bool)0;
000000CC  00000000   NOP
5192:                    }
5193:                }
5194:                
5195:                PLIB_INLINE_API bool PLIB_USART_ExistsTransmitterEmptyStatus(USART_MODULE_ID index)
5196:                {
5197:                    switch (index) {
5198:                        case USART_ID_1 :
5199:                            return USART_ExistsTransmitterEmptyStatus_Default(index);
5200:                        case USART_ID_3 :
5201:                            return USART_ExistsTransmitterEmptyStatus_Default(index);
5202:                        case USART_ID_2 :
5203:                            return USART_ExistsTransmitterEmptyStatus_Default(index);
5204:                        case USART_ID_4 :
5205:                            return USART_ExistsTransmitterEmptyStatus_Default(index);
5206:                        case USART_ID_6 :
5207:                            return USART_ExistsTransmitterEmptyStatus_Default(index);
5208:                        case USART_ID_5 :
5209:                            return USART_ExistsTransmitterEmptyStatus_Default(index);
5210:                        case USART_NUMBER_OF_MODULES :
5211:                        default :
5212:                            return (bool)0;
5213:                    }
5214:                }
5215:                
5216:                PLIB_INLINE_API bool PLIB_USART_ExistsTransmitterEnable(USART_MODULE_ID index)
5217:                {
5218:                    switch (index) {
5219:                        case USART_ID_1 :
5220:                            return USART_ExistsTransmitterEnable_Default(index);
5221:                        case USART_ID_3 :
5222:                            return USART_ExistsTransmitterEnable_Default(index);
5223:                        case USART_ID_2 :
5224:                            return USART_ExistsTransmitterEnable_Default(index);
5225:                        case USART_ID_4 :
5226:                            return USART_ExistsTransmitterEnable_Default(index);
5227:                        case USART_ID_6 :
5228:                            return USART_ExistsTransmitterEnable_Default(index);
5229:                        case USART_ID_5 :
5230:                            return USART_ExistsTransmitterEnable_Default(index);
5231:                        case USART_NUMBER_OF_MODULES :
5232:                        default :
5233:                            return (bool)0;
5234:                    }
5235:                }
5236:                
5237:                PLIB_INLINE_API void PLIB_USART_TransmitterEnable(USART_MODULE_ID index)
5238:                {
5239:                    switch (index) {
5240:                        case USART_ID_1 :
5241:                            USART_TransmitterEnable_Default(index);
5242:                            break;
5243:                        case USART_ID_3 :
5244:                            USART_TransmitterEnable_Default(index);
5245:                            break;
5246:                        case USART_ID_2 :
5247:                            USART_TransmitterEnable_Default(index);
5248:                            break;
5249:                        case USART_ID_4 :
5250:                            USART_TransmitterEnable_Default(index);
5251:                            break;
5252:                        case USART_ID_6 :
5253:                            USART_TransmitterEnable_Default(index);
5254:                            break;
5255:                        case USART_ID_5 :
5256:                            USART_TransmitterEnable_Default(index);
5257:                            break;
5258:                        case USART_NUMBER_OF_MODULES :
5259:                        default :
5260:                            break;
5261:                    }
5262:                }
5263:                
5264:                PLIB_INLINE_API void PLIB_USART_TransmitterDisable(USART_MODULE_ID index)
5265:                {
5266:                    switch (index) {
5267:                        case USART_ID_1 :
5268:                            USART_TransmitterDisable_Default(index);
5269:                            break;
5270:                        case USART_ID_3 :
5271:                            USART_TransmitterDisable_Default(index);
5272:                            break;
5273:                        case USART_ID_2 :
5274:                            USART_TransmitterDisable_Default(index);
5275:                            break;
5276:                        case USART_ID_4 :
5277:                            USART_TransmitterDisable_Default(index);
5278:                            break;
5279:                        case USART_ID_6 :
5280:                            USART_TransmitterDisable_Default(index);
5281:                            break;
5282:                        case USART_ID_5 :
5283:                            USART_TransmitterDisable_Default(index);
5284:                            break;
5285:                        case USART_NUMBER_OF_MODULES :
5286:                        default :
5287:                            break;
5288:                    }
5289:                }
5290:                
5291:                PLIB_INLINE_API void PLIB_USART_TransmitterInterruptModeSelect(USART_MODULE_ID index, USART_TRANSMIT_INTR_MODE fifolevel)
5292:                {
5293:                    switch (index) {
5294:                        case USART_ID_1 :
5295:                            USART_TransmitterInterruptModeSelect_Default(index, fifolevel);
5296:                            break;
5297:                        case USART_ID_3 :
5298:                            USART_TransmitterInterruptModeSelect_Default(index, fifolevel);
5299:                            break;
5300:                        case USART_ID_2 :
5301:                            USART_TransmitterInterruptModeSelect_Default(index, fifolevel);
5302:                            break;
5303:                        case USART_ID_4 :
5304:                            USART_TransmitterInterruptModeSelect_Default(index, fifolevel);
5305:                            break;
5306:                        case USART_ID_6 :
5307:                            USART_TransmitterInterruptModeSelect_Default(index, fifolevel);
5308:                            break;
5309:                        case USART_ID_5 :
5310:                            USART_TransmitterInterruptModeSelect_Default(index, fifolevel);
5311:                            break;
5312:                        case USART_NUMBER_OF_MODULES :
5313:                        default :
5314:                            break;
5315:                    }
5316:                }
5317:                
5318:                PLIB_INLINE_API bool PLIB_USART_ExistsTransmitterInterruptMode(USART_MODULE_ID index)
5319:                {
5320:                    switch (index) {
5321:                        case USART_ID_1 :
5322:                            return USART_ExistsTransmitterInterruptMode_Default(index);
5323:                        case USART_ID_3 :
5324:                            return USART_ExistsTransmitterInterruptMode_Default(index);
5325:                        case USART_ID_2 :
5326:                            return USART_ExistsTransmitterInterruptMode_Default(index);
5327:                        case USART_ID_4 :
5328:                            return USART_ExistsTransmitterInterruptMode_Default(index);
5329:                        case USART_ID_6 :
5330:                            return USART_ExistsTransmitterInterruptMode_Default(index);
5331:                        case USART_ID_5 :
5332:                            return USART_ExistsTransmitterInterruptMode_Default(index);
5333:                        case USART_NUMBER_OF_MODULES :
5334:                        default :
5335:                            return (bool)0;
5336:                    }
5337:                }
5338:                
5339:                PLIB_INLINE_API bool PLIB_USART_ExistsTransmitterIdleIsLow(USART_MODULE_ID index)
5340:                {
5341:                    switch (index) {
5342:                        case USART_ID_1 :
5343:                            return USART_ExistsTransmitterIdleIsLow_pic32(index);
5344:                        case USART_ID_3 :
5345:                            return USART_ExistsTransmitterIdleIsLow_pic32(index);
5346:                        case USART_ID_2 :
5347:                            return USART_ExistsTransmitterIdleIsLow_pic32(index);
5348:                        case USART_ID_4 :
5349:                            return USART_ExistsTransmitterIdleIsLow_pic32(index);
5350:                        case USART_ID_6 :
5351:                            return USART_ExistsTransmitterIdleIsLow_pic32(index);
5352:                        case USART_ID_5 :
5353:                            return USART_ExistsTransmitterIdleIsLow_pic32(index);
5354:                        case USART_NUMBER_OF_MODULES :
5355:                        default :
5356:                            return (bool)0;
5357:                    }
5358:                }
5359:                
5360:                PLIB_INLINE_API void PLIB_USART_TransmitterIdleIsLowDisable(USART_MODULE_ID index)
5361:                {
5362:                    switch (index) {
5363:                        case USART_ID_1 :
5364:                            USART_TransmitterIdleIsLowDisable_pic32(index);
5365:                            break;
5366:                        case USART_ID_3 :
5367:                            USART_TransmitterIdleIsLowDisable_pic32(index);
5368:                            break;
5369:                        case USART_ID_2 :
5370:                            USART_TransmitterIdleIsLowDisable_pic32(index);
5371:                            break;
5372:                        case USART_ID_4 :
5373:                            USART_TransmitterIdleIsLowDisable_pic32(index);
5374:                            break;
5375:                        case USART_ID_6 :
5376:                            USART_TransmitterIdleIsLowDisable_pic32(index);
5377:                            break;
5378:                        case USART_ID_5 :
5379:                            USART_TransmitterIdleIsLowDisable_pic32(index);
5380:                            break;
5381:                        case USART_NUMBER_OF_MODULES :
5382:                        default :
5383:                            break;
5384:                    }
5385:                }
5386:                
5387:                PLIB_INLINE_API void PLIB_USART_TransmitterIdleIsLowEnable(USART_MODULE_ID index)
5388:                {
5389:                    switch (index) {
5390:                        case USART_ID_1 :
5391:                            USART_TransmitterIdleIsLowEnable_pic32(index);
5392:                            break;
5393:                        case USART_ID_3 :
5394:                            USART_TransmitterIdleIsLowEnable_pic32(index);
5395:                            break;
5396:                        case USART_ID_2 :
5397:                            USART_TransmitterIdleIsLowEnable_pic32(index);
5398:                            break;
5399:                        case USART_ID_4 :
5400:                            USART_TransmitterIdleIsLowEnable_pic32(index);
5401:                            break;
5402:                        case USART_ID_6 :
5403:                            USART_TransmitterIdleIsLowEnable_pic32(index);
5404:                            break;
5405:                        case USART_ID_5 :
5406:                            USART_TransmitterIdleIsLowEnable_pic32(index);
5407:                            break;
5408:                        case USART_NUMBER_OF_MODULES :
5409:                        default :
5410:                            break;
5411:                    }
5412:                }
5413:                
5414:                #endif
---  c:/microchip/harmony/v1_08_01/framework/peripheral/tmr/templates/tmr_stopinidle_default.h  ---------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_StopInIdle_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopInIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_StopInIdleEnable
16:                          PLIB_TMR_StopInIdleDisable
17:                          PLIB_TMR_ExistsStopInIdleControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_STOPINIDLE_DEFAULT_H
48:                  #define _TMR_STOPINIDLE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _TMR_STOP_IN_IDLE_VREG(index)
55:                  
56:                    MASKs: 
57:                      _TMR_STOP_IN_IDLE_MASK(index)
58:                  
59:                    POSs: 
60:                      _TMR_STOP_IN_IDLE_POS(index)
61:                  
62:                    LENs: 
63:                      _TMR_STOP_IN_IDLE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  TMR_StopInIdleEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_TMR_StopInIdleEnable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_TMR_StopInIdleEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void TMR_StopInIdleEnable_Default( TMR_MODULE_ID index )
79:                  {
80:                      _SFR_BIT_SET( _TMR_STOP_IN_IDLE_VREG( index ),
81:                                    _TMR_STOP_IN_IDLE_POS( index ) );
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  TMR_StopInIdleDisable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_TMR_StopInIdleDisable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_TMR_StopInIdleDisable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void TMR_StopInIdleDisable_Default( TMR_MODULE_ID index )
96:                  {
97:                      _SFR_BIT_CLEAR( _TMR_STOP_IN_IDLE_VREG( index ),
00000000  00000000   NOP
98:                                      _TMR_STOP_IN_IDLE_POS( index ) );
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  TMR_ExistsStopInIdleControl_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_TMR_ExistsStopInIdleControl
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_TMR_ExistsStopInIdleControl function.
110:                 */
111:                 
112:                 #define PLIB_TMR_ExistsStopInIdleControl PLIB_TMR_ExistsStopInIdleControl
113:                 PLIB_TEMPLATE bool TMR_ExistsStopInIdleControl_Default( TMR_MODULE_ID index )
114:                 {
115:                     return true;
116:                 }
117:                 
118:                 
119:                 #endif /*_TMR_STOPINIDLE_DEFAULT_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/tmr/templates/tmr_prescale_default.h  -----------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Prescale_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Prescale
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_PrescaleSelect
16:                          PLIB_TMR_PrescaleGet
17:                          PLIB_TMR_ExistsPrescale
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PRESCALE_DEFAULT_H
48:                  #define _TMR_PRESCALE_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
53:                  
54:                    VREGs:
55:                      _TMR_PRESCALE_VREG(index)
56:                  
57:                    MASKs:
58:                      _TMR_PRESCALE_MASK(index)
59:                  
60:                    POSs:
61:                      _TMR_PRESCALE_POS(index)
62:                  
63:                    LENs:
64:                      _TMR_PRESCALE_LEN(index)
65:                  
66:                  */
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  TMR_PrescaleSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_TMR_PrescaleSelect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_TMR_PrescaleSelect function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void TMR_PrescaleSelect_Default( TMR_MODULE_ID index , TMR_PRESCALE prescale )
80:                  {
81:                  	if(index == TMR_ID_1)
82:                  	{
83:                  		switch(prescale)
84:                  		{
85:                  			case TMR_PRESCALE_VALUE_1: _SFR_FIELD_WRITE( _TMR_PRESCALE_VREG(index),
86:                  														  _TMR_PRESCALE_MASK(index),
87:                  														  _TMR_PRESCALE_POS(index),
88:                  															0x00 );
89:                  										break;
90:                  			case TMR_PRESCALE_VALUE_8: _SFR_FIELD_WRITE( _TMR_PRESCALE_VREG(index),
91:                  														  _TMR_PRESCALE_MASK(index),
92:                  														  _TMR_PRESCALE_POS(index),
93:                  															0x01 );
94:                  										break;
95:                  			case TMR_PRESCALE_VALUE_64: _SFR_FIELD_WRITE( _TMR_PRESCALE_VREG(index),
96:                  														  _TMR_PRESCALE_MASK(index),
97:                  														  _TMR_PRESCALE_POS(index),
98:                  															0x02 );
99:                  										break;
100:                 			case TMR_PRESCALE_VALUE_256: _SFR_FIELD_WRITE( _TMR_PRESCALE_VREG(index),
101:                 														  _TMR_PRESCALE_MASK(index),
102:                 														  _TMR_PRESCALE_POS(index),
103:                 															0x03 );
104:                 										break;
105:                 			default: PLIB_ASSERT(false, " Given Prescale value is not supported for Timer1");
106:                 		}
107:                 	}
108:                 	else
109:                 	{
110:                 		_SFR_FIELD_WRITE( _TMR_PRESCALE_VREG(index),
9D00C080  8C650800   LW A1, 2048(V1)
9D00C084  2404FF8F   ADDIU A0, ZERO, -113
9D00C088  00A42024   AND A0, A1, A0
9D00C08C  34840060   ORI A0, A0, 96
9D00C090  AC640800   SW A0, 2048(V1)
00000048  00000000   NOP
00000070  00000000   NOP
000000B0  00000000   NOP
111:                 						  _TMR_PRESCALE_MASK(index),
112:                 						  _TMR_PRESCALE_POS(index),
113:                 							prescale );
114:                 	}
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  TMR_PrescaleGet_Default
120:                 
121:                   Summary:
122:                     Implements Default variant of PLIB_TMR_PrescaleGet
123:                 
124:                   Description:
125:                     This template implements the Default variant of the PLIB_TMR_PrescaleGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE uint16_t TMR_PrescaleGet_Default( TMR_MODULE_ID index )
129:                 {
130:                     uint8_t temp_prescaler;
131:                     uint16_t preScaler;
132:                 
133:                 	temp_prescaler = _SFR_FIELD_READ( _TMR_PRESCALE_VREG(index),
00000000  00000000   NOP
00000010  00000000   NOP
134:                                                               _TMR_PRESCALE_MASK(index),
135:                                                               _TMR_PRESCALE_POS(index) );
136:                 						  
137:                 	if(index == TMR_ID_1)
138:                 	{
139:                 		switch(temp_prescaler)
140:                 		{
141:                 			case 0x00: return 1;
142:                 										
143:                 			case 0x01: return 8;
144:                 										
145:                 			case 0x02: return 64;
146:                 										
147:                 			case 0x03: return 256;
148:                 
149:                                     default: return 0;
150:                 		}
151:                 	}
152:                 	else
153:                 	{
154:                             /* 1, 2, 4, 8, 16, 32, 64, 256 */
155:                             if ( temp_prescaler == 7 )
0000000C  00000000   NOP
156:                             {
157:                                 temp_prescaler++;
158:                             }
159:                             preScaler = 0x01 << temp_prescaler;
0000001C  00000000   NOP
00000028  00000000   NOP
160:                             return ( preScaler );
161:                 	}
162:                 }
163:                 
164:                 
165:                 //******************************************************************************
166:                 /* Function :  TMR_ExistsPrescale_Default
167:                 
168:                   Summary:
169:                     Implements Default variant of PLIB_TMR_ExistsPrescale
170:                 
171:                   Description:
172:                     This template implements the Default variant of the PLIB_TMR_ExistsPrescale function.
173:                 */
174:                 
175:                 #define PLIB_TMR_ExistsPrescale PLIB_TMR_ExistsPrescale
176:                 PLIB_TEMPLATE bool TMR_ExistsPrescale_Default( TMR_MODULE_ID index )
177:                 {
178:                     return true;
179:                 }
180:                 
181:                 
182:                 #endif /*_TMR_PRESCALE_DEFAULT_H*/
183:                 
184:                 /******************************************************************************
185:                  End of File
186:                 */
187:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/tmr/templates/tmr_period16bit_default.h  --------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Period16Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Period16Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Period16BitSet
16:                          PLIB_TMR_Period16BitGet
17:                          PLIB_TMR_ExistsPeriod16Bit
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PERIOD16BIT_Default_H
48:                  #define _TMR_PERIOD16BIT_Default_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
52:                  
53:                    VREGs:
54:                      _TMR_PERIOD_REGISTER_16BIT_VREG(index)
55:                  
56:                    MASKs:
57:                      _TMR_PERIOD_REGISTER_16BIT_MASK(index)
58:                  
59:                    POSs:
60:                      _TMR_PERIOD_REGISTER_16BIT_POS(index)
61:                  
62:                    LENs:
63:                      _TMR_PERIOD_REGISTER_16BIT_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  TMR_Period16BitSet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_TMR_Period16BitSet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_TMR_Period16BitSet function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void TMR_Period16BitSet_Default( TMR_MODULE_ID index , uint16_t period )
79:                  {
80:                      /* Period Match TMR */
81:                      _SFR_WRITE( _TMR_PERIOD_REGISTER_16BIT_VREG( index ), period );
9D00C0A4  3403FFFF   ORI V1, ZERO, -1
9D00C0A8  3C02BF80   LUI V0, -16512
9D00C0AC  AC430820   SW V1, 2080(V0)
00000004  00000000   NOP
82:                  
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  TMR_Period16BitGet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_TMR_Period16BitGet
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_TMR_Period16BitGet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE uint16_t TMR_Period16BitGet_Default( TMR_MODULE_ID index )
97:                  {
98:                      return ( _SFR_READ( _TMR_PERIOD_REGISTER_16BIT_VREG( index ) ) );
00000000  00000000   NOP
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  TMR_ExistsPeriod16Bit_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_TMR_ExistsPeriod16Bit
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_TMR_ExistsPeriod16Bit function.
110:                 */
111:                 
112:                 #define PLIB_TMR_ExistsPeriod16Bit PLIB_TMR_ExistsPeriod16Bit
113:                 PLIB_TEMPLATE bool TMR_ExistsPeriod16Bit_Default( TMR_MODULE_ID index )
114:                 {
115:                     return true;
116:                 }
117:                 
118:                 
119:                 #endif /*_TMR_PERIOD16BIT_Default_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/tmr/templates/tmr_mode16bit_default.h  ----------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Mode16Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Mode16Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Mode16BitEnable
16:                          PLIB_TMR_ExistsMode16Bit
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_MODE16BIT_DEFAULT_H
47:                  #define _TMR_MODE16BIT_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _TMR_MODE_16BIT_VREG(index)
54:                  
55:                    MASKs: 
56:                      _TMR_MODE_16BIT_MASK(index)
57:                  
58:                    POSs: 
59:                      _TMR_MODE_16BIT_POS(index)
60:                  
61:                    LENs: 
62:                      _TMR_MODE_16BIT_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  TMR_Mode16BitEnable_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_TMR_Mode16BitEnable 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_TMR_Mode16BitEnable function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void TMR_Mode16BitEnable_Default( TMR_MODULE_ID index )
78:                  {
79:                      _SFR_BIT_CLEAR( _TMR_MODE_16BIT_VREG( index ),
9D00C094  24030008   ADDIU V1, ZERO, 8
9D00C098  AC430004   SW V1, 4(V0)
80:                                      _TMR_MODE_16BIT_POS( index ) );
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  TMR_ExistsMode16Bit_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_TMR_ExistsMode16Bit
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_TMR_ExistsMode16Bit function.
92:                  */
93:                  
94:                  #define PLIB_TMR_ExistsMode16Bit PLIB_TMR_ExistsMode16Bit
95:                  PLIB_TEMPLATE bool TMR_ExistsMode16Bit_Default( TMR_MODULE_ID index )
96:                  {
97:                      return true;
98:                  }
99:                  
100:                 
101:                 #endif /*_TMR_MODE16BIT_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/tmr/templates/tmr_enablecontrol_default.h  ------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Start
16:                          PLIB_TMR_Stop
17:                          PLIB_TMR_ExistsEnableControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_ENABLECONTROL_DEFAULT_H
48:                  #define _TMR_ENABLECONTROL_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _TMR_ENABLE_VREG(index)
55:                  
56:                    MASKs: 
57:                      _TMR_ENABLE_MASK(index)
58:                  
59:                    POSs: 
60:                      _TMR_ENABLE_POS(index)
61:                  
62:                    LENs: 
63:                      _TMR_ENABLE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  TMR_Start_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_TMR_Start 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_TMR_Start function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void TMR_Start_Default( TMR_MODULE_ID index )
79:                  {
80:                      _SFR_BIT_SET(_TMR_ENABLE_VREG(index),
9D00D4CC  34038000   ORI V1, ZERO, -32768
00000098  00000000   NOP
81:                                   _TMR_ENABLE_POS(index) );
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  TMR_Stop_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_TMR_Stop 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_TMR_Stop function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void TMR_Stop_Default( TMR_MODULE_ID index )
96:                  {
97:                      _SFR_BIT_CLEAR(_TMR_ENABLE_VREG(index),
9D00C068  3C03BF80   LUI V1, -16512
9D00C06C  24620800   ADDIU V0, V1, 2048
9D00C070  34048000   ORI A0, ZERO, -32768
9D00C074  AC440004   SW A0, 4(V0)
00000018  00000000   NOP
0000001C  00000000   NOP
98:                                     _TMR_ENABLE_POS(index) );
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  TMR_ExistsEnableControl_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_TMR_ExistsEnableControl
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_TMR_ExistsEnableControl function.
110:                 */
111:                 
112:                 #define PLIB_TMR_ExistsEnableControl PLIB_TMR_ExistsEnableControl
113:                 PLIB_TEMPLATE bool TMR_ExistsEnableControl_Default( TMR_MODULE_ID index )
114:                 {
115:                     return true;
116:                 }
117:                 
118:                 
119:                 #endif /*_TMR_ENABLECONTROL_DEFAULT_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/tmr/templates/tmr_counter16bit_in16bitregister.h  
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Counter16Bit_In16BitRegister.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Counter16Bit
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_TMR_Counter16BitSet
16:                          PLIB_TMR_Counter16BitGet
17:                          PLIB_TMR_Counter16BitClear
18:                          PLIB_TMR_ExistsCounter16Bit
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _TMR_COUNTER16BIT_IN16BITREGISTER_H
49:                  #define _TMR_COUNTER16BIT_IN16BITREGISTER_H
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
53:                  
54:                    VREGs:
55:                      _TMR_VALUE_REGISTER_16BIT_VREG(index)
56:                  
57:                    MASKs:
58:                      _TMR_VALUE_REGISTER_16BIT_MASK(index)
59:                  
60:                    POSs:
61:                      _TMR_VALUE_REGISTER_16BIT_POS(index)
62:                  
63:                    LENs:
64:                      _TMR_VALUE_REGISTER_16BIT_LEN(index)
65:                  
66:                  */
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  TMR_Counter16BitSet_In16BitRegister
71:                  
72:                    Summary:
73:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitSet
74:                  
75:                    Description:
76:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void TMR_Counter16BitSet_In16BitRegister( TMR_MODULE_ID index , uint16_t value )
80:                  {
81:                      if( _TMR_PERIOD_MATCH_MODE_VREG( index ) == (SFR_TYPE *)-1 )
82:                      {
83:                          /* Overflow TMR */
84:                          _SFR_WRITE( _TMR_VALUE_REGISTER_16BIT_VREG( index ), ( UINT16_MAX + 1 - _SFR_READ( _TMR_PERIOD_REGISTER_16BIT_VREG( index ) ) + (uint16_t)value ) );
85:                      }
86:                      else
87:                      {
88:                          /* Period Match TMR */
89:                          _SFR_WRITE( _TMR_VALUE_REGISTER_16BIT_VREG( index ), value );
00000004  00000000   NOP
90:                      }
91:                  }
92:                  
93:                  
94:                  //******************************************************************************
95:                  /* Function :  TMR_Counter16BitGet_In16BitRegister
96:                  
97:                    Summary:
98:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitGet
99:                  
100:                   Description:
101:                     This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitGet function.
102:                 */
103:                 
104:                 PLIB_TEMPLATE uint16_t TMR_Counter16BitGet_In16BitRegister( TMR_MODULE_ID index )
105:                 {
106:                     return ( _SFR_READ( _TMR_VALUE_REGISTER_16BIT_VREG( index ) ) );
00000000  00000000   NOP
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  TMR_Counter16BitClear_In16BitRegister
112:                 
113:                   Summary:
114:                     Implements In16BitRegister variant of PLIB_TMR_Counter16BitClear
115:                 
116:                   Description:
117:                     This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitClear function.
118:                 */
119:                 
120:                 PLIB_TEMPLATE void TMR_Counter16BitClear_In16BitRegister( TMR_MODULE_ID index )
121:                 {
122:                     _SFR_WRITE( _TMR_VALUE_REGISTER_16BIT_VREG( index ), 0 );
9D00C09C  3C02BF80   LUI V0, -16512
9D00C0A0  AC400810   SW ZERO, 2064(V0)
00000000  00000000   NOP
123:                 }
124:                 
125:                 
126:                 //******************************************************************************
127:                 /* Function :  TMR_ExistsCounter16Bit_In16BitRegister
128:                 
129:                   Summary:
130:                     Implements In16BitRegister variant of PLIB_TMR_ExistsCounter16Bit
131:                 
132:                   Description:
133:                     This template implements the In16BitRegister variant of the PLIB_TMR_ExistsCounter16Bit function.
134:                 */
135:                 
136:                 #define PLIB_TMR_ExistsCounter16Bit PLIB_TMR_ExistsCounter16Bit
137:                 PLIB_TEMPLATE bool TMR_ExistsCounter16Bit_In16BitRegister( TMR_MODULE_ID index )
138:                 {
139:                     return true;
140:                 }
141:                 
142:                 
143:                 #endif /*_TMR_COUNTER16BIT_IN16BITREGISTER_H*/
144:                 
145:                 /******************************************************************************
146:                  End of File
147:                 */
148:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/tmr/templates/tmr_clocksource_default.h  --------
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_ClockSource_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockSource
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_ClockSourceSelect
16:                          PLIB_TMR_ExistsClockSource
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_CLOCKSOURCE_DEFAULT_H
47:                  #define _TMR_CLOCKSOURCE_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _TMR_CLOCK_SOURCE_VREG(index)
54:                  
55:                    MASKs: 
56:                      _TMR_CLOCK_SOURCE_MASK(index)
57:                  
58:                    POSs: 
59:                      _TMR_CLOCK_SOURCE_POS(index)
60:                  
61:                    LENs: 
62:                      _TMR_CLOCK_SOURCE_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  TMR_ClockSourceSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_TMR_ClockSourceSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_TMR_ClockSourceSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void TMR_ClockSourceSelect_Default( TMR_MODULE_ID index , TMR_CLOCK_SOURCE source )
78:                  {
79:                      switch( source )
80:                      {
81:                          case TMR_CLOCK_SOURCE_EXTERNAL_INPUT_PIN:
82:                                  _SFR_BIT_SET( _TMR_CLOCK_SOURCE_VREG( index ),
00000064  00000000   NOP
83:                                                _TMR_CLOCK_SOURCE_POS( index ) );
84:                              break;
85:                          case TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK:
86:                                  _SFR_BIT_CLEAR( _TMR_CLOCK_SOURCE_VREG( index ),
9D00C078  24040002   ADDIU A0, ZERO, 2
9D00C07C  AC440004   SW A0, 4(V0)
00000038  00000000   NOP
87:                                                  _TMR_CLOCK_SOURCE_POS( index ) );
88:                              break;
89:                          default:
90:                              break;
91:                      }
92:                  }
93:                  
94:                  
95:                  //******************************************************************************
96:                  /* Function :  TMR_ExistsClockSource_Default
97:                  
98:                    Summary:
99:                      Implements Default variant of PLIB_TMR_ExistsClockSource
100:                 
101:                   Description:
102:                     This template implements the Default variant of the PLIB_TMR_ExistsClockSource function.
103:                 */
104:                 
105:                 #define PLIB_TMR_ExistsClockSource PLIB_TMR_ExistsClockSource
106:                 PLIB_TEMPLATE bool TMR_ExistsClockSource_Default( TMR_MODULE_ID index )
107:                 {
108:                     return true;
109:                 }
110:                 
111:                 
112:                 #endif /*_TMR_CLOCKSOURCE_DEFAULT_H*/
113:                 
114:                 /******************************************************************************
115:                  End of File
116:                 */
117:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ports/templates/ports_portswrite_mcu32.h  -------
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsWrite_MCU32.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsWrite
13:                      and its Variant : MCU32
14:                      For following APIs :
15:                          PLIB_PORTS_PinWrite
16:                          PLIB_PORTS_PinSet
17:                          PLIB_PORTS_PinClear
18:                          PLIB_PORTS_PinToggle
19:                          PLIB_PORTS_Write
20:                          PLIB_PORTS_Set
21:                          PLIB_PORTS_Toggle
22:                          PLIB_PORTS_Clear
23:                          PLIB_PORTS_ExistsPortsWrite
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _PORTS_PORTSWRITE_MCU32_H
54:                  #define _PORTS_PORTSWRITE_MCU32_H
55:                  
56:                  //******************************************************************************
57:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
58:                  
59:                    VREGs: 
60:                      _PORTS_WRITE_B_VREG(index)
61:                      _PORTS_PIN_MODE_VREG(index)
62:                  
63:                    MASKs: 
64:                      _PORTS_WRITE_B_MASK(index)
65:                      _PORTS_PIN_MODE_MASK(index)
66:                  
67:                    POSs: 
68:                      _PORTS_WRITE_B_POS(index)
69:                      _PORTS_PIN_MODE_POS(index)
70:                  
71:                    LENs: 
72:                      _PORTS_WRITE_B_LEN(index)
73:                      _PORTS_PIN_MODE_LEN(index)
74:                  
75:                  */
76:                  
77:                  
78:                  //******************************************************************************
79:                  /* Function :  PORTS_PinWrite_MCU32
80:                  
81:                    Summary:
82:                      Implements MCU32 variant of PLIB_PORTS_PinWrite 
83:                  
84:                    Description:
85:                      This template implements the MCU32 variant of the PLIB_PORTS_PinWrite function.
86:                  */
87:                  
88:                  PLIB_TEMPLATE void PORTS_PinWrite_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos , bool            value )
89:                  {
90:                      /* Atomic Implementation */
91:                      if(value == true)
00000008  00000000   NOP
92:                      {
93:                          _SFR_BIT_SET(_PORTS_WRITE_B_VREG(index) + ((channel-1) * 0x10),
94:                                             bitPos );
95:                      }
96:                      else
97:                      {
98:                          _SFR_BIT_CLEAR(_PORTS_WRITE_B_VREG(index) + ((channel-1) * 0x10) ,
00000010  00000000   NOP
00000030  00000000   NOP
00000040  00000000   NOP
00000050  00000000   NOP
00000060  00000000   NOP
0000006C  00000000   NOP
00000078  00000000   NOP
00000088  00000000   NOP
99:                                             bitPos );
100:                     }
101:                 	
102:                 }
103:                 
104:                 
105:                 //******************************************************************************
106:                 /* Function :  PORTS_PinSet_MCU32
107:                 
108:                   Summary:
109:                     Implements MCU32 variant of PLIB_PORTS_PinSet 
110:                 
111:                   Description:
112:                     This template implements the MCU32 variant of the PLIB_PORTS_PinSet function.
113:                 */
114:                 
115:                 PLIB_TEMPLATE void PORTS_PinSet_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
116:                 {
117:                 
118:                 	_SFR_BIT_SET(_PORTS_WRITE_B_VREG(index) + ((channel-1) * 0x10),
9D00BF84  3442FFFF   ORI V0, V0, -1
9D00BF88  00A21021   ADDU V0, A1, V0
9D00BF8C  00021180   SLL V0, V0, 6
9D00BF90  24420008   ADDIU V0, V0, 8
9D00BF94  3C05BF88   LUI A1, -16504
9D00BF98  24A56060   ADDIU A1, A1, 24672
9D00BF9C  00A22821   ADDU A1, A1, V0
9D00BFA0  24020001   ADDIU V0, ZERO, 1
9D00BFA4  00C23004   SLLV A2, V0, A2
9D00BFA8  ACA60000   SW A2, 0(A1)
9D00BFAC  03E00008   JR RA
9D00BFB0  00000000   NOP
00000008  00000000   NOP
119:                                            bitPos );
120:                     
121:                 }
122:                 
123:                 
124:                 //******************************************************************************
125:                 /* Function :  PORTS_PinClear_MCU32
126:                 
127:                   Summary:
128:                     Implements MCU32 variant of PLIB_PORTS_PinClear 
129:                 
130:                   Description:
131:                     This template implements the MCU32 variant of the PLIB_PORTS_PinClear function.
132:                 */
133:                 
134:                 PLIB_TEMPLATE void PORTS_PinClear_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
135:                 {
136:                 	
137:                 	_SFR_BIT_CLEAR(_PORTS_WRITE_B_VREG(index) + ((channel-1) * 0x10) ,
9D00BFBC  3442FFFF   ORI V0, V0, -1
138:                                            bitPos );
139:                 						   
140:                 }
141:                 
142:                 
143:                 //******************************************************************************
144:                 /* Function :  PORTS_PinToggle_MCU32
145:                 
146:                   Summary:
147:                     Implements MCU32 variant of PLIB_PORTS_PinToggle 
148:                 
149:                   Description:
150:                     This template implements the MCU32 variant of the PLIB_PORTS_PinToggle function.
151:                 */
152:                 
153:                 PLIB_TEMPLATE void PORTS_PinToggle_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
154:                 {
155:                 
156:                 	_SFR_BIT_INVERT(_PORTS_WRITE_B_VREG(index) + ((channel-1) * 0x10),
00000008  00000000   NOP
157:                                            bitPos );
158:                 						   
159:                 }
160:                 
161:                 
162:                 //******************************************************************************
163:                 /* Function :  PORTS_Write_MCU32
164:                 
165:                   Summary:
166:                     Implements MCU32 variant of PLIB_PORTS_Write 
167:                 
168:                   Description:
169:                     This template implements the MCU32 variant of the PLIB_PORTS_Write function.
170:                 */
171:                 
172:                 PLIB_TEMPLATE void PORTS_Write_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value )
173:                 {
174:                     _SFR_WRITE(_PORTS_WRITE_B_VREG(index) + ((channel-1) * 0x10),
9D00C50C  240300FA   ADDIU V1, ZERO, 250
9D00C510  3C02BF88   LUI V0, -16504
9D00C514  24426060   ADDIU V0, V0, 24672
9D00C518  AC4300C0   SW V1, 192(V0)
9D00D6D8  3C02BF88   LUI V0, -16504
9D00D6DC  24426060   ADDIU V0, V0, 24672
9D00D6E0  AC4000C0   SW ZERO, 192(V0)
00000008  00000000   NOP
0000002C  00000000   NOP
175:                                            value );
176:                 }
177:                 
178:                 
179:                 //******************************************************************************
180:                 /* Function :  PORTS_Set_MCU32
181:                 
182:                   Summary:
183:                     Implements MCU32 variant of PLIB_PORTS_Set 
184:                 
185:                   Description:
186:                     This template implements the MCU32 variant of the PLIB_PORTS_Set function.
187:                 */
188:                 
189:                 PLIB_TEMPLATE void PORTS_Set_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value , PORTS_DATA_MASK mask )
190:                 {
191:                 
192:                     _SFR_FIELD_SET(_PORTS_WRITE_B_VREG(index) + ((channel-1) * 0x10),
193:                                          mask, 0 , value);
194:                 	
195:                 }
196:                 
197:                 
198:                 //******************************************************************************
199:                 /* Function :  PORTS_Toggle_MCU32
200:                 
201:                   Summary:
202:                     Implements MCU32 variant of PLIB_PORTS_Toggle 
203:                 
204:                   Description:
205:                     This template implements the MCU32 variant of the PLIB_PORTS_Toggle function.
206:                 */
207:                 
208:                 PLIB_TEMPLATE void PORTS_Toggle_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK toggleMask )
209:                 {
210:                     _SFR_FIELD_INVERT( _PORTS_WRITE_B_VREG(index) + ((channel-1) * 0x10),
211:                                                 toggleMask, 0,
212:                                                 0xFFFF );
213:                 }
214:                 
215:                 
216:                 //******************************************************************************
217:                 /* Function :  PORTS_Clear_MCU32
218:                 
219:                   Summary:
220:                     Implements MCU32 variant of PLIB_PORTS_Clear 
221:                 
222:                   Description:
223:                     This template implements the MCU32 variant of the PLIB_PORTS_Clear function.
224:                 */
225:                 
226:                 PLIB_TEMPLATE void PORTS_Clear_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK clearMask )
227:                 {
228:                     
229:                 	_SFR_FIELD_CLEAR(_PORTS_WRITE_B_VREG(index) + ((channel-1) * 0x10),
00000008  00000000   NOP
230:                                          clearMask, 0 , 0xFFFF);
231:                 						 
232:                 }
233:                 
234:                 
235:                 //******************************************************************************
236:                 /* Function :  PORTS_ExistsPortsWrite_MCU32
237:                 
238:                   Summary:
239:                     Implements MCU32 variant of PLIB_PORTS_ExistsPortsWrite
240:                 
241:                   Description:
242:                     This template implements the MCU32 variant of the PLIB_PORTS_ExistsPortsWrite function.
243:                 */
244:                 
245:                 #define PLIB_PORTS_ExistsPortsWrite PLIB_PORTS_ExistsPortsWrite
246:                 PLIB_TEMPLATE bool PORTS_ExistsPortsWrite_MCU32( PORTS_MODULE_ID index )
247:                 {
248:                     return true;
249:                 }
250:                 
251:                 
252:                 #endif /*_PORTS_PORTSWRITE_MCU32_H*/
253:                 
254:                 /******************************************************************************
255:                  End of File
256:                 */
257:                 
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsRead_MCU32.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsRead
13:                      and its Variant : MCU32
14:                      For following APIs :
15:                          PLIB_PORTS_PinGet
16:                          PLIB_PORTS_Read
17:                          PLIB_PORTS_ExistsPortsRead
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PORTSREAD_MCU32_H
48:                  #define _PORTS_PORTSREAD_MCU32_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _PORTS_READ_B_VREG(index)
55:                      _PORTS_PIN_MODE_VREG(index)
56:                  
57:                    MASKs: 
58:                      _PORTS_READ_B_MASK(index)
59:                      _PORTS_PIN_MODE_MASK(index)
60:                  
61:                    POSs: 
62:                      _PORTS_READ_B_POS(index)
63:                      _PORTS_PIN_MODE_POS(index)
64:                  
65:                    LENs: 
66:                      _PORTS_READ_B_LEN(index)
67:                      _PORTS_PIN_MODE_LEN(index)
68:                  
69:                  */
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  PORTS_PinGet_MCU32
74:                  
75:                    Summary:
76:                      Implements MCU32 variant of PLIB_PORTS_PinGet 
77:                  
78:                    Description:
79:                      This template implements the MCU32 variant of the PLIB_PORTS_PinGet function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE bool PORTS_PinGet_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
83:                  {
84:                      return( _SFR_BIT_READ( _PORTS_READ_B_VREG(index) + ((channel-1) * 0x10), bitPos ) );
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  PORTS_Read_MCU32
90:                  
91:                    Summary:
92:                      Implements MCU32 variant of PLIB_PORTS_Read 
93:                  
94:                    Description:
95:                      This template implements the MCU32 variant of the PLIB_PORTS_Read function.
96:                  */
97:                  
98:                  PLIB_TEMPLATE PORTS_DATA_TYPE PORTS_Read_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
99:                  {
100:                     return( _SFR_READ( _PORTS_READ_B_VREG(index) + ((channel-1) * 0x10) ) );
00000008  00000000   NOP
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  PORTS_ExistsPortsRead_MCU32
106:                 
107:                   Summary:
108:                     Implements MCU32 variant of PLIB_PORTS_ExistsPortsRead
109:                 
110:                   Description:
111:                     This template implements the MCU32 variant of the PLIB_PORTS_ExistsPortsRead function.
112:                 */
113:                 
114:                 #define PLIB_PORTS_ExistsPortsRead PLIB_PORTS_ExistsPortsRead
115:                 PLIB_TEMPLATE bool PORTS_ExistsPortsRead_MCU32( PORTS_MODULE_ID index )
116:                 {
117:                     return true;
118:                 }
119:                 
120:                 
121:                 #endif /*_PORTS_PORTSREAD_MCU32_H*/
122:                 
123:                 /******************************************************************************
124:                  End of File
125:                 */
126:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ports/templates/ports_portsopendrain_mcu32.h  ---
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsOpenDrain_MCU32.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsOpenDrain
13:                      and its Variant : MCU32
14:                      For following APIs :
15:                          PLIB_PORTS_PinOpenDrainEnable
16:                          PLIB_PORTS_PinOpenDrainDisable
17:                          PLIB_PORTS_OpenDrainEnable
18:                          PLIB_PORTS_OpenDrainDisable
19:                          PLIB_PORTS_ExistsPortsOpenDrain
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PORTSOPENDRAIN_MCU32_H
50:                  #define _PORTS_PORTSOPENDRAIN_MCU32_H
51:                  
52:                  //******************************************************************************
53:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
54:                  
55:                    VREGs: 
56:                      _PORTS_OPEN_DRAIN_B_VREG(index)
57:                      _PORTS_PIN_MODE_VREG(index)
58:                  
59:                    MASKs: 
60:                      _PORTS_OPEN_DRAIN_B_MASK(index)
61:                      _PORTS_PIN_MODE_MASK(index)
62:                  
63:                    POSs: 
64:                      _PORTS_OPEN_DRAIN_B_POS(index)
65:                      _PORTS_PIN_MODE_POS(index)
66:                  
67:                    LENs: 
68:                      _PORTS_OPEN_DRAIN_B_LEN(index)
69:                      _PORTS_PIN_MODE_LEN(index)
70:                  
71:                  */
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  PORTS_PinOpenDrainEnable_MCU32
76:                  
77:                    Summary:
78:                      Implements MCU32 variant of PLIB_PORTS_PinOpenDrainEnable 
79:                  
80:                    Description:
81:                      This template implements the MCU32 variant of the PLIB_PORTS_PinOpenDrainEnable function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void PORTS_PinOpenDrainEnable_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
85:                  {
86:                      _SFR_BIT_SET( _PORTS_OPEN_DRAIN_B_VREG(index) + ((channel-1) * 0x10), bitPos );
00000000  00000000   NOP
00000008  00000000   NOP
00000028  00000000   NOP
00000038  00000000   NOP
00000048  00000000   NOP
00000058  00000000   NOP
00000068  00000000   NOP
00000074  00000000   NOP
00000080  00000000   NOP
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  PORTS_PinOpenDrainDisable_MCU32
92:                  
93:                    Summary:
94:                      Implements MCU32 variant of PLIB_PORTS_PinOpenDrainDisable 
95:                  
96:                    Description:
97:                      This template implements the MCU32 variant of the PLIB_PORTS_PinOpenDrainDisable function.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void PORTS_PinOpenDrainDisable_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
101:                 {
102:                      _SFR_BIT_CLEAR( _PORTS_OPEN_DRAIN_B_VREG(index) + ((channel-1) * 0x10), bitPos );
00000008  00000000   NOP
103:                 }
104:                 
105:                 
106:                 //******************************************************************************
107:                 /* Function :  PORTS_OpenDrainEnable_MCU32
108:                 
109:                   Summary:
110:                     Implements MCU32 variant of PLIB_PORTS_OpenDrainEnable 
111:                 
112:                   Description:
113:                     This template implements the MCU32 variant of the PLIB_PORTS_OpenDrainEnable function.
114:                 */
115:                 
116:                 PLIB_TEMPLATE void PORTS_OpenDrainEnable_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
117:                 {
118:                     _SFR_SET( _PORTS_OPEN_DRAIN_B_VREG(index) + ((channel-1) * 0x10), mask );
9D00D6CC  3C02BF88   LUI V0, -16504
9D00D6D0  24426070   ADDIU V0, V0, 24688
9D00D6D4  AC4000C8   SW ZERO, 200(V0)
119:                 }
120:                 
121:                 
122:                 //******************************************************************************
123:                 /* Function :  PORTS_OpenDrainDisable_MCU32
124:                 
125:                   Summary:
126:                     Implements MCU32 variant of PLIB_PORTS_OpenDrainDisable 
127:                 
128:                   Description:
129:                     This template implements the MCU32 variant of the PLIB_PORTS_OpenDrainDisable function.
130:                 */
131:                 
132:                 PLIB_TEMPLATE void PORTS_OpenDrainDisable_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
133:                 {
134:                     _SFR_CLEAR( _PORTS_OPEN_DRAIN_B_VREG(index) + ((channel-1) * 0x10), mask );
00000008  00000000   NOP
135:                 }
136:                 
137:                 
138:                 //******************************************************************************
139:                 /* Function :  PORTS_ExistsPortsOpenDrain_MCU32
140:                 
141:                   Summary:
142:                     Implements MCU32 variant of PLIB_PORTS_ExistsPortsOpenDrain
143:                 
144:                   Description:
145:                     This template implements the MCU32 variant of the PLIB_PORTS_ExistsPortsOpenDrain function.
146:                 */
147:                 
148:                 #define PLIB_PORTS_ExistsPortsOpenDrain PLIB_PORTS_ExistsPortsOpenDrain
149:                 PLIB_TEMPLATE bool PORTS_ExistsPortsOpenDrain_MCU32( PORTS_MODULE_ID index )
150:                 {
151:                     return true;
152:                 }
153:                 
154:                 
155:                 #endif /*_PORTS_PORTSOPENDRAIN_MCU32_H*/
156:                 
157:                 /******************************************************************************
158:                  End of File
159:                 */
160:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ports/templates/ports_portsdirection_mcu32.h  ---
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsDirection_MCU32.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsDirection
13:                      and its Variant : MCU32
14:                      For following APIs :
15:                          PLIB_PORTS_PinDirectionInputSet
16:                          PLIB_PORTS_PinDirectionOutputSet
17:                          PLIB_PORTS_DirectionInputSet
18:                          PLIB_PORTS_DirectionOutputSet
19:                          PLIB_PORTS_DirectionGet
20:                          PLIB_PORTS_ExistsPortsDirection
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _PORTS_PORTSDIRECTION_MCU32_H
51:                  #define _PORTS_PORTSDIRECTION_MCU32_H
52:                  
53:                  //******************************************************************************
54:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
55:                  
56:                    VREGs: 
57:                      _PORTS_DIRECTION_B_VREG(index)
58:                      _PORTS_PIN_MODE_VREG(index)
59:                  
60:                    MASKs: 
61:                      _PORTS_DIRECTION_B_MASK(index)
62:                      _PORTS_PIN_MODE_MASK(index)
63:                  
64:                    POSs: 
65:                      _PORTS_DIRECTION_B_POS(index)
66:                      _PORTS_PIN_MODE_POS(index)
67:                  
68:                    LENs: 
69:                      _PORTS_DIRECTION_B_LEN(index)
70:                      _PORTS_PIN_MODE_LEN(index)
71:                  
72:                  */
73:                  
74:                  
75:                  //******************************************************************************
76:                  /* Function :  PORTS_PinDirectionInputSet_MCU32
77:                  
78:                    Summary:
79:                      Implements MCU32 variant of PLIB_PORTS_PinDirectionInputSet 
80:                  
81:                    Description:
82:                      This template implements the MCU32 variant of the PLIB_PORTS_PinDirectionInputSet function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE void PORTS_PinDirectionInputSet_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
86:                  {
87:                      _SFR_BIT_SET( _PORTS_DIRECTION_B_VREG(index) + ((channel-1) * 0x10), bitPos );
00000048  00000000   NOP
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  PORTS_PinDirectionOutputSet_MCU32
93:                  
94:                    Summary:
95:                      Implements MCU32 variant of PLIB_PORTS_PinDirectionOutputSet 
96:                  
97:                    Description:
98:                      This template implements the MCU32 variant of the PLIB_PORTS_PinDirectionOutputSet function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void PORTS_PinDirectionOutputSet_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
102:                 {
103:                     _SFR_BIT_CLEAR( _PORTS_DIRECTION_B_VREG(index) + ((channel-1) * 0x10), bitPos );
00000010  00000000   NOP
0000001C  00000000   NOP
00000034  00000000   NOP
00000044  00000000   NOP
00000054  00000000   NOP
00000064  00000000   NOP
00000070  00000000   NOP
0000007C  00000000   NOP
0000008C  00000000   NOP
104:                 }
105:                 
106:                 
107:                 //******************************************************************************
108:                 /* Function :  PORTS_DirectionInputSet_MCU32
109:                 
110:                   Summary:
111:                     Implements MCU32 variant of PLIB_PORTS_DirectionInputSet 
112:                 
113:                   Description:
114:                     This template implements the MCU32 variant of the PLIB_PORTS_DirectionInputSet function.
115:                 */
116:                 
117:                 PLIB_TEMPLATE void PORTS_DirectionInputSet_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
118:                 {
119:                     _SFR_SET( _PORTS_DIRECTION_B_VREG(index) + ((channel-1) * 0x10), mask );
00000014  00000000   NOP
120:                 }
121:                 
122:                 
123:                 //******************************************************************************
124:                 /* Function :  PORTS_DirectionOutputSet_MCU32
125:                 
126:                   Summary:
127:                     Implements MCU32 variant of PLIB_PORTS_DirectionOutputSet 
128:                 
129:                   Description:
130:                     This template implements the MCU32 variant of the PLIB_PORTS_DirectionOutputSet function.
131:                 */
132:                 
133:                 PLIB_TEMPLATE void PORTS_DirectionOutputSet_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
134:                 {
135:                     _SFR_CLEAR( _PORTS_DIRECTION_B_VREG(index) + ((channel-1) * 0x10), mask );
9D00D6E4  3403FCFF   ORI V1, ZERO, -769
00000044  00000000   NOP
136:                 }
137:                 
138:                 
139:                 //******************************************************************************
140:                 /* Function :  PORTS_DirectionGet_MCU32
141:                 
142:                   Summary:
143:                     Implements MCU32 variant of PLIB_PORTS_DirectionGet 
144:                 
145:                   Description:
146:                     This template implements the MCU32 variant of the PLIB_PORTS_DirectionGet function.
147:                 */
148:                 
149:                 PLIB_TEMPLATE PORTS_DATA_MASK PORTS_DirectionGet_MCU32( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
150:                 {
151:                     return( _SFR_READ( _PORTS_DIRECTION_B_VREG(index) + ((channel-1) * 0x10) ) );
00000008  00000000   NOP
152:                 }
153:                 
154:                 
155:                 //******************************************************************************
156:                 /* Function :  PORTS_ExistsPortsDirection_MCU32
157:                 
158:                   Summary:
159:                     Implements MCU32 variant of PLIB_PORTS_ExistsPortsDirection
160:                 
161:                   Description:
162:                     This template implements the MCU32 variant of the PLIB_PORTS_ExistsPortsDirection function.
163:                 */
164:                 
165:                 #define PLIB_PORTS_ExistsPortsDirection PLIB_PORTS_ExistsPortsDirection
166:                 PLIB_TEMPLATE bool PORTS_ExistsPortsDirection_MCU32( PORTS_MODULE_ID index )
167:                 {
168:                     return true;
169:                 }
170:                 
171:                 
172:                 #endif /*_PORTS_PORTSDIRECTION_MCU32_H*/
173:                 
174:                 /******************************************************************************
175:                  End of File
176:                 */
177:                 
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinMode_Non_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinMode
13:                      and its Variant : Non_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinModeSelect
16:                          PLIB_PORTS_ExistsPinMode
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_PINMODE_NON_PPS_H
47:                  #define _PORTS_PINMODE_NON_PPS_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _PORTS_PIN_MODE_VREG(index)
54:                  
55:                    MASKs: 
56:                      _PORTS_PIN_MODE_MASK(index)
57:                  
58:                    POSs: 
59:                      _PORTS_PIN_MODE_POS(index)
60:                  
61:                    LENs: 
62:                      _PORTS_PIN_MODE_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_PinModeSelect_Non_PPS
69:                  
70:                    Summary:
71:                      Implements Non_PPS variant of PLIB_PORTS_PinModeSelect 
72:                  
73:                    Description:
74:                      This template implements the Non_PPS variant of the PLIB_PORTS_PinModeSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void PORTS_PinModeSelect_Non_PPS( PORTS_MODULE_ID  index , PORTS_ANALOG_PIN pin , PORTS_PIN_MODE   mode )
78:                  {
79:                      if (mode == PORTS_PIN_MODE_DIGITAL)
00000008  00000000   NOP
80:                      {
81:                          _SFR_BIT_SET(_PORTS_PIN_MODE_VREG(index), pin );
00000010  00000000   NOP
82:                      }
83:                      else
84:                      {
85:                          _SFR_BIT_CLEAR(_PORTS_PIN_MODE_VREG(index), pin );
00000024  00000000   NOP
86:                      }
87:                  }
88:                  
89:                  //******************************************************************************
90:                  /* Function :  PORTS_ExistsPinMode_Non_PPS
91:                  
92:                    Summary:
93:                      Implements Non_PPS variant of PLIB_PORTS_ExistsPinMode
94:                  
95:                    Description:
96:                      This template implements the Non_PPS variant of the PLIB_PORTS_ExistsPinMode function.
97:                  */
98:                  
99:                  #define PLIB_PORTS_ExistsPinMode PLIB_PORTS_ExistsPinMode
100:                 PLIB_TEMPLATE bool PORTS_ExistsPinMode_Non_PPS( PORTS_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_PORTS_PINMODE_NON_PPS_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ports/templates/ports_pinchangenotice_default.h  
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinChangeNotice_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinChangeNotice
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinChangeNoticeEnable
16:                          PLIB_PORTS_PinChangeNoticeDisable
17:                          PLIB_PORTS_CnPinsEnable
18:                          PLIB_PORTS_CnPinsDisable
19:                          PLIB_PORTS_ExistsPinChangeNotice
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PINCHANGENOTICE_DEFAULT_H
50:                  #define _PORTS_PINCHANGENOTICE_DEFAULT_H
51:                  
52:                  //******************************************************************************
53:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
54:                  
55:                    VREGs: 
56:                      _PORTS_PIN_CHANGE_NOTICE_VREG(index)
57:                  
58:                    MASKs: 
59:                      _PORTS_PIN_CHANGE_NOTICE_MASK(index)
60:                  
61:                    POSs: 
62:                      _PORTS_PIN_CHANGE_NOTICE_POS(index)
63:                  
64:                    LENs: 
65:                      _PORTS_PIN_CHANGE_NOTICE_LEN(index)
66:                  
67:                  */
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinChangeNoticeEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_PORTS_PinChangeNoticeEnable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticeEnable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinChangeNoticeEnable_Default( PORTS_MODULE_ID         index , PORTS_CHANGE_NOTICE_PIN pinNum )
81:                  {
82:                      _SFR_BIT_SET(_PORTS_PIN_CHANGE_NOTICE_VREG(index),
00000034  00000000   NOP
00000048  00000000   NOP
00000060  00000000   NOP
83:                                       pinNum );
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  PORTS_PinChangeNoticeDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_PORTS_PinChangeNoticeDisable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticeDisable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void PORTS_PinChangeNoticeDisable_Default( PORTS_MODULE_ID         index , PORTS_CHANGE_NOTICE_PIN pinNum )
98:                  {
99:                      _SFR_BIT_CLEAR(_PORTS_PIN_CHANGE_NOTICE_VREG(index),
00000008  00000000   NOP
100:                                      pinNum );
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  PORTS_CnPinsEnable_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_PORTS_CnPinsEnable 
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_PORTS_CnPinsEnable function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE void PORTS_CnPinsEnable_Default( PORTS_MODULE_ID  index , PORTS_CN_PIN   cnPins )
115:                 {
116:                     _SFR_SET(_PORTS_PIN_CHANGE_NOTICE_VREG(index), cnPins );
9D00D3D8  3C02BF88   LUI V0, -16504
9D00D3DC  244261D0   ADDIU V0, V0, 25040
9D00D3E0  AC400008   SW ZERO, 8(V0)
117:                 }
118:                 
119:                 
120:                 //******************************************************************************
121:                 /* Function :  PORTS_CnPinsDisable_Default
122:                 
123:                   Summary:
124:                     Implements Default variant of PLIB_PORTS_CnPinsDisable 
125:                 
126:                   Description:
127:                     This template implements the Default variant of the PLIB_PORTS_CnPinsDisable function.
128:                 */
129:                 
130:                 PLIB_TEMPLATE void PORTS_CnPinsDisable_Default( PORTS_MODULE_ID  index , PORTS_CN_PIN   cnPins )
131:                 {
132:                     _SFR_CLEAR(_PORTS_PIN_CHANGE_NOTICE_VREG(index), cnPins );
133:                 }
134:                 
135:                 
136:                 //******************************************************************************
137:                 /* Function :  PORTS_ExistsPinChangeNotice_Default
138:                 
139:                   Summary:
140:                     Implements Default variant of PLIB_PORTS_ExistsPinChangeNotice
141:                 
142:                   Description:
143:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinChangeNotice function.
144:                 */
145:                 
146:                 #define PLIB_PORTS_ExistsPinChangeNotice PLIB_PORTS_ExistsPinChangeNotice
147:                 PLIB_TEMPLATE bool PORTS_ExistsPinChangeNotice_Default( PORTS_MODULE_ID index )
148:                 {
149:                     return true;
150:                 }
151:                 
152:                 
153:                 #endif /*_PORTS_PINCHANGENOTICE_DEFAULT_H*/
154:                 
155:                 /******************************************************************************
156:                  End of File
157:                 */
158:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ports/templates/ports_changenoticepullup_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullup_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullup
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullUpEnable
16:                          PLIB_PORTS_ChangeNoticePullUpDisable
17:                          PLIB_PORTS_CnPinsPullUpEnable
18:                          PLIB_PORTS_CnPinsPullUpDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullUp
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLUP_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLUP_DEFAULT_H
51:                  
52:                  //******************************************************************************
53:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
54:                  
55:                    VREGs: 
56:                      _PORTS_CHANGE_NOTICE_PULL_UP_VREG(index)
57:                  
58:                    MASKs: 
59:                      _PORTS_CHANGE_NOTICE_PULL_UP_MASK(index)
60:                  
61:                    POSs: 
62:                      _PORTS_CHANGE_NOTICE_PULL_UP_POS(index)
63:                  
64:                    LENs: 
65:                      _PORTS_CHANGE_NOTICE_PULL_UP_LEN(index)
66:                  
67:                  */
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_ChangeNoticePullUpEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpEnable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpEnable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpEnable_Default( PORTS_MODULE_ID         index , PORTS_CHANGE_NOTICE_PIN pinNum )
81:                  {
82:                      _SFR_BIT_SET(_PORTS_CHANGE_NOTICE_PULL_UP_VREG(index),
00000008  00000000   NOP
0000003C  00000000   NOP
83:                                       pinNum );
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  PORTS_ChangeNoticePullUpDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpDisable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpDisable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpDisable_Default( PORTS_MODULE_ID         index , PORTS_CHANGE_NOTICE_PIN pinNum )
98:                  {
99:                      _SFR_BIT_CLEAR(_PORTS_CHANGE_NOTICE_PULL_UP_VREG(index),
00000008  00000000   NOP
00000024  00000000   NOP
100:                                      pinNum );
101:                 }
102:                 
103:                 //******************************************************************************
104:                 /* Function :  PORTS_CnPinsPullUpEnable_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_PORTS_CnPinsPullUpEnable 
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_PORTS_CnPinsPullUpEnable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void PORTS_CnPinsPullUpEnable_Default( PORTS_MODULE_ID  index , PORTS_CN_PIN   cnPins )
114:                 {
115:                     _SFR_SET(_PORTS_CHANGE_NOTICE_PULL_UP_VREG(index), cnPins );
9D00D3CC  3C02BF88   LUI V0, -16504
9D00D3D0  244261E0   ADDIU V0, V0, 25056
9D00D3D4  AC400008   SW ZERO, 8(V0)
116:                 }
117:                 
118:                 
119:                 //******************************************************************************
120:                 /* Function :  PORTS_CnPinsPullUpDisable_Default
121:                 
122:                   Summary:
123:                     Implements Default variant of PLIB_PORTS_CnPinsPullUpDisable 
124:                 
125:                   Description:
126:                     This template implements the Default variant of the PLIB_PORTS_CnPinsPullUpDisable function.
127:                 */
128:                 
129:                 PLIB_TEMPLATE void PORTS_CnPinsPullUpDisable_Default( PORTS_MODULE_ID  index , PORTS_CN_PIN   cnPins )
130:                 {
131:                     _SFR_CLEAR(_PORTS_CHANGE_NOTICE_PULL_UP_VREG(index), cnPins );
132:                 }
133:                 
134:                 
135:                 //******************************************************************************
136:                 /* Function :  PORTS_ExistsChangeNoticePullUp_Default
137:                 
138:                   Summary:
139:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullUp
140:                 
141:                   Description:
142:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullUp function.
143:                 */
144:                 
145:                 #define PLIB_PORTS_ExistsChangeNoticePullUp PLIB_PORTS_ExistsChangeNoticePullUp
146:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullUp_Default( PORTS_MODULE_ID index )
147:                 {
148:                     return true;
149:                 }
150:                 
151:                 
152:                 #endif /*_PORTS_CHANGENOTICEPULLUP_DEFAULT_H*/
153:                 
154:                 /******************************************************************************
155:                  End of File
156:                 */
157:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ports/templates/ports_changenoticeinidle_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticeInIdle_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticeInIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticeInIdleEnable
16:                          PLIB_PORTS_ChangeNoticeInIdleDisable
17:                          PLIB_PORTS_ExistsChangeNoticeInIdle
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_CHANGENOTICEINIDLE_DEFAULT_H
48:                  #define _PORTS_CHANGENOTICEINIDLE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _PORTS_CHANGE_NOTICE_IN_IDLE_VREG(index)
55:                  
56:                    MASKs: 
57:                      _PORTS_CHANGE_NOTICE_IN_IDLE_MASK(index)
58:                  
59:                    POSs: 
60:                      _PORTS_CHANGE_NOTICE_IN_IDLE_POS(index)
61:                  
62:                    LENs: 
63:                      _PORTS_CHANGE_NOTICE_IN_IDLE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  PORTS_ChangeNoticeInIdleEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_PORTS_ChangeNoticeInIdleEnable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticeInIdleEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void PORTS_ChangeNoticeInIdleEnable_Default( PORTS_MODULE_ID index )
79:                  {
80:                      _SFR_BIT_CLEAR(_PORTS_CHANGE_NOTICE_IN_IDLE_VREG(index),
81:                  								   _PORTS_CHANGE_NOTICE_IN_IDLE_POS(index) );
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  PORTS_ChangeNoticeInIdleDisable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_PORTS_ChangeNoticeInIdleDisable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticeInIdleDisable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void PORTS_ChangeNoticeInIdleDisable_Default( PORTS_MODULE_ID index )
96:                  {
97:                      _SFR_BIT_SET(_PORTS_CHANGE_NOTICE_IN_IDLE_VREG(index),
00000008  00000000   NOP
98:                  								   _PORTS_CHANGE_NOTICE_IN_IDLE_POS(index) );
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_ExistsChangeNoticeInIdle_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticeInIdle
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticeInIdle function.
110:                 */
111:                 
112:                 #define PLIB_PORTS_ExistsChangeNoticeInIdle PLIB_PORTS_ExistsChangeNoticeInIdle
113:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticeInIdle_Default( PORTS_MODULE_ID index )
114:                 {
115:                     return true;
116:                 }
117:                 
118:                 
119:                 #endif /*_PORTS_CHANGENOTICEINIDLE_DEFAULT_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ports/templates/ports_changenotice_default.h  ---
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNotice_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNotice
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticeEnable
16:                          PLIB_PORTS_ChangeNoticeDisable
17:                          PLIB_PORTS_ExistsChangeNotice
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_CHANGENOTICE_DEFAULT_H
48:                  #define _PORTS_CHANGENOTICE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _PORTS_CHANGE_NOTICE_VREG(index)
55:                  
56:                    MASKs: 
57:                      _PORTS_CHANGE_NOTICE_MASK(index)
58:                  
59:                    POSs: 
60:                      _PORTS_CHANGE_NOTICE_POS(index)
61:                  
62:                    LENs: 
63:                      _PORTS_CHANGE_NOTICE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  PORTS_ChangeNoticeEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_PORTS_ChangeNoticeEnable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticeEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void PORTS_ChangeNoticeEnable_Default( PORTS_MODULE_ID index )
79:                  {
80:                      _SFR_BIT_SET(_PORTS_CHANGE_NOTICE_VREG(index),
9D00D3E4  34038000   ORI V1, ZERO, -32768
81:                  								   _PORTS_CHANGE_NOTICE_POS(index) );
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  PORTS_ChangeNoticeDisable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_PORTS_ChangeNoticeDisable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticeDisable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void PORTS_ChangeNoticeDisable_Default( PORTS_MODULE_ID index )
96:                  {
97:                      _SFR_BIT_CLEAR(_PORTS_CHANGE_NOTICE_VREG(index),
00000008  00000000   NOP
98:                  								   _PORTS_CHANGE_NOTICE_POS(index) );
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_ExistsChangeNotice_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_PORTS_ExistsChangeNotice
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNotice function.
110:                 */
111:                 
112:                 #define PLIB_PORTS_ExistsChangeNotice PLIB_PORTS_ExistsChangeNotice
113:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNotice_Default( PORTS_MODULE_ID index )
114:                 {
115:                     return true;
116:                 }
117:                 
118:                 
119:                 #endif /*_PORTS_CHANGENOTICE_DEFAULT_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ports/templates/ports_anpinsmode_non_pps.h  -----
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_AnPinsMode_Non_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AnPinsMode
13:                      and its Variant : Non_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_AnPinsModeSelect
16:                          PLIB_PORTS_ExistsAnPinsMode
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_ANPINSMODE_NON_PPS_H
47:                  #define _PORTS_ANPINSMODE_NON_PPS_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _PORTS_PIN_MODE_VREG(index)
54:                  
55:                    MASKs: 
56:                      _PORTS_PIN_MODE_MASK(index)
57:                  
58:                    POSs: 
59:                      _PORTS_PIN_MODE_POS(index)
60:                  
61:                    LENs: 
62:                      _PORTS_PIN_MODE_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_AnPinsModeSelect_Non_PPS
69:                  
70:                    Summary:
71:                      Implements Non_PPS variant of PLIB_PORTS_AnPinsModeSelect 
72:                  
73:                    Description:
74:                      This template implements the Non_PPS variant of the PLIB_PORTS_AnPinsModeSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void PORTS_AnPinsModeSelect_Non_PPS( PORTS_MODULE_ID  index , PORTS_AN_PIN   anPins , PORTS_PIN_MODE mode )
78:                  {
79:                      if ( mode == PORTS_PIN_MODE_ANALOG )
80:                  	{
81:                  		_SFR_CLEAR(_PORTS_PIN_MODE_VREG(index), anPins );	
82:                  	}
83:                  	else
84:                  	{
85:                  		_SFR_SET(_PORTS_PIN_MODE_VREG(index), anPins );
9D00D3BC  3C03FFFF   LUI V1, -1
9D00D3C0  3C02BF81   LUI V0, -16511
9D00D3C4  24429060   ADDIU V0, V0, -28576
9D00D3C8  AC430008   SW V1, 8(V0)
86:                  	}
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  PORTS_ExistsAnPinsMode_Non_PPS
92:                  
93:                    Summary:
94:                      Implements Non_PPS variant of PLIB_PORTS_ExistsAnPinsMode
95:                  
96:                    Description:
97:                      This template implements the Non_PPS variant of the PLIB_PORTS_ExistsAnPinsMode function.
98:                  */
99:                  
100:                 #define PLIB_PORTS_ExistsAnPinsMode PLIB_PORTS_ExistsAnPinsMode
101:                 PLIB_TEMPLATE bool PORTS_ExistsAnPinsMode_Non_PPS( PORTS_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_PORTS_ANPINSMODE_NON_PPS_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ports/processor/ports_p32mx795f512l.h  ----------
1:                   /* Created by plibgen $Revision: 1.31 $ */
2:                   
3:                   #ifndef _PORTS_P32MX795F512L_H
4:                   #define _PORTS_P32MX795F512L_H
5:                   
6:                   /* Section 1 - Enumerate instances, define constants, VREGs */
7:                   
8:                   #include <xc.h>
9:                   #include <stdbool.h>
10:                  
11:                  #include "peripheral/peripheral_common_32bit.h"
12:                  
13:                  /* Default definition used for all API dispatch functions */
14:                  #ifndef PLIB_INLINE_API
15:                      #define PLIB_INLINE_API extern inline
16:                  #endif
17:                  
18:                  /* Default definition used for all other functions */
19:                  #ifndef PLIB_INLINE
20:                      #define PLIB_INLINE extern inline
21:                  #endif
22:                  
23:                  typedef enum {
24:                  
25:                      PORTS_ID_0 = 0,
26:                      PORTS_NUMBER_OF_MODULES
27:                  
28:                  } PORTS_MODULE_ID;
29:                  
30:                  typedef enum {
31:                  
32:                      PORTS_PIN_MODE_ANALOG = 0,
33:                      PORTS_PIN_MODE_DIGITAL = 1
34:                  
35:                  } PORTS_PIN_MODE;
36:                  
37:                  typedef enum {
38:                  
39:                      CN8 = 8,
40:                      CN9 = 9,
41:                      CN10 = 10,
42:                      CN11 = 11,
43:                      CN7 = 7,
44:                      CN6 = 6,
45:                      CN5 = 5,
46:                      CN4 = 4,
47:                      CN3 = 3,
48:                      CN2 = 2,
49:                      CN12 = 12,
50:                      CN20 = 20,
51:                      CN21 = 21,
52:                      CN17 = 17,
53:                      CN18 = 18,
54:                      CN1 = 1,
55:                      CN0 = 0,
56:                      CN19 = 19,
57:                      CN13 = 13,
58:                      CN14 = 14,
59:                      CN15 = 15,
60:                      CN16 = 16
61:                  
62:                  } PORTS_CHANGE_NOTICE_PIN;
63:                  
64:                  typedef enum {
65:                  
66:                      CHANGE_NOTICE_PIN_0 = 0x00001,
67:                      CHANGE_NOTICE_PIN_1 = 0x00002,
68:                      CHANGE_NOTICE_PIN_2 = 0x00004,
69:                      CHANGE_NOTICE_PIN_3 = 0x00008,
70:                      CHANGE_NOTICE_PIN_4 = 0x00010,
71:                      CHANGE_NOTICE_PIN_5 = 0x00020,
72:                      CHANGE_NOTICE_PIN_6 = 0x00040,
73:                      CHANGE_NOTICE_PIN_7 = 0x00080,
74:                      CHANGE_NOTICE_PIN_8 = 0x00100,
75:                      CHANGE_NOTICE_PIN_9 = 0x00200,
76:                      CHANGE_NOTICE_PIN_10 = 0x00400,
77:                      CHANGE_NOTICE_PIN_11 = 0x00800,
78:                      CHANGE_NOTICE_PIN_12 = 0x01000,
79:                      CHANGE_NOTICE_PIN_13 = 0x02000,
80:                      CHANGE_NOTICE_PIN_14 = 0x04000,
81:                      CHANGE_NOTICE_PIN_15 = 0x08000,
82:                      CHANGE_NOTICE_PIN_16 = 0x10000,
83:                      CHANGE_NOTICE_PIN_17 = 0x20000,
84:                      CHANGE_NOTICE_PIN_18 = 0x40000,
85:                      CHANGE_NOTICE_PIN_19 = 0x80000,
86:                      CHANGE_NOTICE_PIN_20 = 0x100000,
87:                      CHANGE_NOTICE_PIN_21 = 0x200000,
88:                      CHANGE_NOTICE_PIN_ALL = 0x3FFFFF
89:                  
90:                  } PORTS_CN_PIN;
91:                  
92:                  typedef enum {
93:                  
94:                      PORTS_ANALOG_PIN_0 = 0,
95:                      PORTS_ANALOG_PIN_1 = 1,
96:                      PORTS_ANALOG_PIN_2 = 2,
97:                      PORTS_ANALOG_PIN_3 = 3,
98:                      PORTS_ANALOG_PIN_4 = 4,
99:                      PORTS_ANALOG_PIN_5 = 5,
100:                     PORTS_ANALOG_PIN_6 = 6,
101:                     PORTS_ANALOG_PIN_7 = 7,
102:                     PORTS_ANALOG_PIN_8 = 8,
103:                     PORTS_ANALOG_PIN_9 = 9,
104:                     PORTS_ANALOG_PIN_10 = 10,
105:                     PORTS_ANALOG_PIN_11 = 11,
106:                     PORTS_ANALOG_PIN_12 = 12,
107:                     PORTS_ANALOG_PIN_13 = 13,
108:                     PORTS_ANALOG_PIN_14 = 14,
109:                     PORTS_ANALOG_PIN_15 = 15
110:                 
111:                 } PORTS_ANALOG_PIN;
112:                 
113:                 typedef enum {
114:                 
115:                     PORTS_AN_PIN_0 = 0x0001,
116:                     PORTS_AN_PIN_1 = 0x0002,
117:                     PORTS_AN_PIN_2 = 0x0004,
118:                     PORTS_AN_PIN_3 = 0x0008,
119:                     PORTS_AN_PIN_4 = 0x0010,
120:                     PORTS_AN_PIN_5 = 0x0020,
121:                     PORTS_AN_PIN_6 = 0x0040,
122:                     PORTS_AN_PIN_7 = 0x0080,
123:                     PORTS_AN_PIN_8 = 0x0100,
124:                     PORTS_AN_PIN_9 = 0x0200,
125:                     PORTS_AN_PIN_10 = 0x0400,
126:                     PORTS_AN_PIN_11 = 0x0800,
127:                     PORTS_AN_PIN_12 = 0x1000,
128:                     PORTS_AN_PIN_13 = 0x2000,
129:                     PORTS_AN_PIN_14 = 0x4000,
130:                     PORTS_AN_PIN_15 = 0x8000,
131:                     PORTS_AN_PIN_ALL = 0xFFFF
132:                 
133:                 } PORTS_AN_PIN;
134:                 
135:                 typedef enum {
136:                 
137:                     PORTS_BIT_POS_0 = 0,
138:                     PORTS_BIT_POS_1 = 1,
139:                     PORTS_BIT_POS_2 = 2,
140:                     PORTS_BIT_POS_3 = 3,
141:                     PORTS_BIT_POS_4 = 4,
142:                     PORTS_BIT_POS_5 = 5,
143:                     PORTS_BIT_POS_6 = 6,
144:                     PORTS_BIT_POS_7 = 7,
145:                     PORTS_BIT_POS_8 = 8,
146:                     PORTS_BIT_POS_9 = 9,
147:                     PORTS_BIT_POS_10 = 10,
148:                     PORTS_BIT_POS_11 = 11,
149:                     PORTS_BIT_POS_12 = 12,
150:                     PORTS_BIT_POS_13 = 13,
151:                     PORTS_BIT_POS_14 = 14,
152:                     PORTS_BIT_POS_15 = 15
153:                 
154:                 } PORTS_BIT_POS;
155:                 
156:                 typedef enum {
157:                 
158:                     PORTS_REMAP_INPUT_FUNCTION_NONE
159:                 
160:                 } PORTS_REMAP_INPUT_FUNCTION;
161:                 
162:                 typedef enum {
163:                 
164:                     PORTS_REMAP_INPUT_PIN_NONE
165:                 
166:                 } PORTS_REMAP_INPUT_PIN;
167:                 
168:                 typedef enum {
169:                 
170:                     PORTS_REMAP_OUTPUT_FUNCTION_NONE
171:                 
172:                 } PORTS_REMAP_OUTPUT_FUNCTION;
173:                 
174:                 typedef enum {
175:                 
176:                     PORTS_REMAP_OUTPUT_PIN_NONE
177:                 
178:                 } PORTS_REMAP_OUTPUT_PIN;
179:                 
180:                 typedef enum {
181:                 
182:                     PORT_CHANNEL_A = 0x00,
183:                     PORT_CHANNEL_B = 0x01,
184:                     PORT_CHANNEL_C = 0x02,
185:                     PORT_CHANNEL_D = 0x03,
186:                     PORT_CHANNEL_E = 0x04,
187:                     PORT_CHANNEL_F = 0x05,
188:                     PORT_CHANNEL_G = 0x06
189:                 
190:                 } PORTS_CHANNEL;
191:                 
192:                 typedef enum {
193:                 
194:                     PORTS_CHANGE_NOTICE_EDGE_NONE
195:                 
196:                 } PORTS_CHANGE_NOTICE_EDGE;
197:                 
198:                 typedef enum {
199:                 
200:                     PORTS_PIN_SLEW_RATE_NONE
201:                 
202:                 } PORTS_PIN_SLEW_RATE;
203:                 
204:                 typedef enum {
205:                 
206:                     PORTS_CHANGE_NOTICE_METHOD_NONE
207:                 
208:                 } PORTS_CHANGE_NOTICE_METHOD;
209:                 
210:                 PLIB_INLINE SFR_TYPE* _PORTS_READ_A_VREG(PORTS_MODULE_ID i)
211:                 {
212:                     switch (i) {
213:                         case PORTS_ID_0 :
214:                             return &PORTA;
215:                         case PORTS_NUMBER_OF_MODULES :
216:                         default :
217:                             return (SFR_TYPE*)-1;
218:                     }
219:                 }
220:                 
221:                 PLIB_INLINE SFR_TYPE* _PORTS_WRITE_A_VREG(PORTS_MODULE_ID i)
222:                 {
223:                     switch (i) {
224:                         case PORTS_ID_0 :
225:                             return &LATA;
226:                         case PORTS_NUMBER_OF_MODULES :
227:                         default :
228:                             return (SFR_TYPE*)-1;
229:                     }
230:                 }
231:                 
232:                 PLIB_INLINE SFR_TYPE* _PORTS_DIRECTION_A_VREG(PORTS_MODULE_ID i)
233:                 {
234:                     switch (i) {
235:                         case PORTS_ID_0 :
236:                             return &TRISA;
237:                         case PORTS_NUMBER_OF_MODULES :
238:                         default :
239:                             return (SFR_TYPE*)-1;
240:                     }
241:                 }
242:                 
243:                 PLIB_INLINE SFR_TYPE* _PORTS_OPEN_DRAIN_A_VREG(PORTS_MODULE_ID i)
244:                 {
245:                     switch (i) {
246:                         case PORTS_ID_0 :
247:                             return &ODCA;
248:                         case PORTS_NUMBER_OF_MODULES :
249:                         default :
250:                             return (SFR_TYPE*)-1;
251:                     }
252:                 }
253:                 
254:                 PLIB_INLINE SFR_TYPE* _PORTS_READ_B_VREG(PORTS_MODULE_ID i)
255:                 {
256:                     switch (i) {
257:                         case PORTS_ID_0 :
258:                             return &PORTB;
259:                         case PORTS_NUMBER_OF_MODULES :
260:                         default :
261:                             return (SFR_TYPE*)-1;
262:                     }
263:                 }
264:                 
265:                 PLIB_INLINE SFR_TYPE* _PORTS_WRITE_B_VREG(PORTS_MODULE_ID i)
266:                 {
267:                     switch (i) {
268:                         case PORTS_ID_0 :
269:                             return &LATB;
270:                         case PORTS_NUMBER_OF_MODULES :
271:                         default :
272:                             return (SFR_TYPE*)-1;
273:                     }
274:                 }
275:                 
276:                 PLIB_INLINE SFR_TYPE* _PORTS_DIRECTION_B_VREG(PORTS_MODULE_ID i)
277:                 {
278:                     switch (i) {
279:                         case PORTS_ID_0 :
280:                             return &TRISB;
281:                         case PORTS_NUMBER_OF_MODULES :
282:                         default :
283:                             return (SFR_TYPE*)-1;
284:                     }
285:                 }
286:                 
287:                 PLIB_INLINE SFR_TYPE* _PORTS_OPEN_DRAIN_B_VREG(PORTS_MODULE_ID i)
288:                 {
289:                     switch (i) {
290:                         case PORTS_ID_0 :
291:                             return &ODCB;
292:                         case PORTS_NUMBER_OF_MODULES :
293:                         default :
294:                             return (SFR_TYPE*)-1;
295:                     }
296:                 }
297:                 
298:                 PLIB_INLINE SFR_TYPE* _PORTS_READ_C_VREG(PORTS_MODULE_ID i)
299:                 {
300:                     switch (i) {
301:                         case PORTS_ID_0 :
302:                             return &PORTC;
303:                         case PORTS_NUMBER_OF_MODULES :
304:                         default :
305:                             return (SFR_TYPE*)-1;
306:                     }
307:                 }
308:                 
309:                 PLIB_INLINE SFR_TYPE* _PORTS_WRITE_C_VREG(PORTS_MODULE_ID i)
310:                 {
311:                     switch (i) {
312:                         case PORTS_ID_0 :
313:                             return &LATC;
314:                         case PORTS_NUMBER_OF_MODULES :
315:                         default :
316:                             return (SFR_TYPE*)-1;
317:                     }
318:                 }
319:                 
320:                 PLIB_INLINE SFR_TYPE* _PORTS_DIRECTION_C_VREG(PORTS_MODULE_ID i)
321:                 {
322:                     switch (i) {
323:                         case PORTS_ID_0 :
324:                             return &TRISC;
325:                         case PORTS_NUMBER_OF_MODULES :
326:                         default :
327:                             return (SFR_TYPE*)-1;
328:                     }
329:                 }
330:                 
331:                 PLIB_INLINE SFR_TYPE* _PORTS_OPEN_DRAIN_C_VREG(PORTS_MODULE_ID i)
332:                 {
333:                     switch (i) {
334:                         case PORTS_ID_0 :
335:                             return &ODCC;
336:                         case PORTS_NUMBER_OF_MODULES :
337:                         default :
338:                             return (SFR_TYPE*)-1;
339:                     }
340:                 }
341:                 
342:                 PLIB_INLINE SFR_TYPE* _PORTS_READ_D_VREG(PORTS_MODULE_ID i)
343:                 {
344:                     switch (i) {
345:                         case PORTS_ID_0 :
346:                             return &PORTD;
347:                         case PORTS_NUMBER_OF_MODULES :
348:                         default :
349:                             return (SFR_TYPE*)-1;
350:                     }
351:                 }
352:                 
353:                 PLIB_INLINE SFR_TYPE* _PORTS_WRITE_D_VREG(PORTS_MODULE_ID i)
354:                 {
355:                     switch (i) {
356:                         case PORTS_ID_0 :
357:                             return &LATD;
358:                         case PORTS_NUMBER_OF_MODULES :
359:                         default :
360:                             return (SFR_TYPE*)-1;
361:                     }
362:                 }
363:                 
364:                 PLIB_INLINE SFR_TYPE* _PORTS_DIRECTION_D_VREG(PORTS_MODULE_ID i)
365:                 {
366:                     switch (i) {
367:                         case PORTS_ID_0 :
368:                             return &TRISD;
369:                         case PORTS_NUMBER_OF_MODULES :
370:                         default :
371:                             return (SFR_TYPE*)-1;
372:                     }
373:                 }
374:                 
375:                 PLIB_INLINE SFR_TYPE* _PORTS_OPEN_DRAIN_D_VREG(PORTS_MODULE_ID i)
376:                 {
377:                     switch (i) {
378:                         case PORTS_ID_0 :
379:                             return &ODCD;
380:                         case PORTS_NUMBER_OF_MODULES :
381:                         default :
382:                             return (SFR_TYPE*)-1;
383:                     }
384:                 }
385:                 
386:                 PLIB_INLINE SFR_TYPE* _PORTS_READ_E_VREG(PORTS_MODULE_ID i)
387:                 {
388:                     switch (i) {
389:                         case PORTS_ID_0 :
390:                             return &PORTE;
391:                         case PORTS_NUMBER_OF_MODULES :
392:                         default :
393:                             return (SFR_TYPE*)-1;
394:                     }
395:                 }
396:                 
397:                 PLIB_INLINE SFR_TYPE* _PORTS_WRITE_E_VREG(PORTS_MODULE_ID i)
398:                 {
399:                     switch (i) {
400:                         case PORTS_ID_0 :
401:                             return &LATE;
402:                         case PORTS_NUMBER_OF_MODULES :
403:                         default :
404:                             return (SFR_TYPE*)-1;
405:                     }
406:                 }
407:                 
408:                 PLIB_INLINE SFR_TYPE* _PORTS_DIRECTION_E_VREG(PORTS_MODULE_ID i)
409:                 {
410:                     switch (i) {
411:                         case PORTS_ID_0 :
412:                             return &TRISE;
413:                         case PORTS_NUMBER_OF_MODULES :
414:                         default :
415:                             return (SFR_TYPE*)-1;
416:                     }
417:                 }
418:                 
419:                 PLIB_INLINE SFR_TYPE* _PORTS_OPEN_DRAIN_E_VREG(PORTS_MODULE_ID i)
420:                 {
421:                     switch (i) {
422:                         case PORTS_ID_0 :
423:                             return &ODCE;
424:                         case PORTS_NUMBER_OF_MODULES :
425:                         default :
426:                             return (SFR_TYPE*)-1;
427:                     }
428:                 }
429:                 
430:                 PLIB_INLINE SFR_TYPE* _PORTS_READ_F_VREG(PORTS_MODULE_ID i)
431:                 {
432:                     switch (i) {
433:                         case PORTS_ID_0 :
434:                             return &PORTF;
435:                         case PORTS_NUMBER_OF_MODULES :
436:                         default :
437:                             return (SFR_TYPE*)-1;
438:                     }
439:                 }
440:                 
441:                 PLIB_INLINE SFR_TYPE* _PORTS_WRITE_F_VREG(PORTS_MODULE_ID i)
442:                 {
443:                     switch (i) {
444:                         case PORTS_ID_0 :
445:                             return &LATF;
446:                         case PORTS_NUMBER_OF_MODULES :
447:                         default :
448:                             return (SFR_TYPE*)-1;
449:                     }
450:                 }
451:                 
452:                 PLIB_INLINE SFR_TYPE* _PORTS_DIRECTION_F_VREG(PORTS_MODULE_ID i)
453:                 {
454:                     switch (i) {
455:                         case PORTS_ID_0 :
456:                             return &TRISF;
457:                         case PORTS_NUMBER_OF_MODULES :
458:                         default :
459:                             return (SFR_TYPE*)-1;
460:                     }
461:                 }
462:                 
463:                 PLIB_INLINE SFR_TYPE* _PORTS_OPEN_DRAIN_F_VREG(PORTS_MODULE_ID i)
464:                 {
465:                     switch (i) {
466:                         case PORTS_ID_0 :
467:                             return &ODCF;
468:                         case PORTS_NUMBER_OF_MODULES :
469:                         default :
470:                             return (SFR_TYPE*)-1;
471:                     }
472:                 }
473:                 
474:                 PLIB_INLINE SFR_TYPE* _PORTS_READ_G_VREG(PORTS_MODULE_ID i)
475:                 {
476:                     switch (i) {
477:                         case PORTS_ID_0 :
478:                             return &PORTG;
479:                         case PORTS_NUMBER_OF_MODULES :
480:                         default :
481:                             return (SFR_TYPE*)-1;
482:                     }
483:                 }
484:                 
485:                 PLIB_INLINE SFR_TYPE* _PORTS_WRITE_G_VREG(PORTS_MODULE_ID i)
486:                 {
487:                     switch (i) {
488:                         case PORTS_ID_0 :
489:                             return &LATG;
490:                         case PORTS_NUMBER_OF_MODULES :
491:                         default :
492:                             return (SFR_TYPE*)-1;
493:                     }
494:                 }
495:                 
496:                 PLIB_INLINE SFR_TYPE* _PORTS_DIRECTION_G_VREG(PORTS_MODULE_ID i)
497:                 {
498:                     switch (i) {
499:                         case PORTS_ID_0 :
500:                             return &TRISG;
501:                         case PORTS_NUMBER_OF_MODULES :
502:                         default :
503:                             return (SFR_TYPE*)-1;
504:                     }
505:                 }
506:                 
507:                 PLIB_INLINE SFR_TYPE* _PORTS_OPEN_DRAIN_G_VREG(PORTS_MODULE_ID i)
508:                 {
509:                     switch (i) {
510:                         case PORTS_ID_0 :
511:                             return &ODCG;
512:                         case PORTS_NUMBER_OF_MODULES :
513:                         default :
514:                             return (SFR_TYPE*)-1;
515:                     }
516:                 }
517:                 
518:                 PLIB_INLINE SFR_TYPE* _PORTS_PIN_MODE_VREG(PORTS_MODULE_ID i)
519:                 {
520:                     switch (i) {
521:                         case PORTS_ID_0 :
522:                             return &AD1PCFG;
523:                         case PORTS_NUMBER_OF_MODULES :
524:                         default :
525:                             return (SFR_TYPE*)-1;
526:                     }
527:                 }
528:                 
529:                 PLIB_INLINE SFR_TYPE* _PORTS_CHANGE_NOTICE_VREG(PORTS_MODULE_ID i)
530:                 {
531:                     switch (i) {
532:                         case PORTS_ID_0 :
533:                             return &CNCON;
534:                         case PORTS_NUMBER_OF_MODULES :
535:                         default :
536:                             return (SFR_TYPE*)-1;
537:                     }
538:                 }
539:                 
540:                 PLIB_INLINE SFR_TYPE* _PORTS_CHANGE_NOTICE_IN_IDLE_VREG(PORTS_MODULE_ID i)
541:                 {
542:                     switch (i) {
543:                         case PORTS_ID_0 :
544:                             return &CNCON;
545:                         case PORTS_NUMBER_OF_MODULES :
546:                         default :
547:                             return (SFR_TYPE*)-1;
548:                     }
549:                 }
550:                 
551:                 PLIB_INLINE SFR_TYPE* _PORTS_PIN_CHANGE_NOTICE_VREG(PORTS_MODULE_ID i)
552:                 {
553:                     switch (i) {
554:                         case PORTS_ID_0 :
555:                             return &CNEN;
556:                         case PORTS_NUMBER_OF_MODULES :
557:                         default :
558:                             return (SFR_TYPE*)-1;
559:                     }
560:                 }
561:                 
562:                 PLIB_INLINE SFR_TYPE* _PORTS_CHANGE_NOTICE_PULL_UP_VREG(PORTS_MODULE_ID i)
563:                 {
564:                     switch (i) {
565:                         case PORTS_ID_0 :
566:                             return &CNPUE;
567:                         case PORTS_NUMBER_OF_MODULES :
568:                         default :
569:                             return (SFR_TYPE*)-1;
570:                     }
571:                 }
572:                 
573:                 PLIB_INLINE SFR_DATA _PORTS_READ_A_MASK(PORTS_MODULE_ID i)
574:                 {
575:                     switch (i) {
576:                         case PORTS_ID_0 :
577:                             return (SFR_DATA)-1;
578:                         case PORTS_NUMBER_OF_MODULES :
579:                         default :
580:                             return (SFR_DATA)-1;
581:                     }
582:                 }
583:                 
584:                 PLIB_INLINE SFR_DATA _PORTS_WRITE_A_MASK(PORTS_MODULE_ID i)
585:                 {
586:                     switch (i) {
587:                         case PORTS_ID_0 :
588:                             return (SFR_DATA)-1;
589:                         case PORTS_NUMBER_OF_MODULES :
590:                         default :
591:                             return (SFR_DATA)-1;
592:                     }
593:                 }
594:                 
595:                 PLIB_INLINE SFR_DATA _PORTS_DIRECTION_A_MASK(PORTS_MODULE_ID i)
596:                 {
597:                     switch (i) {
598:                         case PORTS_ID_0 :
599:                             return (SFR_DATA)-1;
600:                         case PORTS_NUMBER_OF_MODULES :
601:                         default :
602:                             return (SFR_DATA)-1;
603:                     }
604:                 }
605:                 
606:                 PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_A_MASK(PORTS_MODULE_ID i)
607:                 {
608:                     switch (i) {
609:                         case PORTS_ID_0 :
610:                             return (SFR_DATA)-1;
611:                         case PORTS_NUMBER_OF_MODULES :
612:                         default :
613:                             return (SFR_DATA)-1;
614:                     }
615:                 }
616:                 
617:                 PLIB_INLINE SFR_DATA _PORTS_READ_B_MASK(PORTS_MODULE_ID i)
618:                 {
619:                     switch (i) {
620:                         case PORTS_ID_0 :
621:                             return (SFR_DATA)-1;
622:                         case PORTS_NUMBER_OF_MODULES :
623:                         default :
624:                             return (SFR_DATA)-1;
625:                     }
626:                 }
627:                 
628:                 PLIB_INLINE SFR_DATA _PORTS_WRITE_B_MASK(PORTS_MODULE_ID i)
629:                 {
630:                     switch (i) {
631:                         case PORTS_ID_0 :
632:                             return (SFR_DATA)-1;
633:                         case PORTS_NUMBER_OF_MODULES :
634:                         default :
635:                             return (SFR_DATA)-1;
636:                     }
637:                 }
638:                 
639:                 PLIB_INLINE SFR_DATA _PORTS_DIRECTION_B_MASK(PORTS_MODULE_ID i)
640:                 {
641:                     switch (i) {
642:                         case PORTS_ID_0 :
643:                             return (SFR_DATA)-1;
644:                         case PORTS_NUMBER_OF_MODULES :
645:                         default :
646:                             return (SFR_DATA)-1;
647:                     }
648:                 }
649:                 
650:                 PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_B_MASK(PORTS_MODULE_ID i)
651:                 {
652:                     switch (i) {
653:                         case PORTS_ID_0 :
654:                             return (SFR_DATA)-1;
655:                         case PORTS_NUMBER_OF_MODULES :
656:                         default :
657:                             return (SFR_DATA)-1;
658:                     }
659:                 }
660:                 
661:                 PLIB_INLINE SFR_DATA _PORTS_READ_C_MASK(PORTS_MODULE_ID i)
662:                 {
663:                     switch (i) {
664:                         case PORTS_ID_0 :
665:                             return (SFR_DATA)-1;
666:                         case PORTS_NUMBER_OF_MODULES :
667:                         default :
668:                             return (SFR_DATA)-1;
669:                     }
670:                 }
671:                 
672:                 PLIB_INLINE SFR_DATA _PORTS_WRITE_C_MASK(PORTS_MODULE_ID i)
673:                 {
674:                     switch (i) {
675:                         case PORTS_ID_0 :
676:                             return (SFR_DATA)-1;
677:                         case PORTS_NUMBER_OF_MODULES :
678:                         default :
679:                             return (SFR_DATA)-1;
680:                     }
681:                 }
682:                 
683:                 PLIB_INLINE SFR_DATA _PORTS_DIRECTION_C_MASK(PORTS_MODULE_ID i)
684:                 {
685:                     switch (i) {
686:                         case PORTS_ID_0 :
687:                             return (SFR_DATA)-1;
688:                         case PORTS_NUMBER_OF_MODULES :
689:                         default :
690:                             return (SFR_DATA)-1;
691:                     }
692:                 }
693:                 
694:                 PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_C_MASK(PORTS_MODULE_ID i)
695:                 {
696:                     switch (i) {
697:                         case PORTS_ID_0 :
698:                             return (SFR_DATA)-1;
699:                         case PORTS_NUMBER_OF_MODULES :
700:                         default :
701:                             return (SFR_DATA)-1;
702:                     }
703:                 }
704:                 
705:                 PLIB_INLINE SFR_DATA _PORTS_READ_D_MASK(PORTS_MODULE_ID i)
706:                 {
707:                     switch (i) {
708:                         case PORTS_ID_0 :
709:                             return (SFR_DATA)-1;
710:                         case PORTS_NUMBER_OF_MODULES :
711:                         default :
712:                             return (SFR_DATA)-1;
713:                     }
714:                 }
715:                 
716:                 PLIB_INLINE SFR_DATA _PORTS_WRITE_D_MASK(PORTS_MODULE_ID i)
717:                 {
718:                     switch (i) {
719:                         case PORTS_ID_0 :
720:                             return (SFR_DATA)-1;
721:                         case PORTS_NUMBER_OF_MODULES :
722:                         default :
723:                             return (SFR_DATA)-1;
724:                     }
725:                 }
726:                 
727:                 PLIB_INLINE SFR_DATA _PORTS_DIRECTION_D_MASK(PORTS_MODULE_ID i)
728:                 {
729:                     switch (i) {
730:                         case PORTS_ID_0 :
731:                             return (SFR_DATA)-1;
732:                         case PORTS_NUMBER_OF_MODULES :
733:                         default :
734:                             return (SFR_DATA)-1;
735:                     }
736:                 }
737:                 
738:                 PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_D_MASK(PORTS_MODULE_ID i)
739:                 {
740:                     switch (i) {
741:                         case PORTS_ID_0 :
742:                             return (SFR_DATA)-1;
743:                         case PORTS_NUMBER_OF_MODULES :
744:                         default :
745:                             return (SFR_DATA)-1;
746:                     }
747:                 }
748:                 
749:                 PLIB_INLINE SFR_DATA _PORTS_READ_E_MASK(PORTS_MODULE_ID i)
750:                 {
751:                     switch (i) {
752:                         case PORTS_ID_0 :
753:                             return (SFR_DATA)-1;
754:                         case PORTS_NUMBER_OF_MODULES :
755:                         default :
756:                             return (SFR_DATA)-1;
757:                     }
758:                 }
759:                 
760:                 PLIB_INLINE SFR_DATA _PORTS_WRITE_E_MASK(PORTS_MODULE_ID i)
761:                 {
762:                     switch (i) {
763:                         case PORTS_ID_0 :
764:                             return (SFR_DATA)-1;
765:                         case PORTS_NUMBER_OF_MODULES :
766:                         default :
767:                             return (SFR_DATA)-1;
768:                     }
769:                 }
770:                 
771:                 PLIB_INLINE SFR_DATA _PORTS_DIRECTION_E_MASK(PORTS_MODULE_ID i)
772:                 {
773:                     switch (i) {
774:                         case PORTS_ID_0 :
775:                             return (SFR_DATA)-1;
776:                         case PORTS_NUMBER_OF_MODULES :
777:                         default :
778:                             return (SFR_DATA)-1;
779:                     }
780:                 }
781:                 
782:                 PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_E_MASK(PORTS_MODULE_ID i)
783:                 {
784:                     switch (i) {
785:                         case PORTS_ID_0 :
786:                             return (SFR_DATA)-1;
787:                         case PORTS_NUMBER_OF_MODULES :
788:                         default :
789:                             return (SFR_DATA)-1;
790:                     }
791:                 }
792:                 
793:                 PLIB_INLINE SFR_DATA _PORTS_READ_F_MASK(PORTS_MODULE_ID i)
794:                 {
795:                     switch (i) {
796:                         case PORTS_ID_0 :
797:                             return (SFR_DATA)-1;
798:                         case PORTS_NUMBER_OF_MODULES :
799:                         default :
800:                             return (SFR_DATA)-1;
801:                     }
802:                 }
803:                 
804:                 PLIB_INLINE SFR_DATA _PORTS_WRITE_F_MASK(PORTS_MODULE_ID i)
805:                 {
806:                     switch (i) {
807:                         case PORTS_ID_0 :
808:                             return (SFR_DATA)-1;
809:                         case PORTS_NUMBER_OF_MODULES :
810:                         default :
811:                             return (SFR_DATA)-1;
812:                     }
813:                 }
814:                 
815:                 PLIB_INLINE SFR_DATA _PORTS_DIRECTION_F_MASK(PORTS_MODULE_ID i)
816:                 {
817:                     switch (i) {
818:                         case PORTS_ID_0 :
819:                             return (SFR_DATA)-1;
820:                         case PORTS_NUMBER_OF_MODULES :
821:                         default :
822:                             return (SFR_DATA)-1;
823:                     }
824:                 }
825:                 
826:                 PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_F_MASK(PORTS_MODULE_ID i)
827:                 {
828:                     switch (i) {
829:                         case PORTS_ID_0 :
830:                             return (SFR_DATA)-1;
831:                         case PORTS_NUMBER_OF_MODULES :
832:                         default :
833:                             return (SFR_DATA)-1;
834:                     }
835:                 }
836:                 
837:                 PLIB_INLINE SFR_DATA _PORTS_READ_G_MASK(PORTS_MODULE_ID i)
838:                 {
839:                     switch (i) {
840:                         case PORTS_ID_0 :
841:                             return (SFR_DATA)-1;
842:                         case PORTS_NUMBER_OF_MODULES :
843:                         default :
844:                             return (SFR_DATA)-1;
845:                     }
846:                 }
847:                 
848:                 PLIB_INLINE SFR_DATA _PORTS_WRITE_G_MASK(PORTS_MODULE_ID i)
849:                 {
850:                     switch (i) {
851:                         case PORTS_ID_0 :
852:                             return (SFR_DATA)-1;
853:                         case PORTS_NUMBER_OF_MODULES :
854:                         default :
855:                             return (SFR_DATA)-1;
856:                     }
857:                 }
858:                 
859:                 PLIB_INLINE SFR_DATA _PORTS_DIRECTION_G_MASK(PORTS_MODULE_ID i)
860:                 {
861:                     switch (i) {
862:                         case PORTS_ID_0 :
863:                             return (SFR_DATA)-1;
864:                         case PORTS_NUMBER_OF_MODULES :
865:                         default :
866:                             return (SFR_DATA)-1;
867:                     }
868:                 }
869:                 
870:                 PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_G_MASK(PORTS_MODULE_ID i)
871:                 {
872:                     switch (i) {
873:                         case PORTS_ID_0 :
874:                             return (SFR_DATA)-1;
875:                         case PORTS_NUMBER_OF_MODULES :
876:                         default :
877:                             return (SFR_DATA)-1;
878:                     }
879:                 }
880:                 
881:                 PLIB_INLINE SFR_DATA _PORTS_PIN_MODE_MASK(PORTS_MODULE_ID i)
882:                 {
883:                     switch (i) {
884:                         case PORTS_ID_0 :
885:                             return (SFR_DATA)-1;
886:                         case PORTS_NUMBER_OF_MODULES :
887:                         default :
888:                             return (SFR_DATA)-1;
889:                     }
890:                 }
891:                 
892:                 PLIB_INLINE SFR_DATA _PORTS_CHANGE_NOTICE_MASK(PORTS_MODULE_ID i)
893:                 {
894:                     switch (i) {
895:                         case PORTS_ID_0 :
896:                             return _CNCON_ON_MASK;
897:                         case PORTS_NUMBER_OF_MODULES :
898:                         default :
899:                             return (SFR_DATA)-1;
900:                     }
901:                 }
902:                 
903:                 PLIB_INLINE SFR_DATA _PORTS_CHANGE_NOTICE_IN_IDLE_MASK(PORTS_MODULE_ID i)
904:                 {
905:                     switch (i) {
906:                         case PORTS_ID_0 :
907:                             return _CNCON_SIDL_MASK;
908:                         case PORTS_NUMBER_OF_MODULES :
909:                         default :
910:                             return (SFR_DATA)-1;
911:                     }
912:                 }
913:                 
914:                 PLIB_INLINE SFR_DATA _PORTS_PIN_CHANGE_NOTICE_MASK(PORTS_MODULE_ID i)
915:                 {
916:                     switch (i) {
917:                         case PORTS_ID_0 :
918:                             return _CNEN_CNEN0_MASK;
919:                         case PORTS_NUMBER_OF_MODULES :
920:                         default :
921:                             return (SFR_DATA)-1;
922:                     }
923:                 }
924:                 
925:                 PLIB_INLINE SFR_DATA _PORTS_CHANGE_NOTICE_PULL_UP_MASK(PORTS_MODULE_ID i)
926:                 {
927:                     switch (i) {
928:                         case PORTS_ID_0 :
929:                             return _CNPUE_CNPUE0_MASK;
930:                         case PORTS_NUMBER_OF_MODULES :
931:                         default :
932:                             return (SFR_DATA)-1;
933:                     }
934:                 }
935:                 
936:                 PLIB_INLINE SFR_DATA _PORTS_READ_A_POS(PORTS_MODULE_ID i)
937:                 {
938:                     switch (i) {
939:                         case PORTS_ID_0 :
940:                             return (SFR_DATA)0;
941:                         case PORTS_NUMBER_OF_MODULES :
942:                         default :
943:                             return (SFR_DATA)-1;
944:                     }
945:                 }
946:                 
947:                 PLIB_INLINE SFR_DATA _PORTS_WRITE_A_POS(PORTS_MODULE_ID i)
948:                 {
949:                     switch (i) {
950:                         case PORTS_ID_0 :
951:                             return (SFR_DATA)0;
952:                         case PORTS_NUMBER_OF_MODULES :
953:                         default :
954:                             return (SFR_DATA)-1;
955:                     }
956:                 }
957:                 
958:                 PLIB_INLINE SFR_DATA _PORTS_DIRECTION_A_POS(PORTS_MODULE_ID i)
959:                 {
960:                     switch (i) {
961:                         case PORTS_ID_0 :
962:                             return (SFR_DATA)0;
963:                         case PORTS_NUMBER_OF_MODULES :
964:                         default :
965:                             return (SFR_DATA)-1;
966:                     }
967:                 }
968:                 
969:                 PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_A_POS(PORTS_MODULE_ID i)
970:                 {
971:                     switch (i) {
972:                         case PORTS_ID_0 :
973:                             return (SFR_DATA)0;
974:                         case PORTS_NUMBER_OF_MODULES :
975:                         default :
976:                             return (SFR_DATA)-1;
977:                     }
978:                 }
979:                 
980:                 PLIB_INLINE SFR_DATA _PORTS_READ_B_POS(PORTS_MODULE_ID i)
981:                 {
982:                     switch (i) {
983:                         case PORTS_ID_0 :
984:                             return (SFR_DATA)0;
985:                         case PORTS_NUMBER_OF_MODULES :
986:                         default :
987:                             return (SFR_DATA)-1;
988:                     }
989:                 }
990:                 
991:                 PLIB_INLINE SFR_DATA _PORTS_WRITE_B_POS(PORTS_MODULE_ID i)
992:                 {
993:                     switch (i) {
994:                         case PORTS_ID_0 :
995:                             return (SFR_DATA)0;
996:                         case PORTS_NUMBER_OF_MODULES :
997:                         default :
998:                             return (SFR_DATA)-1;
999:                     }
1000:                }
1001:                
1002:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_B_POS(PORTS_MODULE_ID i)
1003:                {
1004:                    switch (i) {
1005:                        case PORTS_ID_0 :
1006:                            return (SFR_DATA)0;
1007:                        case PORTS_NUMBER_OF_MODULES :
1008:                        default :
1009:                            return (SFR_DATA)-1;
1010:                    }
1011:                }
1012:                
1013:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_B_POS(PORTS_MODULE_ID i)
1014:                {
1015:                    switch (i) {
1016:                        case PORTS_ID_0 :
1017:                            return (SFR_DATA)0;
1018:                        case PORTS_NUMBER_OF_MODULES :
1019:                        default :
1020:                            return (SFR_DATA)-1;
1021:                    }
1022:                }
1023:                
1024:                PLIB_INLINE SFR_DATA _PORTS_READ_C_POS(PORTS_MODULE_ID i)
1025:                {
1026:                    switch (i) {
1027:                        case PORTS_ID_0 :
1028:                            return (SFR_DATA)0;
1029:                        case PORTS_NUMBER_OF_MODULES :
1030:                        default :
1031:                            return (SFR_DATA)-1;
1032:                    }
1033:                }
1034:                
1035:                PLIB_INLINE SFR_DATA _PORTS_WRITE_C_POS(PORTS_MODULE_ID i)
1036:                {
1037:                    switch (i) {
1038:                        case PORTS_ID_0 :
1039:                            return (SFR_DATA)0;
1040:                        case PORTS_NUMBER_OF_MODULES :
1041:                        default :
1042:                            return (SFR_DATA)-1;
1043:                    }
1044:                }
1045:                
1046:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_C_POS(PORTS_MODULE_ID i)
1047:                {
1048:                    switch (i) {
1049:                        case PORTS_ID_0 :
1050:                            return (SFR_DATA)0;
1051:                        case PORTS_NUMBER_OF_MODULES :
1052:                        default :
1053:                            return (SFR_DATA)-1;
1054:                    }
1055:                }
1056:                
1057:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_C_POS(PORTS_MODULE_ID i)
1058:                {
1059:                    switch (i) {
1060:                        case PORTS_ID_0 :
1061:                            return (SFR_DATA)0;
1062:                        case PORTS_NUMBER_OF_MODULES :
1063:                        default :
1064:                            return (SFR_DATA)-1;
1065:                    }
1066:                }
1067:                
1068:                PLIB_INLINE SFR_DATA _PORTS_READ_D_POS(PORTS_MODULE_ID i)
1069:                {
1070:                    switch (i) {
1071:                        case PORTS_ID_0 :
1072:                            return (SFR_DATA)0;
1073:                        case PORTS_NUMBER_OF_MODULES :
1074:                        default :
1075:                            return (SFR_DATA)-1;
1076:                    }
1077:                }
1078:                
1079:                PLIB_INLINE SFR_DATA _PORTS_WRITE_D_POS(PORTS_MODULE_ID i)
1080:                {
1081:                    switch (i) {
1082:                        case PORTS_ID_0 :
1083:                            return (SFR_DATA)0;
1084:                        case PORTS_NUMBER_OF_MODULES :
1085:                        default :
1086:                            return (SFR_DATA)-1;
1087:                    }
1088:                }
1089:                
1090:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_D_POS(PORTS_MODULE_ID i)
1091:                {
1092:                    switch (i) {
1093:                        case PORTS_ID_0 :
1094:                            return (SFR_DATA)0;
1095:                        case PORTS_NUMBER_OF_MODULES :
1096:                        default :
1097:                            return (SFR_DATA)-1;
1098:                    }
1099:                }
1100:                
1101:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_D_POS(PORTS_MODULE_ID i)
1102:                {
1103:                    switch (i) {
1104:                        case PORTS_ID_0 :
1105:                            return (SFR_DATA)0;
1106:                        case PORTS_NUMBER_OF_MODULES :
1107:                        default :
1108:                            return (SFR_DATA)-1;
1109:                    }
1110:                }
1111:                
1112:                PLIB_INLINE SFR_DATA _PORTS_READ_E_POS(PORTS_MODULE_ID i)
1113:                {
1114:                    switch (i) {
1115:                        case PORTS_ID_0 :
1116:                            return (SFR_DATA)0;
1117:                        case PORTS_NUMBER_OF_MODULES :
1118:                        default :
1119:                            return (SFR_DATA)-1;
1120:                    }
1121:                }
1122:                
1123:                PLIB_INLINE SFR_DATA _PORTS_WRITE_E_POS(PORTS_MODULE_ID i)
1124:                {
1125:                    switch (i) {
1126:                        case PORTS_ID_0 :
1127:                            return (SFR_DATA)0;
1128:                        case PORTS_NUMBER_OF_MODULES :
1129:                        default :
1130:                            return (SFR_DATA)-1;
1131:                    }
1132:                }
1133:                
1134:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_E_POS(PORTS_MODULE_ID i)
1135:                {
1136:                    switch (i) {
1137:                        case PORTS_ID_0 :
1138:                            return (SFR_DATA)0;
1139:                        case PORTS_NUMBER_OF_MODULES :
1140:                        default :
1141:                            return (SFR_DATA)-1;
1142:                    }
1143:                }
1144:                
1145:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_E_POS(PORTS_MODULE_ID i)
1146:                {
1147:                    switch (i) {
1148:                        case PORTS_ID_0 :
1149:                            return (SFR_DATA)0;
1150:                        case PORTS_NUMBER_OF_MODULES :
1151:                        default :
1152:                            return (SFR_DATA)-1;
1153:                    }
1154:                }
1155:                
1156:                PLIB_INLINE SFR_DATA _PORTS_READ_F_POS(PORTS_MODULE_ID i)
1157:                {
1158:                    switch (i) {
1159:                        case PORTS_ID_0 :
1160:                            return (SFR_DATA)0;
1161:                        case PORTS_NUMBER_OF_MODULES :
1162:                        default :
1163:                            return (SFR_DATA)-1;
1164:                    }
1165:                }
1166:                
1167:                PLIB_INLINE SFR_DATA _PORTS_WRITE_F_POS(PORTS_MODULE_ID i)
1168:                {
1169:                    switch (i) {
1170:                        case PORTS_ID_0 :
1171:                            return (SFR_DATA)0;
1172:                        case PORTS_NUMBER_OF_MODULES :
1173:                        default :
1174:                            return (SFR_DATA)-1;
1175:                    }
1176:                }
1177:                
1178:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_F_POS(PORTS_MODULE_ID i)
1179:                {
1180:                    switch (i) {
1181:                        case PORTS_ID_0 :
1182:                            return (SFR_DATA)0;
1183:                        case PORTS_NUMBER_OF_MODULES :
1184:                        default :
1185:                            return (SFR_DATA)-1;
1186:                    }
1187:                }
1188:                
1189:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_F_POS(PORTS_MODULE_ID i)
1190:                {
1191:                    switch (i) {
1192:                        case PORTS_ID_0 :
1193:                            return (SFR_DATA)0;
1194:                        case PORTS_NUMBER_OF_MODULES :
1195:                        default :
1196:                            return (SFR_DATA)-1;
1197:                    }
1198:                }
1199:                
1200:                PLIB_INLINE SFR_DATA _PORTS_READ_G_POS(PORTS_MODULE_ID i)
1201:                {
1202:                    switch (i) {
1203:                        case PORTS_ID_0 :
1204:                            return (SFR_DATA)0;
1205:                        case PORTS_NUMBER_OF_MODULES :
1206:                        default :
1207:                            return (SFR_DATA)-1;
1208:                    }
1209:                }
1210:                
1211:                PLIB_INLINE SFR_DATA _PORTS_WRITE_G_POS(PORTS_MODULE_ID i)
1212:                {
1213:                    switch (i) {
1214:                        case PORTS_ID_0 :
1215:                            return (SFR_DATA)0;
1216:                        case PORTS_NUMBER_OF_MODULES :
1217:                        default :
1218:                            return (SFR_DATA)-1;
1219:                    }
1220:                }
1221:                
1222:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_G_POS(PORTS_MODULE_ID i)
1223:                {
1224:                    switch (i) {
1225:                        case PORTS_ID_0 :
1226:                            return (SFR_DATA)0;
1227:                        case PORTS_NUMBER_OF_MODULES :
1228:                        default :
1229:                            return (SFR_DATA)-1;
1230:                    }
1231:                }
1232:                
1233:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_G_POS(PORTS_MODULE_ID i)
1234:                {
1235:                    switch (i) {
1236:                        case PORTS_ID_0 :
1237:                            return (SFR_DATA)0;
1238:                        case PORTS_NUMBER_OF_MODULES :
1239:                        default :
1240:                            return (SFR_DATA)-1;
1241:                    }
1242:                }
1243:                
1244:                PLIB_INLINE SFR_DATA _PORTS_PIN_MODE_POS(PORTS_MODULE_ID i)
1245:                {
1246:                    switch (i) {
1247:                        case PORTS_ID_0 :
1248:                            return (SFR_DATA)0;
1249:                        case PORTS_NUMBER_OF_MODULES :
1250:                        default :
1251:                            return (SFR_DATA)-1;
1252:                    }
1253:                }
1254:                
1255:                PLIB_INLINE SFR_DATA _PORTS_CHANGE_NOTICE_POS(PORTS_MODULE_ID i)
1256:                {
1257:                    switch (i) {
1258:                        case PORTS_ID_0 :
1259:                            return _CNCON_ON_POSITION;
1260:                        case PORTS_NUMBER_OF_MODULES :
1261:                        default :
1262:                            return (SFR_DATA)-1;
1263:                    }
1264:                }
1265:                
1266:                PLIB_INLINE SFR_DATA _PORTS_CHANGE_NOTICE_IN_IDLE_POS(PORTS_MODULE_ID i)
1267:                {
1268:                    switch (i) {
1269:                        case PORTS_ID_0 :
1270:                            return _CNCON_SIDL_POSITION;
1271:                        case PORTS_NUMBER_OF_MODULES :
1272:                        default :
1273:                            return (SFR_DATA)-1;
1274:                    }
1275:                }
1276:                
1277:                PLIB_INLINE SFR_DATA _PORTS_PIN_CHANGE_NOTICE_POS(PORTS_MODULE_ID i)
1278:                {
1279:                    switch (i) {
1280:                        case PORTS_ID_0 :
1281:                            return _CNEN_CNEN0_POSITION;
1282:                        case PORTS_NUMBER_OF_MODULES :
1283:                        default :
1284:                            return (SFR_DATA)-1;
1285:                    }
1286:                }
1287:                
1288:                PLIB_INLINE SFR_DATA _PORTS_CHANGE_NOTICE_PULL_UP_POS(PORTS_MODULE_ID i)
1289:                {
1290:                    switch (i) {
1291:                        case PORTS_ID_0 :
1292:                            return _CNPUE_CNPUE0_POSITION;
1293:                        case PORTS_NUMBER_OF_MODULES :
1294:                        default :
1295:                            return (SFR_DATA)-1;
1296:                    }
1297:                }
1298:                
1299:                PLIB_INLINE SFR_DATA _PORTS_READ_A_LEN(PORTS_MODULE_ID i)
1300:                {
1301:                    switch (i) {
1302:                        case PORTS_ID_0 :
1303:                            return (SFR_DATA)sizeof(SFR_DATA);
1304:                        case PORTS_NUMBER_OF_MODULES :
1305:                        default :
1306:                            return (SFR_DATA)-1;
1307:                    }
1308:                }
1309:                
1310:                PLIB_INLINE SFR_DATA _PORTS_WRITE_A_LEN(PORTS_MODULE_ID i)
1311:                {
1312:                    switch (i) {
1313:                        case PORTS_ID_0 :
1314:                            return (SFR_DATA)sizeof(SFR_DATA);
1315:                        case PORTS_NUMBER_OF_MODULES :
1316:                        default :
1317:                            return (SFR_DATA)-1;
1318:                    }
1319:                }
1320:                
1321:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_A_LEN(PORTS_MODULE_ID i)
1322:                {
1323:                    switch (i) {
1324:                        case PORTS_ID_0 :
1325:                            return (SFR_DATA)sizeof(SFR_DATA);
1326:                        case PORTS_NUMBER_OF_MODULES :
1327:                        default :
1328:                            return (SFR_DATA)-1;
1329:                    }
1330:                }
1331:                
1332:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_A_LEN(PORTS_MODULE_ID i)
1333:                {
1334:                    switch (i) {
1335:                        case PORTS_ID_0 :
1336:                            return (SFR_DATA)sizeof(SFR_DATA);
1337:                        case PORTS_NUMBER_OF_MODULES :
1338:                        default :
1339:                            return (SFR_DATA)-1;
1340:                    }
1341:                }
1342:                
1343:                PLIB_INLINE SFR_DATA _PORTS_READ_B_LEN(PORTS_MODULE_ID i)
1344:                {
1345:                    switch (i) {
1346:                        case PORTS_ID_0 :
1347:                            return (SFR_DATA)sizeof(SFR_DATA);
1348:                        case PORTS_NUMBER_OF_MODULES :
1349:                        default :
1350:                            return (SFR_DATA)-1;
1351:                    }
1352:                }
1353:                
1354:                PLIB_INLINE SFR_DATA _PORTS_WRITE_B_LEN(PORTS_MODULE_ID i)
1355:                {
1356:                    switch (i) {
1357:                        case PORTS_ID_0 :
1358:                            return (SFR_DATA)sizeof(SFR_DATA);
1359:                        case PORTS_NUMBER_OF_MODULES :
1360:                        default :
1361:                            return (SFR_DATA)-1;
1362:                    }
1363:                }
1364:                
1365:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_B_LEN(PORTS_MODULE_ID i)
1366:                {
1367:                    switch (i) {
1368:                        case PORTS_ID_0 :
1369:                            return (SFR_DATA)sizeof(SFR_DATA);
1370:                        case PORTS_NUMBER_OF_MODULES :
1371:                        default :
1372:                            return (SFR_DATA)-1;
1373:                    }
1374:                }
1375:                
1376:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_B_LEN(PORTS_MODULE_ID i)
1377:                {
1378:                    switch (i) {
1379:                        case PORTS_ID_0 :
1380:                            return (SFR_DATA)sizeof(SFR_DATA);
1381:                        case PORTS_NUMBER_OF_MODULES :
1382:                        default :
1383:                            return (SFR_DATA)-1;
1384:                    }
1385:                }
1386:                
1387:                PLIB_INLINE SFR_DATA _PORTS_READ_C_LEN(PORTS_MODULE_ID i)
1388:                {
1389:                    switch (i) {
1390:                        case PORTS_ID_0 :
1391:                            return (SFR_DATA)sizeof(SFR_DATA);
1392:                        case PORTS_NUMBER_OF_MODULES :
1393:                        default :
1394:                            return (SFR_DATA)-1;
1395:                    }
1396:                }
1397:                
1398:                PLIB_INLINE SFR_DATA _PORTS_WRITE_C_LEN(PORTS_MODULE_ID i)
1399:                {
1400:                    switch (i) {
1401:                        case PORTS_ID_0 :
1402:                            return (SFR_DATA)sizeof(SFR_DATA);
1403:                        case PORTS_NUMBER_OF_MODULES :
1404:                        default :
1405:                            return (SFR_DATA)-1;
1406:                    }
1407:                }
1408:                
1409:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_C_LEN(PORTS_MODULE_ID i)
1410:                {
1411:                    switch (i) {
1412:                        case PORTS_ID_0 :
1413:                            return (SFR_DATA)sizeof(SFR_DATA);
1414:                        case PORTS_NUMBER_OF_MODULES :
1415:                        default :
1416:                            return (SFR_DATA)-1;
1417:                    }
1418:                }
1419:                
1420:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_C_LEN(PORTS_MODULE_ID i)
1421:                {
1422:                    switch (i) {
1423:                        case PORTS_ID_0 :
1424:                            return (SFR_DATA)sizeof(SFR_DATA);
1425:                        case PORTS_NUMBER_OF_MODULES :
1426:                        default :
1427:                            return (SFR_DATA)-1;
1428:                    }
1429:                }
1430:                
1431:                PLIB_INLINE SFR_DATA _PORTS_READ_D_LEN(PORTS_MODULE_ID i)
1432:                {
1433:                    switch (i) {
1434:                        case PORTS_ID_0 :
1435:                            return (SFR_DATA)sizeof(SFR_DATA);
1436:                        case PORTS_NUMBER_OF_MODULES :
1437:                        default :
1438:                            return (SFR_DATA)-1;
1439:                    }
1440:                }
1441:                
1442:                PLIB_INLINE SFR_DATA _PORTS_WRITE_D_LEN(PORTS_MODULE_ID i)
1443:                {
1444:                    switch (i) {
1445:                        case PORTS_ID_0 :
1446:                            return (SFR_DATA)sizeof(SFR_DATA);
1447:                        case PORTS_NUMBER_OF_MODULES :
1448:                        default :
1449:                            return (SFR_DATA)-1;
1450:                    }
1451:                }
1452:                
1453:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_D_LEN(PORTS_MODULE_ID i)
1454:                {
1455:                    switch (i) {
1456:                        case PORTS_ID_0 :
1457:                            return (SFR_DATA)sizeof(SFR_DATA);
1458:                        case PORTS_NUMBER_OF_MODULES :
1459:                        default :
1460:                            return (SFR_DATA)-1;
1461:                    }
1462:                }
1463:                
1464:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_D_LEN(PORTS_MODULE_ID i)
1465:                {
1466:                    switch (i) {
1467:                        case PORTS_ID_0 :
1468:                            return (SFR_DATA)sizeof(SFR_DATA);
1469:                        case PORTS_NUMBER_OF_MODULES :
1470:                        default :
1471:                            return (SFR_DATA)-1;
1472:                    }
1473:                }
1474:                
1475:                PLIB_INLINE SFR_DATA _PORTS_READ_E_LEN(PORTS_MODULE_ID i)
1476:                {
1477:                    switch (i) {
1478:                        case PORTS_ID_0 :
1479:                            return (SFR_DATA)sizeof(SFR_DATA);
1480:                        case PORTS_NUMBER_OF_MODULES :
1481:                        default :
1482:                            return (SFR_DATA)-1;
1483:                    }
1484:                }
1485:                
1486:                PLIB_INLINE SFR_DATA _PORTS_WRITE_E_LEN(PORTS_MODULE_ID i)
1487:                {
1488:                    switch (i) {
1489:                        case PORTS_ID_0 :
1490:                            return (SFR_DATA)sizeof(SFR_DATA);
1491:                        case PORTS_NUMBER_OF_MODULES :
1492:                        default :
1493:                            return (SFR_DATA)-1;
1494:                    }
1495:                }
1496:                
1497:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_E_LEN(PORTS_MODULE_ID i)
1498:                {
1499:                    switch (i) {
1500:                        case PORTS_ID_0 :
1501:                            return (SFR_DATA)sizeof(SFR_DATA);
1502:                        case PORTS_NUMBER_OF_MODULES :
1503:                        default :
1504:                            return (SFR_DATA)-1;
1505:                    }
1506:                }
1507:                
1508:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_E_LEN(PORTS_MODULE_ID i)
1509:                {
1510:                    switch (i) {
1511:                        case PORTS_ID_0 :
1512:                            return (SFR_DATA)sizeof(SFR_DATA);
1513:                        case PORTS_NUMBER_OF_MODULES :
1514:                        default :
1515:                            return (SFR_DATA)-1;
1516:                    }
1517:                }
1518:                
1519:                PLIB_INLINE SFR_DATA _PORTS_READ_F_LEN(PORTS_MODULE_ID i)
1520:                {
1521:                    switch (i) {
1522:                        case PORTS_ID_0 :
1523:                            return (SFR_DATA)sizeof(SFR_DATA);
1524:                        case PORTS_NUMBER_OF_MODULES :
1525:                        default :
1526:                            return (SFR_DATA)-1;
1527:                    }
1528:                }
1529:                
1530:                PLIB_INLINE SFR_DATA _PORTS_WRITE_F_LEN(PORTS_MODULE_ID i)
1531:                {
1532:                    switch (i) {
1533:                        case PORTS_ID_0 :
1534:                            return (SFR_DATA)sizeof(SFR_DATA);
1535:                        case PORTS_NUMBER_OF_MODULES :
1536:                        default :
1537:                            return (SFR_DATA)-1;
1538:                    }
1539:                }
1540:                
1541:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_F_LEN(PORTS_MODULE_ID i)
1542:                {
1543:                    switch (i) {
1544:                        case PORTS_ID_0 :
1545:                            return (SFR_DATA)sizeof(SFR_DATA);
1546:                        case PORTS_NUMBER_OF_MODULES :
1547:                        default :
1548:                            return (SFR_DATA)-1;
1549:                    }
1550:                }
1551:                
1552:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_F_LEN(PORTS_MODULE_ID i)
1553:                {
1554:                    switch (i) {
1555:                        case PORTS_ID_0 :
1556:                            return (SFR_DATA)sizeof(SFR_DATA);
1557:                        case PORTS_NUMBER_OF_MODULES :
1558:                        default :
1559:                            return (SFR_DATA)-1;
1560:                    }
1561:                }
1562:                
1563:                PLIB_INLINE SFR_DATA _PORTS_READ_G_LEN(PORTS_MODULE_ID i)
1564:                {
1565:                    switch (i) {
1566:                        case PORTS_ID_0 :
1567:                            return (SFR_DATA)sizeof(SFR_DATA);
1568:                        case PORTS_NUMBER_OF_MODULES :
1569:                        default :
1570:                            return (SFR_DATA)-1;
1571:                    }
1572:                }
1573:                
1574:                PLIB_INLINE SFR_DATA _PORTS_WRITE_G_LEN(PORTS_MODULE_ID i)
1575:                {
1576:                    switch (i) {
1577:                        case PORTS_ID_0 :
1578:                            return (SFR_DATA)sizeof(SFR_DATA);
1579:                        case PORTS_NUMBER_OF_MODULES :
1580:                        default :
1581:                            return (SFR_DATA)-1;
1582:                    }
1583:                }
1584:                
1585:                PLIB_INLINE SFR_DATA _PORTS_DIRECTION_G_LEN(PORTS_MODULE_ID i)
1586:                {
1587:                    switch (i) {
1588:                        case PORTS_ID_0 :
1589:                            return (SFR_DATA)sizeof(SFR_DATA);
1590:                        case PORTS_NUMBER_OF_MODULES :
1591:                        default :
1592:                            return (SFR_DATA)-1;
1593:                    }
1594:                }
1595:                
1596:                PLIB_INLINE SFR_DATA _PORTS_OPEN_DRAIN_G_LEN(PORTS_MODULE_ID i)
1597:                {
1598:                    switch (i) {
1599:                        case PORTS_ID_0 :
1600:                            return (SFR_DATA)sizeof(SFR_DATA);
1601:                        case PORTS_NUMBER_OF_MODULES :
1602:                        default :
1603:                            return (SFR_DATA)-1;
1604:                    }
1605:                }
1606:                
1607:                PLIB_INLINE SFR_DATA _PORTS_PIN_MODE_LEN(PORTS_MODULE_ID i)
1608:                {
1609:                    switch (i) {
1610:                        case PORTS_ID_0 :
1611:                            return (SFR_DATA)sizeof(SFR_DATA);
1612:                        case PORTS_NUMBER_OF_MODULES :
1613:                        default :
1614:                            return (SFR_DATA)-1;
1615:                    }
1616:                }
1617:                
1618:                PLIB_INLINE SFR_DATA _PORTS_CHANGE_NOTICE_LEN(PORTS_MODULE_ID i)
1619:                {
1620:                    switch (i) {
1621:                        case PORTS_ID_0 :
1622:                            return _CNCON_ON_LENGTH;
1623:                        case PORTS_NUMBER_OF_MODULES :
1624:                        default :
1625:                            return (SFR_DATA)-1;
1626:                    }
1627:                }
1628:                
1629:                PLIB_INLINE SFR_DATA _PORTS_CHANGE_NOTICE_IN_IDLE_LEN(PORTS_MODULE_ID i)
1630:                {
1631:                    switch (i) {
1632:                        case PORTS_ID_0 :
1633:                            return _CNCON_SIDL_LENGTH;
1634:                        case PORTS_NUMBER_OF_MODULES :
1635:                        default :
1636:                            return (SFR_DATA)-1;
1637:                    }
1638:                }
1639:                
1640:                PLIB_INLINE SFR_DATA _PORTS_PIN_CHANGE_NOTICE_LEN(PORTS_MODULE_ID i)
1641:                {
1642:                    switch (i) {
1643:                        case PORTS_ID_0 :
1644:                            return _CNEN_CNEN0_LENGTH;
1645:                        case PORTS_NUMBER_OF_MODULES :
1646:                        default :
1647:                            return (SFR_DATA)-1;
1648:                    }
1649:                }
1650:                
1651:                PLIB_INLINE SFR_DATA _PORTS_CHANGE_NOTICE_PULL_UP_LEN(PORTS_MODULE_ID i)
1652:                {
1653:                    switch (i) {
1654:                        case PORTS_ID_0 :
1655:                            return _CNPUE_CNPUE0_LENGTH;
1656:                        case PORTS_NUMBER_OF_MODULES :
1657:                        default :
1658:                            return (SFR_DATA)-1;
1659:                    }
1660:                }
1661:                
1662:                /* Section 2 - Feature variant inclusion */
1663:                
1664:                #define PLIB_TEMPLATE PLIB_INLINE
1665:                #include "../templates/ports_RemapInput_Unsupported.h"
1666:                #include "../templates/ports_RemapOutput_Unsupported.h"
1667:                #include "../templates/ports_PinMode_Non_PPS.h"
1668:                #include "../templates/ports_AnPinsMode_Non_PPS.h"
1669:                #include "../templates/ports_PortsRead_MCU32.h"
1670:                #include "../templates/ports_LatchRead_MCU32.h"
1671:                #include "../templates/ports_PortsWrite_MCU32.h"
1672:                #include "../templates/ports_PortsDirection_MCU32.h"
1673:                #include "../templates/ports_PortsOpenDrain_MCU32.h"
1674:                #include "../templates/ports_ChangeNotice_Default.h"
1675:                #include "../templates/ports_PinChangeNotice_Default.h"
1676:                #include "../templates/ports_ChangeNoticeInIdle_Default.h"
1677:                #include "../templates/ports_ChangeNoticePullup_Default.h"
1678:                #include "../templates/ports_PinModePerPort_Unsupported.h"
1679:                #include "../templates/ports_ChangeNoticePullDownPerPort_Unsupported.h"
1680:                #include "../templates/ports_ChangeNoticePullUpPerPort_Unsupported.h"
1681:                #include "../templates/ports_PinChangeNoticePerPort_Unsupported.h"
1682:                #include "../templates/ports_ChangeNoticePerPortTurnOn_Unsupported.h"
1683:                #include "../templates/ports_ChangeNoticeInIdlePerPort_Unsupported.h"
1684:                #include "../templates/ports_ChangeNoticePerPortStatus_Unsupported.h"
1685:                #include "../templates/ports_SlewRateControl_Unsupported.h"
1686:                #include "../templates/ports_ChannelChangeNoticeMethod_Unsupported.h"
1687:                #include "../templates/ports_ChangeNoticeEdgeControl_Unsupported.h"
1688:                #include "../templates/ports_ChangeNoticeEdgeStatus_Unsupported.h"
1689:                
1690:                /* Section 3 - PLIB dispatch function definitions */
1691:                
1692:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_RemapInput(PORTS_MODULE_ID index, PORTS_REMAP_INPUT_FUNCTION inputFunction, PORTS_REMAP_INPUT_PIN remapInputPin)
1693:                {
1694:                    switch (index) {
1695:                        case PORTS_ID_0 :
1696:                            PORTS_RemapInput_Unsupported(index, inputFunction, remapInputPin);
1697:                            break;
1698:                        case PORTS_NUMBER_OF_MODULES :
1699:                        default :
1700:                            break;
1701:                    }
1702:                }
1703:                
1704:                PLIB_INLINE_API bool PLIB_PORTS_ExistsRemapInput(PORTS_MODULE_ID index)
1705:                {
1706:                    switch (index) {
1707:                        case PORTS_ID_0 :
1708:                            return PORTS_ExistsRemapInput_Unsupported(index);
1709:                        case PORTS_NUMBER_OF_MODULES :
1710:                        default :
1711:                            return (bool)0;
1712:                    }
1713:                }
1714:                
1715:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_RemapOutput(PORTS_MODULE_ID index, PORTS_REMAP_OUTPUT_FUNCTION outputFunction, PORTS_REMAP_OUTPUT_PIN remapOutputPin)
1716:                {
1717:                    switch (index) {
1718:                        case PORTS_ID_0 :
1719:                            PORTS_RemapOutput_Unsupported(index, outputFunction, remapOutputPin);
1720:                            break;
1721:                        case PORTS_NUMBER_OF_MODULES :
1722:                        default :
1723:                            break;
1724:                    }
1725:                }
1726:                
1727:                PLIB_INLINE_API bool PLIB_PORTS_ExistsRemapOutput(PORTS_MODULE_ID index)
1728:                {
1729:                    switch (index) {
1730:                        case PORTS_ID_0 :
1731:                            return PORTS_ExistsRemapOutput_Unsupported(index);
1732:                        case PORTS_NUMBER_OF_MODULES :
1733:                        default :
1734:                            return (bool)0;
1735:                    }
1736:                }
1737:                
1738:                PLIB_INLINE_API void PLIB_PORTS_PinModeSelect(PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin, PORTS_PIN_MODE mode)
1739:                {
1740:                    switch (index) {
1741:                        case PORTS_ID_0 :
1742:                            PORTS_PinModeSelect_Non_PPS(index, pin, mode);
1743:                            break;
1744:                        case PORTS_NUMBER_OF_MODULES :
1745:                        default :
1746:                            break;
1747:                    }
1748:                }
1749:                
1750:                PLIB_INLINE_API bool PLIB_PORTS_ExistsPinMode(PORTS_MODULE_ID index)
1751:                {
1752:                    switch (index) {
1753:                        case PORTS_ID_0 :
1754:                            return PORTS_ExistsPinMode_Non_PPS(index);
1755:                        case PORTS_NUMBER_OF_MODULES :
1756:                        default :
1757:                            return (bool)0;
1758:                    }
1759:                }
1760:                
1761:                PLIB_INLINE_API void PLIB_PORTS_AnPinsModeSelect(PORTS_MODULE_ID index, PORTS_AN_PIN anPins, PORTS_PIN_MODE mode)
1762:                {
1763:                    switch (index) {
1764:                        case PORTS_ID_0 :
1765:                            PORTS_AnPinsModeSelect_Non_PPS(index, anPins, mode);
1766:                            break;
1767:                        case PORTS_NUMBER_OF_MODULES :
1768:                        default :
1769:                            break;
1770:                    }
1771:                }
1772:                
1773:                PLIB_INLINE_API bool PLIB_PORTS_ExistsAnPinsMode(PORTS_MODULE_ID index)
1774:                {
1775:                    switch (index) {
1776:                        case PORTS_ID_0 :
1777:                            return PORTS_ExistsAnPinsMode_Non_PPS(index);
1778:                        case PORTS_NUMBER_OF_MODULES :
1779:                        default :
1780:                            return (bool)0;
1781:                    }
1782:                }
1783:                
1784:                PLIB_INLINE_API bool PLIB_PORTS_PinGet(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
1785:                {
1786:                    switch (index) {
1787:                        case PORTS_ID_0 :
1788:                            return PORTS_PinGet_MCU32(index, channel, bitPos);
1789:                        case PORTS_NUMBER_OF_MODULES :
1790:                        default :
1791:                            return (bool)0;
1792:                    }
1793:                }
1794:                
1795:                PLIB_INLINE_API PORTS_DATA_TYPE PLIB_PORTS_Read(PORTS_MODULE_ID index, PORTS_CHANNEL channel)
1796:                {
1797:                    switch (index) {
1798:                        case PORTS_ID_0 :
1799:                            return PORTS_Read_MCU32(index, channel);
1800:                        case PORTS_NUMBER_OF_MODULES :
1801:                        default :
1802:                            return (PORTS_DATA_TYPE)0;
1803:                    }
1804:                }
1805:                
1806:                PLIB_INLINE_API bool PLIB_PORTS_ExistsPortsRead(PORTS_MODULE_ID index)
1807:                {
1808:                    switch (index) {
1809:                        case PORTS_ID_0 :
1810:                            return PORTS_ExistsPortsRead_MCU32(index);
1811:                        case PORTS_NUMBER_OF_MODULES :
1812:                        default :
1813:                            return (bool)0;
1814:                    }
1815:                }
1816:                
1817:                PLIB_INLINE_API bool PLIB_PORTS_PinGetLatched(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
1818:                {
1819:                    switch (index) {
1820:                        case PORTS_ID_0 :
1821:                            return PORTS_PinGetLatched_MCU32(index, channel, bitPos);
1822:                        case PORTS_NUMBER_OF_MODULES :
1823:                        default :
1824:                            return (bool)0;
1825:                    }
1826:                }
1827:                
1828:                PLIB_INLINE_API PORTS_DATA_TYPE PLIB_PORTS_ReadLatched(PORTS_MODULE_ID index, PORTS_CHANNEL channel)
1829:                {
1830:                    switch (index) {
1831:                        case PORTS_ID_0 :
1832:                            return PORTS_ReadLatched_MCU32(index, channel);
1833:                        case PORTS_NUMBER_OF_MODULES :
1834:                        default :
1835:                            return (PORTS_DATA_TYPE)0;
1836:                    }
1837:                }
1838:                
1839:                PLIB_INLINE_API bool PLIB_PORTS_ExistsLatchRead(PORTS_MODULE_ID index)
1840:                {
1841:                    switch (index) {
1842:                        case PORTS_ID_0 :
1843:                            return PORTS_ExistsLatchRead_MCU32(index);
1844:                        case PORTS_NUMBER_OF_MODULES :
1845:                        default :
1846:                            return (bool)0;
1847:                    }
1848:                }
1849:                
1850:                PLIB_INLINE_API void PLIB_PORTS_PinWrite(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos, bool value)
1851:                {
1852:                    switch (index) {
00000000  00000000   NOP
1853:                        case PORTS_ID_0 :
1854:                            PORTS_PinWrite_MCU32(index, channel, bitPos, value);
1855:                            break;
1856:                        case PORTS_NUMBER_OF_MODULES :
1857:                        default :
1858:                            break;
1859:                    }
1860:                }
1861:                
1862:                PLIB_INLINE_API void PLIB_PORTS_PinSet(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
1863:                {
1864:                    switch (index) {
9D00BF7C  1480000B   BNE A0, ZERO, 0x9D00BFAC
9D00BF80  3C0203FF   LUI V0, 1023
00000000  00000000   NOP
1865:                        case PORTS_ID_0 :
1866:                            PORTS_PinSet_MCU32(index, channel, bitPos);
1867:                            break;
1868:                        case PORTS_NUMBER_OF_MODULES :
1869:                        default :
1870:                            break;
1871:                    }
1872:                }
1873:                
1874:                PLIB_INLINE_API void PLIB_PORTS_PinClear(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
1875:                {
1876:                    switch (index) {
9D00BFB4  1480FFFD   BNE A0, ZERO, 0x9D00BFAC
9D00BFB8  3C0203FF   LUI V0, 1023
1877:                        case PORTS_ID_0 :
1878:                            PORTS_PinClear_MCU32(index, channel, bitPos);
1879:                            break;
1880:                        case PORTS_NUMBER_OF_MODULES :
1881:                        default :
1882:                            break;
1883:                    }
1884:                }
1885:                
1886:                PLIB_INLINE_API void PLIB_PORTS_PinToggle(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
1887:                {
1888:                    switch (index) {
1889:                        case PORTS_ID_0 :
1890:                            PORTS_PinToggle_MCU32(index, channel, bitPos);
1891:                            break;
1892:                        case PORTS_NUMBER_OF_MODULES :
1893:                        default :
1894:                            break;
1895:                    }
1896:                }
1897:                
1898:                PLIB_INLINE_API void PLIB_PORTS_Write(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_TYPE value)
1899:                {
1900:                    switch (index) {
1901:                        case PORTS_ID_0 :
1902:                            PORTS_Write_MCU32(index, channel, value);
1903:                            break;
1904:                        case PORTS_NUMBER_OF_MODULES :
1905:                        default :
1906:                            break;
1907:                    }
1908:                }
1909:                
1910:                PLIB_INLINE_API void PLIB_PORTS_Set(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_TYPE value, PORTS_DATA_MASK mask)
1911:                {
1912:                    switch (index) {
1913:                        case PORTS_ID_0 :
1914:                            PORTS_Set_MCU32(index, channel, value, mask);
1915:                            break;
1916:                        case PORTS_NUMBER_OF_MODULES :
1917:                        default :
1918:                            break;
1919:                    }
1920:                }
1921:                
1922:                PLIB_INLINE_API void PLIB_PORTS_Toggle(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK toggleMask)
1923:                {
1924:                    switch (index) {
1925:                        case PORTS_ID_0 :
1926:                            PORTS_Toggle_MCU32(index, channel, toggleMask);
1927:                            break;
1928:                        case PORTS_NUMBER_OF_MODULES :
1929:                        default :
1930:                            break;
1931:                    }
1932:                }
1933:                
1934:                PLIB_INLINE_API void PLIB_PORTS_Clear(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK clearMask)
1935:                {
1936:                    switch (index) {
00000000  00000000   NOP
1937:                        case PORTS_ID_0 :
1938:                            PORTS_Clear_MCU32(index, channel, clearMask);
1939:                            break;
1940:                        case PORTS_NUMBER_OF_MODULES :
1941:                        default :
1942:                            break;
1943:                    }
1944:                }
1945:                
1946:                PLIB_INLINE_API bool PLIB_PORTS_ExistsPortsWrite(PORTS_MODULE_ID index)
1947:                {
1948:                    switch (index) {
1949:                        case PORTS_ID_0 :
1950:                            return PORTS_ExistsPortsWrite_MCU32(index);
1951:                        case PORTS_NUMBER_OF_MODULES :
1952:                        default :
1953:                            return (bool)0;
1954:                    }
1955:                }
1956:                
1957:                PLIB_INLINE_API void PLIB_PORTS_PinDirectionInputSet(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
1958:                {
1959:                    switch (index) {
00000040  00000000   NOP
1960:                        case PORTS_ID_0 :
1961:                            PORTS_PinDirectionInputSet_MCU32(index, channel, bitPos);
1962:                            break;
1963:                        case PORTS_NUMBER_OF_MODULES :
1964:                        default :
1965:                            break;
1966:                    }
1967:                }
1968:                
1969:                PLIB_INLINE_API void PLIB_PORTS_PinDirectionOutputSet(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
1970:                {
1971:                    switch (index) {
00000008  00000000   NOP
1972:                        case PORTS_ID_0 :
1973:                            PORTS_PinDirectionOutputSet_MCU32(index, channel, bitPos);
1974:                            break;
1975:                        case PORTS_NUMBER_OF_MODULES :
1976:                        default :
1977:                            break;
1978:                    }
1979:                }
1980:                
1981:                PLIB_INLINE_API void PLIB_PORTS_DirectionInputSet(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
1982:                {
1983:                    switch (index) {
0000000C  00000000   NOP
1984:                        case PORTS_ID_0 :
1985:                            PORTS_DirectionInputSet_MCU32(index, channel, mask);
1986:                            break;
1987:                        case PORTS_NUMBER_OF_MODULES :
1988:                        default :
1989:                            break;
1990:                    }
1991:                }
1992:                
1993:                PLIB_INLINE_API void PLIB_PORTS_DirectionOutputSet(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
1994:                {
1995:                    switch (index) {
0000003C  00000000   NOP
1996:                        case PORTS_ID_0 :
1997:                            PORTS_DirectionOutputSet_MCU32(index, channel, mask);
1998:                            break;
1999:                        case PORTS_NUMBER_OF_MODULES :
2000:                        default :
2001:                            break;
2002:                    }
2003:                }
2004:                
2005:                PLIB_INLINE_API PORTS_DATA_MASK PLIB_PORTS_DirectionGet(PORTS_MODULE_ID index, PORTS_CHANNEL channel)
2006:                {
2007:                    switch (index) {
2008:                        case PORTS_ID_0 :
2009:                            return PORTS_DirectionGet_MCU32(index, channel);
2010:                        case PORTS_NUMBER_OF_MODULES :
2011:                        default :
2012:                            return (PORTS_DATA_MASK)0;
2013:                    }
2014:                }
2015:                
2016:                PLIB_INLINE_API bool PLIB_PORTS_ExistsPortsDirection(PORTS_MODULE_ID index)
2017:                {
2018:                    switch (index) {
2019:                        case PORTS_ID_0 :
2020:                            return PORTS_ExistsPortsDirection_MCU32(index);
2021:                        case PORTS_NUMBER_OF_MODULES :
2022:                        default :
2023:                            return (bool)0;
2024:                    }
2025:                }
2026:                
2027:                PLIB_INLINE_API void PLIB_PORTS_PinOpenDrainEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2028:                {
2029:                    switch (index) {
2030:                        case PORTS_ID_0 :
2031:                            PORTS_PinOpenDrainEnable_MCU32(index, channel, bitPos);
2032:                            break;
2033:                        case PORTS_NUMBER_OF_MODULES :
2034:                        default :
2035:                            break;
2036:                    }
2037:                }
2038:                
2039:                PLIB_INLINE_API void PLIB_PORTS_PinOpenDrainDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2040:                {
2041:                    switch (index) {
2042:                        case PORTS_ID_0 :
2043:                            PORTS_PinOpenDrainDisable_MCU32(index, channel, bitPos);
2044:                            break;
2045:                        case PORTS_NUMBER_OF_MODULES :
2046:                        default :
2047:                            break;
2048:                    }
2049:                }
2050:                
2051:                PLIB_INLINE_API void PLIB_PORTS_OpenDrainEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
2052:                {
2053:                    switch (index) {
2054:                        case PORTS_ID_0 :
2055:                            PORTS_OpenDrainEnable_MCU32(index, channel, mask);
2056:                            break;
2057:                        case PORTS_NUMBER_OF_MODULES :
2058:                        default :
2059:                            break;
2060:                    }
2061:                }
2062:                
2063:                PLIB_INLINE_API void PLIB_PORTS_OpenDrainDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
2064:                {
2065:                    switch (index) {
2066:                        case PORTS_ID_0 :
2067:                            PORTS_OpenDrainDisable_MCU32(index, channel, mask);
2068:                            break;
2069:                        case PORTS_NUMBER_OF_MODULES :
2070:                        default :
2071:                            break;
2072:                    }
2073:                }
2074:                
2075:                PLIB_INLINE_API bool PLIB_PORTS_ExistsPortsOpenDrain(PORTS_MODULE_ID index)
2076:                {
2077:                    switch (index) {
2078:                        case PORTS_ID_0 :
2079:                            return PORTS_ExistsPortsOpenDrain_MCU32(index);
2080:                        case PORTS_NUMBER_OF_MODULES :
2081:                        default :
2082:                            return (bool)0;
2083:                    }
2084:                }
2085:                
2086:                PLIB_INLINE_API void PLIB_PORTS_ChangeNoticeEnable(PORTS_MODULE_ID index)
2087:                {
2088:                    switch (index) {
2089:                        case PORTS_ID_0 :
2090:                            PORTS_ChangeNoticeEnable_Default(index);
2091:                            break;
2092:                        case PORTS_NUMBER_OF_MODULES :
2093:                        default :
2094:                            break;
2095:                    }
2096:                }
2097:                
2098:                PLIB_INLINE_API void PLIB_PORTS_ChangeNoticeDisable(PORTS_MODULE_ID index)
2099:                {
2100:                    switch (index) {
2101:                        case PORTS_ID_0 :
2102:                            PORTS_ChangeNoticeDisable_Default(index);
2103:                            break;
2104:                        case PORTS_NUMBER_OF_MODULES :
2105:                        default :
2106:                            break;
2107:                    }
2108:                }
2109:                
2110:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNotice(PORTS_MODULE_ID index)
2111:                {
2112:                    switch (index) {
00000000  00000000   NOP
2113:                        case PORTS_ID_0 :
2114:                            return PORTS_ExistsChangeNotice_Default(index);
2115:                        case PORTS_NUMBER_OF_MODULES :
2116:                        default :
2117:                            return (bool)0;
2118:                    }
2119:                }
2120:                
2121:                PLIB_INLINE_API void PLIB_PORTS_PinChangeNoticeEnable(PORTS_MODULE_ID index, PORTS_CHANGE_NOTICE_PIN pinNum)
2122:                {
2123:                    switch (index) {
00000058  00000000   NOP
2124:                        case PORTS_ID_0 :
2125:                            PORTS_PinChangeNoticeEnable_Default(index, pinNum);
2126:                            break;
2127:                        case PORTS_NUMBER_OF_MODULES :
2128:                        default :
2129:                            break;
2130:                    }
2131:                }
2132:                
2133:                PLIB_INLINE_API void PLIB_PORTS_PinChangeNoticeDisable(PORTS_MODULE_ID index, PORTS_CHANGE_NOTICE_PIN pinNum)
2134:                {
2135:                    switch (index) {
2136:                        case PORTS_ID_0 :
2137:                            PORTS_PinChangeNoticeDisable_Default(index, pinNum);
2138:                            break;
2139:                        case PORTS_NUMBER_OF_MODULES :
2140:                        default :
2141:                            break;
2142:                    }
2143:                }
2144:                
2145:                PLIB_INLINE_API void PLIB_PORTS_CnPinsEnable(PORTS_MODULE_ID index, PORTS_CN_PIN cnPins)
2146:                {
2147:                    switch (index) {
2148:                        case PORTS_ID_0 :
2149:                            PORTS_CnPinsEnable_Default(index, cnPins);
2150:                            break;
2151:                        case PORTS_NUMBER_OF_MODULES :
2152:                        default :
2153:                            break;
2154:                    }
2155:                }
2156:                
2157:                PLIB_INLINE_API void PLIB_PORTS_CnPinsDisable(PORTS_MODULE_ID index, PORTS_CN_PIN cnPins)
2158:                {
2159:                    switch (index) {
2160:                        case PORTS_ID_0 :
2161:                            PORTS_CnPinsDisable_Default(index, cnPins);
2162:                            break;
2163:                        case PORTS_NUMBER_OF_MODULES :
2164:                        default :
2165:                            break;
2166:                    }
2167:                }
2168:                
2169:                PLIB_INLINE_API bool PLIB_PORTS_ExistsPinChangeNotice(PORTS_MODULE_ID index)
2170:                {
2171:                    switch (index) {
00000000  00000000   NOP
00000050  00000000   NOP
2172:                        case PORTS_ID_0 :
2173:                            return PORTS_ExistsPinChangeNotice_Default(index);
2174:                        case PORTS_NUMBER_OF_MODULES :
2175:                        default :
2176:                            return (bool)0;
2177:                    }
2178:                }
2179:                
2180:                PLIB_INLINE_API void PLIB_PORTS_ChangeNoticeInIdleEnable(PORTS_MODULE_ID index)
2181:                {
2182:                    switch (index) {
2183:                        case PORTS_ID_0 :
2184:                            PORTS_ChangeNoticeInIdleEnable_Default(index);
2185:                            break;
2186:                        case PORTS_NUMBER_OF_MODULES :
2187:                        default :
2188:                            break;
2189:                    }
2190:                }
2191:                
2192:                PLIB_INLINE_API void PLIB_PORTS_ChangeNoticeInIdleDisable(PORTS_MODULE_ID index)
2193:                {
2194:                    switch (index) {
2195:                        case PORTS_ID_0 :
2196:                            PORTS_ChangeNoticeInIdleDisable_Default(index);
2197:                            break;
2198:                        case PORTS_NUMBER_OF_MODULES :
2199:                        default :
2200:                            break;
2201:                    }
2202:                }
2203:                
2204:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNoticeInIdle(PORTS_MODULE_ID index)
2205:                {
2206:                    switch (index) {
2207:                        case PORTS_ID_0 :
2208:                            return PORTS_ExistsChangeNoticeInIdle_Default(index);
2209:                        case PORTS_NUMBER_OF_MODULES :
2210:                        default :
2211:                            return (bool)0;
2212:                    }
2213:                }
2214:                
2215:                PLIB_INLINE_API void PLIB_PORTS_ChangeNoticePullUpEnable(PORTS_MODULE_ID index, PORTS_CHANGE_NOTICE_PIN pinNum)
2216:                {
2217:                    switch (index) {
2218:                        case PORTS_ID_0 :
2219:                            PORTS_ChangeNoticePullUpEnable_Default(index, pinNum);
2220:                            break;
2221:                        case PORTS_NUMBER_OF_MODULES :
2222:                        default :
2223:                            break;
2224:                    }
2225:                }
2226:                
2227:                PLIB_INLINE_API void PLIB_PORTS_ChangeNoticePullUpDisable(PORTS_MODULE_ID index, PORTS_CHANGE_NOTICE_PIN pinNum)
2228:                {
2229:                    switch (index) {
2230:                        case PORTS_ID_0 :
2231:                            PORTS_ChangeNoticePullUpDisable_Default(index, pinNum);
2232:                            break;
2233:                        case PORTS_NUMBER_OF_MODULES :
2234:                        default :
2235:                            break;
2236:                    }
2237:                }
2238:                
2239:                PLIB_INLINE_API void PLIB_PORTS_CnPinsPullUpEnable(PORTS_MODULE_ID index, PORTS_CN_PIN cnPins)
2240:                {
2241:                    switch (index) {
2242:                        case PORTS_ID_0 :
2243:                            PORTS_CnPinsPullUpEnable_Default(index, cnPins);
2244:                            break;
2245:                        case PORTS_NUMBER_OF_MODULES :
2246:                        default :
2247:                            break;
2248:                    }
2249:                }
2250:                
2251:                PLIB_INLINE_API void PLIB_PORTS_CnPinsPullUpDisable(PORTS_MODULE_ID index, PORTS_CN_PIN cnPins)
2252:                {
2253:                    switch (index) {
2254:                        case PORTS_ID_0 :
2255:                            PORTS_CnPinsPullUpDisable_Default(index, cnPins);
2256:                            break;
2257:                        case PORTS_NUMBER_OF_MODULES :
2258:                        default :
2259:                            break;
2260:                    }
2261:                }
2262:                
2263:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNoticePullUp(PORTS_MODULE_ID index)
2264:                {
2265:                    switch (index) {
00000000  00000000   NOP
2266:                        case PORTS_ID_0 :
2267:                            return PORTS_ExistsChangeNoticePullUp_Default(index);
2268:                        case PORTS_NUMBER_OF_MODULES :
2269:                        default :
2270:                            return (bool)0;
2271:                    }
2272:                }
2273:                
2274:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_PinModePerPortSelect(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos, PORTS_PIN_MODE mode)
2275:                {
2276:                    switch (index) {
2277:                        case PORTS_ID_0 :
2278:                            PORTS_PinModePerPortSelect_Unsupported(index, channel, bitPos, mode);
2279:                            break;
2280:                        case PORTS_NUMBER_OF_MODULES :
2281:                        default :
2282:                            break;
2283:                    }
2284:                }
2285:                
2286:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelModeSelect(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK modeMask, PORTS_PIN_MODE mode)
2287:                {
2288:                    switch (index) {
2289:                        case PORTS_ID_0 :
2290:                            PORTS_ChannelModeSelect_Unsupported(index, channel, modeMask, mode);
2291:                            break;
2292:                        case PORTS_NUMBER_OF_MODULES :
2293:                        default :
2294:                            break;
2295:                    }
2296:                }
2297:                
2298:                PLIB_INLINE_API bool PLIB_PORTS_ExistsPinModePerPort(PORTS_MODULE_ID index)
2299:                {
2300:                    switch (index) {
2301:                        case PORTS_ID_0 :
2302:                            return PORTS_ExistsPinModePerPort_Unsupported(index);
2303:                        case PORTS_NUMBER_OF_MODULES :
2304:                        default :
2305:                            return (bool)0;
2306:                    }
2307:                }
2308:                
2309:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticePullDownPerPortEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2310:                {
2311:                    switch (index) {
2312:                        case PORTS_ID_0 :
2313:                            PORTS_ChangeNoticePullDownPerPortEnable_Unsupported(index, channel, bitPos);
2314:                            break;
2315:                        case PORTS_NUMBER_OF_MODULES :
2316:                        default :
2317:                            break;
2318:                    }
2319:                }
2320:                
2321:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticePullDownPerPortDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2322:                {
2323:                    switch (index) {
2324:                        case PORTS_ID_0 :
2325:                            PORTS_ChangeNoticePullDownPerPortDisable_Unsupported(index, channel, bitPos);
2326:                            break;
2327:                        case PORTS_NUMBER_OF_MODULES :
2328:                        default :
2329:                            break;
2330:                    }
2331:                }
2332:                
2333:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
2334:                {
2335:                    switch (index) {
2336:                        case PORTS_ID_0 :
2337:                            PORTS_ChannelChangeNoticePullDownEnable_Unsupported(index, channel, mask);
2338:                            break;
2339:                        case PORTS_NUMBER_OF_MODULES :
2340:                        default :
2341:                            break;
2342:                    }
2343:                }
2344:                
2345:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticePullDownDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
2346:                {
2347:                    switch (index) {
2348:                        case PORTS_ID_0 :
2349:                            PORTS_ChannelChangeNoticePullDownDisable_Unsupported(index, channel, mask);
2350:                            break;
2351:                        case PORTS_NUMBER_OF_MODULES :
2352:                        default :
2353:                            break;
2354:                    }
2355:                }
2356:                
2357:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNoticePullDownPerPort(PORTS_MODULE_ID index)
2358:                {
2359:                    switch (index) {
2360:                        case PORTS_ID_0 :
2361:                            return PORTS_ExistsChangeNoticePullDownPerPort_Unsupported(index);
2362:                        case PORTS_NUMBER_OF_MODULES :
2363:                        default :
2364:                            return (bool)0;
2365:                    }
2366:                }
2367:                
2368:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticePullUpPerPortEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2369:                {
2370:                    switch (index) {
2371:                        case PORTS_ID_0 :
2372:                            PORTS_ChangeNoticePullUpPerPortEnable_Unsupported(index, channel, bitPos);
2373:                            break;
2374:                        case PORTS_NUMBER_OF_MODULES :
2375:                        default :
2376:                            break;
2377:                    }
2378:                }
2379:                
2380:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticePullUpPerPortDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2381:                {
2382:                    switch (index) {
2383:                        case PORTS_ID_0 :
2384:                            PORTS_ChangeNoticePullUpPerPortDisable_Unsupported(index, channel, bitPos);
2385:                            break;
2386:                        case PORTS_NUMBER_OF_MODULES :
2387:                        default :
2388:                            break;
2389:                    }
2390:                }
2391:                
2392:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
2393:                {
2394:                    switch (index) {
2395:                        case PORTS_ID_0 :
2396:                            PORTS_ChannelChangeNoticePullUpEnable_Unsupported(index, channel, mask);
2397:                            break;
2398:                        case PORTS_NUMBER_OF_MODULES :
2399:                        default :
2400:                            break;
2401:                    }
2402:                }
2403:                
2404:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticePullUpDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
2405:                {
2406:                    switch (index) {
2407:                        case PORTS_ID_0 :
2408:                            PORTS_ChannelChangeNoticePullUpDisable_Unsupported(index, channel, mask);
2409:                            break;
2410:                        case PORTS_NUMBER_OF_MODULES :
2411:                        default :
2412:                            break;
2413:                    }
2414:                }
2415:                
2416:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNoticePullUpPerPort(PORTS_MODULE_ID index)
2417:                {
2418:                    switch (index) {
2419:                        case PORTS_ID_0 :
2420:                            return PORTS_ExistsChangeNoticePullUpPerPort_Unsupported(index);
2421:                        case PORTS_NUMBER_OF_MODULES :
2422:                        default :
2423:                            return (bool)0;
2424:                    }
2425:                }
2426:                
2427:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_PinChangeNoticePerPortEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2428:                {
2429:                    switch (index) {
2430:                        case PORTS_ID_0 :
2431:                            PORTS_PinChangeNoticePerPortEnable_Unsupported(index, channel, bitPos);
2432:                            break;
2433:                        case PORTS_NUMBER_OF_MODULES :
2434:                        default :
2435:                            break;
2436:                    }
2437:                }
2438:                
2439:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_PinChangeNoticePerPortDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2440:                {
2441:                    switch (index) {
2442:                        case PORTS_ID_0 :
2443:                            PORTS_PinChangeNoticePerPortDisable_Unsupported(index, channel, bitPos);
2444:                            break;
2445:                        case PORTS_NUMBER_OF_MODULES :
2446:                        default :
2447:                            break;
2448:                    }
2449:                }
2450:                
2451:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
2452:                {
2453:                    switch (index) {
2454:                        case PORTS_ID_0 :
2455:                            PORTS_ChannelChangeNoticeEnable_Unsupported(index, channel, mask);
2456:                            break;
2457:                        case PORTS_NUMBER_OF_MODULES :
2458:                        default :
2459:                            break;
2460:                    }
2461:                }
2462:                
2463:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticeDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK mask)
2464:                {
2465:                    switch (index) {
2466:                        case PORTS_ID_0 :
2467:                            PORTS_ChannelChangeNoticeDisable_Unsupported(index, channel, mask);
2468:                            break;
2469:                        case PORTS_NUMBER_OF_MODULES :
2470:                        default :
2471:                            break;
2472:                    }
2473:                }
2474:                
2475:                PLIB_INLINE_API bool PLIB_PORTS_ExistsPinChangeNoticePerPort(PORTS_MODULE_ID index)
2476:                {
2477:                    switch (index) {
2478:                        case PORTS_ID_0 :
2479:                            return PORTS_ExistsPinChangeNoticePerPort_Unsupported(index);
2480:                        case PORTS_NUMBER_OF_MODULES :
2481:                        default :
2482:                            return (bool)0;
2483:                    }
2484:                }
2485:                
2486:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_MODULE_ID index, PORTS_CHANNEL channel)
2487:                {
2488:                    switch (index) {
2489:                        case PORTS_ID_0 :
2490:                            PORTS_ChangeNoticePerPortTurnOn_Unsupported(index, channel);
2491:                            break;
2492:                        case PORTS_NUMBER_OF_MODULES :
2493:                        default :
2494:                            break;
2495:                    }
2496:                }
2497:                
2498:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticePerPortTurnOff(PORTS_MODULE_ID index, PORTS_CHANNEL channel)
2499:                {
2500:                    switch (index) {
2501:                        case PORTS_ID_0 :
2502:                            PORTS_ChangeNoticePerPortTurnOff_Unsupported(index, channel);
2503:                            break;
2504:                        case PORTS_NUMBER_OF_MODULES :
2505:                        default :
2506:                            break;
2507:                    }
2508:                }
2509:                
2510:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNoticePerPortTurnOn(PORTS_MODULE_ID index)
2511:                {
2512:                    switch (index) {
2513:                        case PORTS_ID_0 :
2514:                            return PORTS_ExistsChangeNoticePerPortTurnOn_Unsupported(index);
2515:                        case PORTS_NUMBER_OF_MODULES :
2516:                        default :
2517:                            return (bool)0;
2518:                    }
2519:                }
2520:                
2521:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticeInIdlePerPortEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel)
2522:                {
2523:                    switch (index) {
2524:                        case PORTS_ID_0 :
2525:                            PORTS_ChangeNoticeInIdlePerPortEnable_Unsupported(index, channel);
2526:                            break;
2527:                        case PORTS_NUMBER_OF_MODULES :
2528:                        default :
2529:                            break;
2530:                    }
2531:                }
2532:                
2533:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticeInIdlePerPortDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel)
2534:                {
2535:                    switch (index) {
2536:                        case PORTS_ID_0 :
2537:                            PORTS_ChangeNoticeInIdlePerPortDisable_Unsupported(index, channel);
2538:                            break;
2539:                        case PORTS_NUMBER_OF_MODULES :
2540:                        default :
2541:                            break;
2542:                    }
2543:                }
2544:                
2545:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNoticePerPortInIdle(PORTS_MODULE_ID index)
2546:                {
2547:                    switch (index) {
2548:                        case PORTS_ID_0 :
2549:                            return PORTS_ExistsChangeNoticePerPortInIdle_Unsupported(index);
2550:                        case PORTS_NUMBER_OF_MODULES :
2551:                        default :
2552:                            return (bool)0;
2553:                    }
2554:                }
2555:                
2556:                PLIB_INLINE_API bool _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticePerPortHasOccured(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2557:                {
2558:                    switch (index) {
2559:                        case PORTS_ID_0 :
2560:                            return PORTS_ChangeNoticePerPortHasOccured_Unsupported(index, channel, bitPos);
2561:                        case PORTS_NUMBER_OF_MODULES :
2562:                        default :
2563:                            return (bool)0;
2564:                    }
2565:                }
2566:                
2567:                PLIB_INLINE_API bool _PLIB_UNSUPPORTED PLIB_PORTS_ChangeNoticePerPortHasOccurred(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2568:                {
2569:                    switch (index) {
2570:                        case PORTS_ID_0 :
2571:                            return PORTS_ChangeNoticePerPortHasOccurred_Unsupported(index, channel, bitPos);
2572:                        case PORTS_NUMBER_OF_MODULES :
2573:                        default :
2574:                            return (bool)0;
2575:                    }
2576:                }
2577:                
2578:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNoticePerPortStatus(PORTS_MODULE_ID index)
2579:                {
2580:                    switch (index) {
2581:                        case PORTS_ID_0 :
2582:                            return PORTS_ExistsChangeNoticePerPortStatus_Unsupported(index);
2583:                        case PORTS_NUMBER_OF_MODULES :
2584:                        default :
2585:                            return (bool)0;
2586:                    }
2587:                }
2588:                
2589:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelSlewRateSelect(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK channelMask, PORTS_PIN_SLEW_RATE slewRate)
2590:                {
2591:                    switch (index) {
2592:                        case PORTS_ID_0 :
2593:                            PORTS_ChannelSlewRateSelect_Unsupported(index, channel, channelMask, slewRate);
2594:                            break;
2595:                        case PORTS_NUMBER_OF_MODULES :
2596:                        default :
2597:                            break;
2598:                    }
2599:                }
2600:                
2601:                PLIB_INLINE_API PORTS_PIN_SLEW_RATE _PLIB_UNSUPPORTED PLIB_PORTS_PinSlewRateGet(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2602:                {
2603:                    switch (index) {
2604:                        case PORTS_ID_0 :
2605:                            return PORTS_PinSlewRateGet_Unsupported(index, channel, bitPos);
2606:                        case PORTS_NUMBER_OF_MODULES :
2607:                        default :
2608:                            return (PORTS_PIN_SLEW_RATE)0;
2609:                    }
2610:                }
2611:                
2612:                PLIB_INLINE_API bool PLIB_PORTS_ExistsSlewRateControl(PORTS_MODULE_ID index)
2613:                {
2614:                    switch (index) {
2615:                        case PORTS_ID_0 :
2616:                            return PORTS_ExistsSlewRateControl_Unsupported(index);
2617:                        case PORTS_NUMBER_OF_MODULES :
2618:                        default :
2619:                            return (bool)0;
2620:                    }
2621:                }
2622:                
2623:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticeMethodSelect(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_CHANGE_NOTICE_METHOD changeNoticeMethod)
2624:                {
2625:                    switch (index) {
2626:                        case PORTS_ID_0 :
2627:                            PORTS_ChannelChangeNoticeMethodSelect_Unsupported(index, channel, changeNoticeMethod);
2628:                            break;
2629:                        case PORTS_NUMBER_OF_MODULES :
2630:                        default :
2631:                            break;
2632:                    }
2633:                }
2634:                
2635:                PLIB_INLINE_API PORTS_CHANGE_NOTICE_METHOD _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticeMethodGet(PORTS_MODULE_ID index, PORTS_CHANNEL channel)
2636:                {
2637:                    switch (index) {
2638:                        case PORTS_ID_0 :
2639:                            return PORTS_ChannelChangeNoticeMethodGet_Unsupported(index, channel);
2640:                        case PORTS_NUMBER_OF_MODULES :
2641:                        default :
2642:                            return (PORTS_CHANGE_NOTICE_METHOD)0;
2643:                    }
2644:                }
2645:                
2646:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChannelChangeNoticeMethod(PORTS_MODULE_ID index)
2647:                {
2648:                    switch (index) {
2649:                        case PORTS_ID_0 :
2650:                            return PORTS_ExistsChannelChangeNoticeMethod_Unsupported(index);
2651:                        case PORTS_NUMBER_OF_MODULES :
2652:                        default :
2653:                            return (bool)0;
2654:                    }
2655:                }
2656:                
2657:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticeEdgeEnable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK edgeRisingMask, PORTS_DATA_MASK edgeFallingMask)
2658:                {
2659:                    switch (index) {
2660:                        case PORTS_ID_0 :
2661:                            PORTS_ChannelChangeNoticeEdgeEnable_Unsupported(index, channel, edgeRisingMask, edgeFallingMask);
2662:                            break;
2663:                        case PORTS_NUMBER_OF_MODULES :
2664:                        default :
2665:                            break;
2666:                    }
2667:                }
2668:                
2669:                PLIB_INLINE_API void _PLIB_UNSUPPORTED PLIB_PORTS_ChannelChangeNoticeEdgeDisable(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_DATA_MASK edgeRisingMask, PORTS_DATA_MASK edgeFallingMask)
2670:                {
2671:                    switch (index) {
2672:                        case PORTS_ID_0 :
2673:                            PORTS_ChannelChangeNoticeEdgeDisable_Unsupported(index, channel, edgeRisingMask, edgeFallingMask);
2674:                            break;
2675:                        case PORTS_NUMBER_OF_MODULES :
2676:                        default :
2677:                            break;
2678:                    }
2679:                }
2680:                
2681:                PLIB_INLINE_API bool _PLIB_UNSUPPORTED PLIB_PORTS_PinChangeNoticeEdgeIsEnabled(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos, PORTS_CHANGE_NOTICE_EDGE cnEdgeType)
2682:                {
2683:                    switch (index) {
2684:                        case PORTS_ID_0 :
2685:                            return PORTS_PinChangeNoticeEdgeIsEnabled_Unsupported(index, channel, bitPos, cnEdgeType);
2686:                        case PORTS_NUMBER_OF_MODULES :
2687:                        default :
2688:                            return (bool)0;
2689:                    }
2690:                }
2691:                
2692:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNoticeEdgeControl(PORTS_MODULE_ID index)
2693:                {
2694:                    switch (index) {
2695:                        case PORTS_ID_0 :
2696:                            return PORTS_ExistsChangeNoticeEdgeControl_Unsupported(index);
2697:                        case PORTS_NUMBER_OF_MODULES :
2698:                        default :
2699:                            return (bool)0;
2700:                    }
2701:                }
2702:                
2703:                PLIB_INLINE_API bool _PLIB_UNSUPPORTED PLIB_PORTS_PinChangeNoticeEdgeHasOccurred(PORTS_MODULE_ID index, PORTS_CHANNEL channel, PORTS_BIT_POS bitPos)
2704:                {
2705:                    switch (index) {
2706:                        case PORTS_ID_0 :
2707:                            return PORTS_PinChangeNoticeEdgeHasOccurred_Unsupported(index, channel, bitPos);
2708:                        case PORTS_NUMBER_OF_MODULES :
2709:                        default :
2710:                            return (bool)0;
2711:                    }
2712:                }
2713:                
2714:                PLIB_INLINE_API bool PLIB_PORTS_ExistsChangeNoticeEdgeStatus(PORTS_MODULE_ID index)
2715:                {
2716:                    switch (index) {
2717:                        case PORTS_ID_0 :
2718:                            return PORTS_ExistsChangeNoticeEdgeStatus_Unsupported(index);
2719:                        case PORTS_NUMBER_OF_MODULES :
2720:                        default :
2721:                            return (bool)0;
2722:                    }
2723:                }
2724:                
2725:                #endif
---  c:/microchip/harmony/v1_08_01/framework/peripheral/pcache/templates/pcache_waitstate_default.h  ----
1:                   /*******************************************************************************
2:                     PCACHE Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pcache_WaitState_Default.h
6:                   
7:                     Summary:
8:                       PCACHE PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : WaitState
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PCACHE_ExistsWaitState
16:                          PLIB_PCACHE_WaitStateSet
17:                          PLIB_PCACHE_WaitStateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PCACHE_WAITSTATE_DEFAULT_H
48:                  #define _PCACHE_WAITSTATE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _PCACHE_WAIT_STATE_VREG(index)
55:                  
56:                    MASKs: 
57:                      _PCACHE_WAIT_STATE_MASK(index)
58:                  
59:                    POSs: 
60:                      _PCACHE_WAIT_STATE_POS(index)
61:                  
62:                    LENs: 
63:                      _PCACHE_WAIT_STATE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  PCACHE_ExistsWaitState_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_PCACHE_ExistsWaitState
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_PCACHE_ExistsWaitState function.
76:                  */
77:                  
78:                  #define PLIB_PCACHE_ExistsWaitState PLIB_PCACHE_ExistsWaitState
79:                  #define PLIB_PCACHE_ExistsWaitState PLIB_PCACHE_ExistsWaitState
80:                  PLIB_TEMPLATE bool PCACHE_ExistsWaitState_Default( PCACHE_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PCACHE_WaitStateSet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_PCACHE_WaitStateSet 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_PCACHE_WaitStateSet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PCACHE_WaitStateSet_Default( PCACHE_MODULE_ID index , uint32_t clocks )
97:                  {
98:                      _SFR_FIELD_WRITE(_PCACHE_WAIT_STATE_VREG(index),
9D00A20C  3C02BF88   LUI V0, -16504
9D00A210  8C464000   LW A2, 16384(V0)
9D00A214  2405FFF8   ADDIU A1, ZERO, -8
9D00A218  00C52824   AND A1, A2, A1
9D00A21C  00651825   OR V1, V1, A1
9D00A220  AC434000   SW V1, 16384(V0)
99:                                       _PCACHE_WAIT_STATE_MASK(index),
100:                                      _PCACHE_WAIT_STATE_POS(index), clocks);
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  PCACHE_WaitStateGet_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_PCACHE_WaitStateGet 
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_PCACHE_WaitStateGet function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE uint32_t PCACHE_WaitStateGet_Default( PCACHE_MODULE_ID index )
115:                 {
116:                      return _SFR_FIELD_READ(_PCACHE_WAIT_STATE_VREG(index),
117:                                     _PCACHE_WAIT_STATE_MASK(index),
118:                                     _PCACHE_WAIT_STATE_POS(index));
119:                 }
120:                 
121:                 
122:                 #endif /*_PCACHE_WAITSTATE_DEFAULT_H*/
123:                 
124:                 /******************************************************************************
125:                  End of File
126:                 */
127:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/pcache/templates/pcache_prefetchenable_default.h  
1:                   /*******************************************************************************
2:                     PCACHE Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pcache_PrefetchEnable_Default.h
6:                   
7:                     Summary:
8:                       PCACHE PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PrefetchEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PCACHE_ExistsPrefetchEnable
16:                          PLIB_PCACHE_PrefetchEnableSet
17:                          PLIB_PCACHE_PrefetchEnableGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PCACHE_PREFETCHENABLE_DEFAULT_H
48:                  #define _PCACHE_PREFETCHENABLE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _PCACHE_PREFETCH_ENABLE_VREG(index)
55:                  
56:                    MASKs: 
57:                      _PCACHE_PREFETCH_ENABLE_MASK(index)
58:                  
59:                    POSs: 
60:                      _PCACHE_PREFETCH_ENABLE_POS(index)
61:                  
62:                    LENs: 
63:                      _PCACHE_PREFETCH_ENABLE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  PCACHE_ExistsPrefetchEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_PCACHE_ExistsPrefetchEnable
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_PCACHE_ExistsPrefetchEnable function.
76:                  */
77:                  
78:                  #define PLIB_PCACHE_ExistsPrefetchEnable PLIB_PCACHE_ExistsPrefetchEnable
79:                  #define PLIB_PCACHE_ExistsPrefetchEnable PLIB_PCACHE_ExistsPrefetchEnable
80:                  PLIB_TEMPLATE bool PCACHE_ExistsPrefetchEnable_Default( PCACHE_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PCACHE_PrefetchEnableSet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_PCACHE_PrefetchEnableSet 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_PCACHE_PrefetchEnableSet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PCACHE_PrefetchEnableSet_Default( PCACHE_MODULE_ID index , PLIB_PCACHE_PREFETCH_ENABLE region )
97:                  {
98:                      _SFR_FIELD_WRITE(_PCACHE_PREFETCH_ENABLE_VREG(index),
9D00A248  3C02BF88   LUI V0, -16504
9D00A24C  8C444000   LW A0, 16384(V0)
9D00A250  34840030   ORI A0, A0, 48
9D00A254  AC444000   SW A0, 16384(V0)
99:                                       _PCACHE_PREFETCH_ENABLE_MASK(index),
100:                                      _PCACHE_PREFETCH_ENABLE_POS(index), region);
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  PCACHE_PrefetchEnableGet_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_PCACHE_PrefetchEnableGet 
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_PCACHE_PrefetchEnableGet function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE PLIB_PCACHE_PREFETCH_ENABLE PCACHE_PrefetchEnableGet_Default( PCACHE_MODULE_ID index )
115:                 {
116:                     return (PLIB_PCACHE_PREFETCH_ENABLE)_SFR_FIELD_READ(_PCACHE_PREFETCH_ENABLE_VREG(index),
117:                                            _PCACHE_PREFETCH_ENABLE_MASK(index),
118:                                            _PCACHE_PREFETCH_ENABLE_POS(index));
119:                 }
120:                 
121:                 
122:                 #endif /*_PCACHE_PREFETCHENABLE_DEFAULT_H*/
123:                 
124:                 /******************************************************************************
125:                  End of File
126:                 */
127:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/osc/templates/osc_secondaryenable_default.h  ----
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_SecondaryEnable_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SecondaryEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsSecondaryEnable
16:                          PLIB_OSC_SecondaryEnable
17:                          PLIB_OSC_SecondaryDisable
18:                          PLIB_OSC_SecondaryIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_SECONDARYENABLE_DEFAULT_H
49:                  #define _OSC_SECONDARYENABLE_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
53:                  
54:                    VREGs: 
55:                      _OSC_SECONDARY_ENABLE_VREG(index)
56:                      _OSC_OSC_REGISTER_LOCK_VREG(index)
57:                  
58:                    MASKs: 
59:                      _OSC_SECONDARY_ENABLE_MASK(index)
60:                      _OSC_OSC_REGISTER_LOCK_MASK(index)
61:                  
62:                    POSs: 
63:                      _OSC_SECONDARY_ENABLE_POS(index)
64:                      _OSC_OSC_REGISTER_LOCK_POS(index)
65:                  
66:                    LENs: 
67:                      _OSC_SECONDARY_ENABLE_LEN(index)
68:                      _OSC_OSC_REGISTER_LOCK_LEN(index)
69:                  
70:                  */
71:                  
72:                  
73:                  //******************************************************************************
74:                  /* Function :  OSC_ExistsSecondaryEnable_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_OSC_ExistsSecondaryEnable
78:                  
79:                    Description:
80:                      This template implements the Default variant of the PLIB_OSC_ExistsSecondaryEnable function.
81:                  */
82:                  
83:                  #define PLIB_OSC_ExistsSecondaryEnable PLIB_OSC_ExistsSecondaryEnable
84:                  PLIB_TEMPLATE bool OSC_ExistsSecondaryEnable_Default( OSC_MODULE_ID index )
85:                  {
86:                      return true;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  OSC_SecondaryEnable_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_OSC_SecondaryEnable 
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_OSC_SecondaryEnable function.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void OSC_SecondaryEnable_Default( OSC_MODULE_ID index )
101:                 {
102:                     _SFR_BIT_SET(_OSC_SECONDARY_ENABLE_VREG(index),
103:                                      _OSC_SECONDARY_ENABLE_POS(index) );
104:                 }
105:                 
106:                 
107:                 //******************************************************************************
108:                 /* Function :  OSC_SecondaryDisable_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_OSC_SecondaryDisable 
112:                 
113:                   Description:
114:                     This template implements the Default variant of the PLIB_OSC_SecondaryDisable function.
115:                 */
116:                 
117:                 PLIB_TEMPLATE void OSC_SecondaryDisable_Default( OSC_MODULE_ID index )
118:                 {
119:                     _SFR_BIT_CLEAR(_OSC_SECONDARY_ENABLE_VREG(index),
00000024  00000000   NOP
120:                          _OSC_SECONDARY_ENABLE_POS(index) );
121:                 }
122:                 
123:                 
124:                 //******************************************************************************
125:                 /* Function :  OSC_SecondaryIsEnabled_Default
126:                 
127:                   Summary:
128:                     Implements Default variant of PLIB_OSC_SecondaryIsEnabled 
129:                 
130:                   Description:
131:                     This template implements the Default variant of the PLIB_OSC_SecondaryIsEnabled function.
132:                 */
133:                 
134:                 PLIB_TEMPLATE bool OSC_SecondaryIsEnabled_Default( OSC_MODULE_ID index )
135:                 {
136:                    return (_SFR_BIT_READ(_OSC_SECONDARY_ENABLE_VREG(index),
00000000  00000000   NOP
137:                                      _OSC_SECONDARY_ENABLE_POS(index) ));
138:                 }
139:                 
140:                 
141:                 #endif /*_OSC_SECONDARYENABLE_DEFAULT_H*/
142:                 
143:                 /******************************************************************************
144:                  End of File
145:                 */
146:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/osc/templates/osc_pbclockdivisor_pic32_1.h  -----
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_PBClockDivisor_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PBClockDivisor
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsPBClockDivisor
16:                          PLIB_OSC_PBClockDivisorGet
17:                          PLIB_OSC_PBClockDivisorSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_PBCLOCKDIVISOR_PIC32_1_H
48:                  #define _OSC_PBCLOCKDIVISOR_PIC32_1_H
49:                  
50:                  
51:                  // *****************************************************************************
52:                  /* Oscillator Peripheral Bus Clock Divisor Value Type
53:                  
54:                    Summary:
55:                      Type of the oscillator PB Clock divisor value.
56:                  
57:                    Description:
58:                      This macro defines the type of the oscillator PB Clock divisor value.
59:                  
60:                    Remarks:
61:                      None
62:                  */
63:                  
64:                  #define OSC_PB_CLOCK_DIV_TYPE						SFR_TYPE
65:                  
66:                  
67:                  // *****************************************************************************
68:                  /* Oscillator Peripheral Bus count
69:                  
70:                    Summary:
71:                      The number of Peripheral buses in available in the device.
72:                  
73:                    Description:
74:                      This macro gives the number of Peripheral buses in available in the device.
75:                  
76:                    Remarks:
77:                      None
78:                  */
79:                  
80:                  #define PERIPHERAL_BUSES_MAX						1
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
85:                  
86:                    VREGs:
87:                      _OSC_OSC_PB_DIVISOR_VREG(index)
88:                      _OSC_OSC_REGISTER_LOCK_VREG(index)
89:                  
90:                    MASKs:
91:                      _OSC_OSC_PB_DIVISOR_MASK(index)
92:                      _OSC_OSC_REGISTER_LOCK_MASK(index)
93:                  
94:                    POSs:
95:                      _OSC_OSC_PB_DIVISOR_POS(index)
96:                      _OSC_OSC_REGISTER_LOCK_POS(index)
97:                  
98:                    LENs:
99:                      _OSC_OSC_PB_DIVISOR_LEN(index)
100:                     _OSC_OSC_REGISTER_LOCK_LEN(index)
101:                 
102:                 */
103:                 
104:                 
105:                 //******************************************************************************
106:                 /* Function :  OSC_ExistsPBClockDivisor_PIC32_1
107:                 
108:                   Summary:
109:                     Implements PIC32_1 variant of PLIB_OSC_ExistsPBClockDivisor
110:                 
111:                   Description:
112:                     This template implements the PIC32_1 variant of the PLIB_OSC_ExistsPBClockDivisor function.
113:                 */
114:                 
115:                 #define PLIB_OSC_ExistsPBClockDivisor PLIB_OSC_ExistsPBClockDivisor
116:                 PLIB_TEMPLATE bool OSC_ExistsPBClockDivisor_PIC32_1( OSC_MODULE_ID index )
117:                 {
118:                     return true;
119:                 }
120:                 
121:                 
122:                 //******************************************************************************
123:                 /* Function :  OSC_PBClockDivisorGet_PIC32_1
124:                 
125:                   Summary:
126:                     Implements PIC32_1 variant of PLIB_OSC_PBClockDivisorGet
127:                 
128:                   Description:
129:                     This template implements the PIC32_1 variant of the PLIB_OSC_PBClockDivisorGet function.
130:                 */
131:                 
132:                 PLIB_TEMPLATE OSC_PB_CLOCK_DIV_TYPE OSC_PBClockDivisorGet_PIC32_1( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber )
133:                 {
134:                     return (0x01 << _SFR_FIELD_READ(_OSC_OSC_PB_DIVISOR_VREG(index),
135:                                            _OSC_OSC_PB_DIVISOR_MASK(index),
136:                                            _OSC_OSC_PB_DIVISOR_POS(index) ));
137:                 }
138:                 
139:                 
140:                 //******************************************************************************
141:                 /* Function :  OSC_PBClockDivisorSet_PIC32_1
142:                 
143:                   Summary:
144:                     Implements PIC32_1 variant of PLIB_OSC_PBClockDivisorSet
145:                 
146:                   Description:
147:                     This template implements the PIC32_1 variant of the PLIB_OSC_PBClockDivisorSet function.
148:                 */
149:                 
150:                 PLIB_TEMPLATE void OSC_PBClockDivisorSet_PIC32_1( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber , OSC_PB_CLOCK_DIV_TYPE peripheralBusClkDiv )
151:                 {
152:                 	uint8_t regValue;
153:                 
154:                 	for (regValue=0; regValue<4; regValue++)
155:                 	{
156:                 		if ( peripheralBusClkDiv == ( 0x01<<regValue ) )
157:                 		{
158:                 			_SFR_FIELD_WRITE(_OSC_OSC_PB_DIVISOR_VREG(index),
9D00CC04  8C44F000   LW A0, -4096(V0)
9D00CC08  3C03FFE7   LUI V1, -25
9D00CC0C  3463FFFF   ORI V1, V1, -1
9D00CC10  00831824   AND V1, A0, V1
9D00CC14  AC43F000   SW V1, -4096(V0)
159:                 							 _OSC_OSC_PB_DIVISOR_MASK(index),
160:                 							 _OSC_OSC_PB_DIVISOR_POS(index) ,
161:                 								 regValue );
162:                 			return;
163:                 		}
164:                 	}
165:                 	PLIB_ASSERT(false, "Given PB Divisor value is not supported for the selected device");
166:                 }
167:                 
168:                 
169:                 #endif /*_OSC_PBCLOCKDIVISOR_PIC32_1_H*/
170:                 
171:                 /******************************************************************************
172:                  End of File
173:                 */
174:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/osc/templates/osc_onwaitaction_default.h  -------
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_OnWaitAction_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OnWaitAction
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsOnWaitAction
16:                          PLIB_OSC_OnWaitActionSet
17:                          PLIB_OSC_OnWaitActionGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_ONWAITACTION_DEFAULT_H
48:                  #define _OSC_ONWAITACTION_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _OSC_ON_WAIT_ACTION_VREG(index)
55:                      _OSC_OSC_REGISTER_LOCK_VREG(index)
56:                  
57:                    MASKs: 
58:                      _OSC_ON_WAIT_ACTION_MASK(index)
59:                      _OSC_OSC_REGISTER_LOCK_MASK(index)
60:                  
61:                    POSs: 
62:                      _OSC_ON_WAIT_ACTION_POS(index)
63:                      _OSC_OSC_REGISTER_LOCK_POS(index)
64:                  
65:                    LENs: 
66:                      _OSC_ON_WAIT_ACTION_LEN(index)
67:                      _OSC_OSC_REGISTER_LOCK_LEN(index)
68:                  
69:                  */
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  OSC_ExistsOnWaitAction_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_OSC_ExistsOnWaitAction
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_OSC_ExistsOnWaitAction function.
80:                  */
81:                  
82:                  #define PLIB_OSC_ExistsOnWaitAction PLIB_OSC_ExistsOnWaitAction
83:                  PLIB_TEMPLATE bool OSC_ExistsOnWaitAction_Default( OSC_MODULE_ID index )
84:                  {
85:                      return true;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  OSC_OnWaitActionSet_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_OSC_OnWaitActionSet 
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_OSC_OnWaitActionSet function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void OSC_OnWaitActionSet_Default( OSC_MODULE_ID index , OSC_OPERATION_ON_WAIT onWait )
100:                 {
101:                     //_SFR_BIT_SET(_OSC_ON_WAIT_ACTION_VREG(index),
102:                       //                 _OSC_ON_WAIT_ACTION_POS(index));
103:                 
104:                     _SFR_BIT_WRITE(_OSC_ON_WAIT_ACTION_VREG(index),
00000018  00000000   NOP
105:                                        _OSC_ON_WAIT_ACTION_POS(index) ,
106:                                        onWait                      );
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  OSC_OnWaitActionGet_Default
112:                 
113:                   Summary:
114:                     Implements Default variant of PLIB_OSC_OnWaitActionGet 
115:                 
116:                   Description:
117:                     This template implements the Default variant of the PLIB_OSC_OnWaitActionGet function.
118:                 */
119:                 
120:                 PLIB_TEMPLATE OSC_OPERATION_ON_WAIT OSC_OnWaitActionGet_Default( OSC_MODULE_ID index )
121:                 {
122:                     return (OSC_OPERATION_ON_WAIT)(_SFR_BIT_READ(_OSC_ON_WAIT_ACTION_VREG(index),
123:                                        _OSC_ON_WAIT_ACTION_POS(index)));
124:                 }
125:                 
126:                 
127:                 #endif /*_OSC_ONWAITACTION_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/osc/templates/osc_frcdivisor_default.h  ---------
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_FRCDivisor_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FRCDivisor
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsFRCDivisor
16:                          PLIB_OSC_FRCDivisorSelect
17:                          PLIB_OSC_FRCDivisorGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_FRCDIVISOR_DEFAULT_H
48:                  #define _OSC_FRCDIVISOR_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _OSC_OSC_FRC_DIVISOR_VREG(index)
55:                      _OSC_OSC_REGISTER_LOCK_VREG(index)
56:                  
57:                    MASKs: 
58:                      _OSC_OSC_FRC_DIVISOR_MASK(index)
59:                      _OSC_OSC_REGISTER_LOCK_MASK(index)
60:                  
61:                    POSs: 
62:                      _OSC_OSC_FRC_DIVISOR_POS(index)
63:                      _OSC_OSC_REGISTER_LOCK_POS(index)
64:                  
65:                    LENs: 
66:                      _OSC_OSC_FRC_DIVISOR_LEN(index)
67:                      _OSC_OSC_REGISTER_LOCK_LEN(index)
68:                  
69:                  */
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  OSC_ExistsFRCDivisor_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_OSC_ExistsFRCDivisor
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_OSC_ExistsFRCDivisor function.
80:                  */
81:                  
82:                  #define PLIB_OSC_ExistsFRCDivisor PLIB_OSC_ExistsFRCDivisor
83:                  PLIB_TEMPLATE bool OSC_ExistsFRCDivisor_Default( OSC_MODULE_ID index )
84:                  {
85:                      return true;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  OSC_FRCDivisorSelect_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_OSC_FRCDivisorSelect 
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_OSC_FRCDivisorSelect function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void OSC_FRCDivisorSelect_Default( OSC_MODULE_ID index , OSC_FRC_DIV divisorFRC )
100:                 {
101:                     _SFR_FIELD_WRITE(_OSC_OSC_FRC_DIVISOR_VREG(index),
9D00CBE4  3C02BF81   LUI V0, -16511
9D00CBE8  8C44F000   LW A0, -4096(V0)
9D00CBEC  3C03F8FF   LUI V1, -1793
9D00CBF0  3463FFFF   ORI V1, V1, -1
9D00CBF4  00831824   AND V1, A0, V1
9D00CBF8  3C040100   LUI A0, 256
9D00CBFC  00641825   OR V1, V1, A0
9D00CC00  AC43F000   SW V1, -4096(V0)
102:                                      _OSC_OSC_FRC_DIVISOR_MASK(index),
103:                                      _OSC_OSC_FRC_DIVISOR_POS(index) ,
104:                                      divisorFRC );
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  OSC_FRCDivisorGet_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_OSC_FRCDivisorGet
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_OSC_FRCDivisorGet function.
116:                 */
117:                 
118:                 PLIB_TEMPLATE uint16_t OSC_FRCDivisorGet_Default( OSC_MODULE_ID index )
119:                 {
120:                     uint8_t regValue;
121:                 
122:                     regValue = _SFR_FIELD_READ(_OSC_OSC_FRC_DIVISOR_VREG(index),
123:                                            _OSC_OSC_FRC_DIVISOR_MASK(index),
124:                                            _OSC_OSC_FRC_DIVISOR_POS(index) );
125:                     if ( regValue != 7 )
126:                     {
127:                         return ( 0x01 << regValue );
128:                     }
129:                     else
130:                     {
131:                         return 256;
132:                     }
133:                 }
134:                 
135:                 
136:                 #endif /*_OSC_FRCDIVISOR_DEFAULT_H*/
137:                 
138:                 /******************************************************************************
139:                  End of File
140:                 */
141:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/oc/templates/oc_timerselect_mx.h  ---------------
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_TimerSelect_MX.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TimerSelect
13:                      and its Variant : MX
14:                      For following APIs :
15:                          PLIB_OC_TimerSelect
16:                          PLIB_OC_ExistsTimerSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_TIMERSELECT_MX_H
47:                  #define _OC_TIMERSELECT_MX_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _OC_TIMER_SELECT_VREG(index)
54:                  
55:                    MASKs: 
56:                      _OC_TIMER_SELECT_MASK(index)
57:                  
58:                    POSs: 
59:                      _OC_TIMER_SELECT_POS(index)
60:                  
61:                    LENs: 
62:                      _OC_TIMER_SELECT_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OC_TimerSelect_MX
69:                  
70:                    Summary:
71:                      Implements MX variant of PLIB_OC_TimerSelect 
72:                  
73:                    Description:
74:                      This template implements the MX variant of the PLIB_OC_TimerSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OC_TimerSelect_MX( OC_MODULE_ID index , OC_16BIT_TIMERS tmr )
78:                  {
79:                      _SFR_BIT_WRITE(_OC_TIMER_SELECT_VREG(index),_OC_TIMER_SELECT_POS(index),tmr);
9D00C5D4  8C443200   LW A0, 12800(V0)
9D00C5D8  2403FFF7   ADDIU V1, ZERO, -9
9D00C5DC  00831824   AND V1, A0, V1
9D00C5E0  AC433200   SW V1, 12800(V0)
9D00C63C  8C443800   LW A0, 14336(V0)
9D00C640  2403FFF7   ADDIU V1, ZERO, -9
9D00C644  00831824   AND V1, A0, V1
9D00C648  AC433800   SW V1, 14336(V0)
9D00C6A4  8C443400   LW A0, 13312(V0)
9D00C6A8  2403FFF7   ADDIU V1, ZERO, -9
9D00C6AC  00831824   AND V1, A0, V1
9D00C6B0  AC433400   SW V1, 13312(V0)
9D00C70C  8C443600   LW A0, 13824(V0)
9D00C710  2403FFF7   ADDIU V1, ZERO, -9
9D00C714  00831824   AND V1, A0, V1
9D00C718  AC433600   SW V1, 13824(V0)
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OC_ExistsTimerSelect_MX
85:                  
86:                    Summary:
87:                      Implements MX variant of PLIB_OC_ExistsTimerSelect
88:                  
89:                    Description:
90:                      This template implements the MX variant of the PLIB_OC_ExistsTimerSelect function.
91:                  */
92:                  
93:                  #define PLIB_OC_ExistsTimerSelect PLIB_OC_ExistsTimerSelect
94:                  PLIB_TEMPLATE bool OC_ExistsTimerSelect_MX( OC_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_OC_TIMERSELECT_MX_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/oc/templates/oc_pulsewidth_32bit_variant.h  -----
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_PulseWidth_32Bit_Variant.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PulseWidth
13:                      and its Variant : 32Bit_Variant
14:                      For following APIs :
15:                          PLIB_OC_PulseWidth32BitSet
16:                          PLIB_OC_PulseWidth16BitSet
17:                          PLIB_OC_ExistsPulseWidth
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OC_PULSEWIDTH_32BIT_VARIANT_H
48:                  #define _OC_PULSEWIDTH_32BIT_VARIANT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _OC_SEC_CMP_VAL_VREG(index)
55:                  
56:                    MASKs: 
57:                      _OC_SEC_CMP_VAL_MASK(index)
58:                  
59:                    POSs: 
60:                      _OC_SEC_CMP_VAL_POS(index)
61:                  
62:                    LENs: 
63:                      _OC_SEC_CMP_VAL_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OC_PulseWidth32BitSet_32Bit_Variant
70:                  
71:                    Summary:
72:                      Implements 32Bit_Variant variant of PLIB_OC_PulseWidth32BitSet 
73:                  
74:                    Description:
75:                      This template implements the 32Bit_Variant variant of the PLIB_OC_PulseWidth32BitSet function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OC_PulseWidth32BitSet_32Bit_Variant( OC_MODULE_ID index , uint32_t pulseWidth )
79:                  {
80:                      _SFR_WRITE(_OC_SEC_CMP_VAL_VREG(index),pulseWidth);
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OC_PulseWidth16BitSet_32Bit_Variant
86:                  
87:                    Summary:
88:                      Implements 32Bit_Variant variant of PLIB_OC_PulseWidth16BitSet 
89:                  
90:                    Description:
91:                      This template implements the 32Bit_Variant variant of the PLIB_OC_PulseWidth16BitSet function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OC_PulseWidth16BitSet_32Bit_Variant( OC_MODULE_ID index , uint16_t pulseWidth )
95:                  {
96:                      _SFR_WRITE(_OC_SEC_CMP_VAL_VREG(index), (pulseWidth & 0X0000ffff));
9D00C5F0  3C02BF80   LUI V0, -16512
9D00C5F4  2404000F   ADDIU A0, ZERO, 15
9D00C5F8  AC443220   SW A0, 12832(V0)
9D00C658  3C02BF80   LUI V0, -16512
9D00C65C  2404000F   ADDIU A0, ZERO, 15
9D00C660  AC443820   SW A0, 14368(V0)
9D00C6C0  3C02BF80   LUI V0, -16512
9D00C6C4  2404000F   ADDIU A0, ZERO, 15
9D00C6C8  AC443420   SW A0, 13344(V0)
9D00C728  3C02BF80   LUI V0, -16512
9D00C72C  2404000F   ADDIU A0, ZERO, 15
9D00C730  AC443620   SW A0, 13856(V0)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OC_ExistsPulseWidth_32Bit_Variant
102:                 
103:                   Summary:
104:                     Implements 32Bit_Variant variant of PLIB_OC_ExistsPulseWidth
105:                 
106:                   Description:
107:                     This template implements the 32Bit_Variant variant of the PLIB_OC_ExistsPulseWidth function.
108:                 */
109:                 
110:                 #define PLIB_OC_ExistsPulseWidth PLIB_OC_ExistsPulseWidth
111:                 PLIB_TEMPLATE bool OC_ExistsPulseWidth_32Bit_Variant( OC_MODULE_ID index )
112:                 {
113:                     return true;
114:                 }
115:                 
116:                 
117:                 #endif /*_OC_PULSEWIDTH_32BIT_VARIANT_H*/
118:                 
119:                 /******************************************************************************
120:                  End of File
121:                 */
122:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/oc/templates/oc_faultstatus_default.h  ----------
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_FaultStatus_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FaultStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_FaultHasOccurred
16:                          PLIB_OC_ExistsFaultStatus
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_FAULTSTATUS_DEFAULT_H
47:                  #define _OC_FAULTSTATUS_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _OC_FAULT_STATUS_VREG(index)
54:                  
55:                    MASKs: 
56:                      _OC_FAULT_STATUS_MASK(index)
57:                  
58:                    POSs: 
59:                      _OC_FAULT_STATUS_POS(index)
60:                  
61:                    LENs: 
62:                      _OC_FAULT_STATUS_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OC_FaultHasOccurred_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OC_FaultHasOccurred 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OC_FaultHasOccurred function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE bool OC_FaultHasOccurred_Default( OC_MODULE_ID index )
78:                  {
79:                      return (bool)(_SFR_BIT_READ(_OC_FAULT_STATUS_VREG(index),_OC_FAULT_STATUS_POS(index)));
00000000  00000000   NOP
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OC_ExistsFaultStatus_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OC_ExistsFaultStatus
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OC_ExistsFaultStatus function.
91:                  */
92:                  
93:                  #define PLIB_OC_ExistsFaultStatus PLIB_OC_ExistsFaultStatus
94:                  PLIB_TEMPLATE bool OC_ExistsFaultStatus_Default( OC_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_OC_FAULTSTATUS_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/oc/templates/oc_enablecontrol_default.h  --------
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_Enable
16:                          PLIB_OC_Disable
17:                          PLIB_OC_IsEnabled
18:                          PLIB_OC_ExistsEnableControl
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OC_ENABLECONTROL_DEFAULT_H
49:                  #define _OC_ENABLECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
53:                  
54:                    VREGs: 
55:                      _OC_ENABLE_CONTROL_VREG(index)
56:                  
57:                    MASKs: 
58:                      _OC_ENABLE_CONTROL_MASK(index)
59:                  
60:                    POSs: 
61:                      _OC_ENABLE_CONTROL_POS(index)
62:                  
63:                    LENs: 
64:                      _OC_ENABLE_CONTROL_LEN(index)
65:                  
66:                  */
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  OC_Enable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_OC_Enable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_OC_Enable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void OC_Enable_Default( OC_MODULE_ID index )
80:                  {
81:                      _SFR_BIT_SET(_OC_ENABLE_CONTROL_VREG(index), _OC_ENABLE_CONTROL_POS(index));
9D00DB30  34038000   ORI V1, ZERO, -32768
9D00DB60  34038000   ORI V1, ZERO, -32768
9D00DB90  34038000   ORI V1, ZERO, -32768
9D00DBC0  34038000   ORI V1, ZERO, -32768
00000000  00000000   NOP
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  OC_Disable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_OC_Disable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_OC_Disable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void OC_Disable_Default( OC_MODULE_ID index )
96:                  {
97:                      _SFR_BIT_CLEAR(_OC_ENABLE_CONTROL_VREG(index), _OC_ENABLE_CONTROL_POS(index));
9D00DB48  34038000   ORI V1, ZERO, -32768
9D00DB78  34038000   ORI V1, ZERO, -32768
9D00DBA8  34038000   ORI V1, ZERO, -32768
9D00DBD8  34038000   ORI V1, ZERO, -32768
00000000  00000000   NOP
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  OC_IsEnabled_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_OC_IsEnabled 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_OC_IsEnabled function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE bool OC_IsEnabled_Default( OC_MODULE_ID index )
112:                 {
113:                 return ( _SFR_BIT_READ(_OC_ENABLE_CONTROL_VREG(index), _OC_ENABLE_CONTROL_POS(index)));
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  OC_ExistsEnableControl_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_OC_ExistsEnableControl
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_OC_ExistsEnableControl function.
125:                 */
126:                 
127:                 #define PLIB_OC_ExistsEnableControl PLIB_OC_ExistsEnableControl
128:                 PLIB_TEMPLATE bool OC_ExistsEnableControl_Default( OC_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_OC_ENABLECONTROL_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/oc/templates/oc_comparemodeselect_default.h  ----
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_CompareModeSelect_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CompareModeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_ModeSelect
16:                          PLIB_OC_ExistsCompareModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_COMPAREMODESELECT_DEFAULT_H
47:                  #define _OC_COMPAREMODESELECT_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _OC_CMP_MODE_SEL_VREG(index)
54:                  
55:                    MASKs: 
56:                      _OC_CMP_MODE_SEL_MASK(index)
57:                  
58:                    POSs: 
59:                      _OC_CMP_MODE_SEL_POS(index)
60:                  
61:                    LENs: 
62:                      _OC_CMP_MODE_SEL_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OC_ModeSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OC_ModeSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OC_ModeSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OC_ModeSelect_Default( OC_MODULE_ID index , OC_COMPARE_MODES cmpMode )
78:                  {
79:                      _SFR_FIELD_WRITE(_OC_CMP_MODE_SEL_VREG(index),_OC_CMP_MODE_SEL_MASK(index),_OC_CMP_MODE_SEL_POS(index),cmpMode);
9D00C5AC  3C02BF80   LUI V0, -16512
9D00C5B0  8C443200   LW A0, 12800(V0)
9D00C5B4  2403FFF8   ADDIU V1, ZERO, -8
9D00C5B8  00831824   AND V1, A0, V1
9D00C5BC  34630005   ORI V1, V1, 5
9D00C5C0  AC433200   SW V1, 12800(V0)
9D00C614  3C02BF80   LUI V0, -16512
9D00C618  8C443800   LW A0, 14336(V0)
9D00C61C  2403FFF8   ADDIU V1, ZERO, -8
9D00C620  00831824   AND V1, A0, V1
9D00C624  34630005   ORI V1, V1, 5
9D00C628  AC433800   SW V1, 14336(V0)
9D00C67C  3C02BF80   LUI V0, -16512
9D00C680  8C443400   LW A0, 13312(V0)
9D00C684  2403FFF8   ADDIU V1, ZERO, -8
9D00C688  00831824   AND V1, A0, V1
9D00C68C  34630005   ORI V1, V1, 5
9D00C690  AC433400   SW V1, 13312(V0)
9D00C6E4  3C02BF80   LUI V0, -16512
9D00C6E8  8C443600   LW A0, 13824(V0)
9D00C6EC  2403FFF8   ADDIU V1, ZERO, -8
9D00C6F0  00831824   AND V1, A0, V1
9D00C6F4  34630005   ORI V1, V1, 5
9D00C6F8  AC433600   SW V1, 13824(V0)
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OC_ExistsCompareModeSelect_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OC_ExistsCompareModeSelect
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OC_ExistsCompareModeSelect function.
91:                  */
92:                  
93:                  #define PLIB_OC_ExistsCompareModeSelect PLIB_OC_ExistsCompareModeSelect
94:                  PLIB_TEMPLATE bool OC_ExistsCompareModeSelect_Default( OC_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_OC_COMPAREMODESELECT_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/oc/templates/oc_buffervalue_32bit_variant.h  ----
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_BufferValue_32Bit_Variant.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferValue
13:                      and its Variant : 32Bit_Variant
14:                      For following APIs :
15:                          PLIB_OC_Buffer32BitSet
16:                          PLIB_OC_Buffer16BitSet
17:                          PLIB_OC_ExistsBufferValue
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OC_BUFFERVALUE_32BIT_VARIANT_H
48:                  #define _OC_BUFFERVALUE_32BIT_VARIANT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _OC_BUF_VAL_VREG(index)
55:                  
56:                    MASKs: 
57:                      _OC_BUF_VAL_MASK(index)
58:                  
59:                    POSs: 
60:                      _OC_BUF_VAL_POS(index)
61:                  
62:                    LENs: 
63:                      _OC_BUF_VAL_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OC_Buffer32BitSet_32Bit_Variant
70:                  
71:                    Summary:
72:                      Implements 32Bit_Variant variant of PLIB_OC_Buffer32BitSet 
73:                  
74:                    Description:
75:                      This template implements the 32Bit_Variant variant of the PLIB_OC_Buffer32BitSet function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OC_Buffer32BitSet_32Bit_Variant( OC_MODULE_ID index , uint32_t val32Bit )
79:                  {
80:                      _SFR_WRITE( _OC_BUF_VAL_VREG(index), val32Bit);
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OC_Buffer16BitSet_32Bit_Variant
86:                  
87:                    Summary:
88:                      Implements 32Bit_Variant variant of PLIB_OC_Buffer16BitSet 
89:                  
90:                    Description:
91:                      This template implements the 32Bit_Variant variant of the PLIB_OC_Buffer16BitSet function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OC_Buffer16BitSet_32Bit_Variant( OC_MODULE_ID index , uint16_t val16Bit )
95:                  {
96:                      _SFR_WRITE( _OC_BUF_VAL_VREG(index), (val16Bit & 0X0000ffff));
9D00C5E4  3C03BF80   LUI V1, -16512
9D00C5E8  24020BB8   ADDIU V0, ZERO, 3000
9D00C5EC  AC623210   SW V0, 12816(V1)
9D00C64C  3C03BF80   LUI V1, -16512
9D00C650  24020BB8   ADDIU V0, ZERO, 3000
9D00C654  AC623810   SW V0, 14352(V1)
9D00C6B4  3C03BF80   LUI V1, -16512
9D00C6B8  24020BB8   ADDIU V0, ZERO, 3000
9D00C6BC  AC623410   SW V0, 13328(V1)
9D00C71C  3C03BF80   LUI V1, -16512
9D00C720  24020BB8   ADDIU V0, ZERO, 3000
9D00C724  AC623610   SW V0, 13840(V1)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OC_ExistsBufferValue_32Bit_Variant
102:                 
103:                   Summary:
104:                     Implements 32Bit_Variant variant of PLIB_OC_ExistsBufferValue
105:                 
106:                   Description:
107:                     This template implements the 32Bit_Variant variant of the PLIB_OC_ExistsBufferValue function.
108:                 */
109:                 
110:                 #define PLIB_OC_ExistsBufferValue PLIB_OC_ExistsBufferValue
111:                 PLIB_TEMPLATE bool OC_ExistsBufferValue_32Bit_Variant( OC_MODULE_ID index )
112:                 {
113:                     return true;
114:                 }
115:                 
116:                 
117:                 #endif /*_OC_BUFFERVALUE_32BIT_VARIANT_H*/
118:                 
119:                 /******************************************************************************
120:                  End of File
121:                 */
122:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/oc/templates/oc_buffersize_default.h  -----------
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_BufferSize_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_BufferSizeSelect
16:                          PLIB_OC_ExistsBufferSize
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_BUFFERSIZE_DEFAULT_H
47:                  #define _OC_BUFFERSIZE_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _OC_BUF_SIZE_VREG(index)
54:                  
55:                    MASKs: 
56:                      _OC_BUF_SIZE_MASK(index)
57:                  
58:                    POSs: 
59:                      _OC_BUF_SIZE_POS(index)
60:                  
61:                    LENs: 
62:                      _OC_BUF_SIZE_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OC_BufferSizeSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OC_BufferSizeSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OC_BufferSizeSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OC_BufferSizeSelect_Default( OC_MODULE_ID index , OC_BUFFER_SIZE size )
78:                  {
79:                      _SFR_BIT_WRITE(_OC_BUF_SIZE_VREG(index),_OC_BUF_SIZE_POS(index),size);
9D00C5C4  8C443200   LW A0, 12800(V0)
9D00C5C8  2403FFDF   ADDIU V1, ZERO, -33
9D00C5CC  00831824   AND V1, A0, V1
9D00C5D0  AC433200   SW V1, 12800(V0)
9D00C62C  8C443800   LW A0, 14336(V0)
9D00C630  2403FFDF   ADDIU V1, ZERO, -33
9D00C634  00831824   AND V1, A0, V1
9D00C638  AC433800   SW V1, 14336(V0)
9D00C694  8C443400   LW A0, 13312(V0)
9D00C698  2403FFDF   ADDIU V1, ZERO, -33
9D00C69C  00831824   AND V1, A0, V1
9D00C6A0  AC433400   SW V1, 13312(V0)
9D00C6FC  8C443600   LW A0, 13824(V0)
9D00C700  2403FFDF   ADDIU V1, ZERO, -33
9D00C704  00831824   AND V1, A0, V1
9D00C708  AC433600   SW V1, 13824(V0)
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OC_ExistsBufferSize_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OC_ExistsBufferSize
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OC_ExistsBufferSize function.
91:                  */
92:                  
93:                  #define PLIB_OC_ExistsBufferSize PLIB_OC_ExistsBufferSize
94:                  PLIB_TEMPLATE bool OC_ExistsBufferSize_Default( OC_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_OC_BUFFERSIZE_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/int/templates/int_vectorselect_default.h  -------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorSelect
16:                          PLIB_INT_MultiVectorSelect
17:                          PLIB_INT_SingleVectorSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_VECTORSELECT_DEFAULT_H
48:                  #define _INT_VECTORSELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _INT_SINGLE_MULTI_VECTOR_VREG(index)
55:                  
56:                    MASKs: 
57:                      _INT_SINGLE_MULTI_VECTOR_MASK(index)
58:                  
59:                    POSs: 
60:                      _INT_SINGLE_MULTI_VECTOR_POS(index)
61:                  
62:                    LENs: 
63:                      _INT_SINGLE_MULTI_VECTOR_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  INT_ExistsVectorSelect_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_INT_ExistsVectorSelect
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_INT_ExistsVectorSelect function.
76:                  */
77:                  
78:                  #define PLIB_INT_ExistsVectorSelect PLIB_INT_ExistsVectorSelect
79:                  PLIB_TEMPLATE bool INT_ExistsVectorSelect_Default( INT_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  INT_MultiVectorSelect_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_INT_MultiVectorSelect 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_INT_MultiVectorSelect function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void INT_MultiVectorSelect_Default( INT_MODULE_ID index )
96:                  {
97:                      _SFR_BIT_SET(_INT_SINGLE_MULTI_VECTOR_VREG(index),_INT_SINGLE_MULTI_VECTOR_POS(index));
9D00DAB8  24031000   ADDIU V1, ZERO, 4096
9D00DABC  3C02BF88   LUI V0, -16504
9D00DAC0  24421000   ADDIU V0, V0, 4096
9D00DAC4  AC430008   SW V1, 8(V0)
9D00DAC8  03E00008   JR RA
9D00DACC  00000000   NOP
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  INT_SingleVectorSelect_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_INT_SingleVectorSelect 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_INT_SingleVectorSelect function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE void INT_SingleVectorSelect_Default( INT_MODULE_ID index )
112:                 {
113:                     _SFR_BIT_CLEAR(_INT_SINGLE_MULTI_VECTOR_VREG(index),_INT_SINGLE_MULTI_VECTOR_POS(index));
114:                 }
115:                 
116:                 
117:                 #endif /*_INT_VECTORSELECT_DEFAULT_H*/
118:                 
119:                 /******************************************************************************
120:                  End of File
121:                 */
122:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/int/templates/int_vectorpriority_default.h  -----
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorPriority_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorPriority
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorPriority
16:                          PLIB_INT_VectorPrioritySet
17:                          PLIB_INT_VectorPriorityGet
18:                          PLIB_INT_VectorSubPrioritySet
19:                          PLIB_INT_VectorSubPriorityGet
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _INT_VECTORPRIORITY_DEFAULT_H
50:                  #define _INT_VECTORPRIORITY_DEFAULT_H
51:                  
52:                  //******************************************************************************
53:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
54:                  
55:                    VREGs: 
56:                      _INT_INT_PRIORITY_CONTROL_0_VREG(index)
57:                      
58:                  
59:                    MASKs: 
60:                      _INT_INT_PRIORITY_CONTROL_0_MASK(index)
61:                      
62:                  
63:                    POSs: 
64:                      _INT_INT_PRIORITY_CONTROL_0_POS(index)
65:                      
66:                  
67:                    LENs: 
68:                      _INT_INT_PRIORITY_CONTROL_0_LEN(index)
69:                      
70:                  
71:                  */
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  INT_ExistsVectorPriority_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_INT_ExistsVectorPriority
79:                  
80:                    Description:
81:                      This template implements the Default variant of the PLIB_INT_ExistsVectorPriority function.
82:                  */
83:                  
84:                  #define PLIB_INT_ExistsVectorPriority PLIB_INT_ExistsVectorPriority
85:                  PLIB_TEMPLATE bool INT_ExistsVectorPriority_Default( INT_MODULE_ID index )
86:                  {
87:                      return true;
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  INT_VectorPrioritySet_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_INT_VectorPrioritySet 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_INT_VectorPrioritySet function.
99:                  
100:                   Note:
101:                     The algorithm to calculate and write the field location has changed to use
102:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
103:                     names to the actual vector numbers.
104:                 */
105:                 
106:                 PLIB_TEMPLATE void INT_VectorPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_PRIORITY_LEVEL priority )
107:                 {
108:                     SFR_TYPE *reg       = _INT_INT_PRIORITY_CONTROL_0_VREG(index) + ((0x10 * (vector >> 2)) >> 2);
109:                     uint32_t mask       = 0x07 << (((vector & 0x03) * 8) + 2);
110:                     uint32_t position   = (((vector & 0x03) * 8) + 2);
111:                  
112:                     _SFR_FIELD_WRITE(reg, mask, position, priority);
9D00881C  3C02BF88   LUI V0, -16504
9D008820  24421090   ADDIU V0, V0, 4240
9D008824  8C430060   LW V1, 96(V0)
9D008828  2404FFE3   ADDIU A0, ZERO, -29
9D00882C  00641824   AND V1, V1, A0
9D008830  34630004   ORI V1, V1, 4
9D008834  AC430060   SW V1, 96(V0)
9D008848  8C450080   LW A1, 128(V0)
9D00884C  00A42024   AND A0, A1, A0
9D008850  34840004   ORI A0, A0, 4
9D008854  AC440080   SW A0, 128(V0)
9D00B440  3C02BF88   LUI V0, -16504
9D00B444  24421090   ADDIU V0, V0, 4240
9D00B448  8C440030   LW A0, 48(V0)
9D00B44C  2403E3FF   ADDIU V1, ZERO, -7169
9D00B450  00831824   AND V1, A0, V1
9D00B454  34630400   ORI V1, V1, 1024
9D00B458  AC430030   SW V1, 48(V0)
9D00B4D8  3C02BF88   LUI V0, -16504
9D00B4DC  24421090   ADDIU V0, V0, 4240
9D00B4E0  8C440010   LW A0, 16(V0)
9D00B4E4  2403E3FF   ADDIU V1, ZERO, -7169
9D00B4E8  00831824   AND V1, A0, V1
9D00B4EC  34630400   ORI V1, V1, 1024
9D00B4F0  AC430010   SW V1, 16(V0)
9D00B570  3C02BF88   LUI V0, -16504
9D00B574  24421090   ADDIU V0, V0, 4240
9D00B578  8C440040   LW A0, 64(V0)
9D00B57C  2403E3FF   ADDIU V1, ZERO, -7169
9D00B580  00831824   AND V1, A0, V1
9D00B584  34630400   ORI V1, V1, 1024
9D00B588  AC430040   SW V1, 64(V0)
9D00B608  3C02BF88   LUI V0, -16504
9D00B60C  24421090   ADDIU V0, V0, 4240
9D00B610  8C440050   LW A0, 80(V0)
9D00B614  2403E3FF   ADDIU V1, ZERO, -7169
9D00B618  00831824   AND V1, A0, V1
9D00B61C  34630400   ORI V1, V1, 1024
9D00B620  AC430050   SW V1, 80(V0)
9D00C0B0  3C02BF88   LUI V0, -16504
9D00C0B4  24421090   ADDIU V0, V0, 4240
9D00C0B8  8C440020   LW A0, 32(V0)
9D00C0BC  2403FFE3   ADDIU V1, ZERO, -29
9D00C0C0  00831824   AND V1, A0, V1
9D00C0C4  34630004   ORI V1, V1, 4
9D00C0C8  AC430020   SW V1, 32(V0)
113:                     
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  INT_VectorPriorityGet_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_INT_VectorPriorityGet 
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_INT_VectorPriorityGet function.
125:                 
126:                   Note:
127:                     The algorithm to calculate and write the field location has changed to use
128:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
129:                     names to the actual vector numbers.
130:                 */
131:                 
132:                 PLIB_TEMPLATE INT_PRIORITY_LEVEL INT_VectorPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
133:                 {
134:                 
135:                     SFR_TYPE *reg       = _INT_INT_PRIORITY_CONTROL_0_VREG(index) + ((0x10 * (vector >> 2)) >> 2);
136:                     uint32_t mask       = 0x07 << (((vector & 0x03) * 8) + 2);
137:                     uint32_t position   = (((vector & 0x03) * 8) + 2);
138:                     
139:                     return (INT_PRIORITY_LEVEL)_SFR_FIELD_READ(reg, mask, position);
140:                 }
141:                 
142:                 
143:                 //******************************************************************************
144:                 /* Function :  INT_VectorSubPrioritySet_Default
145:                 
146:                   Summary:
147:                     Implements Default variant of PLIB_INT_VectorSubPrioritySet 
148:                 
149:                   Description:
150:                     This template implements the Default variant of the PLIB_INT_VectorSubPrioritySet function.
151:                 
152:                   Note:
153:                     The algorithm to calculate and write the field location has changed to use
154:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
155:                     names to the actual vector numbers.
156:                 */
157:                 
158:                 PLIB_TEMPLATE void INT_VectorSubPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_SUBPRIORITY_LEVEL subPriority )
159:                 {
160:                     SFR_TYPE *reg       = _INT_INT_PRIORITY_CONTROL_0_VREG(index) + ((0x10 * (vector >> 2)) >> 2);
161:                     uint32_t mask       = 0x03 << ((vector & 0x03) * 8);
162:                     uint32_t position   = (vector & 0x03) * 8;
163:                     
164:                     _SFR_FIELD_WRITE(reg, mask, position, subPriority);
9D008838  8C450060   LW A1, 96(V0)
9D00883C  2403FFFC   ADDIU V1, ZERO, -4
9D008840  00A32824   AND A1, A1, V1
9D008844  AC450060   SW A1, 96(V0)
9D008858  8C440080   LW A0, 128(V0)
9D00885C  00831824   AND V1, A0, V1
9D008860  AC430080   SW V1, 128(V0)
9D00B45C  8C440030   LW A0, 48(V0)
9D00B4F4  8C440010   LW A0, 16(V0)
9D00B58C  8C440040   LW A0, 64(V0)
9D00B624  8C440050   LW A0, 80(V0)
9D00C0CC  8C440020   LW A0, 32(V0)
9D00C0D0  2403FFFC   ADDIU V1, ZERO, -4
9D00C0D4  00831824   AND V1, A0, V1
9D00C0D8  AC430020   SW V1, 32(V0)
9D00C0DC  03E00008   JR RA
9D00C0E0  00000000   NOP
165:                 }
166:                 
167:                 
168:                 //******************************************************************************
169:                 /* Function :  INT_VectorSubPriorityGet_Default
170:                 
171:                   Summary:
172:                     Implements Default variant of PLIB_INT_VectorSubPriorityGet 
173:                 
174:                   Description:
175:                     This template implements the Default variant of the PLIB_INT_VectorSubPriorityGet function.
176:                 
177:                   Note:
178:                     The algorithm to calculate and write the field location has changed to use
179:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
180:                     names to the actual vector numbers.
181:                 */
182:                 
183:                 PLIB_TEMPLATE INT_SUBPRIORITY_LEVEL INT_VectorSubPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
184:                 {
185:                     SFR_TYPE *reg       = _INT_INT_PRIORITY_CONTROL_0_VREG(index) + ((0x10 * (vector >> 2)) >> 2);
186:                     uint32_t mask       = 0x03 << ((vector & 0x03) * 8);
187:                     uint32_t position   = (vector & 0x03) * 8;
188:                     
189:                     return (INT_SUBPRIORITY_LEVEL)(_SFR_FIELD_READ(reg, mask, position));
190:                 }
191:                 
192:                 
193:                 #endif /*_INT_VECTORPRIORITY_DEFAULT_H*/
194:                 
195:                 /******************************************************************************
196:                  End of File
197:                 */
198:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/int/templates/int_sourceflag_default.h  ---------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceFlag_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceFlag
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceFlag
16:                          PLIB_INT_SourceFlagGet
17:                          PLIB_INT_SourceFlagSet
18:                          PLIB_INT_SourceFlagClear
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCEFLAG_DEFAULT_H
49:                  #define _INT_SOURCEFLAG_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
53:                  
54:                    VREGs: 
55:                      _INT_INT_FLAG_STATUS_0_VREG(index)
56:                      _INT_INT_FLAG_STATUS_1_VREG(index)
57:                      _INT_INT_FLAG_STATUS_2_VREG(index)
58:                  
59:                    MASKs: 
60:                      _INT_INT_FLAG_STATUS_0_MASK(index)
61:                      _INT_INT_FLAG_STATUS_1_MASK(index)
62:                      _INT_INT_FLAG_STATUS_2_MASK(index)
63:                  
64:                    POSs: 
65:                      _INT_INT_FLAG_STATUS_0_POS(index)
66:                      _INT_INT_FLAG_STATUS_1_POS(index)
67:                      _INT_INT_FLAG_STATUS_2_POS(index)
68:                  
69:                    LENs: 
70:                      _INT_INT_FLAG_STATUS_0_LEN(index)
71:                      _INT_INT_FLAG_STATUS_1_LEN(index)
72:                      _INT_INT_FLAG_STATUS_2_LEN(index)
73:                  
74:                  */
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  INT_ExistsSourceFlag_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_INT_ExistsSourceFlag
82:                  
83:                    Description:
84:                      This template implements the Default variant of the PLIB_INT_ExistsSourceFlag function.
85:                  */
86:                  
87:                  #define PLIB_INT_ExistsSourceFlag PLIB_INT_ExistsSourceFlag
88:                  PLIB_TEMPLATE bool INT_ExistsSourceFlag_Default( INT_MODULE_ID index )
89:                  {
90:                      return true;
91:                  }
92:                  
93:                  
94:                  //******************************************************************************
95:                  /* Function :  INT_SourceFlagGet_Default
96:                  
97:                    Summary:
98:                      Implements Default variant of PLIB_INT_SourceFlagGet 
99:                  
100:                   Description:
101:                     This template implements the Default variant of the PLIB_INT_SourceFlagGet function.
102:                 
103:                   Note:
104:                     The source enum encoding is (x * 32) + y, where x is the register number 
105:                     (IFSx) and y is the bit position. 0b0xxy_yyyy
106:                 */
107:                 
108:                 PLIB_TEMPLATE bool INT_SourceFlagGet_Default( INT_MODULE_ID index , INT_SOURCE source )
109:                 {
110:                     return (1 << (source & 0x1F)) & _SFR_READ(_INT_INT_FLAG_STATUS_0_VREG(index) + ((0x10 * (source >> 5)) >> 2));
9D0064A0  00022942   SRL A1, V0, 5
9D0064A4  00052900   SLL A1, A1, 4
9D0064A8  3C03BF88   LUI V1, -16504
9D0064AC  24631030   ADDIU V1, V1, 4144
9D0064B0  00651821   ADDU V1, V1, A1
9D0064B4  8C630000   LW V1, 0(V1)
9D0064B8  24050001   ADDIU A1, ZERO, 1
9D0064BC  00451004   SLLV V0, A1, V0
9D0064C0  00621024   AND V0, V1, V0
9D00AE5C  00022942   SRL A1, V0, 5
9D00AE60  00052900   SLL A1, A1, 4
9D00AE64  3C03BF88   LUI V1, -16504
9D00AE68  24631030   ADDIU V1, V1, 4144
9D00AE6C  00651821   ADDU V1, V1, A1
9D00AE70  8C630000   LW V1, 0(V1)
9D00AE74  24050001   ADDIU A1, ZERO, 1
9D00AE78  00451004   SLLV V0, A1, V0
9D00AE7C  00621024   AND V0, V1, V0
9D00AF08  00022942   SRL A1, V0, 5
9D00AF0C  00052900   SLL A1, A1, 4
9D00AF10  3C03BF88   LUI V1, -16504
9D00AF14  24631030   ADDIU V1, V1, 4144
9D00AF18  00651821   ADDU V1, V1, A1
9D00AF1C  8C630000   LW V1, 0(V1)
9D00AF20  24050001   ADDIU A1, ZERO, 1
9D00AF24  00451004   SLLV V0, A1, V0
9D00AF28  00621024   AND V0, V1, V0
111:                 }
112:                 
113:                 
114:                 //******************************************************************************
115:                 /* Function :  INT_SourceFlagSet_Default
116:                 
117:                   Summary:
118:                     Implements Default variant of PLIB_INT_SourceFlagSet 
119:                 
120:                   Description:
121:                     This template implements the Default variant of the PLIB_INT_SourceFlagSet function.
122:                 
123:                   Note:
124:                     The source enum encoding is (x * 32) + y, where x is the register number 
125:                     (IFSx) and y is the bit position. 0b0xxy_yyyy
126:                 */
127:                 
128:                 PLIB_TEMPLATE void INT_SourceFlagSet_Default( INT_MODULE_ID index , INT_SOURCE source )
129:                 {
130:                     _SFR_BIT_SET(_INT_INT_FLAG_STATUS_0_VREG(index) + ((0x10 * (source >> 5)) >> 2), source & 0x1F);
131:                 }
132:                 
133:                 
134:                 //******************************************************************************
135:                 /* Function :  INT_SourceFlagClear_Default
136:                 
137:                   Summary:
138:                     Implements Default variant of PLIB_INT_SourceFlagClear 
139:                 
140:                   Description:
141:                     This template implements the Default variant of the PLIB_INT_SourceFlagClear function.
142:                 
143:                   Note:
144:                     The source enum encoding is (x * 32) + y, where x is the register number 
145:                     (IFSx) and y is the bit position. 0b0xxy_yyyy
146:                 */
147:                 
148:                 PLIB_TEMPLATE void INT_SourceFlagClear_Default( INT_MODULE_ID index , INT_SOURCE source )
149:                 {
150:                     _SFR_BIT_CLEAR(_INT_INT_FLAG_STATUS_0_VREG(index) + ((0x10 * (source >> 5)) >> 2), source & 0x1F);
9D0049A8  00032142   SRL A0, V1, 5
9D0049AC  00042100   SLL A0, A0, 4
9D0049B0  24840004   ADDIU A0, A0, 4
9D0049B4  3C02BF88   LUI V0, -16504
9D0049B8  24421030   ADDIU V0, V0, 4144
9D0049BC  00442021   ADDU A0, V0, A0
9D0049C0  24130001   ADDIU S3, ZERO, 1
9D0049C4  00731804   SLLV V1, S3, V1
9D0049C8  AC830000   SW V1, 0(A0)
9D0049D0  00032142   SRL A0, V1, 5
9D0049D4  00042100   SLL A0, A0, 4
9D0049D8  24840004   ADDIU A0, A0, 4
9D0049DC  00442821   ADDU A1, V0, A0
9D0049E0  00731804   SLLV V1, S3, V1
9D0049E4  ACA30000   SW V1, 0(A1)
9D0049EC  00053142   SRL A2, A1, 5
9D0049F0  00063100   SLL A2, A2, 4
9D0049F4  24C60004   ADDIU A2, A2, 4
9D0049F8  00461021   ADDU V0, V0, A2
9D0049FC  00B32804   SLLV A1, S3, A1
9D004A00  AC450000   SW A1, 0(V0)
9D00653C  00022142   SRL A0, V0, 5
9D006540  00042100   SLL A0, A0, 4
9D006544  24840004   ADDIU A0, A0, 4
9D006548  3C03BF88   LUI V1, -16504
9D00654C  24631030   ADDIU V1, V1, 4144
9D006550  00641821   ADDU V1, V1, A0
9D006554  24040001   ADDIU A0, ZERO, 1
9D006558  00441004   SLLV V0, A0, V0
9D00655C  AC620000   SW V0, 0(V1)
9D00ABE8  24030100   ADDIU V1, ZERO, 256
9D00ABEC  3C02BF88   LUI V0, -16504
9D00ABF0  24421030   ADDIU V0, V0, 4144
9D00ABF4  AC430004   SW V1, 4(V0)
9D00AE94  00022142   SRL A0, V0, 5
9D00AE98  00042100   SLL A0, A0, 4
9D00AE9C  24840004   ADDIU A0, A0, 4
9D00AEA0  3C03BF88   LUI V1, -16504
9D00AEA4  24631030   ADDIU V1, V1, 4144
9D00AEA8  00641821   ADDU V1, V1, A0
9D00AEAC  24040001   ADDIU A0, ZERO, 1
9D00AEB0  00441004   SLLV V0, A0, V0
9D00AEB4  AC620000   SW V0, 0(V1)
9D00AF40  00022142   SRL A0, V0, 5
9D00AF44  00042100   SLL A0, A0, 4
9D00AF48  24840004   ADDIU A0, A0, 4
9D00AF4C  3C03BF88   LUI V1, -16504
9D00AF50  24631030   ADDIU V1, V1, 4144
9D00AF54  00641821   ADDU V1, V1, A0
9D00AF58  24040001   ADDIU A0, ZERO, 1
9D00AF5C  00441004   SLLV V0, A0, V0
9D00AF60  AC620000   SW V0, 0(V1)
9D00CC68  24030020   ADDIU V1, ZERO, 32
9D00CC6C  3C02BF88   LUI V0, -16504
9D00CC70  24421030   ADDIU V0, V0, 4144
9D00CC74  AC430004   SW V1, 4(V0)
9D00CE0C  24032000   ADDIU V1, ZERO, 8192
9D00CE10  3C02BF88   LUI V0, -16504
9D00CE14  24421030   ADDIU V0, V0, 4144
9D00CE18  AC430004   SW V1, 4(V0)
9D00D0B4  3C030002   LUI V1, 2
9D00D0B8  3C02BF88   LUI V0, -16504
9D00D0BC  24421030   ADDIU V0, V0, 4144
9D00D0C0  AC430004   SW V1, 4(V0)
9D00D0FC  3C030020   LUI V1, 32
9D00D100  3C02BF88   LUI V0, -16504
9D00D104  24421030   ADDIU V0, V0, 4144
9D00D108  AC430004   SW V1, 4(V0)
9D00D4B0  24020100   ADDIU V0, ZERO, 256
9D00D4B4  3C03BF88   LUI V1, -16504
9D00D4B8  24631030   ADDIU V1, V1, 4144
9D00D4BC  AC620004   SW V0, 4(V1)
00000028  00000000   NOP
00000080  00000000   NOP
151:                 }
152:                 
153:                 
154:                 #endif /*_INT_SOURCEFLAG_DEFAULT_H*/
155:                 
156:                 /******************************************************************************
157:                  End of File
158:                 */
159:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/int/templates/int_sourcecontrol_default.h  ------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceControl_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceControl
16:                          PLIB_INT_SourceEnable
17:                          PLIB_INT_SourceDisable
18:                          PLIB_INT_SourceIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCECONTROL_DEFAULT_H
49:                  #define _INT_SOURCECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
53:                  
54:                    VREGs: 
55:                      _INT_INT_ENABLE_CONTROL_0_VREG(index)
56:                      _INT_INT_ENABLE_CONTROL_1_VREG(index)
57:                      _INT_INT_ENABLE_CONTROL_2_VREG(index)
58:                  
59:                    MASKs: 
60:                      _INT_INT_ENABLE_CONTROL_0_MASK(index)
61:                      _INT_INT_ENABLE_CONTROL_1_MASK(index)
62:                      _INT_INT_ENABLE_CONTROL_2_MASK(index)
63:                  
64:                    POSs: 
65:                      _INT_INT_ENABLE_CONTROL_0_POS(index)
66:                      _INT_INT_ENABLE_CONTROL_1_POS(index)
67:                      _INT_INT_ENABLE_CONTROL_2_POS(index)
68:                  
69:                    LENs: 
70:                      _INT_INT_ENABLE_CONTROL_0_LEN(index)
71:                      _INT_INT_ENABLE_CONTROL_1_LEN(index)
72:                      _INT_INT_ENABLE_CONTROL_2_LEN(index)
73:                  
74:                  */
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  INT_ExistsSourceControl_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_INT_ExistsSourceControl
82:                  
83:                    Description:
84:                      This template implements the Default variant of the PLIB_INT_ExistsSourceControl function.
85:                  */
86:                  
87:                  #define PLIB_INT_ExistsSourceControl PLIB_INT_ExistsSourceControl
88:                  PLIB_TEMPLATE bool INT_ExistsSourceControl_Default( INT_MODULE_ID index )
89:                  {
90:                      return true;
91:                  }
92:                  
93:                  
94:                  //******************************************************************************
95:                  /* Function :  INT_SourceEnable_Default
96:                  
97:                    Summary:
98:                      Implements Default variant of PLIB_INT_SourceEnable 
99:                  
100:                   Description:
101:                     This template implements the Default variant of the PLIB_INT_SourceEnable function.
102:                 
103:                   Note:
104:                     The source enum encoding is (x * 32) + y, where x is the register number 
105:                     (IECx) and y is the bit position. 0b0xxy_yyyy
106:                 */
107:                 
108:                 PLIB_TEMPLATE void INT_SourceEnable_Default( INT_MODULE_ID index , INT_SOURCE source )
109:                 {
110:                     _SFR_BIT_SET(_INT_INT_ENABLE_CONTROL_0_VREG(index) + ((0x10 * (source >> 5)) >> 2), source & 0x1F);
9D004A04  24C60004   ADDIU A2, A2, 4
9D004A08  3C02BF88   LUI V0, -16504
9D004A0C  24421060   ADDIU V0, V0, 4192
9D004A10  00463021   ADDU A2, V0, A2
9D004A14  ACC50000   SW A1, 0(A2)
9D004A18  24840004   ADDIU A0, A0, 4
9D004A1C  00441021   ADDU V0, V0, A0
9D004A20  AC430000   SW V1, 0(V0)
9D008950  00022142   SRL A0, V0, 5
9D008954  00042100   SLL A0, A0, 4
9D008958  24840008   ADDIU A0, A0, 8
9D00895C  3C03BF88   LUI V1, -16504
9D008960  24631060   ADDIU V1, V1, 4192
9D008964  00641821   ADDU V1, V1, A0
9D008968  24040001   ADDIU A0, ZERO, 1
9D00896C  00441004   SLLV V0, A0, V0
9D008970  AC620000   SW V0, 0(V1)
9D00B430  24032000   ADDIU V1, ZERO, 8192
9D00B434  3C02BF88   LUI V0, -16504
9D00B438  24421060   ADDIU V0, V0, 4192
9D00B43C  AC430008   SW V1, 8(V0)
9D00B4C8  24030020   ADDIU V1, ZERO, 32
9D00B4CC  3C02BF88   LUI V0, -16504
9D00B4D0  24421060   ADDIU V0, V0, 4192
9D00B4D4  AC430008   SW V1, 8(V0)
9D00B560  3C030002   LUI V1, 2
9D00B564  3C02BF88   LUI V0, -16504
9D00B568  24421060   ADDIU V0, V0, 4192
9D00B56C  AC430008   SW V1, 8(V0)
9D00B5F8  3C030020   LUI V1, 32
9D00B5FC  3C02BF88   LUI V0, -16504
9D00B600  24421060   ADDIU V0, V0, 4192
9D00B604  AC430008   SW V1, 8(V0)
9D00D4C0  3C03BF88   LUI V1, -16504
0000008C  00000000   NOP
000000FC  00000000   NOP
000001E0  00000000   NOP
111:                 }
112:                 
113:                 
114:                 //******************************************************************************
115:                 /* Function :  INT_SourceDisable_Default
116:                 
117:                   Summary:
118:                     Implements Default variant of PLIB_INT_SourceDisable 
119:                 
120:                   Description:
121:                     This template implements the Default variant of the PLIB_INT_SourceDisable function.
122:                 
123:                   Note:
124:                     The source enum encoding is (x * 32) + y, where x is the register number 
125:                     (IECx) and y is the bit position. 0b0xxy_yyyy
126:                 */
127:                 
128:                 PLIB_TEMPLATE void INT_SourceDisable_Default( INT_MODULE_ID index , INT_SOURCE source )
129:                 {
130:                     _SFR_BIT_CLEAR(_INT_INT_ENABLE_CONTROL_0_VREG(index) + ((0x10 * (source >> 5)) >> 2), source & 0x1F);
9D00CBAC  24840004   ADDIU A0, A0, 4
9D00CBB0  00641821   ADDU V1, V1, A0
9D00CBB4  AC620000   SW V0, 0(V1)
0000000C  00000000   NOP
131:                 }
132:                 
133:                 
134:                 //******************************************************************************
135:                 /* Function :  INT_SourceIsEnabled_Default
136:                 
137:                   Summary:
138:                     Implements Default variant of PLIB_INT_SourceIsEnabled 
139:                 
140:                   Description:
141:                     This template implements the Default variant of the PLIB_INT_SourceIsEnabled function.
142:                 
143:                   Note:
144:                     The source enum encoding is (x * 32) + y, where x is the register number 
145:                     (IECx) and y is the bit position. 0b0xxy_yyyy
146:                 */
147:                 
148:                 PLIB_TEMPLATE bool INT_SourceIsEnabled_Default( INT_MODULE_ID index , INT_SOURCE source )
149:                 {
150:                     return (1 << (source & 0x1F)) & _SFR_READ(_INT_INT_ENABLE_CONTROL_0_VREG(index) + ((0x10 * (source >> 5)) >> 2));
9D00BD9C  00022942   SRL A1, V0, 5
9D00BDA0  00052900   SLL A1, A1, 4
9D00BDA4  3C03BF88   LUI V1, -16504
9D00BDA8  24631060   ADDIU V1, V1, 4192
9D00BDAC  00651821   ADDU V1, V1, A1
9D00BDB0  8C630000   LW V1, 0(V1)
9D00BDB4  24050001   ADDIU A1, ZERO, 1
9D00BDB8  00451004   SLLV V0, A1, V0
9D00BDBC  00621024   AND V0, V1, V0
9D00C1F0  00023142   SRL A2, V0, 5
9D00C1F4  00063100   SLL A2, A2, 4
9D00C1F8  3C05BF88   LUI A1, -16504
9D00C1FC  24A51060   ADDIU A1, A1, 4192
9D00C200  00A62821   ADDU A1, A1, A2
9D00C204  8CA50000   LW A1, 0(A1)
9D00C208  24060001   ADDIU A2, ZERO, 1
9D00C20C  00461004   SLLV V0, A2, V0
9D00C210  00A21024   AND V0, A1, V0
9D00C264  00023142   SRL A2, V0, 5
9D00C268  00063100   SLL A2, A2, 4
9D00C26C  3C05BF88   LUI A1, -16504
9D00C270  24A51060   ADDIU A1, A1, 4192
9D00C274  00A62821   ADDU A1, A1, A2
9D00C278  8CA50000   LW A1, 0(A1)
9D00C27C  24060001   ADDIU A2, ZERO, 1
9D00C280  00461004   SLLV V0, A2, V0
9D00C284  00A21024   AND V0, A1, V0
9D00CB8C  24020001   ADDIU V0, ZERO, 1
9D00CB90  00821004   SLLV V0, V0, A0
9D00CB94  00042142   SRL A0, A0, 5
9D00CB98  00042100   SLL A0, A0, 4
9D00CB9C  3C03BF88   LUI V1, -16504
9D00CBA0  24631060   ADDIU V1, V1, 4192
9D00CBA4  00642821   ADDU A1, V1, A0
9D00CBA8  8CA50000   LW A1, 0(A1)
9D00CBC0  00A21024   AND V0, A1, V0
9D00CBC4  0002102B   SLTU V0, ZERO, V0
9D00CBC8  8FBF0004   LW RA, 4(SP)
9D00CBCC  03E00008   JR RA
9D00CBD0  27BD0008   ADDIU SP, SP, 8
151:                 }
152:                 
153:                 
154:                 #endif /*_INT_SOURCECONTROL_DEFAULT_H*/
155:                 
156:                 /******************************************************************************
157:                  End of File
158:                 */
159:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/int/templates/int_externalintedgeselect_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_ExternalINTEdgeSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ExternalINTEdgeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsExternalINTEdgeSelect
16:                          PLIB_INT_ExternalRisingEdgeSelect
17:                          PLIB_INT_ExternalFallingEdgeSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_EXTERNALINTEDGESELECT_DEFAULT_H
48:                  #define _INT_EXTERNALINTEDGESELECT_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  _INT_EXTERNAL_INT_TRIGGER_MASK(index)
53:                  
54:                    Summary:
55:                      Macro defines the mask for external interrupt edge trigger mask.
56:                  
57:                    Description:
58:                      Macro defines the mask for external interrupt edge trigger mask.
59:                  */
60:                  
61:                  #define _INT_EXTERNAL_INT_TRIGGER_MASK(index) 		0x0000001F
62:                  
63:                  
64:                  //******************************************************************************
65:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
66:                  
67:                    VREGs:
68:                      _INT_INT_EXT_INT0_VREG(index)
69:                  
70:                    MASKs:
71:                      _INT_INT_EXT_INT0_MASK(index)
72:                  
73:                    POSs:
74:                      _INT_INT_EXT_INT0_POS(index)
75:                  
76:                    LENs:
77:                      _INT_INT_EXT_INT0_LEN(index)
78:                  
79:                  */
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  INT_ExistsExternalINTEdgeSelect_Default
84:                  
85:                    Summary:
86:                      Implements Default variant of PLIB_INT_ExistsExternalINTEdgeSelect
87:                  
88:                    Description:
89:                      This template implements the Default variant of the PLIB_INT_ExistsExternalINTEdgeSelect function.
90:                  */
91:                  
92:                  #define PLIB_INT_ExistsExternalINTEdgeSelect PLIB_INT_ExistsExternalINTEdgeSelect
93:                  PLIB_TEMPLATE bool INT_ExistsExternalINTEdgeSelect_Default( INT_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  //******************************************************************************
100:                 /* Function :  INT_ExternalRisingEdgeSelect_Default
101:                 
102:                   Summary:
103:                     Implements Default variant of PLIB_INT_ExternalRisingEdgeSelect
104:                 
105:                   Description:
106:                     This template implements the Default variant of the PLIB_INT_ExternalRisingEdgeSelect function.
107:                 */
108:                 
109:                 PLIB_TEMPLATE void INT_ExternalRisingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
110:                 {
111:                     _SFR_FIELD_SET(_INT_INT_EXT_INT0_VREG(index), _INT_EXTERNAL_INT_TRIGGER_MASK(index),
0000000C  00000000   NOP
112:                 	                       _INT_INT_EXT_INT0_POS(index) , source );
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  INT_ExternalFallingEdgeSelect_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_INT_ExternalFallingEdgeSelect
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_INT_ExternalFallingEdgeSelect function.
124:                 */
125:                 
126:                 PLIB_TEMPLATE void INT_ExternalFallingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
127:                 {
128:                     _SFR_FIELD_CLEAR(_INT_INT_EXT_INT0_VREG(index), _INT_EXTERNAL_INT_TRIGGER_MASK(index),
00000020  00000000   NOP
129:                     	                       _INT_INT_EXT_INT0_POS(index) , source );
130:                 }
131:                 
132:                 
133:                 #endif /*_INT_EXTERNALINTEDGESELECT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/int/templates/int_enablecontrol_pic32.h  --------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_EnableControl_PIC32.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_INT_ExistsEnableControl
16:                          PLIB_INT_Enable
17:                          PLIB_INT_Disable
18:                          PLIB_INT_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_ENABLECONTROL_PIC32_H
49:                  #define _INT_ENABLECONTROL_PIC32_H
50:                  
51:                  #include "peripheral/int/plib_int_private_pic32.h"
52:                  
53:                  //******************************************************************************
54:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
55:                  
56:                    VREGs: 
57:                  
58:                    MASKs: 
59:                  
60:                    POSs: 
61:                  
62:                    LENs: 
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  INT_ExistsEnableControl_PIC32
69:                  
70:                    Summary:
71:                      Implements PIC32 variant of PLIB_INT_ExistsEnableControl
72:                  
73:                    Description:
74:                      This template implements the PIC32 variant of the PLIB_INT_ExistsEnableControl function.
75:                  */
76:                  
77:                  #define PLIB_INT_ExistsEnableControl PLIB_INT_ExistsEnableControl
78:                  PLIB_TEMPLATE bool INT_ExistsEnableControl_PIC32( INT_MODULE_ID index )
79:                  {
80:                      return true;
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  INT_Enable_PIC32
86:                  
87:                    Summary:
88:                      Implements PIC32 variant of PLIB_INT_Enable 
89:                  
90:                    Description:
91:                      This template implements the PIC32 variant of the PLIB_INT_Enable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_Enable_PIC32( INT_MODULE_ID index )
95:                  {
96:                      //PLIB_INT_Enable_pic32();
97:                      //__builtin_enable_interrupts();
98:                      //nop();
99:                      __builtin_mtc0(12,0,(__builtin_mfc0(12,0) | 0x0001));
9D00A230  40026000   MFC0 V0, Status
9D00A234  34420001   ORI V0, V0, 1
9D00A238  40826000   MTC0 V0, Status
9D00A23C  000000C0   EHB
9D00A278  40026000   MFC0 V0, Status
9D00A27C  34420001   ORI V0, V0, 1
9D00A280  40826000   MTC0 V0, Status
9D00A284  000000C0   EHB
9D00CB60  40026000   MFC0 V0, Status
9D00CB64  34420001   ORI V0, V0, 1
9D00CB68  40826000   MTC0 V0, Status
9D00CB6C  000000C0   EHB
9D00D06C  40026000   MFC0 V0, Status
9D00D070  34420001   ORI V0, V0, 1
9D00D074  40826000   MTC0 V0, Status
9D00D078  000000C0   EHB
100:                     
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  INT_Disable_PIC32
106:                 
107:                   Summary:
108:                     Implements PIC32 variant of PLIB_INT_Disable 
109:                 
110:                   Description:
111:                     This template implements the PIC32 variant of the PLIB_INT_Disable function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE __attribute__((nomips16,always_inline))void INT_Disable_PIC32( INT_MODULE_ID index )
115:                 {
116:                     //PLIB_INT_Disable_pic32( );
117:                     __builtin_disable_interrupts();
118:                 }
119:                 
120:                 //******************************************************************************
121:                 /* Function :  PLIB_INT_SetState_PIC32
122:                 
123:                   Summary:
124:                     Implements PIC32 variant of PLIB_INT_Enable 
125:                 
126:                   Description:
127:                     This template implements the PIC32 variant of the PLIB_INT_Enable function.
128:                 */
129:                 
130:                 PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_SetState_PIC32( INT_MODULE_ID index, INT_STATE_GLOBAL interrupt_state )
131:                 {
132:                     //PLIB_INT_SetState_pic32(interrupt_state);
133:                     __builtin_mtc0(12,0,interrupt_state);
9D00CBB8  40866000   MTC0 A2, Status
9D00CBBC  000000C0   EHB
00000008  00000000   NOP
134:                 }
135:                 
136:                 
137:                 //******************************************************************************
138:                 /* Function :  PLIB_INT_GetStateAndDisable_PIC32
139:                 
140:                   Summary:
141:                     Implements PIC32 variant of PLIB_INT_Disable 
142:                 
143:                   Description:
144:                     This template implements the PIC32 variant of the PLIB_INT_Disable function.
145:                 */
146:                 
147:                 INT_STATE_GLOBAL PLIB_TEMPLATE __attribute__((nomips16,always_inline)) INT_GetStateAndDisable_PIC32( INT_MODULE_ID index )
148:                 {
149:                     //PLIB_INT_GetStateAndDisable_pic32(interrupt_state);    
150:                     return (INT_STATE_GLOBAL)(__builtin_disable_interrupts());
9D00A204  41646000   DI A0
9D00A208  000000C0   EHB
9D00A240  41636000   DI V1
9D00A244  000000C0   EHB
9D00CB2C  41636000   DI V1
9D00CB30  000000C0   EHB
9D00CB84  41666000   DI A2
9D00CB88  000000C0   EHB
9D00D048  41626000   DI V0
9D00D04C  000000C0   EHB
00000008  00000000   NOP
151:                 }
152:                 
153:                 //******************************************************************************
154:                 /* Function :  INT_IsEnabled_PIC32
155:                 
156:                   Summary:
157:                     Implements PIC32 variant of PLIB_INT_IsEnabled 
158:                 
159:                   Description:
160:                     This template implements the PIC32 variant of the PLIB_INT_IsEnabled function.
161:                 */
162:                 
163:                 PLIB_TEMPLATE bool __attribute__((nomips16,always_inline)) INT_IsEnabled_PIC32( INT_MODULE_ID index )
164:                 {
165:                     return((_CP0_GET_STATUS() & (0x0001)));
166:                 }
167:                 
168:                 
169:                 #endif /*_INT_ENABLECONTROL_PIC32_H*/
170:                 
171:                 /******************************************************************************
172:                  End of File
173:                 */
174:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ic/templates/ic_timerselect_mx.h  ---------------
1:                   /*******************************************************************************
2:                     IC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ic_TimerSelect_MX.h
6:                   
7:                     Summary:
8:                       IC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TimerSelect
13:                      and its Variant : MX
14:                      For following APIs :
15:                          PLIB_IC_TimerSelect
16:                          PLIB_IC_ExistsTimerSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _IC_TIMERSELECT_MX_H
47:                  #define _IC_TIMERSELECT_MX_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _IC_TIMER_SELECT_VREG(index)
54:                  
55:                    MASKs: 
56:                      _IC_TIMER_SELECT_MASK(index)
57:                  
58:                    POSs: 
59:                      _IC_TIMER_SELECT_POS(index)
60:                  
61:                    LENs: 
62:                      _IC_TIMER_SELECT_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  IC_TimerSelect_MX
69:                  
70:                    Summary:
71:                      Implements MX variant of PLIB_IC_TimerSelect 
72:                  
73:                    Description:
74:                      This template implements the MX variant of the PLIB_IC_TimerSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void IC_TimerSelect_MX( IC_MODULE_ID index , IC_TIMERS tmr )
78:                  {
79:                      _SFR_BIT_WRITE(_IC_TIMER_SELECT_VREG(index),
9D00B400  8C432400   LW V1, 9216(V0)
9D00B404  34630080   ORI V1, V1, 128
9D00B408  AC432400   SW V1, 9216(V0)
9D00B498  8C432000   LW V1, 8192(V0)
9D00B49C  34630080   ORI V1, V1, 128
9D00B4A0  AC432000   SW V1, 8192(V0)
9D00B530  8C432600   LW V1, 9728(V0)
9D00B534  34630080   ORI V1, V1, 128
9D00B538  AC432600   SW V1, 9728(V0)
9D00B5C8  8C432800   LW V1, 10240(V0)
9D00B5CC  34630080   ORI V1, V1, 128
9D00B5D0  AC432800   SW V1, 10240(V0)
80:                  				_IC_TIMER_SELECT_POS(index), tmr);
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  IC_ExistsTimerSelect_MX
86:                  
87:                    Summary:
88:                      Implements MX variant of PLIB_IC_ExistsTimerSelect
89:                  
90:                    Description:
91:                      This template implements the MX variant of the PLIB_IC_ExistsTimerSelect function.
92:                  */
93:                  
94:                  #define PLIB_IC_ExistsTimerSelect PLIB_IC_ExistsTimerSelect
95:                  PLIB_TEMPLATE bool IC_ExistsTimerSelect_MX( IC_MODULE_ID index )
96:                  {
97:                      return true;
98:                  }
99:                  
100:                 
101:                 #endif /*_IC_TIMERSELECT_MX_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ic/templates/ic_eventsperinterruptselect_default.h
1:                   /*******************************************************************************
2:                     IC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ic_EventsPerInterruptSelect_Default.h
6:                   
7:                     Summary:
8:                       IC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EventsPerInterruptSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_IC_EventsPerInterruptSelect
16:                          PLIB_IC_ExistsEventsPerInterruptSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _IC_EVENTSPERINTERRUPTSELECT_DEFAULT_H
47:                  #define _IC_EVENTSPERINTERRUPTSELECT_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _IC_EVENTS_PER_INTERRUPT_VREG(index)
54:                  
55:                    MASKs: 
56:                      _IC_EVENTS_PER_INTERRUPT_MASK(index)
57:                  
58:                    POSs: 
59:                      _IC_EVENTS_PER_INTERRUPT_POS(index)
60:                  
61:                    LENs: 
62:                      _IC_EVENTS_PER_INTERRUPT_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  IC_EventsPerInterruptSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_IC_EventsPerInterruptSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_IC_EventsPerInterruptSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void IC_EventsPerInterruptSelect_Default( IC_MODULE_ID index , IC_EVENTS_PER_INTERRUPT event )
78:                  {
79:                      _SFR_FIELD_WRITE(_IC_EVENTS_PER_INTERRUPT_VREG(index),_IC_EVENTS_PER_INTERRUPT_MASK(index),
9D00B41C  8C442400   LW A0, 9216(V0)
9D00B420  2403FF9F   ADDIU V1, ZERO, -97
9D00B424  00831824   AND V1, A0, V1
9D00B428  34630020   ORI V1, V1, 32
9D00B42C  AC432400   SW V1, 9216(V0)
9D00B4B4  8C442000   LW A0, 8192(V0)
9D00B4B8  2403FF9F   ADDIU V1, ZERO, -97
9D00B4BC  00831824   AND V1, A0, V1
9D00B4C0  34630020   ORI V1, V1, 32
9D00B4C4  AC432000   SW V1, 8192(V0)
9D00B54C  8C442600   LW A0, 9728(V0)
9D00B550  2403FF9F   ADDIU V1, ZERO, -97
9D00B554  00831824   AND V1, A0, V1
9D00B558  34630020   ORI V1, V1, 32
9D00B55C  AC432600   SW V1, 9728(V0)
9D00B5E4  8C442800   LW A0, 10240(V0)
9D00B5E8  2403FF9F   ADDIU V1, ZERO, -97
9D00B5EC  00831824   AND V1, A0, V1
9D00B5F0  34630020   ORI V1, V1, 32
9D00B5F4  AC432800   SW V1, 10240(V0)
80:                  					_IC_EVENTS_PER_INTERRUPT_POS(index), event);
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  IC_ExistsEventsPerInterruptSelect_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_IC_ExistsEventsPerInterruptSelect
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_IC_ExistsEventsPerInterruptSelect function.
92:                  */
93:                  
94:                  #define PLIB_IC_ExistsEventsPerInterruptSelect PLIB_IC_ExistsEventsPerInterruptSelect
95:                  PLIB_TEMPLATE bool IC_ExistsEventsPerInterruptSelect_Default( IC_MODULE_ID index )
96:                  {
97:                      return true;
98:                  }
99:                  
100:                 
101:                 #endif /*_IC_EVENTSPERINTERRUPTSELECT_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ic/templates/ic_enablecontrol_default.h  --------
1:                   /*******************************************************************************
2:                     IC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ic_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       IC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_IC_Enable
16:                          PLIB_IC_Disable
17:                          PLIB_IC_ExistsEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _IC_ENABLECONTROL_DEFAULT_H
48:                  #define _IC_ENABLECONTROL_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _IC_ENABLE_CONTROL_VREG(index)
55:                  
56:                    MASKs: 
57:                      _IC_ENABLE_CONTROL_MASK(index)
58:                  
59:                    POSs: 
60:                      _IC_ENABLE_CONTROL_POS(index)
61:                  
62:                    LENs: 
63:                      _IC_ENABLE_CONTROL_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  IC_Enable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_IC_Enable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_IC_Enable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void IC_Enable_Default( IC_MODULE_ID index )
79:                  {
80:                      _SFR_BIT_SET(_IC_ENABLE_CONTROL_VREG(index),
9D00DAD0  34038000   ORI V1, ZERO, -32768
9D00DAE8  34038000   ORI V1, ZERO, -32768
9D00DB00  34038000   ORI V1, ZERO, -32768
9D00DB18  34038000   ORI V1, ZERO, -32768
81:                  				_IC_ENABLE_CONTROL_POS(index));
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  IC_Disable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_IC_Disable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_IC_Disable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void IC_Disable_Default( IC_MODULE_ID index )
96:                  {
97:                      _SFR_BIT_CLEAR(_IC_ENABLE_CONTROL_VREG(index),
00000000  00000000   NOP
98:                  				_IC_ENABLE_CONTROL_POS(index));
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  IC_ExistsEnable_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_IC_ExistsEnable
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_IC_ExistsEnable function.
110:                 */
111:                 
112:                 #define PLIB_IC_ExistsEnable PLIB_IC_ExistsEnable
113:                 PLIB_TEMPLATE bool IC_ExistsEnable_Default( IC_MODULE_ID index )
114:                 {
115:                     return true;
116:                 }
117:                 
118:                 
119:                 #endif /*_IC_ENABLECONTROL_DEFAULT_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ic/templates/ic_edgecapture_default.h  ----------
1:                   /*******************************************************************************
2:                     IC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ic_EdgeCapture_Default.h
6:                   
7:                     Summary:
8:                       IC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EdgeCapture
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_IC_FirstCaptureEdgeSelect
16:                          PLIB_IC_ExistsEdgeCapture
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _IC_EDGECAPTURE_DEFAULT_H
47:                  #define _IC_EDGECAPTURE_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _IC_EDGE_CAPTURE_VREG(index)
54:                  
55:                    MASKs: 
56:                      _IC_EDGE_CAPTURE_MASK(index)
57:                  
58:                    POSs: 
59:                      _IC_EDGE_CAPTURE_POS(index)
60:                  
61:                    LENs: 
62:                      _IC_EDGE_CAPTURE_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  IC_FirstCaptureEdgeSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_IC_FirstCaptureEdgeSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_IC_FirstCaptureEdgeSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void IC_FirstCaptureEdgeSelect_Default( IC_MODULE_ID index , IC_EDGE_TYPES edgeType )
78:                  {
79:                      _SFR_BIT_WRITE(_IC_EDGE_CAPTURE_VREG(index),_IC_EDGE_CAPTURE_POS(index),edgeType);
9D00B3F4  8C432400   LW V1, 9216(V0)
9D00B3F8  34630200   ORI V1, V1, 512
9D00B3FC  AC432400   SW V1, 9216(V0)
9D00B48C  8C432000   LW V1, 8192(V0)
9D00B490  34630200   ORI V1, V1, 512
9D00B494  AC432000   SW V1, 8192(V0)
9D00B524  8C432600   LW V1, 9728(V0)
9D00B528  34630200   ORI V1, V1, 512
9D00B52C  AC432600   SW V1, 9728(V0)
9D00B5BC  8C432800   LW V1, 10240(V0)
9D00B5C0  34630200   ORI V1, V1, 512
9D00B5C4  AC432800   SW V1, 10240(V0)
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  IC_ExistsEdgeCapture_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_IC_ExistsEdgeCapture
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_IC_ExistsEdgeCapture function.
91:                  */
92:                  
93:                  #define PLIB_IC_ExistsEdgeCapture PLIB_IC_ExistsEdgeCapture
94:                  PLIB_TEMPLATE bool IC_ExistsEdgeCapture_Default( IC_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_IC_EDGECAPTURE_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ic/templates/ic_capturemode_default.h  ----------
1:                   /*******************************************************************************
2:                     IC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ic_CaptureMode_Default.h
6:                   
7:                     Summary:
8:                       IC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CaptureMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_IC_ModeSelect
16:                          PLIB_IC_ExistsCaptureMode
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _IC_CAPTUREMODE_DEFAULT_H
47:                  #define _IC_CAPTUREMODE_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _IC_CAPTURE_MODE_SELECT_VREG(index)
54:                  
55:                    MASKs: 
56:                      _IC_CAPTURE_MODE_SELECT_MASK(index)
57:                  
58:                    POSs: 
59:                      _IC_CAPTURE_MODE_SELECT_POS(index)
60:                  
61:                    LENs: 
62:                      _IC_CAPTURE_MODE_SELECT_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  IC_ModeSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_IC_ModeSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_IC_ModeSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void IC_ModeSelect_Default( IC_MODULE_ID index , IC_INPUT_CAPTURE_MODES modeSel )
78:                  {
79:                      _SFR_FIELD_WRITE(_IC_CAPTURE_MODE_SELECT_VREG(index),_IC_CAPTURE_MODE_SELECT_MASK(index),
9D00B3DC  3C02BF80   LUI V0, -16512
9D00B3E0  8C442400   LW A0, 9216(V0)
9D00B3E4  2403FFF8   ADDIU V1, ZERO, -8
9D00B3E8  00831824   AND V1, A0, V1
9D00B3EC  34630001   ORI V1, V1, 1
9D00B3F0  AC432400   SW V1, 9216(V0)
9D00B474  3C02BF80   LUI V0, -16512
9D00B478  8C442000   LW A0, 8192(V0)
9D00B47C  2403FFF8   ADDIU V1, ZERO, -8
9D00B480  00831824   AND V1, A0, V1
9D00B484  34630001   ORI V1, V1, 1
9D00B488  AC432000   SW V1, 8192(V0)
9D00B50C  3C02BF80   LUI V0, -16512
9D00B510  8C442600   LW A0, 9728(V0)
9D00B514  2403FFF8   ADDIU V1, ZERO, -8
9D00B518  00831824   AND V1, A0, V1
9D00B51C  34630001   ORI V1, V1, 1
9D00B520  AC432600   SW V1, 9728(V0)
9D00B5A4  3C02BF80   LUI V0, -16512
9D00B5A8  8C442800   LW A0, 10240(V0)
9D00B5AC  2403FFF8   ADDIU V1, ZERO, -8
9D00B5B0  00831824   AND V1, A0, V1
9D00B5B4  34630001   ORI V1, V1, 1
9D00B5B8  AC432800   SW V1, 10240(V0)
80:                  					_IC_CAPTURE_MODE_SELECT_POS(index), modeSel);
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  IC_ExistsCaptureMode_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_IC_ExistsCaptureMode
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_IC_ExistsCaptureMode function.
92:                  */
93:                  
94:                  #define PLIB_IC_ExistsCaptureMode PLIB_IC_ExistsCaptureMode
95:                  PLIB_TEMPLATE bool IC_ExistsCaptureMode_Default( IC_MODULE_ID index )
96:                  {
97:                      return true;
98:                  }
99:                  
100:                 
101:                 #endif /*_IC_CAPTUREMODE_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ic/templates/ic_buffervalue_32bit_variant.h  ----
1:                   /*******************************************************************************
2:                     IC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ic_BufferValue_32Bit_Variant.h
6:                   
7:                     Summary:
8:                       IC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferValue
13:                      and its Variant : 32Bit_Variant
14:                      For following APIs :
15:                          PLIB_IC_Buffer32BitGet
16:                          PLIB_IC_Buffer16BitGet
17:                          PLIB_IC_ExistsBufferValue
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _IC_BUFFERVALUE_32BIT_VARIANT_H
48:                  #define _IC_BUFFERVALUE_32BIT_VARIANT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _IC_BUFFER_32BIT_VALUE_VREG(index)
55:                  
56:                    MASKs: 
57:                      _IC_BUFFER_32BIT_VALUE_MASK(index)
58:                  
59:                    POSs: 
60:                      _IC_BUFFER_32BIT_VALUE_POS(index)
61:                  
62:                    LENs: 
63:                      _IC_BUFFER_32BIT_VALUE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  IC_Buffer32BitGet_32Bit_Variant
70:                  
71:                    Summary:
72:                      Implements 32Bit_Variant variant of PLIB_IC_Buffer32BitGet 
73:                  
74:                    Description:
75:                      This template implements the 32Bit_Variant variant of the PLIB_IC_Buffer32BitGet function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE uint32_t IC_Buffer32BitGet_32Bit_Variant( IC_MODULE_ID index )
79:                  {
80:                      return (uint32_t)(_SFR_READ(_IC_BUFFER_32BIT_VALUE_VREG(index)));
00000000  00000000   NOP
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  IC_Buffer16BitGet_32Bit_Variant
86:                  
87:                    Summary:
88:                      Implements 32Bit_Variant variant of PLIB_IC_Buffer16BitGet 
89:                  
90:                    Description:
91:                      This template implements the 32Bit_Variant variant of the PLIB_IC_Buffer16BitGet function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE uint16_t IC_Buffer16BitGet_32Bit_Variant( IC_MODULE_ID index )
95:                  {
96:                      return (uint16_t)(_SFR_READ(_IC_BUFFER_32BIT_VALUE_VREG(index)) & 0x0000FFFF);
9D00DD10  3C02BF80   LUI V0, -16512
9D00DD14  8C422410   LW V0, 9232(V0)
9D00DD20  3C02BF80   LUI V0, -16512
9D00DD24  8C422010   LW V0, 8208(V0)
9D00DD30  3C02BF80   LUI V0, -16512
9D00DD34  8C422610   LW V0, 9744(V0)
9D00DD40  3C02BF80   LUI V0, -16512
9D00DD44  8C422810   LW V0, 10256(V0)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  IC_ExistsBufferValue_32Bit_Variant
102:                 
103:                   Summary:
104:                     Implements 32Bit_Variant variant of PLIB_IC_ExistsBufferValue
105:                 
106:                   Description:
107:                     This template implements the 32Bit_Variant variant of the PLIB_IC_ExistsBufferValue function.
108:                 */
109:                 
110:                 #define PLIB_IC_ExistsBufferValue PLIB_IC_ExistsBufferValue
111:                 PLIB_TEMPLATE bool IC_ExistsBufferValue_32Bit_Variant( IC_MODULE_ID index )
112:                 {
113:                     return true;
114:                 }
115:                 
116:                 
117:                 #endif /*_IC_BUFFERVALUE_32BIT_VARIANT_H*/
118:                 
119:                 /******************************************************************************
120:                  End of File
121:                 */
122:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ic/templates/ic_buffersize_default.h  -----------
1:                   /*******************************************************************************
2:                     IC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ic_BufferSize_Default.h
6:                   
7:                     Summary:
8:                       IC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_IC_BufferSizeSelect
16:                          PLIB_IC_ExistsBufferSize
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _IC_BUFFERSIZE_DEFAULT_H
47:                  #define _IC_BUFFERSIZE_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _IC_BUFFER_SIZE_SET_VREG(index)
54:                  
55:                    MASKs: 
56:                      _IC_BUFFER_SIZE_SET_MASK(index)
57:                  
58:                    POSs: 
59:                      _IC_BUFFER_SIZE_SET_POS(index)
60:                  
61:                    LENs: 
62:                      _IC_BUFFER_SIZE_SET_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  IC_BufferSizeSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_IC_BufferSizeSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_IC_BufferSizeSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void IC_BufferSizeSelect_Default( IC_MODULE_ID index , IC_BUFFER_SIZE bufSize )
78:                  {
79:                      _SFR_BIT_WRITE(_IC_BUFFER_SIZE_SET_VREG(index),_IC_BUFFER_SIZE_SET_POS(index),bufSize);
9D00B40C  8C442400   LW A0, 9216(V0)
9D00B410  2403FEFF   ADDIU V1, ZERO, -257
9D00B414  00831824   AND V1, A0, V1
9D00B418  AC432400   SW V1, 9216(V0)
9D00B4A4  8C442000   LW A0, 8192(V0)
9D00B4A8  2403FEFF   ADDIU V1, ZERO, -257
9D00B4AC  00831824   AND V1, A0, V1
9D00B4B0  AC432000   SW V1, 8192(V0)
9D00B53C  8C442600   LW A0, 9728(V0)
9D00B540  2403FEFF   ADDIU V1, ZERO, -257
9D00B544  00831824   AND V1, A0, V1
9D00B548  AC432600   SW V1, 9728(V0)
9D00B5D4  8C442800   LW A0, 10240(V0)
9D00B5D8  2403FEFF   ADDIU V1, ZERO, -257
9D00B5DC  00831824   AND V1, A0, V1
9D00B5E0  AC432800   SW V1, 10240(V0)
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  IC_ExistsBufferSize_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_IC_ExistsBufferSize
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_IC_ExistsBufferSize function.
91:                  */
92:                  
93:                  #define PLIB_IC_ExistsBufferSize PLIB_IC_ExistsBufferSize
94:                  PLIB_TEMPLATE bool IC_ExistsBufferSize_Default( IC_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_IC_BUFFERSIZE_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/ic/templates/ic_bufferisemptystatus_default.h  --
1:                   /*******************************************************************************
2:                     IC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ic_BufferIsEmptyStatus_Default.h
6:                   
7:                     Summary:
8:                       IC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferIsEmptyStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_IC_BufferIsEmpty
16:                          PLIB_IC_ExistsBufferIsEmptyStatus
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _IC_BUFFERISEMPTYSTATUS_DEFAULT_H
47:                  #define _IC_BUFFERISEMPTYSTATUS_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
51:                  
52:                    VREGs: 
53:                      _IC_BUFFER_IS_EMPTY_STATUS_VREG(index)
54:                  
55:                    MASKs: 
56:                      _IC_BUFFER_IS_EMPTY_STATUS_MASK(index)
57:                  
58:                    POSs: 
59:                      _IC_BUFFER_IS_EMPTY_STATUS_POS(index)
60:                  
61:                    LENs: 
62:                      _IC_BUFFER_IS_EMPTY_STATUS_LEN(index)
63:                  
64:                  */
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  IC_BufferIsEmpty_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_IC_BufferIsEmpty 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_IC_BufferIsEmpty function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE bool IC_BufferIsEmpty_Default( IC_MODULE_ID index )
78:                  {
79:                      return (bool)(!(_SFR_BIT_READ(_IC_BUFFER_IS_EMPTY_STATUS_VREG(index),
00000000  00000000   NOP
80:                  			_IC_BUFFER_IS_EMPTY_STATUS_POS(index))));
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  IC_ExistsBufferIsEmptyStatus_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_IC_ExistsBufferIsEmptyStatus
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_IC_ExistsBufferIsEmptyStatus function.
92:                  */
93:                  
94:                  #define PLIB_IC_ExistsBufferIsEmptyStatus PLIB_IC_ExistsBufferIsEmptyStatus
95:                  PLIB_TEMPLATE bool IC_ExistsBufferIsEmptyStatus_Default( IC_MODULE_ID index )
96:                  {
97:                      return true;
98:                  }
99:                  
100:                 
101:                 #endif /*_IC_BUFFERISEMPTYSTATUS_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_TraceOutput_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TraceOutput
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_TraceOutputEnable
16:                          PLIB_DEVCON_TraceOutputDisable
17:                          PLIB_DEVCON_ExistsTraceOutput
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_TRACEOUTPUT_DEFAULT_H
48:                  #define _DEVCON_TRACEOUTPUT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
52:                  
53:                    VREGs:
54:                      _DEVCON_TRACE_OUTPUT_ENABLE_VREG(index)
55:                  
56:                    MASKs:
57:                      _DEVCON_TRACE_OUTPUT_ENABLE_MASK(index)
58:                  
59:                    POSs:
60:                      _DEVCON_TRACE_OUTPUT_ENABLE_POS(index)
61:                  
62:                    LENs:
63:                      _DEVCON_TRACE_OUTPUT_ENABLE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DEVCON_TraceOutputEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DEVCON_TraceOutputEnable
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DEVCON_TraceOutputEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void DEVCON_TraceOutputEnable_Default( DEVCON_MODULE_ID index )
79:                  {
80:                      _SFR_BIT_WRITE(_DEVCON_TRACE_OUTPUT_ENABLE_VREG(index),_DEVCON_TRACE_OUTPUT_ENABLE_POS(index),1);
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  DEVCON_TraceOutputDisable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_DEVCON_TraceOutputDisable
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_DEVCON_TraceOutputDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void DEVCON_TraceOutputDisable_Default( DEVCON_MODULE_ID index )
95:                  {
96:                      _SFR_BIT_WRITE(_DEVCON_TRACE_OUTPUT_ENABLE_VREG(index),_DEVCON_TRACE_OUTPUT_ENABLE_POS(index),0);
00000000  00000000   NOP
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  DEVCON_ExistsTraceOutput_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_DEVCON_ExistsTraceOutput
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_DEVCON_ExistsTraceOutput function.
108:                 */
109:                 
110:                 #define PLIB_DEVCON_ExistsTraceOutput PLIB_DEVCON_ExistsTraceOutput
111:                 PLIB_TEMPLATE bool DEVCON_ExistsTraceOutput_Default( DEVCON_MODULE_ID index )
112:                 {
113:                     return true;
114:                 }
115:                 
116:                 
117:                 #endif /*_DEVCON_TRACEOUTPUT_DEFAULT_H*/
118:                 
119:                 /******************************************************************************
120:                  End of File
121:                 */
122:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/devcon/templates/devcon_syslockunlock_default.h  
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_SysLockUnlock_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SysLockUnlock
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_SystemUnlock
16:                          PLIB_DEVCON_SystemLock
17:                          PLIB_DEVCON_ExistsSystemLockUnlock
18:                          PLIB_DEVCON_ExistsDeviceVerAndId
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
49:                  #define _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
53:                  
54:                    VREGs: 
55:                      _DEVCON_SYS_LOCK_VREG(index)
56:                  
57:                    MASKs: 
58:                      _DEVCON_SYS_LOCK_MASK(index)
59:                  
60:                    POSs: 
61:                      _DEVCON_SYS_LOCK_POS(index)
62:                  
63:                    LENs: 
64:                      _DEVCON_SYS_LOCK_LEN(index)
65:                  
66:                  */
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DEVCON_SystemUnlock_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DEVCON_SystemUnlock 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DEVCON_SystemUnlock function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DEVCON_SystemUnlock_Default( DEVCON_MODULE_ID index )
80:                  {
81:                      _SFR_WRITE(_DEVCON_SYS_LOCK_VREG(index), 0x00000000);
9D00CB34  3C02BF81   LUI V0, -16511
9D00CB38  AC40F230   SW ZERO, -3536(V0)
82:                      _SFR_WRITE(_DEVCON_SYS_LOCK_VREG(index), 0xAA996655);
9D00CB3C  3C04AA99   LUI A0, -21863
9D00CB40  24846655   ADDIU A0, A0, 26197
9D00CB44  AC44F230   SW A0, -3536(V0)
83:                      _SFR_WRITE(_DEVCON_SYS_LOCK_VREG(index), 0x556699AA);
9D00CB48  3C045566   LUI A0, 21862
9D00CB4C  348499AA   ORI A0, A0, -26198
9D00CB50  AC44F230   SW A0, -3536(V0)
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  DEVCON_SystemLock_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_DEVCON_SystemLock 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_DEVCON_SystemLock function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void DEVCON_SystemLock_Default( DEVCON_MODULE_ID index )
98:                  {
99:                      _SFR_WRITE(_DEVCON_SYS_LOCK_VREG(index), 0x33333333);
9D00D050  3C043333   LUI A0, 13107
9D00D054  24843333   ADDIU A0, A0, 13107
9D00D058  3C03BF81   LUI V1, -16511
9D00D05C  AC64F230   SW A0, -3536(V1)
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  DEVCON_ExistsSystemLockUnlock_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_DEVCON_ExistsSystemLockUnlock
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_DEVCON_ExistsSystemLockUnlock function.
111:                 */
112:                 
113:                 #define PLIB_DEVCON_ExistsSystemLockUnlock PLIB_DEVCON_ExistsSystemLockUnlock
114:                 PLIB_TEMPLATE bool DEVCON_ExistsSystemLockUnlock_Default( DEVCON_MODULE_ID index )
115:                 {
116:                     return true;
117:                 }
118:                 
119:                 #endif /*_DEVCON_SYSLOCKUNLOCK_DEFAULT_H*/
120:                 
121:                 /******************************************************************************
122:                  End of File
123:                 */
124:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/devcon/templates/devcon_jtagenable_default.h  ---
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_JTAGEnable_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : JTAGEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_JTAGPortEnable
16:                          PLIB_DEVCON_JTAGPortDisable
17:                          PLIB_DEVCON_ExistsJTAGEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_JTAGENABLE_DEFAULT_H
48:                  #define _DEVCON_JTAGENABLE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are
52:                  
53:                    VREGs:
54:                      _DEVCON_JTAG_ENABLE_VREG(index)
55:                  
56:                    MASKs:
57:                      _DEVCON_JTAG_ENABLE_MASK(index)
58:                  
59:                    POSs:
60:                      _DEVCON_JTAG_ENABLE_POS(index)
61:                  
62:                    LENs:
63:                      _DEVCON_JTAG_ENABLE_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DEVCON_JTAGPortEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DEVCON_JTAGPortEnable
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DEVCON_JTAGPortEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void DEVCON_JTAGPortEnable_Default( DEVCON_MODULE_ID index )
79:                  {
80:                      *((SFR_TYPE *)(_DEVCON_JTAG_ENABLE_VREG(index))) |=  1<<(_DEVCON_JTAG_ENABLE_POS(index) );
00000000  00000000   NOP
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  DEVCON_JTAGPortDisable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_DEVCON_JTAGPortDisable
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_DEVCON_JTAGPortDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void DEVCON_JTAGPortDisable_Default( DEVCON_MODULE_ID index )
95:                  {
96:                      *((SFR_TYPE *)(_DEVCON_JTAG_ENABLE_VREG(index))) &= ~(1<<(_DEVCON_JTAG_ENABLE_POS(index)));
9D00DA80  3C02BF81   LUI V0, -16511
9D00DA84  8C44F200   LW A0, -3584(V0)
9D00DA88  2403FFF7   ADDIU V1, ZERO, -9
9D00DA8C  00831824   AND V1, A0, V1
9D00DA90  AC43F200   SW V1, -3584(V0)
9D00DA94  03E00008   JR RA
9D00DA98  00000000   NOP
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  DEVCON_ExistsJTAGEnable_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_DEVCON_ExistsJTAGEnable
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_DEVCON_ExistsJTAGEnable function.
108:                 */
109:                 
110:                 #define PLIB_DEVCON_ExistsJTAGEnable PLIB_DEVCON_ExistsJTAGEnable
111:                 PLIB_TEMPLATE bool DEVCON_ExistsJTAGEnable_Default( DEVCON_MODULE_ID index )
112:                 {
113:                     return true;
114:                 }
115:                 
116:                 
117:                 #endif /*_DEVCON_JTAGENABLE_DEFAULT_H*/
118:                 
119:                 /******************************************************************************
120:                  End of File
121:                 */
122:                 
---  c:/microchip/harmony/v1_08_01/framework/peripheral/bmx/templates/bmx_dataramwaitstate_default.h  ---
1:                   /*******************************************************************************
2:                     BMX Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       bmx_DataRamWaitState_Default.h
6:                   
7:                     Summary:
8:                       BMX PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DataRamWaitState
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_BMX_ExistsDataRamWaitState
16:                          PLIB_BMX_DataRamWaitStateSet
17:                          PLIB_BMX_DataRamWaitStateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _BMX_DATARAMWAITSTATE_DEFAULT_H
48:                  #define _BMX_DATARAMWAITSTATE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Routines available for accessing VREGS, MASKS, POS, LEN are 
52:                  
53:                    VREGs: 
54:                      _BMX_DRM_WS_VREG(index)
55:                  
56:                    MASKs: 
57:                      _BMX_DRM_WS_MASK(index)
58:                  
59:                    POSs: 
60:                      _BMX_DRM_WS_POS(index)
61:                  
62:                    LENs: 
63:                      _BMX_DRM_WS_LEN(index)
64:                  
65:                  */
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  BMX_ExistsDataRamWaitState_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_BMX_ExistsDataRamWaitState
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_BMX_ExistsDataRamWaitState function.
76:                  */
77:                  
78:                  #define PLIB_BMX_ExistsDataRamWaitState PLIB_BMX_ExistsDataRamWaitState
79:                  PLIB_TEMPLATE bool BMX_ExistsDataRamWaitState_Default( BMX_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  BMX_DataRamWaitStateSet_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_BMX_DataRamWaitStateSet 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_BMX_DataRamWaitStateSet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void BMX_DataRamWaitStateSet_Default( BMX_MODULE_ID index , PLIB_BMX_DATA_RAM_WAIT_STATES wait )
96:                  {
97:                      _SFR_BIT_WRITE(_BMX_DRM_WS_VREG(index), _BMX_DRM_WS_POS(index), wait);
9D00A258  3C02BF88   LUI V0, -16504
9D00A25C  8C452000   LW A1, 8192(V0)
9D00A260  2404FFBF   ADDIU A0, ZERO, -65
9D00A264  00A42024   AND A0, A1, A0
9D00A268  AC442000   SW A0, 8192(V0)
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  BMX_DataRamWaitStateGet_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_BMX_DataRamWaitStateGet 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_BMX_DataRamWaitStateGet function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE PLIB_BMX_DATA_RAM_WAIT_STATES BMX_DataRamWaitStateGet_Default( BMX_MODULE_ID index )
112:                 {
113:                     return (PLIB_BMX_DATA_RAM_WAIT_STATES)_SFR_BIT_READ(_BMX_DRM_WS_VREG(index), _BMX_DRM_WS_POS(index));
114:                 }
115:                 
116:                 
117:                 #endif /*_BMX_DATARAMWAITSTATE_DEFAULT_H*/
118:                 
119:                 /******************************************************************************
120:                  End of File
121:                 */
122:                 
---  c:/microchip/harmony/v1_08_01/framework/osal/src/osal_freertos.c  ----------------------------------
1:                   /*******************************************************************************
2:                     FreeRTOS OSAL compatibility layer
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       osal_freertos.c
9:                   
10:                    Summary:
11:                      Provide OSAL mappings for the FreeRTOS(tm) Real-time operating system
12:                  
13:                    Description:
14:                      This file contains functional implementations of the OSAL for FreeRTOS.
15:                  
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2011-2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  /*  This section lists the other files that are included in this file.
50:                   */
51:                  
52:                  #include <xc.h>
53:                  #include "FreeRTOS.h"
54:                  #include "queue.h"
55:                  #include "semphr.h"
56:                  #include "task.h"
57:                  
58:                  #include "osal/src/osal_freertos.h"
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: OSAL Routines
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  /* These routines implement the OSAL for the chosen RTOS.
66:                  */
67:                  
68:                  // Critical Section group
69:                  // *****************************************************************************
70:                  /* Function: void OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
71:                  
72:                    Summary:
73:                      Enter a critical section with the specified severity level.
74:                  
75:                    Description:
76:                       The program is entering a critical section of code. It is assumed that the
77:                       sequence of operations bounded by the enter and leave critical section operations
78:                       is treated as one atomic sequence that will not be disturbed.
79:                  
80:                    Precondition:
81:                      None
82:                  
83:                    Parameters:
84:                      severity      - OSAL_CRIT_TYPE_LOW, The RTOS should disable all other running
85:                                      tasks effectively locking the scheduling mechanism.
86:                                    - OSAL_CRIT_TYPE_HIGH, The RTOS should disable all possible
87:                                      interrupts sources including the scheduler ensuring that the
88:                                      sequence of code operates without interruption.
89:                  
90:                    Returns:
91:                      None
92:                  
93:                    Example:
94:                      <code>
95:                       // prevent other tasks pre-empting this sequence of code
96:                       OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
97:                       // modify the peripheral
98:                       DRV_USART_Reinitialize( objUSART,  &initData);
99:                       OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW);
100:                     </code>
101:                 
102:                   Remarks:
103:                     The sequence of operations bounded by the OSAL_CRIT_Enter and OSAL_CRIT_Leave
104:                     form a critical section. The severity level defines whether the RTOS should
105:                     perform task locking or completely disable all interrupts.
106:                 
107:                    NOTE - 
108:                     In FreeRTOS only interrupts below configMAX_SYSCALL_INTERRUPT_PRIORITY are
109:                     disabled.  FreeRTOS will handle nesting of this function is scheduler is 
110:                     running.
111:                  */
112:                 OSAL_CRITSECT_DATA_TYPE __attribute__((nomips16,nomicromips)) OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
113:                 {
00000000  00000000   NOP
114:                     switch (severity)
00000004  00000000   NOP
115:                     {
116:                         case OSAL_CRIT_TYPE_LOW:
117:                             /* LOW priority critical sections just disable the scheduler */
118:                             vTaskSuspendAll();
00000020  00000000   NOP
119:                             break;
00000028  00000000   NOP
120:                 
121:                         case OSAL_CRIT_TYPE_HIGH:
122:                             /* HIGH priority critical sections disable interrupts */
123:                             portENTER_CRITICAL();
00000030  00000000   NOP
124:                             break;
125:                     }
126:                     
127:                     return(0);
128:                 }
00000018  00000000   NOP
00000038  00000000   NOP
129:                 
130:                 // *****************************************************************************
131:                 /* Function: void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity,OSAL_CRITSECT_DATA_TYPE status)
132:                 
133:                   Summary:
134:                     Leave a critical section with the specified severity level.
135:                 
136:                   Description:
137:                      The program is leaving a critical section of code. It is assumed that the
138:                      sequence of operations bounded by the enter and leave critical section operations
139:                      is treated as one atomic sequence that will not be disturbed.
140:                     The severity should match the severity level used in the corresponding
141:                     OSAL_CRIT_Enter call to ensure that the RTOS carries out the correct action.
142:                 
143:                   Precondition:
144:                     None
145:                 
146:                   Parameters:
147:                     severity      - OSAL_CRIT_TYPE_LOW, The RTOS should disable all other running
148:                                     tasks effectively locking the scheduling mechanism.
149:                                   - OSAL_CRIT_TYPE_HIGH, The RTOS should disable all possible
150:                                     interrupts sources including the scheduler ensuring that the
151:                                     sequence of code operates without interruption.
152:                 
153:                   Returns:
154:                     None
155:                 
156:                   Example:
157:                     <code>
158:                      OSAL_CRITSECT_DATA_TYPE intStatus;
159:                      // prevent other tasks pre-empting this sequence of code
160:                      intStatus = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
161:                      // modify the peripheral
162:                      DRV_USART_Reinitialize( objUSART,  &initData);
163:                      OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, intStatus);
164:                     </code>
165:                 
166:                   Remarks:
167:                     The sequence of operations bounded by the OSAL_CRIT_Enter and OSAL_CRIT_Leave
168:                     form a critical section. The severity level defines whether the RTOS should
169:                     perform task locking or completely disable all interrupts.
170:                 
171:                  */
172:                 void __attribute__((nomips16,nomicromips)) OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
173:                 {
00000000  00000000   NOP
174:                     switch (severity)
00000004  00000000   NOP
175:                     {
176:                         case OSAL_CRIT_TYPE_LOW:
177:                             /* LOW priority resumes scheduler */
178:                             xTaskResumeAll();
00000020  00000000   NOP
179:                             break;
00000028  00000000   NOP
180:                 
181:                         case OSAL_CRIT_TYPE_HIGH:
182:                             /* HIGH priority renables interrupts */
183:                             portEXIT_CRITICAL();
00000030  00000000   NOP
184:                             break;
185:                     }
186:                 }
00000038  00000000   NOP
187:                 
188:                 // Semaphore group
189:                 // *****************************************************************************
190:                 /* Function: OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type,
191:                                                 uint8_t maxCount, uint8_t initialCount)
192:                   Summary:
193:                     Create an OSAL Semaphore
194:                 
195:                   Description:
196:                     Create an OSAL binary or counting semaphore. If OSAL_SEM_TYPE_BINARY is specified then
197:                     the maxcount and initialCount values are ignored otherwise these must contain valid
198:                     values.
199:                 
200:                   Precondition:
201:                     Semaphore must have been declared.
202:                 
203:                   Parameters:
204:                     semID       - Pointer to the Semaphore ID
205:                 
206:                     type        - OSAL_SEM_TYPE_BINARY, create a binary semaphore
207:                                 - OSAL_SEM_TYPE_COUNTING, create a counting semaphore with the specified
208:                                   count values.
209:                 
210:                     maxCount    - Maximum value for a counting semaphore. Ignored for a BINARY semaphore.
211:                 
212:                     initialCount - Starting count value for the semaphore. Ignored for a BINARY semaphore
213:                 
214:                   Returns:
215:                     OSAL_RESULT_TRUE    - Semaphore created
216:                     OSAL_RESULT_FALSE   - Semaphore creation failed
217:                 
218:                   Example:
219:                     <code>
220:                     OSAL_SEM_Create(&mySemID, OSAL_SEM_TYPE_COUNTING, 10, 5);
221:                     </code>
222:                 
223:                   Remarks:
224:                  */
225:                 OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount)
226:                 {
9D00B63C  27BDFFE8   ADDIU SP, SP, -24
9D00B640  AFBF0014   SW RA, 20(SP)
9D00B644  AFB00010   SW S0, 16(SP)
9D00B648  00808021   ADDU S0, A0, ZERO
9D00B64C  30C400FF   ANDI A0, A2, 255
227:                    switch (type) {
9D00B650  10A00006   BEQ A1, ZERO, 0x9D00B66C
9D00B654  30E700FF   ANDI A3, A3, 255
9D00B658  24020001   ADDIU V0, ZERO, 1
9D00B65C  10A20010   BEQ A1, V0, 0x9D00B6A0
9D00B660  00000000   NOP
228:                       case OSAL_SEM_TYPE_BINARY:
229:                          vSemaphoreCreateBinary(*(SemaphoreHandle_t*)semID);
9D00B66C  24040001   ADDIU A0, ZERO, 1
9D00B670  00002821   ADDU A1, ZERO, ZERO
9D00B674  0F402DB4   JAL xQueueGenericCreate
9D00B678  24060003   ADDIU A2, ZERO, 3
9D00B67C  1040000E   BEQ V0, ZERO, 0x9D00B6B8
9D00B680  AE020000   SW V0, 0(S0)
9D00B684  00402021   ADDU A0, V0, ZERO
9D00B688  00002821   ADDU A1, ZERO, ZERO
9D00B68C  00003021   ADDU A2, ZERO, ZERO
9D00B690  0F40199A   JAL xQueueGenericSend
9D00B694  00003821   ADDU A3, ZERO, ZERO
230:                          break;
231:                 
232:                       case OSAL_SEM_TYPE_COUNTING:
233:                          *(SemaphoreHandle_t*)semID = xSemaphoreCreateCounting((UBaseType_t)maxCount, (UBaseType_t)initialCount);
9D00B6A0  0F403582   JAL xQueueCreateCountingSemaphore
9D00B6A4  00E02821   ADDU A1, A3, ZERO
234:                          break;
9D00B6A8  0B402DAE   J 0x9D00B6B8
9D00B6AC  AE020000   SW V0, 0(S0)
235:                 
236:                       default:
237:                          *(SemaphoreHandle_t*)semID = NULL;
9D00B664  0B402DAC   J 0x9D00B6B0
9D00B668  AE000000   SW ZERO, 0(S0)
238:                          return OSAL_RESULT_NOT_IMPLEMENTED;
9D00B6B0  0B402DB0   J 0x9D00B6C0
9D00B6B4  2402FFFF   ADDIU V0, ZERO, -1
239:                    }
240:                 
241:                    if (*(SemaphoreHandle_t*)semID == NULL)
9D00B698  0B402DAF   J 0x9D00B6BC
9D00B69C  8E020000   LW V0, 0(S0)
9D00B6B8  8E020000   LW V0, 0(S0)
9D00B6BC  0002102B   SLTU V0, ZERO, V0
242:                    {
243:                       return OSAL_RESULT_FALSE;
244:                    }
245:                 
246:                    return OSAL_RESULT_TRUE;
247:                 }
9D00B6C0  8FBF0014   LW RA, 20(SP)
9D00B6C4  8FB00010   LW S0, 16(SP)
9D00B6C8  03E00008   JR RA
9D00B6CC  27BD0018   ADDIU SP, SP, 24
248:                 
249:                 // *****************************************************************************
250:                 /* Function: OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID)
251:                 
252:                   Summary:
253:                     Delete an OSAL Semaphore
254:                 
255:                   Description:
256:                     Delete an OSAL semaphore freeing up any allocated storage associated with it.
257:                 
258:                   Precondition:
259:                     Semaphore must have been created.
260:                 
261:                   Parameters:
262:                     semID       - Pointer to the semID
263:                 
264:                   Returns:
265:                     OSAL_RESULT_TRUE    - Semaphore deleted
266:                     OSAL_RESULT_FALSE   - Semaphore deletion failed
267:                 
268:                   Example:
269:                     <code>
270:                      OSAL_SEM_Delete(&mySemID);
271:                    </code>
272:                 
273:                   Remarks:
274:                  */
275:                 OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID)
276:                 {
00000000  00000000   NOP
277:                    vSemaphoreDelete(*(SemaphoreHandle_t*)semID);
00000010  00000000   NOP
278:                    *(SemaphoreHandle_t*)semID = NULL;
00000018  00000000   NOP
279:                    return OSAL_RESULT_TRUE;
280:                 }
0000001C  00000000   NOP
281:                 
282:                 // *****************************************************************************
283:                 /* Function: OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
284:                 
285:                   Summary:
286:                      Pend on a semaphore. Returns true if semaphore obtained within time limit.
287:                 
288:                   Description:
289:                      Blocking function call that pends (waits) on a semaphore. The function will
290:                      return true is the semaphore has been obtained or false if it was not available
291:                      or the time limit was exceeded.
292:                 
293:                   Precondition:
294:                      Semaphore must have been created.
295:                 
296:                   Parameters:
297:                      semID       - The semID
298:                 
299:                     waitMS       - Time limit to wait in milliseconds.
300:                                    0 - do not wait
301:                                    OSAL_WAIT_FOREVER - return only when semaphore is obtained
302:                                    Other values - timeout delay
303:                 
304:                   Returns:
305:                     OSAL_RESULT_TRUE    - Semaphore obtained
306:                     OSAL_RESULT_FALSE   - Semaphore not obtained or timeout occurred
307:                 
308:                   Example:
309:                     <code>
310:                     if (OSAL_SEM_Pend(semUARTRX, 50) == OSAL_RESULT_TRUE)
311:                     {
312:                         // character available
313:                         c = DRV_USART_ReadByte(drvID);
314:                         ...
315:                     }
316:                     else
317:                     {
318:                         // character not available, resend prompt
319:                         ...
320:                     }
321:                    </code>
322:                 
323:                   Remarks:
324:                  */
325:                 OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
326:                 {
00000000  00000000   NOP
327:                    TickType_t timeout = 0;
328:                 
329:                    if(waitMS == OSAL_WAIT_FOREVER)
330:                    {
331:                       timeout = portMAX_DELAY;
332:                    }
333:                    else
334:                    {
335:                       timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
0000000C  00000000   NOP
336:                    }
337:                    if (xSemaphoreTake(*(SemaphoreHandle_t*)semID, timeout) == pdTRUE)
00000020  00000000   NOP
338:                       return OSAL_RESULT_TRUE;
339:                    else
340:                       return OSAL_RESULT_FALSE;
341:                 }
00000034  00000000   NOP
342:                 
343:                 // *****************************************************************************
344:                 /* Function: OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
345:                 
346:                   Summary:
347:                      Post a semaphore or increment a counting semaphore.
348:                 
349:                   Description:
350:                      Post a binary semaphore or increment a counting semaphore. The highest
351:                      priority task currently blocked on the semaphore will be released and
352:                      made ready to run.
353:                 
354:                   Precondition:
355:                      Semaphore must have been created.
356:                 
357:                   Parameters:
358:                      semID       - The semID
359:                 
360:                   Returns:
361:                     OSAL_RESULT_TRUE    - Semaphore posted
362:                     OSAL_RESULT_FALSE   - Semaphore not posted
363:                 
364:                   Example:
365:                     <code>
366:                     OSAL_SEM_Post(semSignal);
367:                     </code>
368:                 
369:                   Remarks:
370:                  */
371:                 OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
372:                 {
00000000  00000000   NOP
373:                    if (xSemaphoreGive(*(SemaphoreHandle_t*)semID) == pdTRUE)
00000008  00000000   NOP
374:                    {
375:                       return OSAL_RESULT_TRUE;
376:                    }
377:                    return OSAL_RESULT_FALSE;
378:                 }
00000020  00000000   NOP
379:                 
380:                 // *****************************************************************************
381:                 /* Function: OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
382:                 
383:                   Summary:
384:                      Post a semaphore or increment a counting semaphore from within an ISR
385:                 
386:                   Description:
387:                      Post a binary semaphore or increment a counting semaphore. The highest
388:                      priority task currently blocked on the semaphore will be released and
389:                      made ready to run. This form of the post function should be used inside
390:                     an ISR.
391:                 
392:                   Precondition:
393:                      Semaphore must have been created.
394:                 
395:                   Parameters:
396:                      semID       - The semID
397:                 
398:                   Returns:
399:                     OSAL_RESULT_TRUE    - Semaphore posted
400:                     OSAL_RESULT_FALSE   - Semaphore not posted
401:                 
402:                   Example:
403:                     <code>
404:                      void __ISR(UART_2_VECTOR) _UART2RXHandler()
405:                      {
406:                         char c;
407:                         // read the character
408:                         c = U2RXREG;
409:                         // clear the interrupt flag
410:                         IFS1bits.U2IF = 0;
411:                         // post a semaphore indicating a character has been received
412:                         OSAL_SEM_PostISR(semSignal);
413:                      }
414:                     </code>
415:                 
416:                   Remarks:
417:                      This version of the OSAL_SEM_Post function should be used if the program
418:                      is, or may be, operating inside and ISR. The OSAL will take the necessary
419:                      steps to ensure correct operation possibly disabling interrupts or entering
420:                      a critical section. The exact requirements will depend upon the particular
421:                      RTOS being used.
422:                  */
423:                 OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
424:                 {
00000000  00000000   NOP
425:                    BaseType_t _taskWoken = pdFALSE;
00000008  00000000   NOP
426:                    
427:                    if (xSemaphoreGiveFromISR(*(SemaphoreHandle_t*)semID, &_taskWoken))
0000000C  00000000   NOP
428:                    {
429:                       portEND_SWITCHING_ISR(_taskWoken);
00000020  00000000   NOP
430:                       return OSAL_RESULT_TRUE;
431:                    }
432:                    return OSAL_RESULT_FALSE;
433:                 }
0000003C  00000000   NOP
434:                 
435:                 // *****************************************************************************
436:                 /* Function: uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
437:                 
438:                   Summary:
439:                     Return the current value of a counting semaphore.
440:                 
441:                   Description:
442:                     Return the current value of a counting semaphore. The value returned is
443:                     assumed to be a single value ranging from 0-255.
444:                 
445:                   Precondition:
446:                      Semaphore must have been created.
447:                 
448:                   Parameters:
449:                      semID       - The semID
450:                 
451:                   Returns:
452:                     0           - Semaphore is unavailable
453:                     1-255       - Current value of the counting semaphore
454:                 
455:                   Example:
456:                     <code>
457:                      uint8_t semCount;
458:                 
459:                      semCount = OSAL_SEM_GetCount(semUART);
460:                 
461:                      if (semCount > 0)
462:                      {
463:                         // obtain the semaphore
464:                          if (OSAL_SEM_Pend(semUART) == OSAL_RESULT_TRUE)
465:                          {
466:                             // perform processing on the comm channel
467:                             ...
468:                          }
469:                      }
470:                      else
471:                      {
472:                         // no comm channels available
473:                         ...
474:                      }
475:                     </code>
476:                 
477:                   Remarks:
478:                      This version of the OSAL_SEM_Post function should be used if the program
479:                      is, or may be, operating inside and ISR. The OSAL will take the necessary
480:                      steps to ensure correct operation possibly disabling interrupts or entering
481:                      a critical section. The exact requirements will depend upon the particular
482:                      RTOS being used.
483:                  */
484:                 uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
485:                 {
00000000  00000000   NOP
486:                    UBaseType_t SemCount;
487:                    SemCount = uxQueueMessagesWaiting(*(SemaphoreHandle_t*)semID);
00000008  00000000   NOP
488:                    if(SemCount > 255)
489:                       SemCount = 255;
490:                    return SemCount;
491:                 }
0000001C  00000000   NOP
492:                 
493:                 // *****************************************************************************
494:                 /* Function: OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
495:                 
496:                   Summary:
497:                     Create a mutex.
498:                 
499:                   Description:
500:                     This function creates a mutex, allocating storage if required and placing
501:                     the mutex handle into the passed parameter.
502:                 
503:                   Precondition:
504:                     None.
505:                 
506:                   Parameters:
507:                     mutexID      - Pointer to the mutex handle
508:                 
509:                   Returns:
510:                     OSAL_RESULT_TRUE    - Mutex successfully created
511:                 
512:                     OSAL_RESULT_FALSE   - Mutex failed to be created.
513:                 
514:                   Example:
515:                     <code>
516:                     OSAL_MUTEX_HANDLE_TYPE mutexData;
517:                 
518:                     OSAL_MUTEX_Create(&mutexData);
519:                     ...
520:                      if (OSAL_MUTEX_Lock(mutexData, 1000) == OSAL_RESULT_TRUE)
521:                      {
522:                         // manipulate the shared data
523:                         ...
524:                      }
525:                     </code>
526:                 
527:                   Remarks:
528:                 
529:                  */
530:                 OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
531:                 {
9D00D438  27BDFFE8   ADDIU SP, SP, -24
9D00D43C  AFBF0014   SW RA, 20(SP)
9D00D440  AFB00010   SW S0, 16(SP)
9D00D444  00808021   ADDU S0, A0, ZERO
532:                     /* mutex may already have been created so test before creating it */
533:                     if (*(SemaphoreHandle_t*)mutexID != NULL)
9D00D448  8C830000   LW V1, 0(A0)
9D00D44C  14600005   BNE V1, ZERO, 0x9D00D464
9D00D450  00001021   ADDU V0, ZERO, ZERO
534:                     {
535:                         return OSAL_RESULT_FALSE;
536:                     }
537:                 
538:                     *(SemaphoreHandle_t*)mutexID = xSemaphoreCreateMutex();
9D00D454  0F402F7D   JAL xQueueCreateMutex
9D00D458  24040001   ADDIU A0, ZERO, 1
9D00D45C  AE020000   SW V0, 0(S0)
539:                     return OSAL_RESULT_TRUE;
9D00D460  24020001   ADDIU V0, ZERO, 1
540:                 }
9D00D464  8FBF0014   LW RA, 20(SP)
9D00D468  8FB00010   LW S0, 16(SP)
9D00D46C  03E00008   JR RA
9D00D470  27BD0018   ADDIU SP, SP, 24
541:                 
542:                 // *****************************************************************************
543:                 /* Function: OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
544:                 
545:                   Summary:
546:                     Delete a mutex.
547:                 
548:                   Description:
549:                     This function deletes a mutex and frees associated storage if required.
550:                 
551:                   Precondition:
552:                     None.
553:                 
554:                   Parameters:
555:                     mutexID      - Pointer to the mutex handle
556:                 
557:                   Returns:
558:                     OSAL_RESULT_TRUE    - Mutex successfully deleted.
559:                 
560:                     OSAL_RESULT_FALSE   - Mutex failed to be deleted.
561:                 
562:                   Example:
563:                     <code>
564:                     OSAL_MUTEX_Delete(mutexData);
565:                     </code>
566:                 
567:                   Remarks:
568:                 
569:                  */
570:                 OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
571:                 {
00000000  00000000   NOP
572:                     if(*(SemaphoreHandle_t*)mutexID == NULL)
00000010  00000000   NOP
573:                     {
574:                        return OSAL_RESULT_FALSE;
575:                     }
576:                     vSemaphoreDelete(*(SemaphoreHandle_t*)mutexID);
0000001C  00000000   NOP
577:                     *(SemaphoreHandle_t*)mutexID = NULL;
00000024  00000000   NOP
578:                     return OSAL_RESULT_TRUE;
579:                 }
0000002C  00000000   NOP
580:                 
581:                 // *****************************************************************************
582:                 /* Function: OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
583:                 
584:                   Summary:
585:                     Lock a mutex.
586:                 
587:                   Description:
588:                     This function locks a mutex, waiting for the specified timeout. If it cannot
589:                     be obtained or the timeout period elapses then false is returned;
590:                 
591:                   Precondition:
592:                     None.
593:                 
594:                   Parameters:
595:                     mutexID      - The mutex handle
596:                 
597:                     waitMS       - Timeout value in milliseconds,
598:                                    0 - do not wait, return immediately
599:                                    OSAL_WAIT_FOREVER - wait until mutex is obtained before returning
600:                                    Other values - Timeout delay
601:                 
602:                   Returns:
603:                     OSAL_RESULT_TRUE    - Mutex successfully obtained.
604:                 
605:                     OSAL_RESULT_FALSE   - Mutex failed to be obtained or timeout occurred.
606:                 
607:                   Example:
608:                     <code>
609:                     OSAL_MUTEX_HANDLE_TYPE* mutexData;
610:                 
611:                     OSAL_MUTEX_Create(&mutexData);
612:                     ...
613:                      if (OSAL_MUTEX_Lock(mutexData, 1000) == OSAL_RESULT_TRUE)
614:                      {
615:                         // manipulate the shared data
616:                         ...
617:                 
618:                         // unlock the mutex
619:                         OSAL_MUTEX_Unlock(mutexData);
620:                      }
621:                     </code>
622:                 
623:                   Remarks:
624:                 
625:                  */
626:                 OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
627:                 {
9D00D1EC  27BDFFE8   ADDIU SP, SP, -24
9D00D1F0  AFBF0014   SW RA, 20(SP)
9D00D1F4  30A5FFFF   ANDI A1, A1, -1
628:                    TickType_t timeout = 0;
629:                    
630:                    if(waitMS == OSAL_WAIT_FOREVER)
631:                    {
632:                       timeout = portMAX_DELAY;
633:                    }
634:                    else
635:                    {
636:                       timeout = (TickType_t)(waitMS / portTICK_PERIOD_MS);
9D00D1F8  00051882   SRL V1, A1, 2
9D00D1FC  38A5FFFF   XORI A1, A1, -1
9D00D200  2402FFFF   ADDIU V0, ZERO, -1
9D00D204  00403021   ADDU A2, V0, ZERO
9D00D208  0065300B   MOVN A2, V1, A1
637:                    }
638:                    if (xSemaphoreTake(*(SemaphoreHandle_t*)mutexID, timeout) == pdTRUE)
9D00D20C  8C840000   LW A0, 0(A0)
9D00D210  00002821   ADDU A1, ZERO, ZERO
9D00D214  0F40165D   JAL xQueueGenericReceive
9D00D218  00003821   ADDU A3, ZERO, ZERO
9D00D21C  38420001   XORI V0, V0, 1
639:                       return OSAL_RESULT_TRUE;
640:                    else
641:                       return OSAL_RESULT_FALSE;
642:                 }
9D00D220  2C420001   SLTIU V0, V0, 1
9D00D224  8FBF0014   LW RA, 20(SP)
9D00D228  03E00008   JR RA
9D00D22C  27BD0018   ADDIU SP, SP, 24
643:                 
644:                 // *****************************************************************************
645:                 /* Function: OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
646:                 
647:                   Summary:
648:                     Unlock a mutex.
649:                 
650:                   Description:
651:                     This function unlocks a previously obtained mutex.
652:                 
653:                   Precondition:
654:                     None.
655:                 
656:                   Parameters:
657:                     mutexID      - The mutex handle
658:                 
659:                   Returns:
660:                     OSAL_RESULT_TRUE    - Mutex released.
661:                 
662:                     OSAL_RESULT_FALSE   - Mutex failed to be released or error occurred.
663:                 
664:                   Example:
665:                     <code>
666:                     OSAL_MUTEX_HANDLE_TYPE* mutexData;
667:                 
668:                     OSAL_MUTEX_Create(&mutexData);
669:                     ...
670:                      if (OSAL_MUTEX_Lock(mutexData, 1000) == OSAL_RESULT_TRUE)
671:                      {
672:                         // manipulate the shared data
673:                         ...
674:                 
675:                         // unlock the mutex
676:                         OSAL_MUTEX_Unlock(mutexData);
677:                      }
678:                     </code>
679:                 
680:                   Remarks:
681:                 
682:                  */
683:                 OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
684:                 {
9D00D78C  27BDFFE8   ADDIU SP, SP, -24
9D00D790  AFBF0014   SW RA, 20(SP)
685:                 
686:                    if (xSemaphoreGive(*(SemaphoreHandle_t*)mutexID) == pdTRUE)
9D00D794  8C840000   LW A0, 0(A0)
9D00D798  00002821   ADDU A1, ZERO, ZERO
9D00D79C  00003021   ADDU A2, ZERO, ZERO
9D00D7A0  0F40199A   JAL xQueueGenericSend
9D00D7A4  00003821   ADDU A3, ZERO, ZERO
9D00D7A8  38420001   XORI V0, V0, 1
687:                    {
688:                       return OSAL_RESULT_TRUE;
689:                    }
690:                 
691:                    return OSAL_RESULT_FALSE;
692:                 }
9D00D7AC  2C420001   SLTIU V0, V0, 1
9D00D7B0  8FBF0014   LW RA, 20(SP)
9D00D7B4  03E00008   JR RA
9D00D7B8  27BD0018   ADDIU SP, SP, 24
693:                 
694:                 // *****************************************************************************
695:                 /* Function: const char* OSAL_Name()
696:                 
697:                   Summary:
698:                     Obtain the name of the underlying RTOS.
699:                 
700:                   Description:
701:                     This function returns a const char* to the textual name of the RTOS.
702:                     The name is a NULL terminated string.
703:                 
704:                   Precondition:
705:                     None
706:                 
707:                   Parameters:
708:                     None
709:                 
710:                   Returns:
711:                     const char* -   Name of the underlying RTOS or NULL
712:                 
713:                   Example:
714:                     <code>
715:                     // get the RTOS name
716:                     const char* sName;
717:                 
718:                     sName = OSAL_Name();
719:                     sprintf(buff, "RTOS: %s", sName);
720:                     </code>
721:                 
722:                   Remarks:
723:                 
724:                  */
725:                 const char* __attribute__ ((always_inline)) OSAL_Name(void)
726:                 {
727:                     return "FreeRTOS";
728:                 }
729:                 
730:                 
731:                 // *****************************************************************************
732:                 /* Function: OSAL_RESULT OSAL_Initialize()
733:                 
734:                   Summary:
735:                     Perform OSAL initialization.
736:                 
737:                   Description:
738:                      This function should be called near the start of main in an application
739:                      that will use an underlying RTOS. This permits the RTOS to perform
740:                      any one time initialization before the application attempts to create
741:                      drivers or other items that may use the RTOS. Typical actions performed by
742:                      OSAL_Initialize would be to allocate and prepare any memory pools for
743:                      later use.
744:                 
745:                   Precondition:
746:                     None.
747:                 
748:                   Parameters:
749:                     None.
750:                 
751:                   Returns:
752:                     OSAL_RESULT_TRUE  - Initialization completed successfully.
753:                 
754:                   Example:
755:                     <code>
756:                      int main()
757:                      {
758:                          OSAL_Initialize();
759:                 
760:                          App_Init();
761:                          OSAL_Start();
762:                      }
763:                     </code>
764:                 
765:                   Remarks:
766:                  */
767:                 OSAL_RESULT OSAL_Initialize()
768:                 {
769:                     // nothing required
770:                     return OSAL_RESULT_TRUE;
771:                 }
00000000  00000000   NOP
772:                 
773:                 /*******************************************************************************
774:                  End of File
775:                 */
776:                 
777:                 
---  c:/microchip/harmony/v1_08_01/framework/driver/usart/src/dynamic/drv_usart_byte_model.c  -----------
1:                   /********************************************************************************
2:                     USART Driver Dynamic implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart_byte_model.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver dynamic implementation.
12:                  
13:                    Description:
14:                      This file contains the source code for the dynamic implementation of the
15:                      USART driver's byte model functionality.
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute Software
23:                  only when embedded on a Microchip microcontroller or digital  signal  controller
24:                  that is integrated into your product or third party  product  (pursuant  to  the
25:                  sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
31:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
35:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
37:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
38:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #include "driver/usart/src/drv_usart_local.h"
44:                  
45:                  // *****************************************************************************
46:                  /* Function:
47:                      void DRV_USART_WriteByte( const DRV_HANDLE handle, const uint8_t byte)
48:                  
49:                    Summary:
50:                      Dynamic implementation of DRV_USART_WriteByte client interface function.
51:                  
52:                    Description:
53:                      This is the dynamic implementation of DRV_USART_WriteByte client
54:                      interface function.
55:                  
56:                    Remarks:
57:                      See drv_usart.h for usage information.
58:                  */
59:                  
60:                  void DRV_USART_WriteByte( const DRV_HANDLE handle, const uint8_t byte)
61:                  {
9D0088B4  27BDFFE0   ADDIU SP, SP, -32
9D0088B8  AFBF001C   SW RA, 28(SP)
9D0088BC  AFB20018   SW S2, 24(SP)
9D0088C0  AFB10014   SW S1, 20(SP)
9D0088C4  AFB00010   SW S0, 16(SP)
62:                      DRV_USART_CLIENT_OBJ * client;
63:                      DRV_USART_OBJ * hDriver;
64:                  
65:                      /* Validate the client handle */
66:                      client = _DRV_USART_DriverHandleValidate(handle);
9D0088C8  0F40365C   JAL _DRV_USART_DriverHandleValidate
9D0088CC  30B200FF   ANDI S2, A1, 255
67:                  
68:                      if(client == NULL)
9D0088D0  10400045   BEQ V0, ZERO, 0x9D0089E8
9D0088D4  8FBF001C   LW RA, 28(SP)
69:                      {
70:                          SYS_DEBUG(0, "Invalid Driver Handle");
71:                          return;
72:                      }
73:                  
74:                      hDriver = client->hDriver;
9D0088D8  8C500000   LW S0, 0(V0)
75:                  
76:                      /* This function needs to be thread safe */
77:                  
78:                      if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
9D0088DC  26110030   ADDIU S1, S0, 48
9D0088E0  02202021   ADDU A0, S1, ZERO
9D0088E4  0F40347B   JAL OSAL_MUTEX_Lock
9D0088E8  3405FFFF   ORI A1, ZERO, -1
9D0088EC  24030001   ADDIU V1, ZERO, 1
9D0088F0  1443003D   BNE V0, V1, 0x9D0089E8
9D0088F4  8FBF001C   LW RA, 28(SP)
79:                      {
80:                          /* Send one byte */
81:                          PLIB_USART_TransmitterByteSend(hDriver->moduleId, byte);
82:                          _DRV_USART_InterruptSourceEnable(hDriver->txInterruptSource);
9D00894C  8E020024   LW V0, 36(S0)
9D008990  0B402254   J DRV_USART_WriteByte::PLIB_INT_SourceEnable
9D008994  8E020024   LW V0, 36(S0)
9D0089A4  0B402254   J DRV_USART_WriteByte::PLIB_INT_SourceEnable
9D0089A8  8E020024   LW V0, 36(S0)
9D0089B8  0B402254   J DRV_USART_WriteByte::PLIB_INT_SourceEnable
9D0089BC  8E020024   LW V0, 36(S0)
9D0089CC  0B402254   J DRV_USART_WriteByte::PLIB_INT_SourceEnable
9D0089D0  8E020024   LW V0, 36(S0)
9D0089E0  0B402254   J DRV_USART_WriteByte::PLIB_INT_SourceEnable
9D0089E4  8E020024   LW V0, 36(S0)
83:                          OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
9D008974  0F4035E3   JAL OSAL_MUTEX_Unlock
9D008978  02202021   ADDU A0, S1, ZERO
9D00897C  0B40227A   J 0x9D0089E8
9D008980  8FBF001C   LW RA, 28(SP)
84:                      }
85:                      else
86:                      {
87:                          SYS_DEBUG(0, "Hardware Instance Mutex Time out in DRV_USART_WriteByte() function");
88:                      }
89:                  }
9D0089E8  8FB20018   LW S2, 24(SP)
9D0089EC  8FB10014   LW S1, 20(SP)
9D0089F0  8FB00010   LW S0, 16(SP)
9D0089F4  03E00008   JR RA
9D0089F8  27BD0020   ADDIU SP, SP, 32
90:                  
91:                  // *****************************************************************************
92:                  /* Function:
93:                      void DRV_USART_ReadByte( const DRV_HANDLE handle)
94:                  
95:                    Summary:
96:                      Dynamic implementation of DRV_USART_ReadByte client interface function.
97:                  
98:                    Description:
99:                      This is the dynamic implementation of DRV_USART_ReadByte client
100:                     interface function.
101:                 
102:                   Remarks:
103:                     See drv_usart.h for usage information.
104:                 */
105:                 
106:                 uint8_t DRV_USART_ReadByte( const DRV_HANDLE handle )
107:                 {
00000000  00000000   NOP
108:                     DRV_USART_CLIENT_OBJ * client;
109:                     DRV_USART_OBJ * hDriver;
110:                     uint8_t readValue;
111:                 
112:                     /* Validate the client handle */
113:                     client = _DRV_USART_DriverHandleValidate(handle);
0000000C  00000000   NOP
114:                 
115:                     if(client == NULL)
00000014  00000000   NOP
116:                     {
117:                         SYS_DEBUG(0, "Invalid Driver Handle");
118:                         return 0;
119:                     }
120:                 
121:                     hDriver = client->hDriver;
0000001C  00000000   NOP
122:                 
123:                     /* This function needs to be thread safe */
124:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
00000020  00000000   NOP
125:                     {
126:                         /* Read one byte */
127:                         readValue = PLIB_USART_ReceiverByteReceive(hDriver->moduleId);
00000094  00000000   NOP
128:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
00000098  00000000   NOP
129:                     }
130:                     else
131:                     {
132:                         SYS_DEBUG(0, "Hardware Instance Mutex Time out in DRV_USART_ReadByte() function");
133:                         return 0;
134:                     }
135:                 	return readValue;
000000A0  00000000   NOP
136:                 }
000000F8  00000000   NOP
137:                 
138:                 // *****************************************************************************
139:                 /* Function:
140:                     void DRV_USART_ReceiverBufferSizeGet( const DRV_HANDLE handle)
141:                 
142:                   Summary:
143:                     Dynamic implementation of DRV_USART_ReceiverBufferSizeGet client interface
144:                     function.
145:                 
146:                   Description:
147:                     This is the dynamic implementation of DRV_USART_ReceiverBufferSizeGet client
148:                     interface function.
149:                 
150:                   Remarks:
151:                     See drv_usart.h for usage information.
152:                 */
153:                 
154:                 unsigned int DRV_USART_ReceiverBufferSizeGet (const DRV_HANDLE handle )
155:                 {
00000000  00000000   NOP
156:                     DRV_USART_CLIENT_OBJ * client;
157:                 
158:                     /* Validate the client handle */
159:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
160:                 
161:                     if(client == NULL)
162:                     {
163:                         SYS_DEBUG(0, "Invalid Driver Handle");
164:                         return 0;
165:                     }
166:                 
167:                     return 8;
168:                 
169:                 }
00000010  00000000   NOP
170:                 
171:                 // *****************************************************************************
172:                 /* Function:
173:                     void DRV_USART_TransmitBufferSizeGet( const DRV_HANDLE handle)
174:                 
175:                   Summary:
176:                     Dynamic implementation of DRV_USART_TransmitBufferSizeGet client interface
177:                     function.
178:                 
179:                   Description:
180:                     This is the dynamic implementation of DRV_USART_TransmitBufferSizeGet client
181:                     interface function.
182:                 
183:                   Remarks:
184:                     See drv_usart.h for usage information.
185:                 */
186:                 
187:                 unsigned int DRV_USART_TransmitBufferSizeGet( const DRV_HANDLE handle )
188:                 {
00000000  00000000   NOP
189:                     DRV_USART_CLIENT_OBJ * client;
190:                 
191:                     /* Validate the client handle */
192:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
193:                 
194:                     if(client == NULL)
195:                     {
196:                         SYS_DEBUG(0, "Invalid Driver Handle");
197:                         return 0;
198:                     }
199:                 
200:                     return 8;
201:                 
202:                 }
00000010  00000000   NOP
203:                 
204:                 // *****************************************************************************
205:                 /* Function:
206:                     void DRV_USART_ReceiverBufferIsEmpty( const DRV_HANDLE handle)
207:                 
208:                   Summary:
209:                     Dynamic implementation of DRV_USART_ReceiverBufferIsEmpty client interface
210:                     function.
211:                 
212:                   Description:
213:                     This is the dynamic implementation of DRV_USART_ReceiverBufferIsEmpty client
214:                     interface function.
215:                 
216:                   Remarks:
217:                     See drv_usart.h for usage information.
218:                 */
219:                 
220:                 bool DRV_USART_ReceiverBufferIsEmpty( const DRV_HANDLE handle )
221:                 {
00000000  00000000   NOP
222:                     DRV_USART_CLIENT_OBJ * client;
223:                     DRV_USART_OBJ * hDriver;
224:                 
225:                     /* Validate the client handle */
226:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
227:                 
228:                     if(client == NULL)
00000010  00000000   NOP
229:                     {
230:                         SYS_DEBUG(0, "Invalid Driver Handle");
231:                         return false;
232:                     }
233:                 
234:                     hDriver = client->hDriver;
235:                 
236:                     /* If there is data available in the receiver, then this function
237:                        buffer is not empty and this function returns false. */
238:                 
239:                     return(PLIB_USART_ReceiverDataIsAvailable(hDriver->moduleId) ? false : true);
00000018  00000000   NOP
240:                 }
000000C8  00000000   NOP
241:                 
242:                 // *****************************************************************************
243:                 /* Function:
244:                     void DRV_USART_TransmitBufferIsFull( const DRV_HANDLE handle)
245:                 
246:                   Summary:
247:                     Dynamic implementation of DRV_USART_TransmitBufferIsFull client interface
248:                     function.
249:                 
250:                   Description:
251:                     This is the dynamic implementation of DRV_USART_TransmitBufferIsFull client
252:                     interface function.
253:                 
254:                   Remarks:
255:                     See drv_usart.h for usage information.
256:                 */
257:                 
258:                 bool DRV_USART_TransmitBufferIsFull( const DRV_HANDLE handle )
259:                 {
00000000  00000000   NOP
260:                     DRV_USART_CLIENT_OBJ * client;
261:                     DRV_USART_OBJ * hDriver;
262:                 
263:                     /* Validate the client handle */
264:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
265:                 
266:                     if(client == NULL)
00000010  00000000   NOP
267:                     {
268:                         SYS_DEBUG(0, "Invalid Driver Handle");
269:                         return false;
270:                     }
271:                 
272:                     hDriver = client->hDriver;
273:                 
274:                     /* If there is data available in the receiver, then this function
275:                        buffer is not empty and this function returns false. */
276:                 
277:                     return(PLIB_USART_TransmitterBufferIsFull(hDriver->moduleId));
00000018  00000000   NOP
278:                 }
000000C0  00000000   NOP
279:                 
---  c:/microchip/harmony/v1_08_01/framework/driver/usart/src/dynamic/drv_usart.c  ----------------------
1:                   /********************************************************************************
2:                     USART Driver Dynamic implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver dynamic implementation.
12:                  
13:                    Description:
14:                      This file contains the source code for the dynamic implementation of the
15:                      USART driver.
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute Software
23:                  only when embedded on a Microchip microcontroller or digital  signal  controller
24:                  that is integrated into your product or third party  product  (pursuant  to  the
25:                  sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
31:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
35:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
37:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
38:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "driver/usart/src/drv_usart_local.h"
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /* This is the driver instance object array. */
58:                  DRV_USART_OBJ gDrvUSARTObj[DRV_USART_INSTANCES_NUMBER] ;
59:                  
60:                  /* This is the client object array. */
61:                  DRV_USART_CLIENT_OBJ gDrvUSARTClientObj[DRV_USART_CLIENTS_NUMBER];
62:                  
63:                  /* This object maintains data that is required by all USART
64:                     driver instances. */
65:                  DRV_USART_COMMON_DATA_OBJ gDrvUSARTCommonDataObj;
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: USART Driver Interface Implementations
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  // *****************************************************************************
74:                  /* Function:
75:                      SYS_MODULE_OBJ DRV_USART_Initialize
76:                      (
77:                          const SYS_MODULE_INDEX drvIndex,
78:                          const SYS_MODULE_INIT * const init
79:                      )
80:                  
81:                    Summary:
82:                      Dynamic implementation of DRV_USART_Initialize system interface function.
83:                  
84:                    Description:
85:                      This is the dynamic implementation of DRV_USART_Initialize system interface
86:                      function.
87:                  
88:                    Remarks:
89:                      See drv_usart.h for usage information.
90:                  */
91:                  
92:                  SYS_MODULE_OBJ DRV_USART_Initialize
93:                  (
94:                      const SYS_MODULE_INDEX drvIndex,
95:                      const SYS_MODULE_INIT * const init
96:                  )
97:                  {
9D00484C  27BDFFD8   ADDIU SP, SP, -40
9D004850  AFBF0024   SW RA, 36(SP)
9D004854  AFB30020   SW S3, 32(SP)
9D004858  AFB2001C   SW S2, 28(SP)
9D00485C  AFB10018   SW S1, 24(SP)
9D004860  AFB00014   SW S0, 20(SP)
9D004864  3090FFFF   ANDI S0, A0, -1
98:                      DRV_USART_OBJ *dObj = (DRV_USART_OBJ*)NULL;
99:                      DRV_USART_INIT *usartInit = NULL ;
100:                 
101:                     /* Check if the specified driver index is in valid range */
102:                     if(drvIndex >= DRV_USART_INSTANCES_NUMBER)
9D004868  2E020002   SLTIU V0, S0, 2
9D00486C  104000DA   BEQ V0, ZERO, 0x9D004BD8
9D004870  2403FFFF   ADDIU V1, ZERO, -1
103:                     {
104:                         SYS_DEBUG(0, "Invalid driver index");
105:                         return SYS_MODULE_OBJ_INVALID;
106:                     }
107:                 
108:                     /* Check if this hardware instance was already initialized */
109:                     if(gDrvUSARTObj[drvIndex].inUse != false)
9D004874  00101140   SLL V0, S0, 5
9D004878  001019C0   SLL V1, S0, 7
9D00487C  00621023   SUBU V0, V1, V0
9D004880  3C03A000   LUI V1, -24576
9D004884  24630B00   ADDIU V1, V1, 2816
9D004888  00431021   ADDU V0, V0, V1
9D00488C  90420014   LBU V0, 20(V0)
9D004890  144000D1   BNE V0, ZERO, 0x9D004BD8
9D004894  2403FFFF   ADDIU V1, ZERO, -1
110:                     {
111:                         SYS_DEBUG(0, "Instance already in use");
112:                         return SYS_MODULE_OBJ_INVALID;
113:                     }
114:                 
115:                     /* Assign to the local pointer the init data passed */
116:                     usartInit = ( DRV_USART_INIT * ) init ;
117:                 
118:                     /* Disable the USART module */
119:                     PLIB_USART_Disable (usartInit->usartID) ;
120:                 
121:                     /* Allocate the driver object and set the operation flag to be in use */
122:                     dObj = &gDrvUSARTObj[drvIndex];
9D0048F0  00101140   SLL V0, S0, 5
9D0048F4  001019C0   SLL V1, S0, 7
9D0048F8  00621023   SUBU V0, V1, V0
9D0048FC  3C12A000   LUI S2, -24576
9D004900  26520B00   ADDIU S2, S2, 2816
9D004904  02429021   ADDU S2, S2, V0
9D004AF8  0B40123D   J 0x9D0048F4
9D004AFC  00101140   SLL V0, S0, 5
9D004B10  0B40123D   J 0x9D0048F4
9D004B14  00101140   SLL V0, S0, 5
9D004B28  0B40123D   J 0x9D0048F4
9D004B2C  00101140   SLL V0, S0, 5
9D004B40  0B40123D   J 0x9D0048F4
9D004B44  00101140   SLL V0, S0, 5
9D004B58  0B40123D   J 0x9D0048F4
9D004B5C  00101140   SLL V0, S0, 5
123:                     dObj->inUse = true;
9D004908  24020001   ADDIU V0, ZERO, 1
9D00490C  A2420014   SB V0, 20(S2)
124:                 
125:                     /* Update the USART PLIB Id and other parameters. */
126:                 
127:                     dObj->nClients              = 0;
9D004910  AE400018   SW ZERO, 24(S2)
128:                     dObj->moduleId              = usartInit->usartID;
9D004914  8E220004   LW V0, 4(S1)
9D004918  AE420000   SW V0, 0(S2)
129:                     dObj->brgClock              = usartInit->brgClock;
9D00491C  8E220014   LW V0, 20(S1)
9D004920  AE42001C   SW V0, 28(S2)
130:                     dObj->isExclusive           = false;
9D004924  A2400015   SB ZERO, 21(S2)
131:                     dObj->queueSizeRead         = usartInit->queueSizeReceive;
9D004928  8E220030   LW V0, 48(S1)
9D00492C  AE420034   SW V0, 52(S2)
132:                     dObj->queueSizeWrite        = usartInit->queueSizeTransmit;
9D004930  8E220034   LW V0, 52(S1)
9D004934  AE420038   SW V0, 56(S2)
133:                     dObj->dmaChannelRead        = usartInit->dmaChannelReceive;
9D004938  8E22003C   LW V0, 60(S1)
9D00493C  AE420044   SW V0, 68(S2)
134:                     dObj->dmaChannelWrite       = usartInit->dmaChannelTransmit;
9D004940  8E220038   LW V0, 56(S1)
9D004944  AE420048   SW V0, 72(S2)
135:                     dObj->txInterruptSource     = usartInit->interruptTransmit;
9D004948  8E220024   LW V0, 36(S1)
9D00494C  AE420024   SW V0, 36(S2)
136:                     dObj->rxInterruptSource     = usartInit->interruptReceive;
9D004950  8E220028   LW V0, 40(S1)
9D004954  AE420028   SW V0, 40(S2)
137:                     dObj->errorInterruptSource  = usartInit->interruptError;
9D004958  8E22002C   LW V0, 44(S1)
9D00495C  AE42002C   SW V0, 44(S2)
138:                     dObj->dmaInterruptTransmit  = usartInit->dmaInterruptTransmit;
9D004960  8E220040   LW V0, 64(S1)
9D004964  AE42004C   SW V0, 76(S2)
139:                     dObj->dmaInterruptReceive   = usartInit->dmaInterruptReceive;
9D004968  8E220044   LW V0, 68(S1)
9D00496C  AE420050   SW V0, 80(S2)
140:                     dObj->interruptNestingCount = 0;
9D004970  AE400020   SW ZERO, 32(S2)
141:                     dObj->queueSizeCurrentRead  = 0;
9D004974  AE40003C   SW ZERO, 60(S2)
142:                     dObj->queueSizeCurrentWrite = 0;
9D004978  AE400040   SW ZERO, 64(S2)
143:                     dObj->queueRead             = NULL;
9D00497C  AE400008   SW ZERO, 8(S2)
144:                     dObj->queueWrite            = NULL;
9D004980  AE400004   SW ZERO, 4(S2)
145:                     dObj->transmitCallback      = NULL;
9D004984  AE400054   SW ZERO, 84(S2)
146:                     dObj->receiveCallback       = NULL;
9D004988  AE400058   SW ZERO, 88(S2)
147:                     dObj->errorCallback         = NULL;
9D00498C  AE40005C   SW ZERO, 92(S2)
148:                     dObj->operationMode         = usartInit->mode;
9D004990  8E220008   LW V0, 8(S1)
9D004994  AE420010   SW V0, 16(S2)
149:                 
150:                     /* Setup the Hardware */
151:                     _DRV_USART_HardwareSetup(usartInit->usartID, usartInit ) ;
9D004998  8E240004   LW A0, 4(S1)
9D00499C  0F400509   JAL _DRV_USART_HardwareSetup
9D0049A0  02202821   ADDU A1, S1, ZERO
152:                 
153:                     /* Clear the interrupts */
154:                     SYS_INT_SourceStatusClear(dObj->txInterruptSource);
9D0049A4  8E430024   LW V1, 36(S2)
155:                     SYS_INT_SourceStatusClear(dObj->rxInterruptSource);
9D0049CC  8E430028   LW V1, 40(S2)
156:                     SYS_INT_SourceStatusClear(dObj->errorInterruptSource);
9D0049E8  8E45002C   LW A1, 44(S2)
157:                 
158:                     /* Enable the interrupt source in case of interrupt mode */
159:                     _DRV_USART_InterruptSourceEnable(dObj->errorInterruptSource);
160:                 
161:                     _DRV_USART_ByteModelInterruptSourceEnable(dObj->rxInterruptSource);
162:                 
163:                     /* TODO: Enable DMA interrupts if the DMA channel is selected */
164:                 
165:                     /* Create the hardware instance mutex. */
166:                      if(OSAL_MUTEX_Create(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
9D004A24  0F40350E   JAL OSAL_MUTEX_Create
9D004A28  26440030   ADDIU A0, S2, 48
9D004A2C  1453006A   BNE V0, S3, 0x9D004BD8
9D004A30  2403FFFF   ADDIU V1, ZERO, -1
167:                      {
168:                                  return SYS_MODULE_OBJ_INVALID;
169:                      }
170:                 
171:                     /* Check if the global mutexes have been created. If not
172:                        then create these. */
173:                 
174:                      if(!gDrvUSARTCommonDataObj.membersAreInitialized)
9D004A34  3C02A000   LUI V0, -24576
9D004A38  90420A10   LBU V0, 2576(V0)
9D004A3C  54400011   BNEL V0, ZERO, 0x9D004A84
9D004A40  8E220004   LW V0, 4(S1)
175:                      {
176:                          /* This means that mutexes where not created. Create them. */
177:                         if(OSAL_MUTEX_Create(&(gDrvUSARTCommonDataObj.mutexClientObjects)) != OSAL_RESULT_TRUE)
9D004A44  3C04A000   LUI A0, -24576
9D004A48  0F40350E   JAL OSAL_MUTEX_Create
9D004A4C  24840A14   ADDIU A0, A0, 2580
9D004A50  24040001   ADDIU A0, ZERO, 1
9D004A54  14440060   BNE V0, A0, 0x9D004BD8
9D004A58  2403FFFF   ADDIU V1, ZERO, -1
178:                         {
179:                                  return SYS_MODULE_OBJ_INVALID;
180:                         }
181:                         if(OSAL_MUTEX_Create(&(gDrvUSARTCommonDataObj.mutexBufferQueueObjects)) != OSAL_RESULT_TRUE)
9D004A5C  3C04A000   LUI A0, -24576
9D004A60  0F40350E   JAL OSAL_MUTEX_Create
9D004A64  24840A18   ADDIU A0, A0, 2584
9D004A68  24040001   ADDIU A0, ZERO, 1
9D004A6C  1444005A   BNE V0, A0, 0x9D004BD8
9D004A70  2403FFFF   ADDIU V1, ZERO, -1
182:                         {
183:                                  return SYS_MODULE_OBJ_INVALID;
184:                         }
185:                          /* Set this flag so that global mutexes get allocated only once */
186:                          gDrvUSARTCommonDataObj.membersAreInitialized = true;
9D004A74  24030001   ADDIU V1, ZERO, 1
9D004A78  3C02A000   LUI V0, -24576
9D004A7C  A0430A10   SB V1, 2576(V0)
187:                      }
188:                 
189:                     /* Enable the USART module */
190:                     PLIB_USART_Enable(usartInit->usartID) ;
191:                 
192:                     /* Update the status */
193:                     dObj->status = SYS_STATUS_READY;
9D004AD8  24020002   ADDIU V0, ZERO, 2
9D004ADC  AE42000C   SW V0, 12(S2)
9D004B70  0B4012B7   J 0x9D004ADC
9D004B74  24020002   ADDIU V0, ZERO, 2
9D004B88  0B4012B7   J 0x9D004ADC
9D004B8C  24020002   ADDIU V0, ZERO, 2
9D004BA0  0B4012B7   J 0x9D004ADC
9D004BA4  24020002   ADDIU V0, ZERO, 2
9D004BB8  0B4012B7   J 0x9D004ADC
9D004BBC  24020002   ADDIU V0, ZERO, 2
9D004BD0  0B4012B7   J 0x9D004ADC
9D004BD4  24020002   ADDIU V0, ZERO, 2
194:                 
195:                     /* Return the object structure */
196:                     return ( (SYS_MODULE_OBJ)drvIndex );
9D004AE0  0B4012F6   J 0x9D004BD8
9D004AE4  02001821   ADDU V1, S0, ZERO
197:                 }
9D004BD8  00601021   ADDU V0, V1, ZERO
9D004BDC  8FBF0024   LW RA, 36(SP)
9D004BE0  8FB30020   LW S3, 32(SP)
9D004BE4  8FB2001C   LW S2, 28(SP)
9D004BE8  8FB10018   LW S1, 24(SP)
9D004BEC  8FB00014   LW S0, 20(SP)
9D004BF0  03E00008   JR RA
9D004BF4  27BD0028   ADDIU SP, SP, 40
198:                 
199:                 // *****************************************************************************
200:                 /* Function:
201:                     void DRV_USART_Deinitialize( SYS_MODULE_OBJ object )
202:                 
203:                   Summary:
204:                     Dynamic implementation of DRV_USART_Deinitialize system interface function.
205:                 
206:                   Description:
207:                     This is the dynamic implementation of DRV_USART_Deinitialize system interface
208:                     function.
209:                 
210:                   Remarks:
211:                     See drv_usart.h for usage information.
212:                 */
213:                 
214:                 void  DRV_USART_Deinitialize(SYS_MODULE_OBJ object)
215:                 {
0000000C  00000000   NOP
216:                     DRV_USART_OBJ * dObj;
217:                     DRV_USART_BUFFER_OBJ * iterator;
218:                 
219:                     bool status;
220:                 
221:                     /* Check that the object is valid */
222:                 
223:                     if(object == SYS_MODULE_OBJ_INVALID)
224:                     {
225:                         SYS_DEBUG(0, "Invalid system object handle" );
226:                         return;
227:                     }
228:                 
229:                     if(object >= DRV_USART_INSTANCES_NUMBER)
00000000  00000000   NOP
230:                     {
231:                         SYS_DEBUG(0, "Invalid system object handle" );
232:                         return;
233:                     }
234:                 
235:                     dObj = (DRV_USART_OBJ*) &gDrvUSARTObj[object];
00000018  00000000   NOP
236:                 
237:                     if(!dObj->inUse)
0000002C  00000000   NOP
238:                     {
239:                         SYS_DEBUG(0, "Invalid system object handle");
240:                         return;
241:                     }
242:                 
243:                     /* The driver will not have clients when it is
244:                        being deinitialized. So the order in which
245:                        we do the following steps is not that important */
246:                 
247:                     /* Indicate that this object is not is use */
248:                     dObj->inUse = false;
00000038  00000000   NOP
249:                 
250:                     /* Deinitialize the USART status */
251:                     dObj->status =  SYS_STATUS_UNINITIALIZED ;
0000003C  00000000   NOP
252:                 
253:                     /* Disable the interrupt */
254:                     status = _DRV_USART_InterruptSourceDisable(dObj->txInterruptSource) ;
00000040  00000000   NOP
255:                     status = _DRV_USART_InterruptSourceDisable(dObj->rxInterruptSource) ;
00000048  00000000   NOP
256:                     status = _DRV_USART_InterruptSourceDisable(dObj->errorInterruptSource);
00000050  00000000   NOP
257:                 
258:                     /* Ignore the warning */
259:                     (void)status;
260:                 
261:                     /* Disable USART module */
262:                     PLIB_USART_Disable (dObj->moduleId);
263:                 
264:                     /* Deallocate all mutexes */
265:                     if(OSAL_MUTEX_Delete(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
000000AC  00000000   NOP
266:                     {
267:                         SYS_DEBUG(0, "Mutex Delete Failed");
268:                         return;
269:                     }
270:                 
271:                     /* TODO: Disable all DMA interrupts */
272:                 
273:                     /* Remove all objects from the read and write queue */
274:                 
275:                     iterator = dObj->queueWrite;
000000C0  00000000   NOP
276:                     while(iterator != NULL)
000000C4  00000000   NOP
000000D4  00000000   NOP
277:                     {
278:                         /* Return the buffer object to the pool */
279:                         iterator->inUse = false;
000000CC  00000000   NOP
280:                         iterator = iterator->next;
000000D0  00000000   NOP
281:                     }
282:                 
283:                     iterator = dObj->queueRead;
000000DC  00000000   NOP
284:                     while(iterator != NULL)
000000E0  00000000   NOP
000000F0  00000000   NOP
285:                     {
286:                         /* Return the buffer object to the pool */
287:                         iterator->inUse = false;
000000E8  00000000   NOP
288:                         iterator = iterator->next;
000000EC  00000000   NOP
289:                     }
290:                 }
00000178  00000000   NOP
291:                 
292:                 // *****************************************************************************
293:                 /* Function:
294:                     SYS_STATUS DRV_USART_Status( SYS_MODULE_OBJ object )
295:                 
296:                   Summary:
297:                     Dynamic implementation of DRV_USART_Status system interface function.
298:                 
299:                   Description:
300:                     This is the dynamic implementation of DRV_USART_Status system interface
301:                     function.
302:                 
303:                   Remarks:
304:                     See drv_usart.h for usage information.
305:                 */
306:                 
307:                 SYS_STATUS DRV_USART_Status( SYS_MODULE_OBJ object)
308:                 {
309:                     /* Check if we have a valid object */
310:                     if(object == SYS_MODULE_OBJ_INVALID)
311:                     {
312:                         SYS_DEBUG(0, "Invalid system object handle");
313:                         return(SYS_STATUS_UNINITIALIZED);
314:                     }
315:                 
316:                     if(object > DRV_USART_INSTANCES_NUMBER)
00000000  00000000   NOP
317:                     {
318:                         SYS_DEBUG(0, "Invalid system object handle");
319:                         return(SYS_STATUS_UNINITIALIZED);
320:                     }
321:                 
322:                     /* Return the system status of the hardware instance object */
323:                     return (gDrvUSARTObj[object].status);
0000000C  00000000   NOP
324:                 }
00000028  00000000   NOP
325:                 
326:                 // *****************************************************************************
327:                 /* Function:
328:                     DRV_HANDLE DRV_USART_Open( const SYS_MODULE_INDEX index,
329:                                                const DRV_IO_INTENT    ioIntent )
330:                 
331:                   Summary:
332:                     Dynamic implementation of DRV_USART_Open client interface function.
333:                 
334:                   Description:
335:                     This is the dynamic implementation of DRV_USART_Open client interface
336:                     function.
337:                 
338:                   Remarks:
339:                     See drv_usart.h for usage information.
340:                 */
341:                 
342:                 DRV_HANDLE DRV_USART_Open
343:                 (
344:                     const SYS_MODULE_INDEX drvIndex,
345:                     const DRV_IO_INTENT ioIntent
346:                 )
347:                 {
9D007D20  3084FFFF   ANDI A0, A0, -1
9D007D30  27BDFFE0   ADDIU SP, SP, -32
9D007D34  AFBF001C   SW RA, 28(SP)
9D007D38  AFB20018   SW S2, 24(SP)
9D007D3C  AFB10014   SW S1, 20(SP)
9D007D40  AFB00010   SW S0, 16(SP)
348:                     DRV_USART_CLIENT_OBJ *clientObj;
349:                     DRV_USART_OBJ *dObj;
350:                     unsigned int iClient;
351:                 
352:                     if (drvIndex >= DRV_USART_INSTANCES_NUMBER)
9D007D24  2C820002   SLTIU V0, A0, 2
9D007D28  10400065   BEQ V0, ZERO, 0x9D007EC0
9D007D2C  2403FFFF   ADDIU V1, ZERO, -1
353:                     {
354:                         /* Invalid driver index */
355:                         SYS_DEBUG(0, "Invalid Driver Instance");
356:                         return (DRV_HANDLE_INVALID);
357:                     }
358:                 
359:                     dObj = &gDrvUSARTObj[drvIndex];
9D007D44  00041140   SLL V0, A0, 5
9D007D48  000421C0   SLL A0, A0, 7
9D007D4C  00822023   SUBU A0, A0, V0
9D007D50  3C11A000   LUI S1, -24576
9D007D54  26310B00   ADDIU S1, S1, 2816
9D007D58  02248821   ADDU S1, S1, A0
360:                 
361:                     if((dObj->status != SYS_STATUS_READY) || (dObj->inUse == false))
9D007D5C  8E24000C   LW A0, 12(S1)
9D007D60  24020002   ADDIU V0, ZERO, 2
9D007D64  14820050   BNE A0, V0, 0x9D007EA8
9D007D68  00601021   ADDU V0, V1, ZERO
9D007D6C  92220014   LBU V0, 20(S1)
9D007D70  1040004D   BEQ V0, ZERO, 0x9D007EA8
9D007D74  00601021   ADDU V0, V1, ZERO
362:                     {
363:                         /* The USART module should be ready */
364:                 
365:                         SYS_DEBUG(0, "Was the driver initialized?");
366:                         return DRV_HANDLE_INVALID;
367:                     }
368:                 
369:                     if(dObj->isExclusive)
9D007D78  92220015   LBU V0, 21(S1)
9D007D7C  1440004A   BNE V0, ZERO, 0x9D007EA8
9D007D80  00601021   ADDU V0, V1, ZERO
370:                     {
371:                         /* This means the another client has opened the driver in exclusive
372:                            mode. The driver cannot be opened again */
373:                 
374:                         SYS_DEBUG(0, "Driver already opened exclusively");
375:                         return ( DRV_HANDLE_INVALID ) ;
376:                     }
377:                 
378:                     if((dObj->nClients > 0) && (ioIntent & DRV_IO_INTENT_EXCLUSIVE))
9D007D84  8E220018   LW V0, 24(S1)
9D007D88  10400004   BEQ V0, ZERO, 0x9D007D9C
9D007D8C  00A08021   ADDU S0, A1, ZERO
9D007D90  30A20008   ANDI V0, A1, 8
9D007D94  14400044   BNE V0, ZERO, 0x9D007EA8
9D007D98  00601021   ADDU V0, V1, ZERO
379:                     {
380:                         /* This means the driver was already opened and another driver was
381:                            trying to open it exclusively.  We cannot give exclusive access in
382:                            this case */
383:                 
384:                         SYS_DEBUG(0, "Driver already opened. Cannot be opened exclusively");
385:                         return(DRV_HANDLE_INVALID);
386:                     }
387:                 
388:                     /* Grab client object mutex here */
389:                 
390:                     if(OSAL_MUTEX_Lock(&(gDrvUSARTCommonDataObj.mutexClientObjects), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
9D007D9C  3C04A000   LUI A0, -24576
9D007DA0  24840A14   ADDIU A0, A0, 2580
9D007DA4  0F40347B   JAL OSAL_MUTEX_Lock
9D007DA8  3405FFFF   ORI A1, ZERO, -1
9D007DAC  24040001   ADDIU A0, ZERO, 1
9D007DB0  1444003C   BNE V0, A0, 0x9D007EA4
9D007DB4  2403FFFF   ADDIU V1, ZERO, -1
391:                     {
392:                         /* Enter here only if the lock was obtained (applicable in
393:                            RTOS only). If the mutex lock fails due to time out then
394:                            this code does not get executed */
395:                 
396:                         for(iClient = 0; iClient != DRV_USART_CLIENTS_NUMBER; iClient ++)
9D007DEC  24020001   ADDIU V0, ZERO, 1
397:                         {
398:                             if(!gDrvUSARTClientObj[iClient].inUse)
9D007DB8  3C02A000   LUI V0, -24576
9D007DBC  90420A24   LBU V0, 2596(V0)
9D007DC0  1040000B   BEQ V0, ZERO, 0x9D007DF0
9D007DC4  00001021   ADDU V0, ZERO, ZERO
9D007DC8  3C02A000   LUI V0, -24576
9D007DCC  90420A70   LBU V0, 2672(V0)
9D007DD0  10400006   BEQ V0, ZERO, 0x9D007DEC
9D007DD4  3C02A000   LUI V0, -24576
9D007DD8  90420ABC   LBU V0, 2748(V0)
9D007DDC  5440002E   BNEL V0, ZERO, 0x9D007E98
9D007DE0  3C04A000   LUI A0, -24576
9D007DE4  0B401F7C   J 0x9D007DF0
9D007DE8  24020002   ADDIU V0, ZERO, 2
399:                             {
400:                                 /* This means we have a free client object to use */
401:                                 clientObj = &gDrvUSARTClientObj[iClient];
9D007DF0  3C03A000   LUI V1, -24576
9D007DF4  24720A1C   ADDIU S2, V1, 2588
9D007DF8  2403004C   ADDIU V1, ZERO, 76
9D007DFC  70432002   MUL A0, V0, V1
9D007E00  00929021   ADDU S2, A0, S2
402:                                 clientObj->inUse        = true;
9D007E04  24020001   ADDIU V0, ZERO, 1
9D007E08  A2420008   SB V0, 8(S2)
403:                 
404:                                 /* We have found a client object. Release the mutex */
405:                 
406:                                 OSAL_MUTEX_Unlock(&(gDrvUSARTCommonDataObj.mutexClientObjects));
9D007E0C  3C04A000   LUI A0, -24576
9D007E10  0F4035E3   JAL OSAL_MUTEX_Unlock
9D007E14  24840A14   ADDIU A0, A0, 2580
407:                 
408:                                 clientObj->hDriver      = dObj;
9D007E18  AE510000   SW S1, 0(S2)
409:                 
410:                                 /* In a case where the driver is configured for polled
411:                                    and bare metal operation, it will not support blocking operation */
412:                 
413:                                 clientObj->ioIntent     = (ioIntent | _DRV_USART_ALWAYS_NON_BLOCKING);
9D007E1C  AE500004   SW S0, 4(S2)
414:                                 clientObj->eventHandler = NULL;
9D007E20  AE400034   SW ZERO, 52(S2)
415:                                 clientObj->context      = (uintptr_t)NULL;
9D007E24  AE400040   SW ZERO, 64(S2)
416:                                 clientObj->error        = DRV_USART_ERROR_NONE;
417:                 
418:                                 if(ioIntent & DRV_IO_INTENT_EXCLUSIVE)
9D007E28  32100008   ANDI S0, S0, 8
9D007E2C  12000003   BEQ S0, ZERO, 0x9D007E3C
9D007E30  AE400038   SW ZERO, 56(S2)
419:                                 {
420:                                     /* Set the driver exclusive flag */
421:                                     dObj->isExclusive = true;
9D007E34  24020001   ADDIU V0, ZERO, 1
9D007E38  A2220015   SB V0, 21(S1)
422:                                 }
423:                 
424:                                 dObj->nClients ++;
9D007E3C  8E220018   LW V0, 24(S1)
9D007E40  24420001   ADDIU V0, V0, 1
9D007E44  AE220018   SW V0, 24(S1)
425:                 
426:                                 /* Create the semaphores */
427:                                 if(OSAL_SEM_Create(&(clientObj->semReadDone), OSAL_SEM_TYPE_COUNTING, 1, 0) != OSAL_RESULT_TRUE)
9D007E48  26440044   ADDIU A0, S2, 68
9D007E4C  24050001   ADDIU A1, ZERO, 1
9D007E50  24060001   ADDIU A2, ZERO, 1
9D007E54  0F402D8F   JAL OSAL_SEM_Create
9D007E58  00003821   ADDU A3, ZERO, ZERO
9D007E5C  24040001   ADDIU A0, ZERO, 1
9D007E60  14440010   BNE V0, A0, 0x9D007EA4
9D007E64  2403FFFF   ADDIU V1, ZERO, -1
428:                                 {
429:                                         SYS_DEBUG(0, "Semaphore creation failed");
430:                                         return(DRV_HANDLE_INVALID);
431:                                 }
432:                                 if(OSAL_SEM_Create(&(clientObj->semWriteDone), OSAL_SEM_TYPE_COUNTING, 1, 0) != OSAL_RESULT_TRUE)
9D007E68  26440048   ADDIU A0, S2, 72
9D007E6C  24050001   ADDIU A1, ZERO, 1
9D007E70  24060001   ADDIU A2, ZERO, 1
9D007E74  0F402D8F   JAL OSAL_SEM_Create
9D007E78  00003821   ADDU A3, ZERO, ZERO
9D007E7C  24040001   ADDIU A0, ZERO, 1
9D007E80  14440008   BNE V0, A0, 0x9D007EA4
9D007E84  2403FFFF   ADDIU V1, ZERO, -1
433:                                 {
434:                                         SYS_DEBUG(0, "Semaphore creation failed");
435:                                         return(DRV_HANDLE_INVALID);
436:                                 }
437:                                 /* Update the client status */
438:                                 clientObj->status = DRV_USART_CLIENT_STATUS_READY;
9D007E88  24020002   ADDIU V0, ZERO, 2
9D007E8C  AE42003C   SW V0, 60(S2)
439:                                 return ((DRV_HANDLE) clientObj );
9D007E90  0B401FA9   J 0x9D007EA4
9D007E94  02401821   ADDU V1, S2, ZERO
440:                             }
441:                         }
442:                 
443:                         /* Could not find a client object. Release the mutex and
444:                            return with an invalid handle. */
445:                         OSAL_MUTEX_Unlock(&(gDrvUSARTCommonDataObj.mutexClientObjects));
9D007E98  0F4035E3   JAL OSAL_MUTEX_Unlock
9D007E9C  24840A14   ADDIU A0, A0, 2580
446:                     }
447:                 
448:                     /* If we have reached here, it means either we could not find a spare
449:                        client object or the mutex timed out in a RTOS environment. */
450:                 
451:                     return DRV_HANDLE_INVALID;
9D007EA0  2403FFFF   ADDIU V1, ZERO, -1
452:                 }
9D007EA4  00601021   ADDU V0, V1, ZERO
9D007EA8  8FBF001C   LW RA, 28(SP)
9D007EAC  8FB20018   LW S2, 24(SP)
9D007EB0  8FB10014   LW S1, 20(SP)
9D007EB4  8FB00010   LW S0, 16(SP)
9D007EB8  03E00008   JR RA
9D007EBC  27BD0020   ADDIU SP, SP, 32
9D007EC0  03E00008   JR RA
9D007EC4  00601021   ADDU V0, V1, ZERO
453:                 
454:                 // *****************************************************************************
455:                 /* Function:
456:                     DRV_CLIENT_STATUS DRV_USART_Close ( DRV_HANDLE handle)
457:                 
458:                   Summary:
459:                     Dynamic implementation of DRV_USART_Close client interface function.
460:                 
461:                   Description:
462:                     This is the dynamic implementation of DRV_USART_Close client interface
463:                     function.
464:                 
465:                   Remarks:
466:                     See drv_usart.h for usage information.
467:                 */
468:                 
469:                 void DRV_USART_Close ( DRV_HANDLE handle)
470:                 {
00000000  00000000   NOP
471:                     /* This function closes the client, The client
472:                        object is deallocated and returned to the
473:                        pool. */
474:                 
475:                     DRV_USART_CLIENT_OBJ * clientObj;
476:                     DRV_USART_OBJ * dObj;
477:                 
478:                     /* Validate the handle */
479:                     clientObj = _DRV_USART_DriverHandleValidate(handle);
0000000C  00000000   NOP
480:                 
481:                     if(clientObj == NULL)
00000014  00000000   NOP
482:                     {
483:                         /* Driver handle is not valid */
484:                         SYS_DEBUG(0, "Invalid Driver Handle");
485:                         return;
486:                     }
487:                 
488:                     dObj = (DRV_USART_OBJ *)clientObj->hDriver;
0000001C  00000000   NOP
489:                 
490:                     /* Remove all buffers that this client owns from the driver queue. This
491:                        function will map to _DRV_USART_ClientBufferQueueObjectsRemove() if the
492:                        driver was built for buffer queue support. Else this condition always
493:                        maps to true. */
494:                 
495:                     if(!_DRV_USART_CLIENT_BUFFER_QUEUE_OBJECTS_REMOVE(clientObj))
496:                     {
497:                         /* The function could fail if the mutex time out occurred */
498:                         SYS_DEBUG(0, "Could not remove client buffer objects");
499:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
500:                         return;
501:                     }
502:                 
503:                     /* Deallocate all semaphores */
504:                     if(OSAL_SEM_Delete(&(clientObj->semWriteDone)) != OSAL_RESULT_TRUE)
00000020  00000000   NOP
505:                     {
506:                         SYS_DEBUG(0, "Unable to delete client write done semaphore");
507:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
508:                         return;
00000034  00000000   NOP
509:                     }
510:                     if(OSAL_SEM_Delete(&(clientObj->semReadDone)) != OSAL_RESULT_TRUE)
0000003C  00000000   NOP
511:                     {
512:                         SYS_DEBUG(0, "Unable to delete client read done semaphore");
513:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
514:                         return;
00000050  00000000   NOP
515:                     }
516:                     /* Reduce the number of clients */
517:                     dObj->nClients --;
00000058  00000000   NOP
518:                 
519:                     /* Reset the exclusive flag */
520:                     dObj->isExclusive = false;
00000064  00000000   NOP
521:                 
522:                     /* De-allocate the object */
523:                     clientObj->status = DRV_USART_CLIENT_STATUS_CLOSED;
00000068  00000000   NOP
524:                     clientObj->inUse = false;
0000006C  00000000   NOP
525:                 
526:                     return;
527:                 }
00000070  00000000   NOP
528:                 
529:                 // *****************************************************************************
530:                 /* Function:
531:                     void DRV_USART_ByteTransmitCallbackSet
532:                     (
533:                         const SYS_MODULE_INDEX index,
534:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
535:                     )
536:                 
537:                   Summary:
538:                     Registers transmit callback function.
539:                 
540:                   Description:
541:                     This function is used to register the callback function to be invoked
542:                     upon transmission of a byte.
543:                 
544:                   Remarks:
545:                     See drv_usart.h for usage information.
546:                 */
547:                 
548:                 void DRV_USART_ByteTransmitCallbackSet
549:                 (
550:                     const SYS_MODULE_INDEX index,
551:                     const DRV_USART_BYTE_EVENT_HANDLER eventHandler
552:                 )
553:                 {
00000000  00000000   NOP
554:                     if (index >= DRV_USART_INSTANCES_NUMBER)
00000004  00000000   NOP
555:                     {
556:                         /* Invalid driver index */
557:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
558:                     }
559:                     else
560:                     {
561:                         gDrvUSARTObj[index].transmitCallback = eventHandler;
00000010  00000000   NOP
562:                     }
563:                 }
564:                 
565:                 // *****************************************************************************
566:                 /* Function:
567:                     void DRV_USART_ByteReceiveCallbackSet
568:                     (
569:                         const SYS_MODULE_INDEX index,
570:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
571:                     )
572:                 
573:                   Summary:
574:                     Registers receive callback function.
575:                 
576:                   Description:
577:                     This function is used to register the callback function to be invoked
578:                     upon reception of a byte.
579:                 
580:                   Remarks:
581:                     See drv_usart.h for usage information.
582:                 */
583:                 
584:                 void DRV_USART_ByteReceiveCallbackSet
585:                 (
586:                     const SYS_MODULE_INDEX index,
587:                     const DRV_USART_BYTE_EVENT_HANDLER eventHandler
588:                 )
589:                 {
9D00D75C  3084FFFF   ANDI A0, A0, -1
590:                     if (index >= DRV_USART_INSTANCES_NUMBER)
9D00D760  2C820002   SLTIU V0, A0, 2
9D00D764  10400007   BEQ V0, ZERO, 0x9D00D784
9D00D768  00041140   SLL V0, A0, 5
591:                     {
592:                         /* Invalid driver index */
593:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
594:                     }
595:                     else
596:                     {
597:                         gDrvUSARTObj[index].receiveCallback = eventHandler;
9D00D76C  000421C0   SLL A0, A0, 7
9D00D770  00822023   SUBU A0, A0, V0
9D00D774  3C02A000   LUI V0, -24576
9D00D778  24420B00   ADDIU V0, V0, 2816
9D00D77C  00822021   ADDU A0, A0, V0
9D00D780  AC850058   SW A1, 88(A0)
9D00D784  03E00008   JR RA
9D00D788  00000000   NOP
598:                     }
599:                 }
600:                 
601:                 // *****************************************************************************
602:                 /* Function:
603:                     void DRV_USART_ByteErrorCallbackSet
604:                     (
605:                         const SYS_MODULE_INDEX index,
606:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
607:                     )
608:                 
609:                   Summary:
610:                     Registers error notification callback function.
611:                 
612:                   Description:
613:                     This function is used to register the callback function to be invoked
614:                     to notify error on the tx or the rx path in byte model of operation.
615:                 
616:                   Remarks:
617:                     See drv_usart.h for usage information.
618:                 */
619:                 
620:                 void DRV_USART_ByteErrorCallbackSet
621:                 (
622:                     const SYS_MODULE_INDEX index,
623:                     const DRV_USART_BYTE_EVENT_HANDLER eventHandler
624:                 )
625:                 {
00000000  00000000   NOP
626:                     if (index >= DRV_USART_INSTANCES_NUMBER)
00000004  00000000   NOP
627:                     {
628:                         /* Invalid driver index */
629:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
630:                     }
631:                     else
632:                     {
633:                         gDrvUSARTObj[index].errorCallback = eventHandler;
00000010  00000000   NOP
634:                     }
635:                 }
636:                 
637:                 
638:                 // *****************************************************************************
639:                 /* Function:
640:                     DRV_USART_ERROR DRV_USART_ErrorGet( DRV_HANDLE hClient )
641:                 
642:                   Summary:
643:                     Dynamic implementation of DRV_USART_ErrorGet client interface function.
644:                 
645:                   Description:
646:                     This is the dynamic implementation of DRV_USART_ErrorGet client interface
647:                     function.
648:                 
649:                   Remarks:
650:                     See drv_usart.h for usage information.
651:                 */
652:                 
653:                 DRV_USART_ERROR DRV_USART_ErrorGet(DRV_HANDLE hClient)
654:                 {
00000000  00000000   NOP
655:                     DRV_USART_CLIENT_OBJ * clientObj;
656:                     DRV_USART_ERROR error;
657:                 
658:                     /* Validate the handle */
659:                     clientObj = _DRV_USART_DriverHandleValidate(hClient);
00000008  00000000   NOP
660:                 
661:                     if(clientObj == NULL)
00000010  00000000   NOP
662:                     {
663:                         /* Driver handle is not valid. Return error */
664:                         SYS_DEBUG(0, "Invalid client handle");
665:                         return DRV_USART_BAUD_SET_ERROR;
666:                     }
667:                 
668:                     /* Return the error. Clear the error before
669:                        returning. */
670:                 
671:                     error = clientObj->error;
00000018  00000000   NOP
672:                     clientObj->error = DRV_USART_ERROR_NONE;
0000001C  00000000   NOP
673:                     return(error);
674:                 }
00000024  00000000   NOP
675:                 
676:                 // *****************************************************************************
677:                 /* Function:
678:                     DRV_USART_BAUD_SET_RESULT DRV_USART_BaudSet(DRV_HANDLE handle, uint32_t baud)
679:                 
680:                   Summary:
681:                     Dynamic implementation of DRV_USART_BaudSet client interface function.
682:                 
683:                   Description:
684:                     This is the dynamic implementation of DRV_USART_BaudSet client interface
685:                     function.
686:                 
687:                   Remarks:
688:                     See drv_usart.h for usage information.
689:                 */
690:                 
691:                 DRV_USART_BAUD_SET_RESULT DRV_USART_BaudSet(DRV_HANDLE handle, uint32_t baud)
692:                 {
00000000  00000000   NOP
693:                     DRV_USART_OBJ * hDriver;
694:                     DRV_USART_CLIENT_OBJ * client;
695:                     USART_MODULE_ID plibID;
696:                     DRV_USART_BAUD_SET_RESULT retVal = DRV_USART_BAUD_SET_SUCCESS;
000000F0  00000000   NOP
00000118  00000000   NOP
00000140  00000000   NOP
00000168  00000000   NOP
00000190  00000000   NOP
000001B8  00000000   NOP
0000024C  00000000   NOP
00000274  00000000   NOP
0000029C  00000000   NOP
000002C4  00000000   NOP
000002EC  00000000   NOP
00000314  00000000   NOP
697:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
698:                     bool isEnabled = false;
699:                 #endif
700:                 
701:                     /* Validate the handle */
702:                     client = _DRV_USART_DriverHandleValidate(handle);
0000001C  00000000   NOP
703:                 
704:                     if(client == NULL)
00000024  00000000   NOP
705:                     {
706:                         /* Driver handle is not valid. Return error */
707:                         SYS_DEBUG(0, "Invalid client handle");
708:                         return DRV_USART_BAUD_SET_ERROR;
709:                     }
710:                 
711:                     hDriver = (DRV_USART_OBJ*)client->hDriver;
0000002C  00000000   NOP
712:                     plibID = hDriver->moduleId;
00000030  00000000   NOP
713:                 
714:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
00000034  00000000   NOP
715:                     {
716:                         int32_t brgValueLow=0;
717:                         int32_t brgValueHigh=0;
718:                 
719:                         brgValueLow  = ( (hDriver->brgClock/baud) >> 4 ) - 1;
00000050  00000000   NOP
000001C0  00000000   NOP
720:                         brgValueHigh = ( (hDriver->brgClock/baud) >> 2 ) - 1;
00000060  00000000   NOP
721:                 
722:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
723:                         isEnabled = PLIB_USART_ModuleIsBusy (plibID);
724:                         if (isEnabled)
725:                         {
726:                             PLIB_USART_Disable (plibID);
727:                             while (PLIB_USART_ModuleIsBusy (plibID));
728:                         }
729:                 #endif
730:                         /* Check if the baud value can be set with high baud settings */
731:                         if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX))
00000068  00000000   NOP
732:                         {
733:                             PLIB_USART_BaudRateHighEnable(plibID);
734:                             PLIB_USART_BaudRateHighSet(plibID, hDriver->brgClock, baud);
000000C8  00000000   NOP
00000338  00000000   NOP
00000350  00000000   NOP
00000368  00000000   NOP
00000380  00000000   NOP
00000398  00000000   NOP
735:                         }
736:                         /* Check if the baud value can be set with low baud settings */
737:                         else if ((brgValueLow >= 0) && (brgValueLow <= UINT16_MAX))
000001C4  00000000   NOP
738:                         {
739:                             PLIB_USART_BaudRateHighDisable(plibID);
740:                             PLIB_USART_BaudRateSet(plibID, hDriver->brgClock, baud);
00000224  00000000   NOP
000003B0  00000000   NOP
000003C8  00000000   NOP
000003E0  00000000   NOP
000003F8  00000000   NOP
00000410  00000000   NOP
741:                         }
742:                         else
743:                         {
744:                             retVal = DRV_USART_BAUD_SET_ERROR;
745:                         }
746:                 
747:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
748:                         if (isEnabled)
749:                         {
750:                             PLIB_USART_Enable (plibID);
751:                         }
752:                 #endif
753:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
00000318  00000000   NOP
754:                     }
755:                     else
756:                     {
757:                         /* The mutex timed out */
758:                         SYS_DEBUG(0, "Hardware instance mutex time out in DRV_USART_BaudSet() function");
759:                         retVal = DRV_USART_BAUD_SET_ERROR;
760:                     }
761:                 
762:                     return retVal;
763:                 }
00000418  00000000   NOP
764:                 
765:                 // *****************************************************************************
766:                 /* Function:
767:                     DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART_LineControlSet
768:                     (
769:                         DRV_HANDLE handle,
770:                         DRV_USART_LINE_CONTROL lineControlMode
771:                     )
772:                 
773:                   Summary:
774:                     Dynamic implementation of DRV_USART_LineControlSet client interface function.
775:                 
776:                   Description:
777:                     This is the dynamic implementation of DRV_USART_LineControlSet client
778:                     interface function.
779:                 
780:                   Remarks:
781:                     See drv_usart.h for usage information.
782:                 */
783:                 
784:                 DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART_LineControlSet
785:                 (
786:                     DRV_HANDLE handle,
787:                     DRV_USART_LINE_CONTROL lineControlMode
788:                 )
789:                 {
00000000  00000000   NOP
790:                     DRV_USART_OBJ * hDriver;
791:                     DRV_USART_CLIENT_OBJ * client;
792:                     USART_MODULE_ID plibID;
793:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
794:                     bool isEnabled = false;
795:                 #endif
796:                 
797:                     /* Validate the driver handle */
798:                     client = _DRV_USART_DriverHandleValidate(handle);
00000014  00000000   NOP
799:                 
800:                     if(client == NULL)
0000001C  00000000   NOP
801:                     {
802:                         /* Driver handle is not valid. Return error */
803:                 
804:                         SYS_DEBUG(0, "Invalid driver handle");
805:                         return DRV_USART_LINE_CONTROL_SET_ERROR;
806:                     }
807:                 
808:                     hDriver = (DRV_USART_OBJ*)client->hDriver;
00000024  00000000   NOP
809:                     plibID = hDriver->moduleId;
00000028  00000000   NOP
810:                 
811:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
0000002C  00000000   NOP
812:                     {
813:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
814:                         isEnabled = PLIB_USART_ModuleIsBusy (plibID);
815:                         if (isEnabled)
816:                         {
817:                             PLIB_USART_Disable (plibID);
818:                             while (PLIB_USART_ModuleIsBusy (plibID));
819:                         }
820:                 #endif
821:                         /* Set the Line Control Mode */
822:                         PLIB_USART_LineControlModeSelect(plibID, lineControlMode);
823:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
824:                         if (isEnabled)
825:                         {
826:                             PLIB_USART_Enable (plibID);
827:                         }
828:                 #endif
829:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
0000011C  00000000   NOP
830:                     }
831:                     else
832:                     {
833:                         SYS_DEBUG(0, "Hardware Instance Mutex time out in DRV_USART_LineControlSet() function");
834:                         return DRV_USART_LINE_CONTROL_SET_ERROR;
835:                     }
836:                 
837:                     /* Return success */
838:                     return(DRV_USART_LINE_CONTROL_SET_SUCCESS);
00000124  00000000   NOP
839:                 }
000002A8  00000000   NOP
840:                 
841:                 // *****************************************************************************
842:                 /* Function:
843:                     void DRV_USART_TasksTransmit (SYS_MODULE_OBJ object )
844:                 
845:                   Summary:
846:                     Dynamic implementation of DRV_USART_TasksTransmit system interface function.
847:                 
848:                   Description:
849:                     This is the dynamic implementation of DRV_USART_TasksTransmit system interface
850:                     function.
851:                 
852:                   Remarks:
853:                     See drv_usart.h for usage information.
854:                 */
855:                 
856:                 void DRV_USART_TasksTransmit(SYS_MODULE_OBJ object)
857:                 {
9D00AE1C  27BDFFE8   ADDIU SP, SP, -24
9D00AE20  AFBF0014   SW RA, 20(SP)
9D00AE24  AFB00010   SW S0, 16(SP)
858:                     /* This is the USART Driver Transmit tasks routine.
859:                        In this function, the driver checks if a transmit
860:                        interrupt is active and if there are any buffers in
861:                        queue. If so the buffer is serviced. A buffer that
862:                        is serviced completely is removed from the queue.
863:                      */
864:                 
865:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00AE28  00041140   SLL V0, A0, 5
9D00AE2C  000481C0   SLL S0, A0, 7
9D00AE30  02021023   SUBU V0, S0, V0
9D00AE34  3C10A000   LUI S0, -24576
9D00AE38  26100B00   ADDIU S0, S0, 2816
9D00AE3C  02028021   ADDU S0, S0, V0
866:                 
867:                     if((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY))
9D00AE40  92020014   LBU V0, 20(S0)
9D00AE44  1040001C   BEQ V0, ZERO, 0x9D00AEB8
9D00AE48  24020002   ADDIU V0, ZERO, 2
9D00AE4C  8E03000C   LW V1, 12(S0)
9D00AE50  1462001A   BNE V1, V0, 0x9D00AEBC
9D00AE54  8FBF0014   LW RA, 20(SP)
868:                     {
869:                         /* This instance of the driver is not initialized. Don't
870:                          * do anything */
871:                         return;
872:                     }
873:                 
874:                     if(SYS_INT_SourceStatusGet(hDriver->txInterruptSource))
9D00AE58  8E020024   LW V0, 36(S0)
9D00AE80  5040000F   BEQL V0, ZERO, 0x9D00AEC0
9D00AE84  8FB00010   LW S0, 16(SP)
875:                     {
876:                         /* The USART driver is configured to generate an
877:                            interrupt when the FIFO is empty. Additionally
878:                            the queue is not empty. Which means there is
879:                            work to done in this routine. */
880:                 
881:                         _DRV_USART_TRANSMIT_BUFFER_QUEUE_TASKS(object);
9D00AE88  0F402F5D   JAL _DRV_USART_ByteTransmitTasks
9D00AE8C  00000000   NOP
882:                 
883:                         /* Clear up the interrupt flag */
884:                         SYS_INT_SourceStatusClear(hDriver->txInterruptSource);
9D00AE90  8E020024   LW V0, 36(S0)
885:                     }
886:                 }
9D00AEB8  8FBF0014   LW RA, 20(SP)
9D00AEBC  8FB00010   LW S0, 16(SP)
9D00AEC0  03E00008   JR RA
9D00AEC4  27BD0018   ADDIU SP, SP, 24
887:                 
888:                 
889:                 // *****************************************************************************
890:                 /* Function:
891:                     void DRV_USART_TasksError (SYS_MODULE_OBJ object );
892:                 
893:                   Summary:
894:                     Maintains the driver's error state machine and implements its ISR
895:                 
896:                   Description:
897:                     This routine is used to maintain the driver's internal error state machine
898:                     and implement its error ISR for interrupt-driven implementations.  In
899:                     polling mode, this function should be called from the SYS_Tasks function.
900:                     In interrupt mode, this function should be called in the error interrupt
901:                     service routine of the USART that is associated with this USART driver
902:                     hardware instance.
903:                 
904:                   Remarks:
905:                     Refer to drv_usart.h for usage information.
906:                 */
907:                 
908:                 void DRV_USART_TasksError(SYS_MODULE_OBJ object)
909:                 {
9D006460  27BDFFE8   ADDIU SP, SP, -24
9D006464  AFBF0014   SW RA, 20(SP)
9D006468  AFB00010   SW S0, 16(SP)
910:                     /* This is the USART Driver Error tasks routine. In this function, the
911:                      * driver checks if an error interrupt has occurred. If so the error
912:                      * condition is cleared.  */
913:                 
914:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00646C  00041140   SLL V0, A0, 5
9D006470  000481C0   SLL S0, A0, 7
9D006474  02021023   SUBU V0, S0, V0
9D006478  3C10A000   LUI S0, -24576
9D00647C  26100B00   ADDIU S0, S0, 2816
9D006480  02028021   ADDU S0, S0, V0
915:                 
916:                     if((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY))
9D006484  92020014   LBU V0, 20(S0)
9D006488  10400073   BEQ V0, ZERO, 0x9D006658
9D00648C  24020002   ADDIU V0, ZERO, 2
9D006490  8E03000C   LW V1, 12(S0)
9D006494  54620071   BNEL V1, V0, 0x9D00665C
9D006498  8FBF0014   LW RA, 20(SP)
917:                     {
918:                         /* This instance of the driver is not initialized. Don't
919:                          * do anything */
920:                         return;
921:                     }
922:                 
923:                     if(SYS_INT_SourceStatusGet(hDriver->errorInterruptSource))
9D00649C  8E02002C   LW V0, 44(S0)
9D0064C4  50400065   BEQL V0, ZERO, 0x9D00665C
9D0064C8  8FBF0014   LW RA, 20(SP)
924:                     {
925:                         /* This means an error has occurred */
926:                 
927:                         if(PLIB_USART_ReceiverOverrunHasOccurred(hDriver->moduleId))
9D00651C  10400004   BEQ V0, ZERO, 0x9D006530
9D006520  24030002   ADDIU V1, ZERO, 2
9D006574  1440001F   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear
9D006578  24030002   ADDIU V1, ZERO, 2
9D00657C  0B40194C   J 0x9D006530
9D006580  00000000   NOP
9D006590  1440001D   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear::USART_ReceiverOverrunErrorClear_Default
9D006594  24030002   ADDIU V1, ZERO, 2
9D006598  0B40194C   J 0x9D006530
9D00659C  00000000   NOP
9D0065AC  1440001B   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear::USART_ReceiverOverrunErrorClear_Default
9D0065B0  24030002   ADDIU V1, ZERO, 2
9D0065B4  0B40194C   J 0x9D006530
9D0065B8  00000000   NOP
9D0065C8  14400019   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear::USART_ReceiverOverrunErrorClear_Default
9D0065CC  24030002   ADDIU V1, ZERO, 2
9D0065D0  0B40194C   J 0x9D006530
9D0065D4  00000000   NOP
9D0065E4  14400017   BNE V0, ZERO, DRV_USART_TasksError::PLIB_USART_ReceiverOverrunErrorClear::USART_ReceiverOverrunErrorClear_Default
9D0065E8  24030002   ADDIU V1, ZERO, 2
9D0065EC  0B40194C   J 0x9D006530
9D0065F0  00000000   NOP
928:                         {
929:                             PLIB_USART_ReceiverOverrunErrorClear(hDriver->moduleId);
930:                         }
931:                 
932:                         _DRV_USART_ERROR_TASKS(object);
9D006530  0F403092   JAL _DRV_USART_ByteErrorTasks
9D006534  00000000   NOP
933:                 
934:                         /* Clear up the error interrupt flag */
935:                         SYS_INT_SourceStatusClear(hDriver->errorInterruptSource);
9D006538  8E02002C   LW V0, 44(S0)
936:                     }
937:                 }
9D006560  0B401997   J 0x9D00665C
9D006564  8FBF0014   LW RA, 20(SP)
9D006658  8FBF0014   LW RA, 20(SP)
9D00665C  8FB00010   LW S0, 16(SP)
9D006660  03E00008   JR RA
9D006664  27BD0018   ADDIU SP, SP, 24
938:                 
939:                 // *****************************************************************************
940:                 /* Function:
941:                     DRV_USART_CLIENT_STATUS DRV_USART_ClientStatus (DRV_HANDLE handle )
942:                 
943:                   Summary:
944:                     Dynamic implementation of DRV_USART_ClientStatus client interface function.
945:                 
946:                   Description:
947:                     This is the dynamic implementation of DRV_USART_ClientStatus client interface
948:                     function.
949:                 
950:                   Remarks:
951:                     See drv_usart.h for usage information.
952:                 */
953:                 
954:                 DRV_USART_CLIENT_STATUS DRV_USART_ClientStatus(DRV_HANDLE handle)
955:                 {
00000000  00000000   NOP
956:                     DRV_USART_CLIENT_OBJ * client;
957:                 
958:                     /* Validate the driver handle */
959:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
960:                 
961:                     if(client == NULL)
00000010  00000000   NOP
962:                     {
963:                         /* Driver handle is not valid */
964:                 
965:                         SYS_DEBUG(0, "Invalid driver handle");
966:                         return DRV_USART_CLIENT_STATUS_CLOSED;
967:                     }
968:                 
969:                     /* Return the client status */
970:                     return(client->status);
971:                 }
0000001C  00000000   NOP
972:                 
973:                 // *****************************************************************************
974:                 /* Function:
975:                     void DRV_USART_TasksReceive (SYS_MODULE_OBJ object )
976:                 
977:                   Summary:
978:                     Dynamic implementation of DRV_USART_Initialize system interface function.
979:                 
980:                   Description:
981:                     This is the dynamic implementation of DRV_USART_Initialize system interface
982:                     function.
983:                 
984:                   Remarks:
985:                     See drv_usart.h for usage information.
986:                 */
987:                 
988:                 void DRV_USART_TasksReceive(SYS_MODULE_OBJ object)
989:                 {
9D00AEC8  27BDFFE8   ADDIU SP, SP, -24
9D00AECC  AFBF0014   SW RA, 20(SP)
9D00AED0  AFB00010   SW S0, 16(SP)
990:                     /* This is the USART Driver Receive tasks routine. If the receive
991:                        interrupt flag is set, the tasks routines are executed.
992:                      */
993:                 
994:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00AED4  00041140   SLL V0, A0, 5
9D00AED8  000481C0   SLL S0, A0, 7
9D00AEDC  02021023   SUBU V0, S0, V0
9D00AEE0  3C10A000   LUI S0, -24576
9D00AEE4  26100B00   ADDIU S0, S0, 2816
9D00AEE8  02028021   ADDU S0, S0, V0
995:                 
996:                     if((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY))
9D00AEEC  92020014   LBU V0, 20(S0)
9D00AEF0  1040001C   BEQ V0, ZERO, 0x9D00AF64
9D00AEF4  24020002   ADDIU V0, ZERO, 2
9D00AEF8  8E03000C   LW V1, 12(S0)
9D00AEFC  1462001A   BNE V1, V0, 0x9D00AF68
9D00AF00  8FBF0014   LW RA, 20(SP)
997:                     {
998:                         /* This instance of the driver is not initialized. Dont
999:                            do anything */
1000:                
1001:                        return;
1002:                    }
1003:                
1004:                    if(SYS_INT_SourceStatusGet(hDriver->rxInterruptSource))
9D00AF04  8E020028   LW V0, 40(S0)
9D00AF2C  5040000F   BEQL V0, ZERO, 0x9D00AF6C
9D00AF30  8FB00010   LW S0, 16(SP)
1005:                    {
1006:                        _DRV_USART_RECEIVE_BUFFER_QUEUE_TASKS(object);
9D00AF34  0F403075   JAL _DRV_USART_ByteReceiveTasks
9D00AF38  00000000   NOP
1007:                
1008:                        /* Clear up the interrupt flag */
1009:                        SYS_INT_SourceStatusClear(hDriver->rxInterruptSource);
9D00AF3C  8E020028   LW V0, 40(S0)
1010:                    }
1011:                }
9D00AF64  8FBF0014   LW RA, 20(SP)
9D00AF68  8FB00010   LW S0, 16(SP)
9D00AF6C  03E00008   JR RA
9D00AF70  27BD0018   ADDIU SP, SP, 24
1012:                
1013:                // *****************************************************************************
1014:                /* Function:
1015:                    DRV_USART_TRANSFER_STATUS DRV_USART_TransferStatus(const DRV_HANDLE handle)
1016:                
1017:                  Summary:
1018:                    Dynamic implementation of DRV_USART_TransferStatus client interface function.
1019:                
1020:                  Description:
1021:                    This is the dynamic implementation of DRV_USART_TransferStatus client
1022:                    interface function.
1023:                
1024:                  Remarks:
1025:                    See drv_usart.h for usage information.
1026:                */
1027:                
1028:                DRV_USART_TRANSFER_STATUS DRV_USART_TransferStatus(const DRV_HANDLE handle)
1029:                {
00000000  00000000   NOP
1030:                    DRV_USART_CLIENT_OBJ * client;
1031:                    DRV_USART_OBJ * hDriver;
1032:                    DRV_USART_TRANSFER_STATUS result = 0;
1033:                
1034:                    client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
1035:                
1036:                    /* Validate the handle */
1037:                    if(client == NULL)
00000010  00000000   NOP
1038:                    {
1039:                        SYS_DEBUG(0, "Invalid Driver handle");
1040:                        return 0;
1041:                    }
1042:                
1043:                    hDriver = client->hDriver;
1044:                
1045:                    /* If the Rx interrupt flag is set then there is data available
1046:                       else there isn't */
1047:                    result |= (PLIB_USART_ReceiverDataIsAvailable(hDriver->moduleId)) ?
00000018  00000000   NOP
00000070  00000000   NOP
1048:                        DRV_USART_TRANSFER_STATUS_RECEIVER_DATA_PRESENT : DRV_USART_TRANSFER_STATUS_RECEIVER_EMPTY;
1049:                
1050:                    /* If the TX interrupt flag is set, then the Tx Buffer is empty */
1051:                    result |= (PLIB_USART_TransmitterIsEmpty(hDriver->moduleId)) ? DRV_USART_TRANSFER_STATUS_TRANSMIT_EMPTY : 0;
000000D0  00000000   NOP
1052:                
1053:                    /* Check if the TX buffer is full */
1054:                    result |= (PLIB_USART_TransmitterBufferIsFull(hDriver->moduleId)) ? DRV_USART_TRANSFER_STATUS_TRANSMIT_FULL : 0;
0000012C  00000000   NOP
1055:                
1056:                    return(result);
00000134  00000000   NOP
1057:                }
0000022C  00000000   NOP
1058:                
1059:                // *****************************************************************************
1060:                // *****************************************************************************
1061:                // Section: File scope functions
1062:                // *****************************************************************************
1063:                // *****************************************************************************
1064:                
1065:                // *****************************************************************************
1066:                /* void _DRV_USART_HardwareSetup
1067:                   (
1068:                        USART_MODULE_ID  plibID,
1069:                        DRV_USART_INIT * init
1070:                   )
1071:                
1072:                  Summary:
1073:                    Initializes the USART module based on the init data structure.
1074:                
1075:                  Description:
1076:                    This function initializes the USART module based on the init data structure.
1077:                
1078:                  Remarks:
1079:                    This is a private function and should not be called directly by the
1080:                    application.
1081:                */
1082:                
1083:                void _DRV_USART_HardwareSetup(USART_MODULE_ID plibID, DRV_USART_INIT * init)
1084:                {
1085:                    bool loopbackMode   = false;
9D0015E4  00001021   ADDU V0, ZERO, ZERO
9D001604  00001021   ADDU V0, ZERO, ZERO
9D001640  00001021   ADDU V0, ZERO, ZERO
9D001F50  00001021   ADDU V0, ZERO, ZERO
9D001FA4  00001021   ADDU V0, ZERO, ZERO
9D001FF0  0B400582   J 0x9D001608
9D001FF4  00001021   ADDU V0, ZERO, ZERO
9D002038  0B400582   J 0x9D001608
9D00203C  00001021   ADDU V0, ZERO, ZERO
9D002080  0B400582   J 0x9D001608
9D002084  00001021   ADDU V0, ZERO, ZERO
9D002088  00001021   ADDU V0, ZERO, ZERO
9D0020CC  00001021   ADDU V0, ZERO, ZERO
1086:                    bool irdaMode       = false;
9D0015F4  00004021   ADDU T0, ZERO, ZERO
9D001600  00004021   ADDU T0, ZERO, ZERO
9D001FEC  00004021   ADDU T0, ZERO, ZERO
9D002034  00004021   ADDU T0, ZERO, ZERO
9D00207C  00004021   ADDU T0, ZERO, ZERO
1087:                    bool wakeFromSleep  = false;
1088:                    bool stopInIdle     = false;
1089:                    bool autoBaud       = false;
1090:                
1091:                    /* Default is to use UxTX and UxRX only */
1092:                    USART_OPERATION_MODE handshakeLines = USART_ENABLE_TX_RX_USED;
9D00143C  24060003   ADDIU A2, ZERO, 3
9D001440  0002300B   MOVN A2, ZERO, V0
9D001444  2C480001   SLTIU T0, V0, 1
9D001448  0002180A   MOVZ V1, ZERO, V0
9D00144C  0B400582   J 0x9D001608
9D001450  00601021   ADDU V0, V1, ZERO
9D0015E8  0B4005A1   J 0x9D001684
9D0015EC  00003021   ADDU A2, ZERO, ZERO
9D0015F0  00003021   ADDU A2, ZERO, ZERO
9D001F54  0B4005A1   J 0x9D001684
9D001F58  00003021   ADDU A2, ZERO, ZERO
9D001FA8  0B4005A1   J 0x9D001684
9D001FAC  00003021   ADDU A2, ZERO, ZERO
9D001FE8  00003021   ADDU A2, ZERO, ZERO
9D002030  00003021   ADDU A2, ZERO, ZERO
9D002078  00003021   ADDU A2, ZERO, ZERO
1093:                
1094:                    /* Check the operational mode and update the relevant flags */
1095:                    switch(init->mode)
9D001424  8CA20008   LW V0, 8(A1)
9D001428  24030002   ADDIU V1, ZERO, 2
9D00142C  10430009   BEQ V0, V1, 0x9D001454
9D001430  24030003   ADDIU V1, ZERO, 3
9D001434  1043006E   BEQ V0, V1, 0x9D0015F0
9D001438  00001821   ADDU V1, ZERO, ZERO
1096:                    {
1097:                        case DRV_USART_OPERATION_MODE_ADDRESSED:
1098:                        {
1099:                            PLIB_USART_ReceiverAddressDetectEnable(plibID);
1100:                            PLIB_USART_AddressSet(plibID, init->modeData.AddressedModeInit.address);
9D0014A0  0B40053A   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet::USART_AddressSet_Default
9D0014A4  90A2000C   LBU V0, 12(A1)
9D001D74  0B400777   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001D78  90A2000C   LBU V0, 12(A1)
9D001D8C  0B400781   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001D90  90A2000C   LBU V0, 12(A1)
9D001DA4  0B40078B   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001DA8  90A2000C   LBU V0, 12(A1)
9D001DBC  0B400795   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001DC0  90A2000C   LBU V0, 12(A1)
9D001DD4  0B40079F   J _DRV_USART_HardwareSetup::PLIB_USART_AddressSet
9D001DD8  90A2000C   LBU V0, 12(A1)
1101:                #if defined (PLIB_USART_ExistsReceiverAddressAutoDetect)
1102:                            PLIB_USART_ReceiverAddressAutoDetectEnable(plibID, PLIB_USART_AddressGet(plibID));
9D001558  0B400568   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D00155C  7C031C20   SEB V1, V1
9D00159C  00001821   ADDU V1, ZERO, ZERO
9D001EB0  0B4007C3   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EB4  7C031C20   SEB V1, V1
9D001EC4  0B4007D8   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EC8  7C031C20   SEB V1, V1
9D001ED8  0B4007ED   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EDC  7C031C20   SEB V1, V1
9D001EEC  0B4007FF   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001EF0  7C031C20   SEB V1, V1
9D001F00  0B400811   J _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressAutoDetectEnable
9D001F04  7C031C20   SEB V1, V1
9D001F08  00001821   ADDU V1, ZERO, ZERO
9D001F5C  00001821   ADDU V1, ZERO, ZERO
9D001FB0  00001821   ADDU V1, ZERO, ZERO
9D001FF8  00001821   ADDU V1, ZERO, ZERO
9D002040  00001821   ADDU V1, ZERO, ZERO
1103:                #endif
1104:                        }
1105:                        break;
1106:                        case DRV_USART_OPERATION_MODE_IRDA:
1107:                            irdaMode = true;
1108:                            handshakeLines = USART_ENABLE_TX_RX_BCLK_USED;
1109:                            break;
1110:                        case DRV_USART_OPERATION_MODE_LOOPBACK:
1111:                            loopbackMode = true;
1112:                            break;
9D0015F8  0B400582   J 0x9D001608
9D0015FC  24020001   ADDIU V0, ZERO, 1
1113:                        default:
1114:                            break;
1115:                    }
1116:                
1117:                    /* Handshaking */
1118:                    if(init->handshake != DRV_USART_HANDSHAKE_NONE)
9D0015D4  8CA30020   LW V1, 32(A1)
9D0015D8  24020002   ADDIU V0, ZERO, 2
9D0015DC  14620018   BNE V1, V0, 0x9D001640
9D0015E0  00004021   ADDU T0, ZERO, ZERO
9D001608  8CA30020   LW V1, 32(A1)
9D00160C  24070002   ADDIU A3, ZERO, 2
9D001610  5067001D   BEQL V1, A3, 0x9D001688
9D001614  8CA30010   LW V1, 16(A1)
9D001F40  8CA30020   LW V1, 32(A1)
9D001F44  24020002   ADDIU V0, ZERO, 2
9D001F48  1462004F   BNE V1, V0, 0x9D002088
9D001F4C  00004021   ADDU T0, ZERO, ZERO
9D001F94  8CA30020   LW V1, 32(A1)
9D001F98  24020002   ADDIU V0, ZERO, 2
9D001F9C  1462004B   BNE V1, V0, 0x9D0020CC
9D001FA0  00004021   ADDU T0, ZERO, ZERO
1119:                    {
1120:                        /* Note that this mode is exclusive of DRV_USART_OPERATION_MODE_IRDA.
1121:                           In that if the driver must be set up to use DRV_USART_OPERATION_MODE_IRDA
1122:                           then handshake parameter of the init data structure must be
1123:                           DRV_USART_HANDSHAKE_NONE. Setting up the driver to use Simplex or
1124:                           flow control will over ride the requirements of the IRDA mode.*/
1125:                
1126:                        handshakeLines = USART_ENABLE_TX_RX_CTS_RTS_USED;
9D00167C  0B4005B4   J _DRV_USART_HardwareSetup::PLIB_USART_InitializeModeGeneral::USART_InitializeModeGeneral_Default
9D001680  24060002   ADDIU A2, ZERO, 2
9D0020C4  0B4005D1   J _DRV_USART_HardwareSetup::PLIB_USART_InitializeModeGeneral
9D0020C8  24060002   ADDIU A2, ZERO, 2
9D002108  0B4005EE   J _DRV_USART_HardwareSetup::PLIB_USART_InitializeModeGeneral
9D00210C  24060002   ADDIU A2, ZERO, 2
1127:                
1128:                        /* Set the handshake mode to either simplex or flow control */
1129:                
1130:                        PLIB_USART_HandshakeModeSelect(plibID, init->handshake);
1131:                    }
1132:                
1133:                
1134:                    /* Wake up the part from sleep on any activity on the RX Line */
1135:                    wakeFromSleep = (init->flags & DRV_USART_INIT_FLAG_WAKE_ON_START);
9D001638  0B4005A2   J 0x9D001688
9D00163C  8CA30010   LW V1, 16(A1)
9D00166C  8CA30010   LW V1, 16(A1)
9D001670  30690001   ANDI T1, V1, 1
9D001684  8CA30010   LW V1, 16(A1)
9D001688  30690001   ANDI T1, V1, 1
9D0020B4  8CA30010   LW V1, 16(A1)
9D0020B8  30690001   ANDI T1, V1, 1
9D0020F8  8CA30010   LW V1, 16(A1)
9D0020FC  30690001   ANDI T1, V1, 1
1136:                
1137:                    /* When the CPU enters IDLE mode, stop the USART */
1138:                    stopInIdle = (init->flags & DRV_USART_INIT_FLAG_STOP_IN_IDLE);
9D001674  7C670080   EXT A3, V1, 2, 1
9D00168C  7C670080   EXT A3, V1, 2, 1
9D0020BC  7C670080   EXT A3, V1, 2, 1
9D002100  7C670080   EXT A3, V1, 2, 1
1139:                
1140:                    /* When the CPU enters IDLE mode, stop the USART */
1141:                    autoBaud = (init->flags & DRV_USART_INIT_FLAG_AUTO_BAUD);
9D001678  7C630040   EXT V1, V1, 1, 1
9D0020C0  7C630040   EXT V1, V1, 1, 1
9D002104  7C630040   EXT V1, V1, 1, 1
1142:                
1143:                    /* Initialize the USART based on initialization data structure */
1144:                    PLIB_USART_InitializeModeGeneral(plibID, autoBaud, loopbackMode,
1145:                            wakeFromSleep, irdaMode, stopInIdle);
1146:                
1147:                    /* Set the line control mode */
1148:                    PLIB_USART_LineControlModeSelect(plibID, init->lineControl);
9D00173C  0B400672   J 0x9D0019C8
9D001740  8CA20018   LW V0, 24(A1)
9D0017B0  0B40067F   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D0017B4  8CA20018   LW V0, 24(A1)
9D001824  0B400684   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001828  8CA20018   LW V0, 24(A1)
9D001898  0B400689   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D00189C  8CA20018   LW V0, 24(A1)
9D00190C  0B40068E   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001910  8CA20018   LW V0, 24(A1)
9D001980  0B400693   J _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001984  8CA20018   LW V0, 24(A1)
1149:                
1150:                    /* We set the receive interrupt mode to receive an interrupt whenever FIFO
1151:                       is not empty */
1152:                    PLIB_USART_InitializeOperation(plibID, USART_RECEIVE_FIFO_ONE_CHAR,
1153:                            USART_TRANSMIT_FIFO_IDLE, handshakeLines);
1154:                
1155:                    /* Set the baud rate and enable the USART */
1156:                    PLIB_USART_BaudSetAndEnable(plibID, init->brgClock, init->baud);
9D001AE8  8CA30014   LW V1, 20(A1)
9D001AEC  0B4006CD   J 0x9D001B34
9D001AF0  8CA2001C   LW V0, 28(A1)
9D001AF4  8CA2001C   LW V0, 28(A1)
9D0022D4  8CA30014   LW V1, 20(A1)
9D0022D8  0B40090C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0022DC  8CA2001C   LW V0, 28(A1)
9D002328  8CA30014   LW V1, 20(A1)
9D00232C  0B40091B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002330  8CA2001C   LW V0, 28(A1)
9D00237C  8CA30014   LW V1, 20(A1)
9D002380  0B40092A   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002384  8CA2001C   LW V0, 28(A1)
9D0023D0  8CA30014   LW V1, 20(A1)
9D0023D4  0B400939   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0023D8  8CA2001C   LW V0, 28(A1)
9D002424  8CA30014   LW V1, 20(A1)
9D002428  0B400948   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00242C  8CA2001C   LW V0, 28(A1)
9D002430  3C04BF80   LUI A0, -16512
9D002434  8C856410   LW A1, 25616(A0)
9D002438  34A51400   ORI A1, A1, 5120
9D00243C  AC856410   SW A1, 25616(A0)
9D002440  0062001B   DIVU V1, V0
9D002444  004001F4   TEQ V0, ZERO
9D002448  00001012   MFLO V0
9D00244C  00022082   SRL A0, V0, 2
9D002450  2484FFFF   ADDIU A0, A0, -1
9D002454  3C030001   LUI V1, 1
9D002458  0083182B   SLTU V1, A0, V1
9D00245C  5460FDD8   BNEL V1, ZERO, 0x9D001BC0
9D002460  3C02BF80   LUI V0, -16512
9D002464  0B4006F7   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002468  3C03BF80   LUI V1, -16512
9D00246C  3C04BF80   LUI A0, -16512
9D002470  8C856810   LW A1, 26640(A0)
9D002474  34A51400   ORI A1, A1, 5120
9D002478  AC856810   SW A1, 26640(A0)
9D00247C  0062001B   DIVU V1, V0
9D002480  004001F4   TEQ V0, ZERO
9D002484  00001012   MFLO V0
9D002488  00022082   SRL A0, V0, 2
9D00248C  2484FFFF   ADDIU A0, A0, -1
9D002490  3C030001   LUI V1, 1
9D002494  0083182B   SLTU V1, A0, V1
9D002498  5460FDDE   BNEL V1, ZERO, 0x9D001C14
9D00249C  3C02BF80   LUI V0, -16512
9D0024A0  0B40070C   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024A4  3C03BF80   LUI V1, -16512
9D0024A8  3C04BF80   LUI A0, -16512
9D0024AC  8C856210   LW A1, 25104(A0)
9D0024B0  34A51400   ORI A1, A1, 5120
9D0024B4  AC856210   SW A1, 25104(A0)
9D0024B8  0062001B   DIVU V1, V0
9D0024BC  004001F4   TEQ V0, ZERO
9D0024C0  00001012   MFLO V0
9D0024C4  00022082   SRL A0, V0, 2
9D0024C8  2484FFFF   ADDIU A0, A0, -1
9D0024CC  3C030001   LUI V1, 1
9D0024D0  0083182B   SLTU V1, A0, V1
9D0024D4  5460FDE4   BNEL V1, ZERO, 0x9D001C68
9D0024D8  3C02BF80   LUI V0, -16512
9D0024DC  0B400721   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0024E0  3C03BF80   LUI V1, -16512
9D0024E4  3C04BF80   LUI A0, -16512
9D0024E8  8C856610   LW A1, 26128(A0)
9D0024EC  34A51400   ORI A1, A1, 5120
9D0024F0  AC856610   SW A1, 26128(A0)
9D0024F4  0062001B   DIVU V1, V0
9D0024F8  004001F4   TEQ V0, ZERO
9D0024FC  00001012   MFLO V0
9D002500  00022082   SRL A0, V0, 2
9D002504  2484FFFF   ADDIU A0, A0, -1
9D002508  3C030001   LUI V1, 1
9D00250C  0083182B   SLTU V1, A0, V1
9D002510  5460FDEA   BNEL V1, ZERO, 0x9D001CBC
9D002514  3C02BF80   LUI V0, -16512
9D002518  0B400736   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D00251C  3C03BF80   LUI V1, -16512
9D002520  3C04BF80   LUI A0, -16512
9D002524  8C856A10   LW A1, 27152(A0)
9D002528  34A51400   ORI A1, A1, 5120
9D00252C  AC856A10   SW A1, 27152(A0)
9D002530  0062001B   DIVU V1, V0
9D002534  004001F4   TEQ V0, ZERO
9D002538  00001012   MFLO V0
9D00253C  00022082   SRL A0, V0, 2
9D002540  2484FFFF   ADDIU A0, A0, -1
9D002544  3C030001   LUI V1, 1
9D002548  0083182B   SLTU V1, A0, V1
9D00254C  5460FDF0   BNEL V1, ZERO, 0x9D001D10
9D002550  3C02BF80   LUI V0, -16512
9D002554  0B40074B   J _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D002558  3C03BF80   LUI V1, -16512
1157:                }
1158:                
1159:                // *****************************************************************************
1160:                /* Function:
1161:                    DRV_USART_CLIENT_OBJ * _DRV_USART_DriverHandleValidate(DRV_HANDLE handle)
1162:                
1163:                  Summary:
1164:                    Dynamic implementation of the _DRV_USART_DriverHandleValidate() function.
1165:                
1166:                  Description:
1167:                    Dynamic implementation of the _DRV_USART_DriverHandleValidate() function.
1168:                    This function return NULL if the handle is invalid else it return a pointer
1169:                    to the USART Driver Client Object associated with this handle.
1170:                
1171:                  Remarks:
1172:                    This is a private function and should not be called directly by an
1173:                    application.
1174:                */
1175:                
1176:                DRV_USART_CLIENT_OBJ * _DRV_USART_DriverHandleValidate(DRV_HANDLE handle)
1177:                {
1178:                    /* This function returns the pointer to the client object that is
1179:                       associated with this handle if the handle is valid. Returns NULL
1180:                       otherwise. */
1181:                
1182:                    DRV_USART_CLIENT_OBJ * client;
1183:                
1184:                    if((DRV_HANDLE_INVALID == handle) ||
9D00D970  2482FFFF   ADDIU V0, A0, -1
9D00D974  2C42FFFE   SLTIU V0, V0, -2
9D00D978  10400005   BEQ V0, ZERO, 0x9D00D990
9D00D97C  00000000   NOP
1185:                            (0 == handle))
1186:                    {
1187:                        return(NULL);
1188:                    }
1189:                
1190:                    client = (DRV_USART_CLIENT_OBJ *)handle;
1191:                
1192:                    if(!client->inUse)
9D00D980  90820008   LBU V0, 8(A0)
1193:                    {
1194:                        return(NULL);
9D00D984  0002200A   MOVZ A0, ZERO, V0
9D00D988  03E00008   JR RA
9D00D98C  00801021   ADDU V0, A0, ZERO
1195:                    }
1196:                
1197:                    return(client);
1198:                }
9D00D990  03E00008   JR RA
9D00D994  00001021   ADDU V0, ZERO, ZERO
1199:                
1200:                // *****************************************************************************
1201:                // *****************************************************************************
1202:                // Section: File scope functions
1203:                // *****************************************************************************
1204:                // *****************************************************************************
1205:                
1206:                bool _DRV_USART_ClientBufferQueueObjectsRemove(DRV_USART_CLIENT_OBJ * clientObj)
1207:                {
00000000  00000000   NOP
1208:                    DRV_USART_OBJ * dObj = clientObj->hDriver;
00000018  00000000   NOP
1209:                    bool interruptWasEnabled = false;
1210:                    DRV_USART_BUFFER_OBJ * iterator = NULL;
1211:                
1212:                    if(OSAL_MUTEX_Lock(&(dObj->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
0000001C  00000000   NOP
1213:                    {
1214:                        /* Disable the transmit interrupt */
1215:                        interruptWasEnabled = _DRV_USART_InterruptSourceDisable(dObj->txInterruptSource);
00000038  00000000   NOP
1216:                        iterator = dObj->queueWrite;
00000040  00000000   NOP
1217:                        while(iterator != NULL)
00000044  00000000   NOP
00000094  00000000   NOP
1218:                        {
1219:                            if(clientObj == (DRV_USART_CLIENT_OBJ *)iterator->hClient)
0000004C  00000000   NOP
1220:                            {
1221:                                /* That means this buffer object is owned
1222:                                   by this client. This buffer object should
1223:                                   be removed. The following code removes
1224:                                   the object from a doubly linked list queue. */
1225:                
1226:                                iterator->inUse = false;
00000058  00000000   NOP
1227:                                if(iterator->previous != NULL)
0000005C  00000000   NOP
1228:                                {
1229:                                    iterator->previous->next = iterator->next;
00000068  00000000   NOP
1230:                                }
1231:                                if(iterator->next != NULL)
00000070  00000000   NOP
1232:                                {
1233:                                    iterator->next->previous = iterator->previous;
0000007C  00000000   NOP
1234:                                }
1235:                                /* Decrementing Current queue size */
1236:                                dObj->queueSizeCurrentWrite --;
00000084  00000000   NOP
1237:                
1238:                            }
1239:                            iterator = iterator->next;
00000090  00000000   NOP
1240:                        }
1241:                        /* If there are no buffers in the write queue.
1242:                         * Make the head pointer point to NULL */
1243:                        if(dObj->queueSizeCurrentWrite == 0)
0000009C  00000000   NOP
1244:                        {
1245:                            dObj->queueWrite = NULL;
1246:                        }
1247:                        else
1248:                        {
1249:                            /* Iterate to update the head pointer to point
1250:                             * the first valid buffer object in the queue */
1251:                            iterator = dObj->queueWrite;
1252:                            while(iterator != NULL)
000000B0  00000000   NOP
000000E8  00000000   NOP
1253:                            {
1254:                                if(iterator->inUse == true)
000000B8  00000000   NOP
000000D0  00000000   NOP
1255:                                {
1256:                                    dObj->queueWrite = iterator;
000000C8  00000000   NOP
1257:                                    break;
000000E0  00000000   NOP
1258:                                }
1259:                                iterator = iterator->next;
1260:                            }
1261:                        }
1262:                
1263:                
1264:                        /* Re-enable the interrupt if it was enabled */
1265:                        if(interruptWasEnabled)
000000F0  00000000   NOP
1266:                        {
1267:                            _DRV_USART_InterruptSourceEnable(dObj->txInterruptSource);
000000F8  00000000   NOP
1268:                        }
1269:                
1270:                        /* Now check the receive buffer queue. Start by disabling the
1271:                           receive interrupt */
1272:                
1273:                        interruptWasEnabled = _DRV_USART_InterruptSourceDisable(dObj->rxInterruptSource);
0000011C  00000000   NOP
1274:                        iterator = dObj->queueRead;
00000124  00000000   NOP
1275:                        while(iterator != NULL)
00000128  00000000   NOP
00000178  00000000   NOP
1276:                        {
1277:                            if(clientObj == (DRV_USART_CLIENT_OBJ *)iterator->hClient)
00000130  00000000   NOP
1278:                            {
1279:                                /* That means this buffer object is owned
1280:                                   by this client. This buffer object should
1281:                                   be removed. The following code removed
1282:                                   the object from a doubly linked list queue. */
1283:                
1284:                                iterator->inUse = false;
0000013C  00000000   NOP
1285:                                if(iterator->previous != NULL)
00000140  00000000   NOP
1286:                                {
1287:                                    iterator->previous->next = iterator->next;
0000014C  00000000   NOP
1288:                                }
1289:                                if(iterator->next != NULL)
00000154  00000000   NOP
1290:                                {
1291:                                    iterator->next->previous = iterator->previous;
00000160  00000000   NOP
1292:                                }
1293:                                /* Decrementing Current queue size */
1294:                                dObj->queueSizeCurrentRead --;
00000168  00000000   NOP
1295:                            }
1296:                            iterator = iterator->next;
00000174  00000000   NOP
1297:                        }
1298:                        /* If there are no buffers in the read queue.
1299:                         * Make the head pointer point to NULL */
1300:                        if(dObj->queueSizeCurrentRead == 0)
00000180  00000000   NOP
1301:                        {
1302:                            dObj->queueRead = NULL;
1303:                        }
1304:                        else
1305:                        {
1306:                            /* Iterate to update the head pointer to point
1307:                             * the first valid buffer object in the queue */
1308:                            iterator = dObj->queueRead;
1309:                            while(iterator != NULL)
00000194  00000000   NOP
000001CC  00000000   NOP
1310:                            {
1311:                                if(iterator->inUse == true)
0000019C  00000000   NOP
000001B4  00000000   NOP
1312:                                {
1313:                                    dObj->queueRead = iterator;
000001AC  00000000   NOP
1314:                                    break;
000001C4  00000000   NOP
1315:                                }
1316:                                iterator = iterator->next;
1317:                            }
1318:                        }
1319:                
1320:                        if(interruptWasEnabled)
000001D4  00000000   NOP
1321:                        {
1322:                            _DRV_USART_InterruptSourceEnable(dObj->rxInterruptSource);
000001DC  00000000   NOP
1323:                        }
1324:                
1325:                        /* Unlock the mutex */
1326:                
1327:                        OSAL_MUTEX_Unlock(&(dObj->mutexDriverInstance));
00000200  00000000   NOP
1328:                    }
1329:                    else
1330:                    {
1331:                        /* The case where the mutex lock timed out and the
1332:                           client buffer objects could not be removed from
1333:                           the driver queue, the close function should fail. */
1334:                
1335:                        return false;
1336:                    }
1337:                
1338:                    return true;
00000208  00000000   NOP
1339:                }
0000020C  00000000   NOP
1340:                
1341:                void _DRV_USART_BufferQueueRxTasks(SYS_MODULE_OBJ object)
1342:                {
00000000  00000000   NOP
1343:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
00000014  00000000   NOP
1344:                    DRV_USART_BUFFER_OBJ * bufferObj;
1345:                    DRV_USART_CLIENT_OBJ * client;
1346:                    USART_MODULE_ID plibID;
1347:                
1348:                    bool status;
1349:                
1350:                    plibID = hDriver->moduleId;
1351:                
1352:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1353:                       routine would be called from another thread. We need to get the driver
1354:                       instance mutex before updating the queue. If the driver is configured for
1355:                       interrupt mode, then _DRV_USART_TAKE_MUTEX will compile to true */
1356:                
1357:                    if(DRV_USART_INTERRUPT_MODE == false)
1358:                    {
1359:                        if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1360:                        {
1361:                            /* We were able to take the mutex */
1362:                        }
1363:                        else
1364:                        {
1365:                            /* The mutex acquisition timed out. Return with an
1366:                               invalid handle. This code will not execute
1367:                               if there is no RTOS. */
1368:                            return;
1369:                        }
1370:                    }
1371:                
1372:                    /* In this function, the driver checks if there are any buffers in queue. If
1373:                       so the buffer is serviced. A buffer that is serviced completely is
1374:                       removed from the queue. Start by getting the buffer at the head of the
1375:                       queue */
1376:                
1377:                    bufferObj = hDriver->queueRead;
0000002C  00000000   NOP
1378:                
1379:                    if(bufferObj != NULL)
00000030  00000000   NOP
1380:                    {
1381:                        /* The USART driver is configured to generate an interrupt when the FIFO
1382:                           is not empty. Additionally the queue is not empty. Which means there
1383:                           is work to done in this routine. Read data from the FIFO until either
1384:                           the FIFO is empty or until we have read the requested number of bytes.
1385:                        */
1386:                        while((PLIB_USART_ReceiverDataIsAvailable(plibID))
0000010C  00000000   NOP
1387:                            && (bufferObj->nCurrentBytes < bufferObj->size ))
00000114  00000000   NOP
1388:                        {
1389:                            bufferObj->buffer[bufferObj->nCurrentBytes] = PLIB_USART_ReceiverByteReceive(plibID);
000000C8  00000000   NOP
1390:                            bufferObj->nCurrentBytes ++;
000000CC  00000000   NOP
1391:                        }
1392:                
1393:                        /* Check if this buffer is done */
1394:                        if(bufferObj->nCurrentBytes >= bufferObj->size)
00000130  00000000   NOP
1395:                        {
1396:                            /* This means the buffer is completed. If there
1397:                               is a callback registered with client, then
1398:                               call it */
1399:                
1400:                            client = (DRV_USART_CLIENT_OBJ *)bufferObj->hClient;
00000140  00000000   NOP
1401:                            if((client->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD))
00000144  00000000   NOP
1402:                            {
1403:                                /* Call the event handler. We additionally increment the
1404:                                   interrupt nesting count which lets the driver functions
1405:                                   that are called from the event handler know that an
1406:                                   interrupt context is active.
1407:                                   */
1408:                
1409:                                hDriver->interruptNestingCount ++;
00000160  00000000   NOP
1410:                
1411:                                client->eventHandler(DRV_USART_BUFFER_EVENT_COMPLETE,
0000016C  00000000   NOP
1412:                                        bufferObj->bufferHandle,
1413:                                        client->context);
1414:                
1415:                                hDriver->interruptNestingCount --;
00000180  00000000   NOP
1416:                            }
1417:                
1418:                            /* Get the next buffer in the queue and deallocate
1419:                               this buffer */
1420:                
1421:                            hDriver->queueRead = bufferObj->next;
0000018C  00000000   NOP
1422:                            bufferObj->inUse = false;
00000194  00000000   NOP
1423:                            hDriver->queueSizeCurrentRead --;
00000198  00000000   NOP
1424:                
1425:                            /* Reset the next and previous pointers */
1426:                            bufferObj->next = NULL;
000001A4  00000000   NOP
1427:                            bufferObj->previous = NULL;
000001A8  00000000   NOP
1428:                
1429:                            /* Reset the current head's previous pointer */
1430:                            if (hDriver->queueRead != NULL)
000001AC  00000000   NOP
1431:                            {
1432:                                hDriver->queueRead->previous = NULL;
1433:                            }
1434:                
1435:                            if(bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE)
000001B8  00000000   NOP
1436:                            {
1437:                                /* This means we should post the semaphore */
1438:                                _DRV_USART_SEM_POST(&(client->semReadDone));
000001C8  00000000   NOP
1439:                            }
1440:                        }
1441:                    }
1442:                
1443:                    if(hDriver->queueRead == NULL)
000001D0  00000000   NOP
1444:                    {
1445:                        /* The queue is empty. We can disable the interrupt */
1446:                        status = _DRV_USART_InterruptSourceDisable(hDriver->rxInterruptSource);
000001DC  00000000   NOP
1447:                        /* Ignore the warning */
1448:                        (void)status;
1449:                    }
1450:                
1451:                    /* Release the mutex */
1452:                
1453:                   _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1454:                }
000001E4  00000000   NOP
00000264  00000000   NOP
1455:                
1456:                void _DRV_USART_BufferQueueTxTasks(SYS_MODULE_OBJ object)
1457:                {
00000000  00000000   NOP
1458:                    /* Start by getting the buffer at the head of queue. */
1459:                
1460:                    DRV_USART_OBJ *hDriver = &gDrvUSARTObj[object];
00000018  00000000   NOP
1461:                    DRV_USART_BUFFER_OBJ * bufferObj;
1462:                    DRV_USART_CLIENT_OBJ * client;
1463:                    USART_MODULE_ID plibID;
1464:                
1465:                    bool status;
1466:                
1467:                    bufferObj = hDriver->queueWrite;
00000030  00000000   NOP
1468:                    plibID = hDriver->moduleId;
1469:                
1470:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1471:                       routine would be called from another thread. We need to get the driver
1472:                       instance mutex before updating the queue. If the driver is configured for
1473:                       interrupt mode, then _DRV_USART_TAKE_MUTEX will compile to true */
1474:                
1475:                    if(DRV_USART_INTERRUPT_MODE == false)
1476:                    {
1477:                        if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER))
1478:                        {
1479:                            /* We were able to take the mutex */
1480:                        }
1481:                        else
1482:                        {
1483:                            /* The mutex acquisition timed out. Return with an
1484:                               invalid handle. This code will not execute
1485:                               if there is no RTOS. */
1486:                            return;
1487:                        }
1488:                    }
1489:                
1490:                    if(bufferObj != NULL)
00000034  00000000   NOP
1491:                    {
1492:                        /* This means the queue is not empty. Check if this buffer is done */
1493:                        if(bufferObj->nCurrentBytes >= bufferObj->size)
0000003C  00000000   NOP
1494:                        {
1495:                            /* This means the buffer is completed. If there
1496:                               is a callback registered with client, then
1497:                               call it */
1498:                
1499:                            client = (DRV_USART_CLIENT_OBJ *)bufferObj->hClient;
00000050  00000000   NOP
1500:                            if((client->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD))
00000054  00000000   NOP
1501:                            {
1502:                                /* Before calling the event handler, the interrupt nesting
1503:                                   counter is incremented. This will allow driver routine that
1504:                                   are called from the event handler to know the interrupt
1505:                                   nesting level. Events are only generated for buffers that
1506:                                   were submitted using the buffer add routine */
1507:                
1508:                                hDriver->interruptNestingCount ++;
00000070  00000000   NOP
1509:                
1510:                                client->eventHandler(DRV_USART_BUFFER_EVENT_COMPLETE,
0000007C  00000000   NOP
1511:                                        bufferObj->bufferHandle,
1512:                                        client->context);
1513:                
1514:                                /* Decrement the nesting count */
1515:                                hDriver->interruptNestingCount -- ;
00000090  00000000   NOP
1516:                            }
1517:                
1518:                            /* Get the next buffer in the queue and deallocate
1519:                             * this buffer */
1520:                
1521:                            hDriver->queueWrite = bufferObj->next;
0000009C  00000000   NOP
1522:                            bufferObj->inUse = false;
000000A4  00000000   NOP
1523:                            hDriver->queueSizeCurrentWrite --;
000000A8  00000000   NOP
1524:                
1525:                            /* Reset the next and previous pointers */
1526:                            bufferObj->next = NULL;
000000B4  00000000   NOP
1527:                            bufferObj->previous = NULL;
000000B8  00000000   NOP
1528:                
1529:                            /* Reset the current head's previous pointer */
1530:                            if (hDriver->queueWrite != NULL)
000000BC  00000000   NOP
1531:                            {
1532:                                hDriver->queueWrite->previous = NULL;
1533:                            }
1534:                
1535:                            if(bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE)
000000C8  00000000   NOP
1536:                            {
1537:                                /* This means we should post the semaphore */
1538:                                _DRV_USART_SEM_POST(&(client->semWriteDone));
000000D8  00000000   NOP
1539:                
1540:                            }
1541:                        }
1542:                    }
1543:                
1544:                    /* Check if the queue is still not empty and process
1545:                       the buffer */
1546:                
1547:                    if(hDriver->queueWrite != NULL)
000000E0  00000000   NOP
1548:                    {
1549:                        bufferObj = hDriver->queueWrite;
1550:                        if(hDriver->operationMode == DRV_USART_OPERATION_MODE_ADDRESSED)
000000F4  00000000   NOP
1551:                        {
1552:                			uint16_t *buf_ptr;
1553:                            buf_ptr = (uint16_t *) bufferObj->buffer;
00000154  00000000   NOP
1554:                
1555:                            /* Fill up the FIFO with data until the FIFO is full
1556:                               and we have data to send */
1557:                            while((!PLIB_USART_TransmitterBufferIsFull(plibID))
000001A8  00000000   NOP
0000037C  00000000   NOP
1558:                                    && (bufferObj->nCurrentBytes < bufferObj->size ))
00000384  00000000   NOP
1559:                            {
1560:                                if((bufferObj->nCurrentBytes == 0) && (false == bufferObj->isAddressSent))
000001B0  00000000   NOP
1561:                                {
1562:                                    /* Send Address */
1563:                                    PLIB_USART_Transmitter9BitsSend(plibID, bufferObj->address, true);
1564:                                    bufferObj->isAddressSent = true;
00000210  00000000   NOP
00000230  00000000   NOP
00000250  00000000   NOP
00000270  00000000   NOP
00000290  00000000   NOP
000002B0  00000000   NOP
1565:                                }
1566:                                else
1567:                                {
1568:                                    /* Send data */
1569:                                    PLIB_USART_Transmitter9BitsSend(plibID, buf_ptr[bufferObj->nCurrentBytes], false);
000002BC  00000000   NOP
1570:                                    bufferObj->nCurrentBytes ++; // Here it is incrementing the 16-bit words number.
000002FC  00000000   NOP
00000308  00000000   NOP
00000314  00000000   NOP
00000320  00000000   NOP
0000032C  00000000   NOP
00000338  00000000   NOP
1571:                                }
1572:                            }
1573:                        }
1574:                        else
1575:                        {
1576:                            /* Fill up the FIFO with data until the FIFO is full
1577:                               and we have data to send */
1578:                            while((!PLIB_USART_TransmitterBufferIsFull(plibID))
00000418  00000000   NOP
1579:                                    && (bufferObj->nCurrentBytes < bufferObj->size ))
00000420  00000000   NOP
1580:                            {
1581:                                /* Send data */
1582:                                PLIB_USART_TransmitterByteSend(plibID, bufferObj->buffer[bufferObj->nCurrentBytes]);
000003A0  00000000   NOP
1583:                                bufferObj->nCurrentBytes ++;
000003D8  00000000   NOP
00000490  00000000   NOP
000004A0  00000000   NOP
000004B0  00000000   NOP
000004C0  00000000   NOP
000004D0  00000000   NOP
1584:                            }
1585:                        }
1586:                    }
1587:                    else
1588:                    {
1589:                        /* If the queue is empty, then disable the TX interrupt */
1590:                        status = _DRV_USART_InterruptSourceDisable(hDriver->txInterruptSource);
0000043C  00000000   NOP
1591:                        /* Ignore the warning */
1592:                        (void)status;
1593:                    }
1594:                
1595:                    /* Release the mutex */
1596:                    _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1597:                }
00000444  00000000   NOP
00000514  00000000   NOP
1598:                
1599:                void _DRV_USART_ByteTransmitTasks (SYS_MODULE_OBJ object)
1600:                {
9D00BD74  27BDFFE8   ADDIU SP, SP, -24
9D00BD78  AFBF0014   SW RA, 20(SP)
9D00BD7C  AFB00010   SW S0, 16(SP)
1601:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00BD80  00041140   SLL V0, A0, 5
9D00BD84  000481C0   SLL S0, A0, 7
9D00BD88  02021023   SUBU V0, S0, V0
9D00BD8C  3C10A000   LUI S0, -24576
9D00BD90  26100B00   ADDIU S0, S0, 2816
9D00BD94  02028021   ADDU S0, S0, V0
1602:                
1603:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->txInterruptSource))
9D00BD98  8E020024   LW V0, 36(S0)
9D00BDC0  10400006   BEQ V0, ZERO, 0x9D00BDDC
9D00BDC4  00000000   NOP
1604:                    {
1605:                        if (hDriver->transmitCallback != NULL)
9D00BDC8  8E020054   LW V0, 84(S0)
9D00BDCC  10400003   BEQ V0, ZERO, 0x9D00BDDC
9D00BDD0  00000000   NOP
1606:                        {
1607:                            hDriver->transmitCallback (object);
9D00BDD4  0040F809   JALR V0
9D00BDD8  3084FFFF   ANDI A0, A0, -1
1608:                        }
1609:                    }
1610:                
1611:                    _DRV_USART_InterruptSourceDisable(hDriver->txInterruptSource);
9D00BDDC  0F4032DF   JAL SYS_INT_SourceDisable
9D00BDE0  8E040024   LW A0, 36(S0)
1612:                }
9D00BDE4  8FBF0014   LW RA, 20(SP)
9D00BDE8  8FB00010   LW S0, 16(SP)
9D00BDEC  03E00008   JR RA
9D00BDF0  27BD0018   ADDIU SP, SP, 24
1613:                
1614:                void _DRV_USART_ByteReceiveTasks (SYS_MODULE_OBJ object)
1615:                {
9D00C228  27BDFFE8   ADDIU SP, SP, -24
9D00C22C  AFBF0014   SW RA, 20(SP)
1616:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00C1D4  00041140   SLL V0, A0, 5
9D00C1D8  000419C0   SLL V1, A0, 7
9D00C1DC  00621023   SUBU V0, V1, V0
9D00C1E0  3C03A000   LUI V1, -24576
9D00C1E4  24630B00   ADDIU V1, V1, 2816
9D00C1E8  00621821   ADDU V1, V1, V0
1617:                
1618:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->rxInterruptSource))
9D00C1EC  8C620028   LW V0, 40(V1)
9D00C214  1040000A   BEQ V0, ZERO, 0x9D00C240
9D00C218  00000000   NOP
1619:                    {
1620:                        if (hDriver->receiveCallback != NULL)
9D00C21C  8C620058   LW V0, 88(V1)
9D00C220  10400007   BEQ V0, ZERO, 0x9D00C240
9D00C224  00000000   NOP
1621:                        {
1622:                            hDriver->receiveCallback (object);
9D00C230  0040F809   JALR V0
9D00C234  3084FFFF   ANDI A0, A0, -1
1623:                        }
1624:                    }
1625:                }
9D00C238  8FBF0014   LW RA, 20(SP)
9D00C23C  27BD0018   ADDIU SP, SP, 24
9D00C240  03E00008   JR RA
9D00C244  00000000   NOP
1626:                
1627:                void _DRV_USART_ByteErrorTasks (SYS_MODULE_OBJ object)
1628:                {
9D00C29C  27BDFFE8   ADDIU SP, SP, -24
9D00C2A0  AFBF0014   SW RA, 20(SP)
1629:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00C248  00041140   SLL V0, A0, 5
9D00C24C  000419C0   SLL V1, A0, 7
9D00C250  00621023   SUBU V0, V1, V0
9D00C254  3C03A000   LUI V1, -24576
9D00C258  24630B00   ADDIU V1, V1, 2816
9D00C25C  00621821   ADDU V1, V1, V0
1630:                
1631:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->errorInterruptSource))
9D00C260  8C62002C   LW V0, 44(V1)
9D00C288  1040000A   BEQ V0, ZERO, 0x9D00C2B4
9D00C28C  00000000   NOP
1632:                    {
1633:                        if (hDriver->errorCallback != NULL)
9D00C290  8C62005C   LW V0, 92(V1)
9D00C294  10400007   BEQ V0, ZERO, 0x9D00C2B4
9D00C298  00000000   NOP
1634:                        {
1635:                            hDriver->errorCallback (object);
9D00C2A4  0040F809   JALR V0
9D00C2A8  3084FFFF   ANDI A0, A0, -1
1636:                        }
1637:                    }
1638:                }
9D00C2AC  8FBF0014   LW RA, 20(SP)
9D00C2B0  27BD0018   ADDIU SP, SP, 24
9D00C2B4  03E00008   JR RA
9D00C2B8  00000000   NOP
1639:                
1640:                /*******************************************************************************
1641:                 End of File
1642:                */
1643:                
---  C:/microchip/harmony/v1_08_01/third_party/rtos/FreeRTOS/Source/portable/MPLAB/PIC32MX/port_asm.S  --
                                                  1:     /*
                                                  2:         FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
                                                  3:         All rights reserved
                                                  4:     
                                                  5:         VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
                                                  6:     
                                                  7:         This file is part of the FreeRTOS distribution.
                                                  8:     
                                                  9:         FreeRTOS is free software; you can redistribute it and/or modify it under
                                                  10:        the terms of the GNU General Public License (version 2) as published by the
                                                  11:        Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
                                                  12:    
                                                  13:        ***************************************************************************
                                                  14:        >>!   NOTE: The modification to the GPL is included to allow you to     !<<
                                                  15:        >>!   distribute a combined work that includes FreeRTOS without being   !<<
                                                  16:        >>!   obliged to provide the source code for proprietary components     !<<
                                                  17:        >>!   outside of the FreeRTOS kernel.                                   !<<
                                                  18:        ***************************************************************************
                                                  19:    
                                                  20:        FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
                                                  21:        WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
                                                  22:        FOR A PARTICULAR PURPOSE.  Full license text is available on the following
                                                  23:        link: http://www.freertos.org/a00114.html
                                                  24:    
                                                  25:        ***************************************************************************
                                                  26:         *                                                                       *
                                                  27:         *    FreeRTOS provides completely free yet professionally developed,    *
                                                  28:         *    robust, strictly quality controlled, supported, and cross          *
                                                  29:         *    platform software that is more than just the market leader, it     *
                                                  30:         *    is the industry's de facto standard.                               *
                                                  31:         *                                                                       *
                                                  32:         *    Help yourself get started quickly while simultaneously helping     *
                                                  33:         *    to support the FreeRTOS project by purchasing a FreeRTOS           *
                                                  34:         *    tutorial book, reference manual, or both:                          *
                                                  35:         *    http://www.FreeRTOS.org/Documentation                              *
                                                  36:         *                                                                       *
                                                  37:        ***************************************************************************
                                                  38:    
                                                  39:        http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
                                                  40:        the FAQ page "My application does not run, what could be wrong?".  Have you
                                                  41:        defined configASSERT()?
                                                  42:    
                                                  43:        http://www.FreeRTOS.org/support - In return for receiving this top quality
                                                  44:        embedded software for free we request you assist our global community by
                                                  45:        participating in the support forum.
                                                  46:    
                                                  47:        http://www.FreeRTOS.org/training - Investing in training allows your team to
                                                  48:        be as productive as possible as early as possible.  Now you can receive
                                                  49:        FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
                                                  50:        Ltd, and the world's leading authority on the world's leading RTOS.
                                                  51:    
                                                  52:        http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
                                                  53:        including FreeRTOS+Trace - an indispensable productivity tool, a DOS
                                                  54:        compatible FAT file system, and our tiny thread aware UDP/IP stack.
                                                  55:    
                                                  56:        http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
                                                  57:        Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
                                                  58:    
                                                  59:        http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
                                                  60:        Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
                                                  61:        licenses offer ticketed support, indemnification and commercial middleware.
                                                  62:    
                                                  63:        http://www.SafeRTOS.com - High Integrity Systems also provide a safety
                                                  64:        engineered and independently SIL3 certified version for use in safety and
                                                  65:        mission critical applications that require provable dependability.
                                                  66:    
                                                  67:        1 tab == 4 spaces!
                                                  68:    */
                                                  69:    
                                                  70:    #include <xc.h>
                                                  71:    #include <sys/asm.h>
                                                  72:    #include "ISR_Support.h"
                                                  73:    
                                                  74:    
                                                  75:    	.set	nomips16
                                                  76:     	.set 	noreorder
                                                  77:    
                                                  78:     	.extern pxCurrentTCB
                                                  79:     	.extern vTaskSwitchContext
                                                  80:     	.extern vPortIncrementTick
                                                  81:    	.extern xISRStackTop
                                                  82:    
                                                  83:     	.global vPortStartFirstTask
                                                  84:    	.global vPortYieldISR
                                                  85:    	.global vPortTickInterruptHandler
                                                  86:    
                                                  87:    
                                                  88:    /******************************************************************/
                                                  89:    
                                                  90:     	.set		noreorder
                                                  91:    	.set 		noat
                                                  92:     	.ent		vPortTickInterruptHandler
                                                  93:    
                                                  94:    vPortTickInterruptHandler:
                                                  95:    
9D0043F8  401A6800   MFC0 K0, Cause               96:    	portSAVE_CONTEXT
                                                  97:    
9D0044D4  0F403360   JAL 0x9D00CD80               98:    	jal 		vPortIncrementTick
9D0044D8  00000000   NOP                          99:    	nop
                                                  100:   
9D0044DC  3C16A000   LUI S6, -24576               101:   	portRESTORE_CONTEXT
                                                  102:   
                                                  103:   	.end vPortTickInterruptHandler
                                                  104:   
                                                  105:   /******************************************************************/
                                                  106:   
                                                  107:    	.set		noreorder
                                                  108:   	.set 		noat
                                                  109:    	.ent		vPortStartFirstTask
                                                  110:   
                                                  111:   vPortStartFirstTask:
                                                  112:   
                                                  113:   	/* Simply restore the context of the highest priority task that has been
                                                  114:   	created so far. */
9D0045A4  3C16A000   LUI S6, -24576               115:   	portRESTORE_CONTEXT
                                                  116:   
                                                  117:   	.end vPortStartFirstTask
                                                  118:   
                                                  119:   
                                                  120:   
                                                  121:   /*******************************************************************/
                                                  122:   
                                                  123:   	.set		noreorder
                                                  124:   	.set 		noat
                                                  125:   	.ent		vPortYieldISR
                                                  126:   
                                                  127:   vPortYieldISR:
                                                  128:   
                                                  129:   	/* Make room for the context. First save the current status so it can be
                                                  130:   	manipulated. */
9D00466C  27BDFF7C   ADDIU SP, SP, -132           131:   	addiu		sp, sp, -portCONTEXT_SIZE
9D004670  401B6000   MFC0 K1, Status              132:   	mfc0		k1, _CP0_STATUS
                                                  133:   
                                                  134:   	/* Also save s6 and s5 so they can be used.  Any nesting interrupts should
                                                  135:   	maintain the values of these registers across the ISR. */
9D004674  AFB6002C   SW S6, 44(SP)                136:   	sw			s6, 44(sp)
9D004678  AFB50028   SW S5, 40(SP)                137:   	sw			s5, 40(sp)
9D00467C  AFBB0080   SW K1, 128(SP)               138:   	sw			k1, portSTATUS_STACK_LOCATION(sp)
                                                  139:   
                                                  140:   	/* Prepare to re-enabled interrupt above the kernel priority. */
9D004680  7C1B7A84   INS K1, ZERO, 10, 6          141:   	ins 		k1, zero, 10, 6
9D004684  377B0C00   ORI K1, K1, 3072             142:   	ori			k1, k1, ( configMAX_SYSCALL_INTERRUPT_PRIORITY << 10 )
9D004688  7C1B2044   INS K1, ZERO, 1, 4           143:   	ins			k1, zero, 1, 4
                                                  144:   
                                                  145:   	/* s5 is used as the frame pointer. */
9D00468C  001DA820   ADD S5, ZERO, SP             146:   	add			s5, zero, sp
                                                  147:   
                                                  148:   	/* Swap to the system stack.  This is not conditional on the nesting
                                                  149:   	count as this interrupt is always the lowest priority and therefore
                                                  150:   	the nesting is always 0. */
9D004690  3C1D9D01   LUI SP, -25343               151:   	la			sp, xISRStackTop
9D004698  8FBD0000   LW SP, 0(SP)                 152:   	lw			sp, (sp)
                                                  153:   
                                                  154:   	/* Set the nesting count. */
9D00469C  3C1AA000   LUI K0, -24576               155:   	la			k0, uxInterruptNesting
9D0046A4  24160001   ADDIU S6, ZERO, 1            156:   	addiu		s6, zero, 1
9D0046A8  AF560000   SW S6, 0(K0)                 157:   	sw			s6, 0(k0)
                                                  158:   
                                                  159:   	/* s6 holds the EPC value, this is saved with the rest of the context
                                                  160:   	after interrupts are enabled. */
9D0046AC  40167000   MFC0 S6, EPC                 161:   	mfc0 		s6, _CP0_EPC
                                                  162:   
                                                  163:   	/* Re-enable interrupts above configMAX_SYSCALL_INTERRUPT_PRIORITY. */
9D0046B0  409B6000   MTC0 K1, Status              164:   	mtc0		k1, _CP0_STATUS
                                                  165:   
                                                  166:   	/* Save the context into the space just created.  s6 is saved again
                                                  167:   	here as it now contains the EPC value. */
9D0046B4  AEBF0078   SW RA, 120(S5)               168:   	sw			ra, 120(s5)
9D0046B8  AEBE0074   SW S8, 116(S5)               169:   	sw			s8, 116(s5)
9D0046BC  AEB90070   SW T9, 112(S5)               170:   	sw			t9, 112(s5)
9D0046C0  AEB8006C   SW T8, 108(S5)               171:   	sw			t8, 108(s5)
9D0046C4  AEAF0068   SW T7, 104(S5)               172:   	sw			t7, 104(s5)
9D0046C8  AEAE0064   SW T6, 100(S5)               173:   	sw			t6, 100(s5)
9D0046CC  AEAD0060   SW T5, 96(S5)                174:   	sw			t5, 96(s5)
9D0046D0  AEAC005C   SW T4, 92(S5)                175:   	sw			t4, 92(s5)
9D0046D4  AEAB0058   SW T3, 88(S5)                176:   	sw			t3, 88(s5)
9D0046D8  AEAA0054   SW T2, 84(S5)                177:   	sw			t2, 84(s5)
9D0046DC  AEA90050   SW T1, 80(S5)                178:   	sw			t1, 80(s5)
9D0046E0  AEA8004C   SW T0, 76(S5)                179:   	sw			t0, 76(s5)
9D0046E4  AEA70048   SW A3, 72(S5)                180:   	sw			a3, 72(s5)
9D0046E8  AEA60044   SW A2, 68(S5)                181:   	sw			a2, 68(s5)
9D0046EC  AEA50040   SW A1, 64(S5)                182:   	sw			a1, 64(s5)
9D0046F0  AEA4003C   SW A0, 60(S5)                183:   	sw			a0, 60(s5)
9D0046F4  AEA30038   SW V1, 56(S5)                184:   	sw			v1, 56(s5)
9D0046F8  AEA20034   SW V0, 52(S5)                185:   	sw			v0, 52(s5)
9D0046FC  AEB70030   SW S7, 48(S5)                186:   	sw			s7, 48(s5)
9D004700  AEB6007C   SW S6, 124(S5)               187:   	sw			s6, portEPC_STACK_LOCATION(s5)
                                                  188:   	/* s5 and s6 has already been saved. */
9D004704  AEB40024   SW S4, 36(S5)                189:   	sw			s4, 36(s5)
9D004708  AEB30020   SW S3, 32(S5)                190:   	sw			s3, 32(s5)
9D00470C  AEB2001C   SW S2, 28(S5)                191:   	sw			s2, 28(s5)
9D004710  AEB10018   SW S1, 24(S5)                192:   	sw			s1, 24(s5)
9D004714  AEB00014   SW S0, 20(S5)                193:   	sw			s0, 20(s5)
9D004718  AEA10010   SW AT, 16(S5)                194:   	sw			$1, 16(s5)
                                                  195:   
                                                  196:   	/* s7 is used as a scratch register as this should always be saved across
                                                  197:   	nesting interrupts. */
9D00471C  0000B810   MFHI S7                      198:   	mfhi		s7
9D004720  AEB7000C   SW S7, 12(S5)                199:   	sw			s7, 12(s5)
9D004724  0000B812   MFLO S7                      200:   	mflo		s7
9D004728  AEB70008   SW S7, 8(S5)                 201:   	sw			s7, 8(s5)
                                                  202:   
                                                  203:   	/* Save the stack pointer to the task. */
9D00472C  3C17A000   LUI S7, -24576               204:   	la			s7, pxCurrentTCB
9D004734  8EF70000   LW S7, 0(S7)                 205:   	lw			s7, (s7)
9D004738  AEF50000   SW S5, 0(S7)                 206:   	sw			s5, (s7)
                                                  207:   
                                                  208:   	/* Set the interrupt mask to the max priority that can use the API.  The
                                                  209:   	yield handler will only be called at configKERNEL_INTERRUPT_PRIORITY which
                                                  210:   	is below configMAX_SYSCALL_INTERRUPT_PRIORITY - so this can only ever
                                                  211:   	raise the IPL value and never lower it. */
9D00473C  41606000   DI ZERO                      212:   	di
9D004740  000000C0   EHB                          213:   	ehb
9D004744  40176000   MFC0 S7, Status              214:   	mfc0		s7, _CP0_STATUS
9D004748  7C177A84   INS S7, ZERO, 10, 6          215:   	ins 		s7, zero, 10, 6
9D00474C  36F60C01   ORI S6, S7, 3073             216:   	ori			s6, s7, ( configMAX_SYSCALL_INTERRUPT_PRIORITY << 10 ) | 1
                                                  217:   
                                                  218:   	/* This mtc0 re-enables interrupts, but only above
                                                  219:   	configMAX_SYSCALL_INTERRUPT_PRIORITY. */
9D004750  40966000   MTC0 S6, Status              220:   	mtc0		s6, _CP0_STATUS
9D004754  000000C0   EHB                          221:   	ehb
                                                  222:   
                                                  223:   	/* Clear the software interrupt in the core. */
9D004758  40166800   MFC0 S6, Cause               224:   	mfc0		s6, _CP0_CAUSE
9D00475C  7C164204   INS S6, ZERO, 8, 1           225:   	ins			s6, zero, 8, 1
9D004760  40966800   MTC0 S6, Cause               226:   	mtc0		s6, _CP0_CAUSE
9D004764  000000C0   EHB                          227:   	ehb
                                                  228:   
                                                  229:   	/* Clear the interrupt in the interrupt controller. */
9D004768  3C16BF88   LUI S6, -16504               230:   	la			s6, IFS0CLR
9D004770  24140002   ADDIU S4, ZERO, 2            231:   	addiu		s4, zero, 2
9D004774  AED40000   SW S4, 0(S6)                 232:   	sw			s4, (s6)
                                                  233:   
9D004778  0F4027FD   JAL 0x9D009FF4               234:   	jal			vTaskSwitchContext
9D00477C  00000000   NOP                          235:   	nop
                                                  236:   
                                                  237:   	/* Clear the interrupt mask again.  The saved status value is still in s7. */
9D004780  40976000   MTC0 S7, Status              238:   	mtc0		s7, _CP0_STATUS
9D004784  000000C0   EHB                          239:   	ehb
                                                  240:   
                                                  241:   	/* Restore the stack pointer from the TCB. */
9D004788  3C10A000   LUI S0, -24576               242:   	la			s0, pxCurrentTCB
9D004790  8E100000   LW S0, 0(S0)                 243:   	lw			s0, (s0)
9D004794  8E150000   LW S5, 0(S0)                 244:   	lw			s5, (s0)
                                                  245:   
                                                  246:   	/* Restore the rest of the context. */
9D004798  8EB00008   LW S0, 8(S5)                 247:   	lw			s0, 8(s5)
9D00479C  02000013   MTLO S0                      248:   	mtlo		s0
9D0047A0  8EB0000C   LW S0, 12(S5)                249:   	lw			s0, 12(s5)
9D0047A4  02000011   MTHI S0                      250:   	mthi		s0
9D0047A8  8EA10010   LW AT, 16(S5)                251:   	lw			$1, 16(s5)
9D0047AC  8EB00014   LW S0, 20(S5)                252:   	lw			s0, 20(s5)
9D0047B0  8EB10018   LW S1, 24(S5)                253:   	lw			s1, 24(s5)
9D0047B4  8EB2001C   LW S2, 28(S5)                254:   	lw			s2, 28(s5)
9D0047B8  8EB30020   LW S3, 32(S5)                255:   	lw			s3, 32(s5)
9D0047BC  8EB40024   LW S4, 36(S5)                256:   	lw			s4, 36(s5)
                                                  257:   	/* s5 is loaded later. */
9D0047C0  8EB6002C   LW S6, 44(S5)                258:   	lw			s6, 44(s5)
9D0047C4  8EB70030   LW S7, 48(S5)                259:   	lw			s7, 48(s5)
9D0047C8  8EA20034   LW V0, 52(S5)                260:   	lw			v0, 52(s5)
9D0047CC  8EA30038   LW V1, 56(S5)                261:   	lw			v1, 56(s5)
9D0047D0  8EA4003C   LW A0, 60(S5)                262:   	lw			a0, 60(s5)
9D0047D4  8EA50040   LW A1, 64(S5)                263:   	lw			a1, 64(s5)
9D0047D8  8EA60044   LW A2, 68(S5)                264:   	lw			a2, 68(s5)
9D0047DC  8EA70048   LW A3, 72(S5)                265:   	lw			a3, 72(s5)
9D0047E0  8EA8004C   LW T0, 76(S5)                266:   	lw			t0, 76(s5)
9D0047E4  8EA90050   LW T1, 80(S5)                267:   	lw			t1, 80(s5)
9D0047E8  8EAA0054   LW T2, 84(S5)                268:   	lw			t2, 84(s5)
9D0047EC  8EAB0058   LW T3, 88(S5)                269:   	lw			t3, 88(s5)
9D0047F0  8EAC005C   LW T4, 92(S5)                270:   	lw			t4, 92(s5)
9D0047F4  8EAD0060   LW T5, 96(S5)                271:   	lw			t5, 96(s5)
9D0047F8  8EAE0064   LW T6, 100(S5)               272:   	lw			t6, 100(s5)
9D0047FC  8EAF0068   LW T7, 104(S5)               273:   	lw			t7, 104(s5)
9D004800  8EB8006C   LW T8, 108(S5)               274:   	lw			t8, 108(s5)
9D004804  8EB90070   LW T9, 112(S5)               275:   	lw			t9, 112(s5)
9D004808  8EBE0074   LW S8, 116(S5)               276:   	lw			s8, 116(s5)
9D00480C  8EBF0078   LW RA, 120(S5)               277:   	lw			ra, 120(s5)
                                                  278:   
                                                  279:   	/* Protect access to the k registers, and others. */
9D004810  41606000   DI ZERO                      280:   	di
9D004814  000000C0   EHB                          281:   	ehb
                                                  282:   
                                                  283:   	/* Set nesting back to zero.  As the lowest priority interrupt this
                                                  284:   	interrupt cannot have nested. */
9D004818  3C1AA000   LUI K0, -24576               285:   	la			k0, uxInterruptNesting
9D004820  AF400000   SW ZERO, 0(K0)               286:   	sw			zero, 0(k0)
                                                  287:   
                                                  288:   	/* Switch back to use the real stack pointer. */
9D004824  0015E820   ADD SP, ZERO, S5             289:   	add			sp, zero, s5
                                                  290:   
                                                  291:   	/* Restore the real s5 value. */
9D004828  8FB50028   LW S5, 40(SP)                292:   	lw			s5, 40(sp)
                                                  293:   
                                                  294:   	/* Pop the status and epc values. */
9D00482C  8FBB0080   LW K1, 128(SP)               295:   	lw			k1, portSTATUS_STACK_LOCATION(sp)
9D004830  8FBA007C   LW K0, 124(SP)               296:   	lw			k0, portEPC_STACK_LOCATION(sp)
                                                  297:   
                                                  298:   	/* Remove stack frame. */
9D004834  27BD0084   ADDIU SP, SP, 132            299:   	addiu		sp, sp, portCONTEXT_SIZE
                                                  300:   
9D004838  409B6000   MTC0 K1, Status              301:   	mtc0		k1, _CP0_STATUS
9D00483C  409A7000   MTC0 K0, EPC                 302:   	mtc0 		k0, _CP0_EPC
9D004840  000000C0   EHB                          303:   	ehb
9D004844  42000018   ERET                         304:   	eret
9D004848  00000000   NOP                          305:   	nop
                                                  306:   
                                                  307:   	.end		vPortYieldISR
                                                  308:   
                                                  309:   
                                                  310:   
---  C:/Users/Daniel/Documents/VT 2016-2017/Embedded/Milestone_4/firmware/src/system_config/default/system_interrupt_a.S
                                                  1:     /*******************************************************************************
                                                  2:      System Interrupt Source File
                                                  3:     
                                                  4:       File Name:
                                                  5:         sys_interrupt_a.S
                                                  6:     
                                                  7:       Summary:
                                                  8:         Raw ISR definitions.
                                                  9:     
                                                  10:      Description:
                                                  11:        This file contains a definitions of the raw ISRs required to support the 
                                                  12:        interrupt sub-system.
                                                  13:    *******************************************************************************/
                                                  14:    
                                                  15:    // DOM-IGNORE-BEGIN
                                                  16:    /*******************************************************************************
                                                  17:    Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
                                                  18:    
                                                  19:    Microchip licenses to you the right to use, modify, copy and distribute
                                                  20:    Software only when embedded on a Microchip microcontroller or digital signal
                                                  21:    controller that is integrated into your product or third party product
                                                  22:    (pursuant to the sublicense terms in the accompanying license agreement).
                                                  23:    
                                                  24:    You should refer to the license agreement accompanying this Software for
                                                  25:    additional information regarding your rights and obligations.
                                                  26:    
                                                  27:    SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
                                                  28:    EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
                                                  29:    MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
                                                  30:    IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
                                                  31:    CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
                                                  32:    OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
                                                  33:    INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
                                                  34:    CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
                                                  35:    SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
                                                  36:    (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
                                                  37:     *******************************************************************************/
                                                  38:    // DOM-IGNORE-END
                                                  39:    /*
                                                  40:    *********************************************************************************************************
                                                  41:    *                                           INCLUDES
                                                  42:    *********************************************************************************************************
                                                  43:    */
                                                  44:    #include <xc.h>
                                                  45:    
                                                  46:    
                                                  47:    
                                                  48:    #include "ISR_Support.h"
                                                  49:    
                                                  50:    
                                                  51:    /* TMR Instance 0 Interrupt */
                                                  52:       .extern  IntHandlerDrvTmrInstance0
                                                  53:    
                                                  54:       .section	.vector_8,code, keep
                                                  55:       .equ     __vector_dispatch_8, IntVectorDrvTmrInstance0
                                                  56:       .global  __vector_dispatch_8
                                                  57:       .set     nomicromips
                                                  58:       .set     noreorder
                                                  59:       .set     nomips16
                                                  60:       .set     noat
                                                  61:       .ent  IntVectorDrvTmrInstance0
                                                  62:    
                                                  63:    IntVectorDrvTmrInstance0:
9FC01300  3C1A9D00   LUI K0, -25344               64:        la    $26,  _IntHandlerDrvTmrInstance0         
9FC01308  03400008   JR K0                        65:        jr    $26
9FC0130C  00000000   NOP                          66:        nop
                                                  67:    	.end	IntVectorDrvTmrInstance0
                                                  68:    
                                                  69:       .section	.DrvTmrInstance0_vector_text, code, keep
                                                  70:       .set     nomicromips
                                                  71:       .set     noreorder
                                                  72:       .set     nomips16
                                                  73:       .set     noat
                                                  74:       .ent  _IntHandlerDrvTmrInstance0
                                                  75:    
                                                  76:    _IntHandlerDrvTmrInstance0:
9D006DDC  401A6800   MFC0 K0, Cause               77:        portSAVE_CONTEXT
9D006EB8  3C169D01   LUI S6, -25343               78:        la    s6,  IntHandlerDrvTmrInstance0
9D006EC0  02C0F809   JALR S6                      79:        jalr  s6
9D006EC4  00000000   NOP                          80:        nop
9D006EC8  3C16A000   LUI S6, -24576               81:        portRESTORE_CONTEXT
                                                  82:        .end	_IntHandlerDrvTmrInstance0
                                                  83:    
                                                  84:    
                                                  85:    
                                                  86:    
                                                  87:    /* USART Instance 0 Interrupt */
                                                  88:    
                                                  89:       .extern  IntHandlerDrvUsartInstance0
                                                  90:    
                                                  91:       .section	.vector_24,code, keep
                                                  92:       .equ     __vector_dispatch_24, IntVectorDrvUsartInstance0
                                                  93:       .global  __vector_dispatch_24
                                                  94:       .set     nomicromips
                                                  95:       .set     noreorder
                                                  96:       .set     nomips16
                                                  97:       .set     noat
                                                  98:       .ent  IntVectorDrvUsartInstance0
                                                  99:    
                                                  100:   IntVectorDrvUsartInstance0:
9FC01500  3C1A9D00   LUI K0, -25344               101:       la    $26,  _IntHandlerDrvUsartInstance0         
9FC01508  03400008   JR K0                        102:       jr    $26
9FC0150C  00000000   NOP                          103:       nop
                                                  104:   	.end	IntVectorDrvUsartInstance0
                                                  105:   
                                                  106:      .section	.DrvUsartInstance0_vector_text, code, keep
                                                  107:      .set     nomicromips
                                                  108:      .set     noreorder
                                                  109:      .set     nomips16
                                                  110:      .set     noat
                                                  111:      .ent  _IntHandlerDrvUsartInstance0
                                                  112:   
                                                  113:   _IntHandlerDrvUsartInstance0:
9D006F90  401A6800   MFC0 K0, Cause               114:       portSAVE_CONTEXT
9D00706C  3C169D01   LUI S6, -25343               115:       la    s6,  IntHandlerDrvUsartInstance0
9D007074  02C0F809   JALR S6                      116:       jalr  s6
9D007078  00000000   NOP                          117:       nop
9D00707C  3C16A000   LUI S6, -24576               118:       portRESTORE_CONTEXT
                                                  119:       .end	_IntHandlerDrvUsartInstance0
                                                  120:   
                                                  121:   
                                                  122:   
                                                  123:   /* USART Instance 1 Interrupt */
                                                  124:   
                                                  125:      .extern  IntHandlerDrvUsartInstance1
                                                  126:   
                                                  127:      .section	.vector_32,code, keep
                                                  128:      .equ     __vector_dispatch_32, IntVectorDrvUsartInstance1
                                                  129:      .global  __vector_dispatch_32
                                                  130:      .set     nomicromips
                                                  131:      .set     noreorder
                                                  132:      .set     nomips16
                                                  133:      .set     noat
                                                  134:      .ent  IntVectorDrvUsartInstance1
                                                  135:   
                                                  136:   IntVectorDrvUsartInstance1:
9FC01600  3C1A9D00   LUI K0, -25344               137:       la    $26,  _IntHandlerDrvUsartInstance1         
9FC01608  03400008   JR K0                        138:       jr    $26
9FC0160C  00000000   NOP                          139:       nop
                                                  140:   	.end	IntVectorDrvUsartInstance1
                                                  141:   
                                                  142:      .section	.DrvUsartInstance1_vector_text, code, keep
                                                  143:      .set     nomicromips
                                                  144:      .set     noreorder
                                                  145:      .set     nomips16
                                                  146:      .set     noat
                                                  147:      .ent  _IntHandlerDrvUsartInstance1
                                                  148:   
                                                  149:   _IntHandlerDrvUsartInstance1:
9D007144  401A6800   MFC0 K0, Cause               150:       portSAVE_CONTEXT
9D007220  3C169D01   LUI S6, -25343               151:       la    s6,  IntHandlerDrvUsartInstance1
9D007228  02C0F809   JALR S6                      152:       jalr  s6
9D00722C  00000000   NOP                          153:       nop
9D007230  3C16A000   LUI S6, -24576               154:       portRESTORE_CONTEXT
                                                  155:       .end	_IntHandlerDrvUsartInstance1
                                                  156:   
                                                  157:   
                                                  158:   /* IC Instance 0 Interrupt */
                                                  159:   
                                                  160:      .extern  IntHandlerDrvICInstance0
                                                  161:   
                                                  162:      .section	.vector_13,code, keep
                                                  163:      .equ     __vector_dispatch_13, IntVectorDrvICInstance0
                                                  164:      .global  __vector_dispatch_13
                                                  165:      .set     nomicromips
                                                  166:      .set     noreorder
                                                  167:      .set     nomips16
                                                  168:      .set     noat
                                                  169:      .ent  IntVectorDrvICInstance0
                                                  170:   
                                                  171:   IntVectorDrvICInstance0:
9FC013A0  3C1A9D00   LUI K0, -25344               172:       la    $26,  _IntHandlerDrvICInstance0         
9FC013A8  03400008   JR K0                        173:       jr    $26
9FC013AC  00000000   NOP                          174:       nop
                                                  175:   	.end	IntVectorDrvICInstance0
                                                  176:   
                                                  177:      .section	.DrvICInstance0_vector_text, code, keep
                                                  178:      .set     nomicromips
                                                  179:      .set     noreorder
                                                  180:      .set     nomips16
                                                  181:      .set     noat
                                                  182:      .ent  _IntHandlerDrvICInstance0
                                                  183:   
                                                  184:   _IntHandlerDrvICInstance0:
9D0072F8  401A6800   MFC0 K0, Cause               185:       portSAVE_CONTEXT
9D0073D4  3C169D01   LUI S6, -25343               186:       la    s6,  IntHandlerDrvICInstance0
9D0073DC  02C0F809   JALR S6                      187:       jalr  s6
9D0073E0  00000000   NOP                          188:       nop
9D0073E4  3C16A000   LUI S6, -24576               189:       portRESTORE_CONTEXT
                                                  190:       .end	_IntHandlerDrvICInstance0
                                                  191:   
                                                  192:   
                                                  193:   /* IC Instance 1 Interrupt */
                                                  194:   
                                                  195:      .extern  IntHandlerDrvICInstance1
                                                  196:   
                                                  197:      .section	.vector_5,code, keep
                                                  198:      .equ     __vector_dispatch_5, IntVectorDrvICInstance1
                                                  199:      .global  __vector_dispatch_5
                                                  200:      .set     nomicromips
                                                  201:      .set     noreorder
                                                  202:      .set     nomips16
                                                  203:      .set     noat
                                                  204:      .ent  IntVectorDrvICInstance1
                                                  205:   
                                                  206:   IntVectorDrvICInstance1:
9FC012A0  3C1A9D00   LUI K0, -25344               207:       la    $26,  _IntHandlerDrvICInstance1         
9FC012A8  03400008   JR K0                        208:       jr    $26
9FC012AC  00000000   NOP                          209:       nop
                                                  210:   	.end	IntVectorDrvICInstance1
                                                  211:   
                                                  212:      .section	.DrvICInstance1_vector_text, code, keep
                                                  213:      .set     nomicromips
                                                  214:      .set     noreorder
                                                  215:      .set     nomips16
                                                  216:      .set     noat
                                                  217:      .ent  _IntHandlerDrvICInstance1
                                                  218:   
                                                  219:   _IntHandlerDrvICInstance1:
9D0074AC  401A6800   MFC0 K0, Cause               220:       portSAVE_CONTEXT
9D007588  3C169D01   LUI S6, -25343               221:       la    s6,  IntHandlerDrvICInstance1
9D007590  02C0F809   JALR S6                      222:       jalr  s6
9D007594  00000000   NOP                          223:       nop
9D007598  3C16A000   LUI S6, -24576               224:       portRESTORE_CONTEXT
                                                  225:       .end	_IntHandlerDrvICInstance1
                                                  226:   
                                                  227:   
                                                  228:   /* IC Instance 2 Interrupt */
                                                  229:   
                                                  230:      .extern  IntHandlerDrvICInstance2
                                                  231:   
                                                  232:      .section	.vector_17,code, keep
                                                  233:      .equ     __vector_dispatch_17, IntVectorDrvICInstance2
                                                  234:      .global  __vector_dispatch_17
                                                  235:      .set     nomicromips
                                                  236:      .set     noreorder
                                                  237:      .set     nomips16
                                                  238:      .set     noat
                                                  239:      .ent  IntVectorDrvICInstance2
                                                  240:   
                                                  241:   IntVectorDrvICInstance2:
9FC01420  3C1A9D00   LUI K0, -25344               242:       la    $26,  _IntHandlerDrvICInstance2         
9FC01428  03400008   JR K0                        243:       jr    $26
9FC0142C  00000000   NOP                          244:       nop
                                                  245:   	.end	IntVectorDrvICInstance2
                                                  246:   
                                                  247:      .section	.DrvICInstance2_vector_text, code, keep
                                                  248:      .set     nomicromips
                                                  249:      .set     noreorder
                                                  250:      .set     nomips16
                                                  251:      .set     noat
                                                  252:      .ent  _IntHandlerDrvICInstance2
                                                  253:   
                                                  254:   _IntHandlerDrvICInstance2:
9D007660  401A6800   MFC0 K0, Cause               255:       portSAVE_CONTEXT
9D00773C  3C169D01   LUI S6, -25343               256:       la    s6,  IntHandlerDrvICInstance2
9D007744  02C0F809   JALR S6                      257:       jalr  s6
9D007748  00000000   NOP                          258:       nop
9D00774C  3C16A000   LUI S6, -24576               259:       portRESTORE_CONTEXT
                                                  260:       .end	_IntHandlerDrvICInstance2
                                                  261:   
                                                  262:   
                                                  263:   /* IC Instance 3 Interrupt */
                                                  264:   
                                                  265:      .extern  IntHandlerDrvICInstance3
                                                  266:   
                                                  267:      .section	.vector_21,code, keep
                                                  268:      .equ     __vector_dispatch_21, IntVectorDrvICInstance3
                                                  269:      .global  __vector_dispatch_21
                                                  270:      .set     nomicromips
                                                  271:      .set     noreorder
                                                  272:      .set     nomips16
                                                  273:      .set     noat
                                                  274:      .ent  IntVectorDrvICInstance3
                                                  275:   
                                                  276:   IntVectorDrvICInstance3:
9FC014A0  3C1A9D00   LUI K0, -25344               277:       la    $26,  _IntHandlerDrvICInstance3         
9FC014A8  03400008   JR K0                        278:       jr    $26
9FC014AC  00000000   NOP                          279:       nop
                                                  280:   	.end	IntVectorDrvICInstance3
                                                  281:   
                                                  282:      .section	.DrvICInstance3_vector_text, code, keep
                                                  283:      .set     nomicromips
                                                  284:      .set     noreorder
                                                  285:      .set     nomips16
                                                  286:      .set     noat
                                                  287:      .ent  _IntHandlerDrvICInstance3
                                                  288:   
                                                  289:   _IntHandlerDrvICInstance3:
9D007814  401A6800   MFC0 K0, Cause               290:       portSAVE_CONTEXT
9D0078F0  3C169D01   LUI S6, -25343               291:       la    s6,  IntHandlerDrvICInstance3
9D0078F8  02C0F809   JALR S6                      292:       jalr  s6
9D0078FC  00000000   NOP                          293:       nop
9D007900  3C16A000   LUI S6, -24576               294:       portRESTORE_CONTEXT
                                                  295:       .end	_IntHandlerDrvICInstance3
                                                  296:   
                                                  297:   
                                                  298:   /*******************************************************************************
                                                  299:    End of File
                                                  300:    */
                                                  301:   
---  /build/bamboo/xml-data/build-dir/XC32-CYXC32-JOB1/xc32-XC32-release-1_42/src48x/gcc/libgcc/libgcc2.c
9D003B3C  00C04021   ADDU T0, A2, ZERO
9D003FA0  00C04021   ADDU T0, A2, ZERO
9D003B40  00804821   ADDU T1, A0, ZERO
9D003FA4  00801021   ADDU V0, A0, ZERO
9D003B44  14E0003B   BNE A3, ZERO, 0x9D003C34
9D003B48  00A01821   ADDU V1, A1, ZERO
9D003FA8  14E0003F   BNE A3, ZERO, 0x9D0040A8
9D003FAC  00A04821   ADDU T1, A1, ZERO
9D003B4C  00A6102B   SLTU V0, A1, A2
9D003B50  10400048   BEQ V0, ZERO, 0x9D003C74
9D003B54  70C21020   CLZ V0, A2
9D003FB0  00A6182B   SLTU V1, A1, A2
9D003FB4  10600047   BEQ V1, ZERO, 0x9D0040D4
9D003FB8  70C31820   CLZ V1, A2
9D003B58  50400008   BEQL V0, ZERO, 0x9D003B7C
9D003B5C  00083402   SRL A2, T0, 16
9D003FBC  50600008   BEQL V1, ZERO, 0x9D003FE0
9D003FC0  00081C02   SRL V1, T0, 16
9D003B6C  00464004   SLLV T0, A2, V0
9D003FD0  00664004   SLLV T0, A2, V1
9D003B60  00021823   SUBU V1, ZERO, V0
9D003B64  00452804   SLLV A1, A1, V0
9D003B68  00641806   SRLV V1, A0, V1
9D003B70  00651825   OR V1, V1, A1
9D003FC4  00034823   SUBU T1, ZERO, V1
9D003FC8  00652804   SLLV A1, A1, V1
9D003FCC  01244806   SRLV T1, A0, T1
9D003FD4  01254825   OR T1, T1, A1
9D003B74  00444804   SLLV T1, A0, V0
9D003FD8  00641004   SLLV V0, A0, V1
9D003B78  00083402   SRL A2, T0, 16
9D003B7C  0066001B   DIVU V1, A2
9D003B80  00C001F4   TEQ A2, ZERO
9D003B84  00002010   MFHI A0
9D003B88  00005812   MFLO T3
9D003B8C  310CFFFF   ANDI T4, T0, -1
9D003B90  00095402   SRL T2, T1, 16
9D003B94  716C5802   MUL T3, T3, T4
9D003B98  00042400   SLL A0, A0, 16
9D003B9C  008A5025   OR T2, A0, T2
9D003BA0  014B682B   SLTU T5, T2, T3
9D003BA4  0066001B   DIVU V1, A2
9D003BA8  00C001F4   TEQ A2, ZERO
9D003BAC  51A00009   BEQL T5, ZERO, 0x9D003BD4
9D003BB0  014B5023   SUBU T2, T2, T3
9D003BB4  01485021   ADDU T2, T2, T0
9D003BB8  0148182B   SLTU V1, T2, T0
9D003BBC  54600005   BNEL V1, ZERO, 0x9D003BD4
9D003BC0  014B5023   SUBU T2, T2, T3
9D003BC4  014B202B   SLTU A0, T2, T3
9D003BC8  01481821   ADDU V1, T2, T0
9D003BCC  0064500B   MOVN T2, V1, A0
9D003BD0  014B5023   SUBU T2, T2, T3
9D003BD4  3123FFFF   ANDI V1, T1, -1
9D003BD8  0146001B   DIVU T2, A2
9D003BDC  00C001F4   TEQ A2, ZERO
9D003BE0  00004810   MFHI T1
9D003BE4  00002012   MFLO A0
9D003BE8  708C2002   MUL A0, A0, T4
9D003BEC  00094C00   SLL T1, T1, 16
9D003BF0  01234825   OR T1, T1, V1
9D003BF4  0124182B   SLTU V1, T1, A0
9D003BF8  0146001B   DIVU T2, A2
9D003BFC  00C001F4   TEQ A2, ZERO
9D003C00  50600009   BEQL V1, ZERO, 0x9D003C28
9D003C04  01244823   SUBU T1, T1, A0
9D003C08  01284821   ADDU T1, T1, T0
9D003C0C  0128182B   SLTU V1, T1, T0
9D003C10  54600005   BNEL V1, ZERO, 0x9D003C28
9D003C14  01244823   SUBU T1, T1, A0
9D003C18  0124182B   SLTU V1, T1, A0
9D003C1C  01284021   ADDU T0, T1, T0
9D003C20  0103480B   MOVN T1, T0, V1
9D003C24  01244823   SUBU T1, T1, A0
9D003FDC  00081C02   SRL V1, T0, 16
9D003FE0  0123001B   DIVU T1, V1
9D003FE4  006001F4   TEQ V1, ZERO
9D003FE8  00006010   MFHI T4
9D003FEC  00005812   MFLO T3
9D003FF0  310AFFFF   ANDI T2, T0, -1
9D003FF4  00022402   SRL A0, V0, 16
9D003FF8  00003012   MFLO A2
9D003FFC  716A3802   MUL A3, T3, T2
9D004000  000C6400   SLL T4, T4, 16
9D004004  01842025   OR A0, T4, A0
9D004008  0087602B   SLTU T4, A0, A3
9D00400C  0123001B   DIVU T1, V1
9D004010  006001F4   TEQ V1, ZERO
9D004014  1180000B   BEQ T4, ZERO, 0x9D004044
9D004018  00872823   SUBU A1, A0, A3
9D00401C  00882021   ADDU A0, A0, T0
9D004020  0088282B   SLTU A1, A0, T0
9D004024  14A00006   BNE A1, ZERO, 0x9D004040
9D004028  2566FFFF   ADDIU A2, T3, -1
9D00402C  0087282B   SLTU A1, A0, A3
9D004030  10A00004   BEQ A1, ZERO, 0x9D004044
9D004034  00872823   SUBU A1, A0, A3
9D004038  2566FFFE   ADDIU A2, T3, -2
9D00403C  00882021   ADDU A0, A0, T0
9D004040  00872823   SUBU A1, A0, A3
9D004044  3042FFFF   ANDI V0, V0, -1
9D004048  00A3001B   DIVU A1, V1
9D00404C  006001F4   TEQ V1, ZERO
9D004050  00004810   MFHI T1
9D004054  00003812   MFLO A3
9D004058  00002012   MFLO A0
9D00405C  70EA5002   MUL T2, A3, T2
9D004060  00094C00   SLL T1, T1, 16
9D004064  01221025   OR V0, T1, V0
9D004068  004A482B   SLTU T1, V0, T2
9D00406C  00A3001B   DIVU A1, V1
9D004070  006001F4   TEQ V1, ZERO
9D004074  51200009   BEQL T1, ZERO, 0x9D00409C
9D004078  00061400   SLL V0, A2, 16
9D00407C  00481021   ADDU V0, V0, T0
9D004080  0048402B   SLTU T0, V0, T0
9D004084  15000004   BNE T0, ZERO, 0x9D004098
9D004088  24E4FFFF   ADDIU A0, A3, -1
9D00408C  004A502B   SLTU T2, V0, T2
9D004090  24E7FFFE   ADDIU A3, A3, -2
9D004094  00EA200B   MOVN A0, A3, T2
9D004098  00061400   SLL V0, A2, 16
9D00409C  00821025   OR V0, A0, V0
9D0040A0  03E00008   JR RA
9D0040A4  00001821   ADDU V1, ZERO, ZERO
9D003C74  14C00006   BNE A2, ZERO, 0x9D003C90
9D003C78  71021020   CLZ V0, T0
9D0040D4  14C00006   BNE A2, ZERO, 0x9D0040F0
9D0040D8  71031820   CLZ V1, T0
9D003C7C  24020001   ADDIU V0, ZERO, 1
9D003C80  0046001B   DIVU V0, A2
9D003C84  00C001F4   TEQ A2, ZERO
9D003C88  00004012   MFLO T0
9D0040DC  24030001   ADDIU V1, ZERO, 1
9D0040E0  0066001B   DIVU V1, A2
9D0040E4  00C001F4   TEQ A2, ZERO
9D0040E8  00004012   MFLO T0
9D003C8C  71021020   CLZ V0, T0
9D0040EC  71031820   CLZ V1, T0
9D003C90  5440007D   BNEL V0, ZERO, 0x9D003E88
9D003C94  00484004   SLLV T0, T0, V0
9D0040F0  5460007B   BNEL V1, ZERO, 0x9D0042E0
9D0040F4  00684004   SLLV T0, T0, V1
9D003C98  00A82823   SUBU A1, A1, T0
9D003C9C  00081C02   SRL V1, T0, 16
9D003CA0  3107FFFF   ANDI A3, T0, -1
9D0040F8  00A82023   SUBU A0, A1, T0
9D0040FC  00083C02   SRL A3, T0, 16
9D004100  310BFFFF   ANDI T3, T0, -1
9D004104  24030001   ADDIU V1, ZERO, 1
9D003E88  24090020   ADDIU T1, ZERO, 32
9D003E8C  01224823   SUBU T1, T1, V0
9D0042E0  24020020   ADDIU V0, ZERO, 32
9D0042E4  00431023   SUBU V0, V0, V1
9D003E90  01255006   SRLV T2, A1, T1
9D0042E8  00454806   SRLV T1, A1, V0
9D003EAC  00452804   SLLV A1, A1, V0
9D003EB0  01244806   SRLV T1, A0, T1
9D003EB4  01252825   OR A1, T1, A1
9D004304  00652804   SLLV A1, A1, V1
9D004308  00441006   SRLV V0, A0, V0
9D00430C  00452825   OR A1, V0, A1
9D003EBC  00444804   SLLV T1, A0, V0
9D004314  00641004   SLLV V0, A0, V1
9D003E94  00081C02   SRL V1, T0, 16
9D003E98  0143001B   DIVU T2, V1
9D003E9C  006001F4   TEQ V1, ZERO
9D003EA0  00003010   MFHI A2
9D003EA4  00005812   MFLO T3
9D003EA8  3107FFFF   ANDI A3, T0, -1
9D003EB8  00056402   SRL T4, A1, 16
9D003EC0  71675802   MUL T3, T3, A3
9D003EC4  00063400   SLL A2, A2, 16
9D003EC8  01863025   OR A2, T4, A2
9D003ECC  00CB202B   SLTU A0, A2, T3
9D003ED0  0143001B   DIVU T2, V1
9D003ED4  006001F4   TEQ V1, ZERO
9D003ED8  50800006   BEQL A0, ZERO, 0x9D003EF4
9D003EDC  00CB3023   SUBU A2, A2, T3
9D003EE0  00C83021   ADDU A2, A2, T0
9D003EE4  00C8202B   SLTU A0, A2, T0
9D003EE8  10800024   BEQ A0, ZERO, 0x9D003F7C
9D003EEC  00CB502B   SLTU T2, A2, T3
9D003EF0  00CB3023   SUBU A2, A2, T3
9D003EF4  30AAFFFF   ANDI T2, A1, -1
9D003EF8  00C3001B   DIVU A2, V1
9D003EFC  006001F4   TEQ V1, ZERO
9D003F00  00002010   MFHI A0
9D003F04  00002812   MFLO A1
9D003F08  70A72802   MUL A1, A1, A3
9D003F0C  00042400   SLL A0, A0, 16
9D003F10  008A2025   OR A0, A0, T2
9D003F14  0085502B   SLTU T2, A0, A1
9D003F18  00C3001B   DIVU A2, V1
9D003F1C  006001F4   TEQ V1, ZERO
9D003F20  5140FF60   BEQL T2, ZERO, 0x9D003CA4
9D003F24  00852823   SUBU A1, A0, A1
9D003F28  00882021   ADDU A0, A0, T0
9D003F2C  0088302B   SLTU A2, A0, T0
9D003F30  54C0FF5C   BNEL A2, ZERO, 0x9D003CA4
9D003F34  00852823   SUBU A1, A0, A1
9D003F38  0085502B   SLTU T2, A0, A1
9D003F3C  00883021   ADDU A2, A0, T0
9D003F40  00CA200B   MOVN A0, A2, T2
9D003F44  0B400F29   J 0x9D003CA4
9D003F48  00852823   SUBU A1, A0, A1
9D003F7C  00C82021   ADDU A0, A2, T0
9D003F80  0B400FBC   J 0x9D003EF0
9D003F84  008A300B   MOVN A2, A0, T2
9D0042EC  00083C02   SRL A3, T0, 16
9D0042F0  0127001B   DIVU T1, A3
9D0042F4  00E001F4   TEQ A3, ZERO
9D0042F8  00003010   MFHI A2
9D0042FC  00006012   MFLO T4
9D004300  310BFFFF   ANDI T3, T0, -1
9D004310  00056C02   SRL T5, A1, 16
9D004318  00001812   MFLO V1
9D00431C  718B5002   MUL T2, T4, T3
9D004320  00063400   SLL A2, A2, 16
9D004324  01A63025   OR A2, T5, A2
9D004328  00CA202B   SLTU A0, A2, T2
9D00432C  0127001B   DIVU T1, A3
9D004330  00E001F4   TEQ A3, ZERO
9D004334  5080000B   BEQL A0, ZERO, 0x9D004364
9D004338  00CA3023   SUBU A2, A2, T2
9D00433C  00C83021   ADDU A2, A2, T0
9D004340  00C8202B   SLTU A0, A2, T0
9D004344  14800006   BNE A0, ZERO, 0x9D004360
9D004348  2583FFFF   ADDIU V1, T4, -1
9D00434C  00CA202B   SLTU A0, A2, T2
9D004350  50800004   BEQL A0, ZERO, 0x9D004364
9D004354  00CA3023   SUBU A2, A2, T2
9D004358  2583FFFE   ADDIU V1, T4, -2
9D00435C  00C83021   ADDU A2, A2, T0
9D004360  00CA3023   SUBU A2, A2, T2
9D004364  30ACFFFF   ANDI T4, A1, -1
9D004368  00C7001B   DIVU A2, A3
9D00436C  00E001F4   TEQ A3, ZERO
9D004370  00002010   MFHI A0
9D004374  00005012   MFLO T2
9D004378  00004812   MFLO T1
9D00437C  714B2802   MUL A1, T2, T3
9D004380  00042400   SLL A0, A0, 16
9D004384  008C2025   OR A0, A0, T4
9D004388  0085602B   SLTU T4, A0, A1
9D00438C  00C7001B   DIVU A2, A3
9D004390  00E001F4   TEQ A3, ZERO
9D004394  5180000B   BEQL T4, ZERO, 0x9D0043C4
9D004398  00031C00   SLL V1, V1, 16
9D00439C  00882021   ADDU A0, A0, T0
9D0043A0  0088302B   SLTU A2, A0, T0
9D0043A4  14C00006   BNE A2, ZERO, 0x9D0043C0
9D0043A8  2549FFFF   ADDIU T1, T2, -1
9D0043AC  0085302B   SLTU A2, A0, A1
9D0043B0  50C00004   BEQL A2, ZERO, 0x9D0043C4
9D0043B4  00031C00   SLL V1, V1, 16
9D0043B8  2549FFFE   ADDIU T1, T2, -2
9D0043BC  00882021   ADDU A0, A0, T0
9D0043C0  00031C00   SLL V1, V1, 16
9D0043C4  00852023   SUBU A0, A0, A1
9D0043C8  0B401042   J 0x9D004108
9D0043CC  01231825   OR V1, T1, V1
9D003CA4  00092402   SRL A0, T1, 16
9D003CA8  00A3001B   DIVU A1, V1
9D003CAC  006001F4   TEQ V1, ZERO
9D003CB0  00005010   MFHI T2
9D003CB4  00003012   MFLO A2
9D003CB8  70C73002   MUL A2, A2, A3
9D003CBC  000A5400   SLL T2, T2, 16
9D003CC0  01442025   OR A0, T2, A0
9D003CC4  0086502B   SLTU T2, A0, A2
9D003CC8  00A3001B   DIVU A1, V1
9D003CCC  006001F4   TEQ V1, ZERO
9D003CD0  51400009   BEQL T2, ZERO, 0x9D003CF8
9D003CD4  00862023   SUBU A0, A0, A2
9D003CD8  00882021   ADDU A0, A0, T0
9D003CDC  0088282B   SLTU A1, A0, T0
9D003CE0  54A00005   BNEL A1, ZERO, 0x9D003CF8
9D003CE4  00862023   SUBU A0, A0, A2
9D003CE8  0086502B   SLTU T2, A0, A2
9D003CEC  00882821   ADDU A1, A0, T0
9D003CF0  00AA200B   MOVN A0, A1, T2
9D003CF4  00862023   SUBU A0, A0, A2
9D003CF8  3126FFFF   ANDI A2, T1, -1
9D003CFC  0083001B   DIVU A0, V1
9D003D00  006001F4   TEQ V1, ZERO
9D003D04  00004810   MFHI T1
9D003D08  00002812   MFLO A1
9D003D0C  70A72802   MUL A1, A1, A3
9D003D10  00094C00   SLL T1, T1, 16
9D003D14  01264825   OR T1, T1, A2
9D003D18  0125302B   SLTU A2, T1, A1
9D003D1C  0083001B   DIVU A0, V1
9D003D20  006001F4   TEQ V1, ZERO
9D003D24  50C00009   BEQL A2, ZERO, 0x9D003D4C
9D003D28  01254823   SUBU T1, T1, A1
9D003D2C  01284821   ADDU T1, T1, T0
9D003D30  0128182B   SLTU V1, T1, T0
9D003D34  54600005   BNEL V1, ZERO, 0x9D003D4C
9D003D38  01254823   SUBU T1, T1, A1
9D003D3C  0125182B   SLTU V1, T1, A1
9D003D40  01284021   ADDU T0, T1, T0
9D003D44  0103480B   MOVN T1, T0, V1
9D003D48  01254823   SUBU T1, T1, A1
9D004108  00023402   SRL A2, V0, 16
9D00410C  0087001B   DIVU A0, A3
9D004110  00E001F4   TEQ A3, ZERO
9D004114  00006810   MFHI T5
9D004118  00006012   MFLO T4
9D00411C  00004812   MFLO T1
9D004120  718B5002   MUL T2, T4, T3
9D004124  000D6C00   SLL T5, T5, 16
9D004128  01A63025   OR A2, T5, A2
9D00412C  00CA682B   SLTU T5, A2, T2
9D004130  0087001B   DIVU A0, A3
9D004134  00E001F4   TEQ A3, ZERO
9D004138  11A00009   BEQ T5, ZERO, 0x9D004160
9D00413C  00CA2823   SUBU A1, A2, T2
9D004140  00C83021   ADDU A2, A2, T0
9D004144  00C8202B   SLTU A0, A2, T0
9D004148  14800004   BNE A0, ZERO, 0x9D00415C
9D00414C  2589FFFF   ADDIU T1, T4, -1
9D004150  00CA202B   SLTU A0, A2, T2
9D004154  548000A6   BNEL A0, ZERO, 0x9D0043F0
9D004158  2589FFFE   ADDIU T1, T4, -2
9D00415C  00CA2823   SUBU A1, A2, T2
9D004160  3042FFFF   ANDI V0, V0, -1
9D004164  00A7001B   DIVU A1, A3
9D004168  00E001F4   TEQ A3, ZERO
9D00416C  00005010   MFHI T2
9D004170  00003012   MFLO A2
9D004174  00002012   MFLO A0
9D004178  70CB5802   MUL T3, A2, T3
9D00417C  000A5400   SLL T2, T2, 16
9D004180  01421025   OR V0, T2, V0
9D004184  004B502B   SLTU T2, V0, T3
9D004188  00A7001B   DIVU A1, A3
9D00418C  00E001F4   TEQ A3, ZERO
9D004190  51400009   BEQL T2, ZERO, 0x9D0041B8
9D004194  00091400   SLL V0, T1, 16
9D004198  00481021   ADDU V0, V0, T0
9D00419C  0048402B   SLTU T0, V0, T0
9D0041A0  15000004   BNE T0, ZERO, 0x9D0041B4
9D0041A4  24C4FFFF   ADDIU A0, A2, -1
9D0041A8  004B582B   SLTU T3, V0, T3
9D0041AC  24C6FFFE   ADDIU A2, A2, -2
9D0041B0  00CB200B   MOVN A0, A2, T3
9D0041B4  00091400   SLL V0, T1, 16
9D0041B8  03E00008   JR RA
9D0041BC  00821025   OR V0, A0, V0
9D0043F0  0B401057   J 0x9D00415C
9D003C28  00491006   SRLV V0, T1, V0
9D003D4C  00491006   SRLV V0, T1, V0
9D003C2C  03E00008   JR RA
9D003C30  00001821   ADDU V1, ZERO, ZERO
9D003D50  03E00008   JR RA
9D003D54  00001821   ADDU V1, ZERO, ZERO
9D003C34  00A7102B   SLTU V0, A1, A3
9D003C38  14400047   BNE V0, ZERO, 0x9D003D58
9D003C3C  70EA5020   CLZ T2, A3
9D0040A8  00A7102B   SLTU V0, A1, A3
9D0040AC  14400044   BNE V0, ZERO, 0x9D0041C0
9D0040B0  70E84020   CLZ T0, A3
9D0041C0  00001821   ADDU V1, ZERO, ZERO
9D0041C4  03E00008   JR RA
9D0041C8  00001021   ADDU V0, ZERO, ZERO
9D003D58  00801021   ADDU V0, A0, ZERO
9D003D5C  03E00008   JR RA
9D003D60  00A01821   ADDU V1, A1, ZERO
9D003C40  15400048   BNE T2, ZERO, 0x9D003D64
9D003C44  240B0020   ADDIU T3, ZERO, 32
9D0040B4  55000045   BNEL T0, ZERO, 0x9D0041CC
9D0040B8  24020020   ADDIU V0, ZERO, 32
9D003C48  00E5102B   SLTU V0, A3, A1
9D003C4C  14400005   BNE V0, ZERO, 0x9D003C64
9D003C50  00861023   SUBU V0, A0, A2
9D003C54  0086402B   SLTU T0, A0, A2
9D003C58  15000089   BNE T0, ZERO, 0x9D003E80
9D003C5C  00801021   ADDU V0, A0, ZERO
9D0040BC  00E5282B   SLTU A1, A3, A1
9D0040C0  14A000C8   BNE A1, ZERO, 0x9D0043E4
9D0040C4  0086302B   SLTU A2, A0, A2
9D0040C8  38C20001   XORI V0, A2, 1
9D0040CC  03E00008   JR RA
9D0040D0  00001821   ADDU V1, ZERO, ZERO
9D0043E4  00001821   ADDU V1, ZERO, ZERO
9D003C60  00861023   SUBU V0, A0, A2
9D003C64  00A72823   SUBU A1, A1, A3
9D003C68  0082202B   SLTU A0, A0, V0
9D003C6C  03E00008   JR RA
9D003C70  00A41823   SUBU V1, A1, A0
9D003D64  016A5823   SUBU T3, T3, T2
9D0041CC  00481023   SUBU V0, V0, T0
9D003D68  01473804   SLLV A3, A3, T2
9D003D6C  01661006   SRLV V0, A2, T3
9D003D70  00473825   OR A3, V0, A3
9D0041D0  01073804   SLLV A3, A3, T0
9D0041D4  00461806   SRLV V1, A2, V0
9D0041D8  00673825   OR A3, V1, A3
9D003DA0  01463004   SLLV A2, A2, T2
9D003D74  01656806   SRLV T5, A1, T3
9D0041DC  00455006   SRLV T2, A1, V0
9D003D90  01452804   SLLV A1, A1, T2
9D003D94  01641006   SRLV V0, A0, T3
9D003D98  00451025   OR V0, V0, A1
9D0041F8  01052804   SLLV A1, A1, T0
9D0041FC  00441006   SRLV V0, A0, V0
9D004200  00452825   OR A1, V0, A1
9D003D78  00074C02   SRL T1, A3, 16
9D003D7C  01A9001B   DIVU T5, T1
9D003D80  012001F4   TEQ T1, ZERO
9D003D84  00006010   MFHI T4
9D003D88  00001812   MFLO V1
9D003D8C  30EEFFFF   ANDI T6, A3, -1
9D003D9C  00022C02   SRL A1, V0, 16
9D003DA4  00004012   MFLO T0
9D003DA8  706E7802   MUL T7, V1, T6
9D003DAC  000C6400   SLL T4, T4, 16
9D003DB0  01856025   OR T4, T4, A1
9D003DB4  018F282B   SLTU A1, T4, T7
9D003DB8  01A9001B   DIVU T5, T1
9D003DBC  012001F4   TEQ T1, ZERO
9D003DC0  10A0000A   BEQ A1, ZERO, 0x9D003DEC
9D003DC4  01442004   SLLV A0, A0, T2
9D003DC8  01876021   ADDU T4, T4, A3
9D003DCC  0187282B   SLTU A1, T4, A3
9D003DD0  14A00006   BNE A1, ZERO, 0x9D003DEC
9D003DD4  2468FFFF   ADDIU T0, V1, -1
9D003DD8  018F282B   SLTU A1, T4, T7
9D003DDC  50A00004   BEQL A1, ZERO, 0x9D003DF0
9D003DE0  018F6023   SUBU T4, T4, T7
9D003DE4  2468FFFE   ADDIU T0, V1, -2
9D003DE8  01876021   ADDU T4, T4, A3
9D003DEC  018F6023   SUBU T4, T4, T7
9D003DF0  3042FFFF   ANDI V0, V0, -1
9D003DF4  0189001B   DIVU T4, T1
9D003DF8  012001F4   TEQ T1, ZERO
9D003DFC  00002810   MFHI A1
9D003E00  00001812   MFLO V1
9D003E04  00006812   MFLO T5
9D003E08  706E7002   MUL T6, V1, T6
9D003E0C  00052C00   SLL A1, A1, 16
9D003E10  00A21025   OR V0, A1, V0
9D003E14  004E282B   SLTU A1, V0, T6
9D003E18  0189001B   DIVU T4, T1
9D003E1C  012001F4   TEQ T1, ZERO
9D003E20  50A00006   BEQL A1, ZERO, 0x9D003E3C
9D003E24  00084400   SLL T0, T0, 16
9D003E28  00471021   ADDU V0, V0, A3
9D003E2C  0047282B   SLTU A1, V0, A3
9D003E30  10A0004C   BEQ A1, ZERO, 0x9D003F64
9D003E34  246DFFFF   ADDIU T5, V1, -1
9D003E38  00084400   SLL T0, T0, 16
9D003E3C  01A84025   OR T0, T5, T0
9D003E40  004E1023   SUBU V0, V0, T6
9D003F64  004E282B   SLTU A1, V0, T6
9D003F68  50A0FFB4   BEQL A1, ZERO, 0x9D003E3C
9D003F6C  00084400   SLL T0, T0, 16
9D003F70  246DFFFE   ADDIU T5, V1, -2
9D003F74  0B400F8E   J 0x9D003E38
9D003F78  00471021   ADDU V0, V0, A3
9D0041E0  00071C02   SRL V1, A3, 16
9D0041E4  0143001B   DIVU T2, V1
9D0041E8  006001F4   TEQ V1, ZERO
9D0041EC  00004810   MFHI T1
9D0041F0  00006812   MFLO T5
9D0041F4  30EBFFFF   ANDI T3, A3, -1
9D004204  00057402   SRL T6, A1, 16
9D004208  00001012   MFLO V0
9D00420C  71AB6002   MUL T4, T5, T3
9D004210  00094C00   SLL T1, T1, 16
9D004214  012E4825   OR T1, T1, T6
9D004218  012C702B   SLTU T6, T1, T4
9D00421C  0143001B   DIVU T2, V1
9D004220  006001F4   TEQ V1, ZERO
9D004224  11C0000A   BEQ T6, ZERO, 0x9D004250
9D004228  01063004   SLLV A2, A2, T0
9D00422C  01274821   ADDU T1, T1, A3
9D004230  0127502B   SLTU T2, T1, A3
9D004234  15400006   BNE T2, ZERO, 0x9D004250
9D004238  25A2FFFF   ADDIU V0, T5, -1
9D00423C  012C502B   SLTU T2, T1, T4
9D004240  51400004   BEQL T2, ZERO, 0x9D004254
9D004244  012C4823   SUBU T1, T1, T4
9D004248  25A2FFFE   ADDIU V0, T5, -2
9D00424C  01274821   ADDU T1, T1, A3
9D004250  012C4823   SUBU T1, T1, T4
9D004254  30A5FFFF   ANDI A1, A1, -1
9D004258  0123001B   DIVU T1, V1
9D00425C  006001F4   TEQ V1, ZERO
9D004260  00006810   MFHI T5
9D004264  00006012   MFLO T4
9D004268  00005012   MFLO T2
9D00426C  718B5802   MUL T3, T4, T3
9D004270  000D6C00   SLL T5, T5, 16
9D004274  01A52825   OR A1, T5, A1
9D004278  00AB682B   SLTU T5, A1, T3
9D00427C  0123001B   DIVU T1, V1
9D004280  006001F4   TEQ V1, ZERO
9D004284  51A0000B   BEQL T5, ZERO, 0x9D0042B4
9D004288  00021400   SLL V0, V0, 16
9D00428C  00A72821   ADDU A1, A1, A3
9D004290  00A7182B   SLTU V1, A1, A3
9D004294  14600006   BNE V1, ZERO, 0x9D0042B0
9D004298  258AFFFF   ADDIU T2, T4, -1
9D00429C  00AB182B   SLTU V1, A1, T3
9D0042A0  50600004   BEQL V1, ZERO, 0x9D0042B4
9D0042A4  00021400   SLL V0, V0, 16
9D0042A8  258AFFFE   ADDIU T2, T4, -2
9D0042AC  00A72821   ADDU A1, A1, A3
9D0042B0  00021400   SLL V0, V0, 16
9D0042B4  01421025   OR V0, T2, V0
9D0042B8  00AB2823   SUBU A1, A1, T3
9D003E44  01060019   MULTU 0, T0, A2
9D003E48  00004810   MFHI T1
9D003E60  00003012   MFLO A2
9D0042BC  00460019   MULTU 0, V0, A2
9D0042C0  00003810   MFHI A3
9D003E4C  0049182B   SLTU V1, V0, T1
9D003E50  1460003E   BNE V1, ZERO, 0x9D003F4C
9D003E54  00004012   MFLO T0
9D003E58  1049004B   BEQ V0, T1, 0x9D003F88
9D003E5C  00491823   SUBU V1, V0, T1
9D003F88  0088182B   SLTU V1, A0, T0
9D0042C4  00A7182B   SLTU V1, A1, A3
9D0042C8  14600044   BNE V1, ZERO, 0x9D0043DC
9D0042CC  00003012   MFLO A2
9D0042D0  10A7003F   BEQ A1, A3, 0x9D0043D0
9D0042D4  01042004   SLLV A0, A0, T0
9D0043D0  0086302B   SLTU A2, A0, A2
9D0043D4  10C0FFC0   BEQ A2, ZERO, 0x9D0042D8
9D0043D8  00000000   NOP
9D0042D8  03E00008   JR RA
9D0042DC  00001821   ADDU V1, ZERO, ZERO
9D0043DC  0B4010B6   J 0x9D0042D8
9D0043E0  2442FFFF   ADDIU V0, V0, -1
9D003F4C  01063023   SUBU A2, T0, A2
9D003F50  01271823   SUBU V1, T1, A3
9D003F54  0106402B   SLTU T0, T0, A2
9D003F58  00681823   SUBU V1, V1, T0
9D003F5C  0B400F99   J 0x9D003E64
9D003F60  00431823   SUBU V1, V0, V1
9D003E64  00863023   SUBU A2, A0, A2
9D003E68  0086202B   SLTU A0, A0, A2
9D003E6C  00641823   SUBU V1, V1, A0
9D003E70  01631004   SLLV V0, V1, T3
9D003E74  01463006   SRLV A2, A2, T2
9D003E78  00461025   OR V0, V0, A2
9D003E7C  01431806   SRLV V1, V1, T2
9D003E80  03E00008   JR RA
9D003E84  00000000   NOP
9D0043E8  03E00008   JR RA
9D0043EC  24020001   ADDIU V0, ZERO, 1
---  /build/bamboo/xml-data/build-dir/XC32-CYXC32-JOB1/xc32-XC32-release-1_42/src48x/gcc/libgcc/floatunsisf.c
9D00CFAC  27BDFFE8   ADDIU SP, SP, -24
9D00CFB0  AFBF0014   SW RA, 20(SP)
9D00CFB4  04800006   BLTZ A0, 0x9D00CFD0
9D00CFB8  00801021   ADDU V0, A0, ZERO
9D00CFD0  00042042   SRL A0, A0, 1
9D00CFD4  30420001   ANDI V0, V0, 1
9D00CFD8  0F403283   JAL __floatsisf
9D00CFDC  00822025   OR A0, A0, V0
9D00CFE0  00402021   ADDU A0, V0, ZERO
9D00CFE4  0F401525   JAL fpadd
9D00CFE8  00402821   ADDU A1, V0, ZERO
9D00CFBC  0F403283   JAL __floatsisf
9D00CFC0  00000000   NOP
9D00CFC4  8FBF0014   LW RA, 20(SP)
9D00CFC8  03E00008   JR RA
9D00CFCC  27BD0018   ADDIU SP, SP, 24
9D00CFEC  8FBF0014   LW RA, 20(SP)
